apiVersion: v1
data:
  admin-Public-Admin-plugins-bootstrap-switch-css-bootstrap2-bootstrap-switch.css: |
    /**
      * bootstrap-switch - Turn checkboxes and radio buttons into toggle switches.
      *
      * @version v3.3.4
      * @homepage https://bttstrp.github.io/bootstrap-switch
      * @author Mattia Larentis <mattia@larentis.eu> (http://larentis.eu)
      * @license Apache-2.0
      */

    .clearfix {
      *zoom: 1;
    }
    .clearfix:before,
    .clearfix:after {
      display: table;
      content: "";
      line-height: 0;
    }
    .clearfix:after {
      clear: both;
    }
    .hide-text {
      font: 0/0 a;
      color: transparent;
      text-shadow: none;
      background-color: transparent;
      border: 0;
    }
    .input-block-level {
      display: block;
      width: 100%;
      min-height: 30px;
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .bootstrap-switch {
      display: inline-block;
      direction: ltr;
      cursor: pointer;
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
      border-radius: 5px;
      border: 1px solid;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      position: relative;
      text-align: left;
      overflow: hidden;
      line-height: 8px;
      z-index: 0;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -o-user-select: none;
      user-select: none;
      vertical-align: middle;
      -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
      -moz-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
      -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
      transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
    }
    .bootstrap-switch .bootstrap-switch-container {
      display: inline-block;
      top: 0;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -webkit-transform: translate3d(0, 0, 0);
      -moz-transform: translate3d(0, 0, 0);
      -o-transform: translate3d(0, 0, 0);
      transform: translate3d(0, 0, 0);
    }
    .bootstrap-switch .bootstrap-switch-handle-on,
    .bootstrap-switch .bootstrap-switch-handle-off,
    .bootstrap-switch .bootstrap-switch-label {
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
      cursor: pointer;
      display: inline-block !important;
      padding-top: 4px;
      padding-bottom: 4px;
      padding-left: 8px;
      padding-right: 8px;
      font-size: 14px;
      line-height: 20px;
    }
    .bootstrap-switch .bootstrap-switch-handle-on,
    .bootstrap-switch .bootstrap-switch-handle-off {
      text-align: center;
      z-index: 1;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary {
      color: #fff;
      text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
      background-color: #005fcc;
      background-image: -moz-linear-gradient(top, #0044cc, #08c);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0044cc), to(#08c));
      background-image: -webkit-linear-gradient(top, #0044cc, #08c);
      background-image: -o-linear-gradient(top, #0044cc, #08c);
      background-image: linear-gradient(to bottom, #0044cc, #08c);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0044cc', endColorstr='#ff0088cc', GradientType=0);
      border-color: #08c #08c #005580;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #08c;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:hover,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:hover,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:focus,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:focus,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary.active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary.disabled,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary.disabled,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary[disabled],
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary[disabled] {
      color: #fff;
      background-color: #08c;
      *background-color: #0077b3;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary.active {
      background-color: #006699 \9;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info {
      color: #fff;
      text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
      background-color: #41a7c5;
      background-image: -moz-linear-gradient(top, #2f96b4, #5bc0de);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#2f96b4), to(#5bc0de));
      background-image: -webkit-linear-gradient(top, #2f96b4, #5bc0de);
      background-image: -o-linear-gradient(top, #2f96b4, #5bc0de);
      background-image: linear-gradient(to bottom, #2f96b4, #5bc0de);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff2f96b4', endColorstr='#ff5bc0de', GradientType=0);
      border-color: #5bc0de #5bc0de #28a1c5;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #5bc0de;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:hover,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:hover,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:focus,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:focus,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info.active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info.disabled,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info.disabled,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info[disabled],
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info[disabled] {
      color: #fff;
      background-color: #5bc0de;
      *background-color: #46b8da;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info.active {
      background-color: #31b0d5 \9;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success {
      color: #fff;
      text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
      background-color: #58b058;
      background-image: -moz-linear-gradient(top, #51a351, #62c462);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#51a351), to(#62c462));
      background-image: -webkit-linear-gradient(top, #51a351, #62c462);
      background-image: -o-linear-gradient(top, #51a351, #62c462);
      background-image: linear-gradient(to bottom, #51a351, #62c462);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff51a351', endColorstr='#ff62c462', GradientType=0);
      border-color: #62c462 #62c462 #3b9e3b;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #62c462;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:hover,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:hover,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:focus,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:focus,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success.active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success.disabled,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success.disabled,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success[disabled],
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success[disabled] {
      color: #fff;
      background-color: #62c462;
      *background-color: #4fbd4f;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success.active {
      background-color: #42b142 \9;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning {
      color: #fff;
      text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
      background-color: #f9a123;
      background-image: -moz-linear-gradient(top, #f89406, #fbb450);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#f89406), to(#fbb450));
      background-image: -webkit-linear-gradient(top, #f89406, #fbb450);
      background-image: -o-linear-gradient(top, #f89406, #fbb450);
      background-image: linear-gradient(to bottom, #f89406, #fbb450);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff89406', endColorstr='#fffbb450', GradientType=0);
      border-color: #fbb450 #fbb450 #f89406;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #fbb450;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:hover,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:hover,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:focus,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:focus,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning.active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning.disabled,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning.disabled,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning[disabled],
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning[disabled] {
      color: #fff;
      background-color: #fbb450;
      *background-color: #faa937;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning.active {
      background-color: #fa9f1e \9;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger {
      color: #fff;
      text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
      background-color: #d14641;
      background-image: -moz-linear-gradient(top, #bd362f, #ee5f5b);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#bd362f), to(#ee5f5b));
      background-image: -webkit-linear-gradient(top, #bd362f, #ee5f5b);
      background-image: -o-linear-gradient(top, #bd362f, #ee5f5b);
      background-image: linear-gradient(to bottom, #bd362f, #ee5f5b);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffbd362f', endColorstr='#ffee5f5b', GradientType=0);
      border-color: #ee5f5b #ee5f5b #e51d18;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #ee5f5b;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:hover,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:hover,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:focus,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:focus,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger.active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger.disabled,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger.disabled,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger[disabled],
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger[disabled] {
      color: #fff;
      background-color: #ee5f5b;
      *background-color: #ec4844;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger.active {
      background-color: #e9322d \9;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default {
      color: #333;
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);
      background-color: #f0f0f0;
      background-image: -moz-linear-gradient(top, #e6e6e6, #fff);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#e6e6e6), to(#fff));
      background-image: -webkit-linear-gradient(top, #e6e6e6, #fff);
      background-image: -o-linear-gradient(top, #e6e6e6, #fff);
      background-image: linear-gradient(to bottom, #e6e6e6, #fff);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe6e6e6', endColorstr='#ffffffff', GradientType=0);
      border-color: #fff #fff #d9d9d9;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #fff;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:hover,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:hover,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:focus,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:focus,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default.active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default.disabled,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default.disabled,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default[disabled],
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default[disabled] {
      color: #333;
      background-color: #fff;
      *background-color: #f2f2f2;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:active,
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default.active,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default.active {
      background-color: #e6e6e6 \9;
    }
    .bootstrap-switch .bootstrap-switch-label {
      text-align: center;
      margin-top: -1px;
      margin-bottom: -1px;
      z-index: 100;
      border-left: 1px solid #ccc;
      border-right: 1px solid #ccc;
      color: #333;
      text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
      background-color: #f5f5f5;
      background-image: -moz-linear-gradient(top, #fff, #e6e6e6);
      background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#fff), to(#e6e6e6));
      background-image: -webkit-linear-gradient(top, #fff, #e6e6e6);
      background-image: -o-linear-gradient(top, #fff, #e6e6e6);
      background-image: linear-gradient(to bottom, #fff, #e6e6e6);
      background-repeat: repeat-x;
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff', endColorstr='#ffe6e6e6', GradientType=0);
      border-color: #e6e6e6 #e6e6e6 #bfbfbf;
      border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
      *background-color: #e6e6e6;
      /* Darken IE7 buttons by default so they stand out more given they won't have borders */
      filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
    }
    .bootstrap-switch .bootstrap-switch-label:hover,
    .bootstrap-switch .bootstrap-switch-label:focus,
    .bootstrap-switch .bootstrap-switch-label:active,
    .bootstrap-switch .bootstrap-switch-label.active,
    .bootstrap-switch .bootstrap-switch-label.disabled,
    .bootstrap-switch .bootstrap-switch-label[disabled] {
      color: #333;
      background-color: #e6e6e6;
      *background-color: #d9d9d9;
    }
    .bootstrap-switch .bootstrap-switch-label:active,
    .bootstrap-switch .bootstrap-switch-label.active {
      background-color: #cccccc \9;
    }
    .bootstrap-switch span::before {
      content: "\200b";
    }
    .bootstrap-switch .bootstrap-switch-handle-on {
      -webkit-border-top-left-radius: 4px;
      -moz-border-radius-topleft: 4px;
      border-top-left-radius: 4px;
      -webkit-border-bottom-left-radius: 4px;
      -moz-border-radius-bottomleft: 4px;
      border-bottom-left-radius: 4px;
    }
    .bootstrap-switch .bootstrap-switch-handle-off {
      -webkit-border-top-right-radius: 4px;
      -moz-border-radius-topright: 4px;
      border-top-right-radius: 4px;
      -webkit-border-bottom-right-radius: 4px;
      -moz-border-radius-bottomright: 4px;
      border-bottom-right-radius: 4px;
    }
    .bootstrap-switch input[type='radio'],
    .bootstrap-switch input[type='checkbox'] {
      position: absolute !important;
      top: 0;
      left: 0;
      opacity: 0;
      filter: alpha(opacity=0);
      z-index: -1;
      visibility: hidden;
    }
    .bootstrap-switch input[type='radio'].form-control,
    .bootstrap-switch input[type='checkbox'].form-control {
      height: auto;
    }
    .bootstrap-switch.bootstrap-switch-mini {
      min-width: 71px;
    }
    .bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-label {
      padding: 3px 6px;
      font-size: 10px;
      line-height: 9px;
    }
    .bootstrap-switch.bootstrap-switch-small {
      min-width: 79px;
    }
    .bootstrap-switch.bootstrap-switch-small .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-small .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-small .bootstrap-switch-label {
      padding: 3px 6px;
      font-size: 12px;
      line-height: 18px;
    }
    .bootstrap-switch.bootstrap-switch-large {
      min-width: 120px;
    }
    .bootstrap-switch.bootstrap-switch-large .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-large .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-large .bootstrap-switch-label {
      padding: 9px 12px;
      font-size: 16px;
      line-height: normal;
    }
    .bootstrap-switch.bootstrap-switch-disabled,
    .bootstrap-switch.bootstrap-switch-readonly,
    .bootstrap-switch.bootstrap-switch-indeterminate {
      cursor: default !important;
    }
    .bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-label {
      opacity: 0.5;
      filter: alpha(opacity=50);
      cursor: default !important;
    }
    .bootstrap-switch.bootstrap-switch-animate .bootstrap-switch-container {
      -webkit-transition: margin-left 0.5s;
      -moz-transition: margin-left 0.5s;
      -o-transition: margin-left 0.5s;
      transition: margin-left 0.5s;
    }
    .bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-on {
      -webkit-border-top-left-radius: 0;
      -moz-border-radius-topleft: 0;
      border-top-left-radius: 0;
      -webkit-border-bottom-left-radius: 0;
      -moz-border-radius-bottomleft: 0;
      border-bottom-left-radius: 0;
      -webkit-border-top-right-radius: 4px;
      -moz-border-radius-topright: 4px;
      border-top-right-radius: 4px;
      -webkit-border-bottom-right-radius: 4px;
      -moz-border-radius-bottomright: 4px;
      border-bottom-right-radius: 4px;
    }
    .bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-off {
      -webkit-border-top-right-radius: 0;
      -moz-border-radius-topright: 0;
      border-top-right-radius: 0;
      -webkit-border-bottom-right-radius: 0;
      -moz-border-radius-bottomright: 0;
      border-bottom-right-radius: 0;
      -webkit-border-top-left-radius: 4px;
      -moz-border-radius-topleft: 4px;
      border-top-left-radius: 4px;
      -webkit-border-bottom-left-radius: 4px;
      -moz-border-radius-bottomleft: 4px;
      border-bottom-left-radius: 4px;
    }
    .bootstrap-switch.bootstrap-switch-focused {
      border-color: rgba(82, 168, 236, 0.8);
      outline: 0;
      outline: thin dotted \9;
      -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(82, 168, 236, .6);
      -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(82, 168, 236, .6);
      box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(82, 168, 236, .6);
    }
    .bootstrap-switch.bootstrap-switch-on .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-inverse.bootstrap-switch-off .bootstrap-switch-label {
      -webkit-border-top-right-radius: 4px;
      -moz-border-radius-topright: 4px;
      border-top-right-radius: 4px;
      -webkit-border-bottom-right-radius: 4px;
      -moz-border-radius-bottomright: 4px;
      border-bottom-right-radius: 4px;
    }
    .bootstrap-switch.bootstrap-switch-off .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-inverse.bootstrap-switch-on .bootstrap-switch-label {
      -webkit-border-top-left-radius: 4px;
      -moz-border-radius-topleft: 4px;
      border-top-left-radius: 4px;
      -webkit-border-bottom-left-radius: 4px;
      -moz-border-radius-bottomleft: 4px;
      border-bottom-left-radius: 4px;
    }
  admin-Public-Admin-plugins-bootstrap-switch-css-bootstrap2-bootstrap-switch.min.css: |-
    /**
      * bootstrap-switch - Turn checkboxes and radio buttons into toggle switches.
      *
      * @version v3.3.4
      * @homepage https://bttstrp.github.io/bootstrap-switch
      * @author Mattia Larentis <mattia@larentis.eu> (http://larentis.eu)
      * @license Apache-2.0
      */

    .clearfix:after,.clearfix:before{display:table;content:"";line-height:0}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.bootstrap-switch{display:inline-block;direction:ltr;cursor:pointer;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;border:1px solid;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);position:relative;text-align:left;overflow:hidden;line-height:8px;z-index:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;vertical-align:middle;-webkit-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;-moz-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.bootstrap-switch .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-off{-webkit-border-top-left-radius:4px;-moz-border-radius-topleft:4px;-webkit-border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px}.bootstrap-switch .bootstrap-switch-container{display:inline-block;top:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.bootstrap-switch .bootstrap-switch-handle-off,.bootstrap-switch .bootstrap-switch-handle-on,.bootstrap-switch .bootstrap-switch-label{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;cursor:pointer;display:inline-block!important;font-size:14px;line-height:20px;padding:4px 8px}.bootstrap-switch .bootstrap-switch-handle-off,.bootstrap-switch .bootstrap-switch-handle-on{text-align:center;z-index:1}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#005fcc;background-image:-moz-linear-gradient(top,#04c,#08c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#04c),to(#08c));background-image:-webkit-linear-gradient(top,#04c,#08c);background-image:-o-linear-gradient(top,#04c,#08c);background-image:linear-gradient(to bottom,#04c,#08c);background-repeat:repeat-x;border-color:#08c #08c #005580;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary.disabled,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:focus,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:hover,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary[disabled],.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary.disabled,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:focus,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:hover,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary[disabled]{color:#fff;background-color:#08c}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary:active{background-color:#069\9}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#41a7c5;background-image:-moz-linear-gradient(top,#2f96b4,#5bc0de);background-image:-webkit-gradient(linear,0 0,0 100%,from(#2f96b4),to(#5bc0de));background-image:-webkit-linear-gradient(top,#2f96b4,#5bc0de);background-image:-o-linear-gradient(top,#2f96b4,#5bc0de);background-image:linear-gradient(to bottom,#2f96b4,#5bc0de);background-repeat:repeat-x;border-color:#5bc0de #5bc0de #28a1c5;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info.disabled,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:focus,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:hover,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info[disabled],.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info.disabled,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:focus,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:hover,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info[disabled]{color:#fff;background-color:#5bc0de}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info:active{background-color:#31b0d5\9}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#58b058;background-image:-moz-linear-gradient(top,#51a351,#62c462);background-image:-webkit-gradient(linear,0 0,0 100%,from(#51a351),to(#62c462));background-image:-webkit-linear-gradient(top,#51a351,#62c462);background-image:-o-linear-gradient(top,#51a351,#62c462);background-image:linear-gradient(to bottom,#51a351,#62c462);background-repeat:repeat-x;border-color:#62c462 #62c462 #3b9e3b;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success.disabled,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:focus,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:hover,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success[disabled],.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success.disabled,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:focus,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:hover,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success[disabled]{color:#fff;background-color:#62c462}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success:active{background-color:#42b142\9}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#f9a123;background-image:-moz-linear-gradient(top,#f89406,#fbb450);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f89406),to(#fbb450));background-image:-webkit-linear-gradient(top,#f89406,#fbb450);background-image:-o-linear-gradient(top,#f89406,#fbb450);background-image:linear-gradient(to bottom,#f89406,#fbb450);background-repeat:repeat-x;border-color:#fbb450 #fbb450 #f89406;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning.disabled,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:focus,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:hover,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning[disabled],.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning.disabled,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:focus,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:hover,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning[disabled]{color:#fff;background-color:#fbb450}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning:active{background-color:#fa9f1e\9}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#d14641;background-image:-moz-linear-gradient(top,#bd362f,#ee5f5b);background-image:-webkit-gradient(linear,0 0,0 100%,from(#bd362f),to(#ee5f5b));background-image:-webkit-linear-gradient(top,#bd362f,#ee5f5b);background-image:-o-linear-gradient(top,#bd362f,#ee5f5b);background-image:linear-gradient(to bottom,#bd362f,#ee5f5b);background-repeat:repeat-x;border-color:#ee5f5b #ee5f5b #e51d18;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger.disabled,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:focus,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:hover,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger[disabled],.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger.disabled,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:focus,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:hover,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger[disabled]{color:#fff;background-color:#ee5f5b}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger:active{background-color:#e9322d\9}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default{color:#333;text-shadow:0 1px 1px rgba(255,255,255,.75);background-color:#f0f0f0;background-image:-moz-linear-gradient(top,#e6e6e6,#fff);background-image:-webkit-gradient(linear,0 0,0 100%,from(#e6e6e6),to(#fff));background-image:-webkit-linear-gradient(top,#e6e6e6,#fff);background-image:-o-linear-gradient(top,#e6e6e6,#fff);background-image:linear-gradient(to bottom,#e6e6e6,#fff);background-repeat:repeat-x;border-color:#fff #fff #d9d9d9;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default.disabled,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:focus,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:hover,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default[disabled],.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default.disabled,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:focus,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:hover,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default[disabled]{color:#333;background-color:#fff}.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default.active,.bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default:active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default.active,.bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default:active{background-color:#e6e6e6\9}.bootstrap-switch .bootstrap-switch-label{text-align:center;margin-top:-1px;margin-bottom:-1px;z-index:100;border-left:1px solid #ccc;border-right:1px solid #ccc;color:#333;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#f5f5f5;background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.bootstrap-switch .bootstrap-switch-label.active,.bootstrap-switch .bootstrap-switch-label.disabled,.bootstrap-switch .bootstrap-switch-label:active,.bootstrap-switch .bootstrap-switch-label:focus,.bootstrap-switch .bootstrap-switch-label:hover,.bootstrap-switch .bootstrap-switch-label[disabled]{color:#333;background-color:#e6e6e6}.bootstrap-switch .bootstrap-switch-label.active,.bootstrap-switch .bootstrap-switch-label:active{background-color:#ccc\9}.bootstrap-switch span::before{content:"\200b"}.bootstrap-switch .bootstrap-switch-handle-on{border-top-left-radius:4px;border-bottom-left-radius:4px}.bootstrap-switch .bootstrap-switch-handle-off{-webkit-border-top-right-radius:4px;-moz-border-radius-topright:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px;border-bottom-right-radius:4px}.bootstrap-switch input[type=radio],.bootstrap-switch input[type=checkbox]{position:absolute!important;top:0;left:0;opacity:0;filter:alpha(opacity=0);z-index:-1;visibility:hidden}.bootstrap-switch input[type=radio].form-control,.bootstrap-switch input[type=checkbox].form-control{height:auto}.bootstrap-switch.bootstrap-switch-mini{min-width:71px}.bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-handle-off,.bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-label{padding:3px 6px;font-size:10px;line-height:9px}.bootstrap-switch.bootstrap-switch-small{min-width:79px}.bootstrap-switch.bootstrap-switch-small .bootstrap-switch-handle-off,.bootstrap-switch.bootstrap-switch-small .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-small .bootstrap-switch-label{padding:3px 6px;font-size:12px;line-height:18px}.bootstrap-switch.bootstrap-switch-large{min-width:120px}.bootstrap-switch.bootstrap-switch-large .bootstrap-switch-handle-off,.bootstrap-switch.bootstrap-switch-large .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-large .bootstrap-switch-label{padding:9px 12px;font-size:16px;line-height:normal}.bootstrap-switch.bootstrap-switch-disabled,.bootstrap-switch.bootstrap-switch-indeterminate,.bootstrap-switch.bootstrap-switch-readonly{cursor:default!important}.bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-handle-off,.bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-label,.bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-handle-off,.bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-label,.bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-handle-off,.bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-handle-on,.bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-label{opacity:.5;filter:alpha(opacity=50);cursor:default!important}.bootstrap-switch.bootstrap-switch-animate .bootstrap-switch-container{-webkit-transition:margin-left .5s;-moz-transition:margin-left .5s;-o-transition:margin-left .5s;transition:margin-left .5s}.bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-on{-webkit-border-top-left-radius:0;-moz-border-radius-topleft:0;-webkit-border-bottom-left-radius:0;-moz-border-radius-bottomleft:0;-webkit-border-top-right-radius:4px;-moz-border-radius-topright:4px;-webkit-border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px;border-radius:0 4px 4px 0}.bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-off{-webkit-border-top-right-radius:0;-moz-border-radius-topright:0;-webkit-border-bottom-right-radius:0;-moz-border-radius-bottomright:0;border-radius:4px 0 0 4px}.bootstrap-switch.bootstrap-switch-focused{border-color:rgba(82,168,236,.8);outline:0;outline:dotted thin\9;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(82,168,236,.6);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(82,168,236,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(82,168,236,.6)}.bootstrap-switch.bootstrap-switch-inverse.bootstrap-switch-off .bootstrap-switch-label,.bootstrap-switch.bootstrap-switch-on .bootstrap-switch-label{-webkit-border-top-right-radius:4px;-moz-border-radius-topright:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px;border-bottom-right-radius:4px}.bootstrap-switch.bootstrap-switch-inverse.bootstrap-switch-on .bootstrap-switch-label,.bootstrap-switch.bootstrap-switch-off .bootstrap-switch-label{-webkit-border-top-left-radius:4px;-moz-border-radius-topleft:4px;border-top-left-radius:4px;-webkit-border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px;border-bottom-left-radius:4px}
  admin-Public-Admin-plugins-bootstrap-switch-css-bootstrap3-bootstrap-switch.css: |
    /**
      * bootstrap-switch - Turn checkboxes and radio buttons into toggle switches.
      *
      * @version v3.3.4
      * @homepage https://bttstrp.github.io/bootstrap-switch
      * @author Mattia Larentis <mattia@larentis.eu> (http://larentis.eu)
      * @license Apache-2.0
      */

    .bootstrap-switch {
      display: inline-block;
      direction: ltr;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid;
      border-color: #ccc;
      position: relative;
      text-align: left;
      overflow: hidden;
      line-height: 8px;
      z-index: 0;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      vertical-align: middle;
      -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
      -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
      transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
    }
    .bootstrap-switch .bootstrap-switch-container {
      display: inline-block;
      top: 0;
      border-radius: 4px;
      -webkit-transform: translate3d(0, 0, 0);
      transform: translate3d(0, 0, 0);
    }
    .bootstrap-switch .bootstrap-switch-handle-on,
    .bootstrap-switch .bootstrap-switch-handle-off,
    .bootstrap-switch .bootstrap-switch-label {
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
      cursor: pointer;
      display: table-cell;
      vertical-align: middle;
      padding: 6px 12px;
      font-size: 14px;
      line-height: 20px;
    }
    .bootstrap-switch .bootstrap-switch-handle-on,
    .bootstrap-switch .bootstrap-switch-handle-off {
      text-align: center;
      z-index: 1;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-primary,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-primary {
      color: #fff;
      background: #337ab7;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-info,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-info {
      color: #fff;
      background: #5bc0de;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-success,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-success {
      color: #fff;
      background: #5cb85c;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-warning,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-warning {
      background: #f0ad4e;
      color: #fff;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-danger,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-danger {
      color: #fff;
      background: #d9534f;
    }
    .bootstrap-switch .bootstrap-switch-handle-on.bootstrap-switch-default,
    .bootstrap-switch .bootstrap-switch-handle-off.bootstrap-switch-default {
      color: #000;
      background: #eeeeee;
    }
    .bootstrap-switch .bootstrap-switch-label {
      text-align: center;
      margin-top: -1px;
      margin-bottom: -1px;
      z-index: 100;
      color: #333;
      background: #fff;
    }
    .bootstrap-switch span::before {
      content: "\200b";
    }
    .bootstrap-switch .bootstrap-switch-handle-on {
      border-bottom-left-radius: 3px;
      border-top-left-radius: 3px;
    }
    .bootstrap-switch .bootstrap-switch-handle-off {
      border-bottom-right-radius: 3px;
      border-top-right-radius: 3px;
    }
    .bootstrap-switch input[type='radio'],
    .bootstrap-switch input[type='checkbox'] {
      position: absolute !important;
      top: 0;
      left: 0;
      margin: 0;
      z-index: -1;
      opacity: 0;
      filter: alpha(opacity=0);
      visibility: hidden;
    }
    .bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-mini .bootstrap-switch-label {
      padding: 1px 5px;
      font-size: 12px;
      line-height: 1.5;
    }
    .bootstrap-switch.bootstrap-switch-small .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-small .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-small .bootstrap-switch-label {
      padding: 5px 10px;
      font-size: 12px;
      line-height: 1.5;
    }
    .bootstrap-switch.bootstrap-switch-large .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-large .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-large .bootstrap-switch-label {
      padding: 6px 16px;
      font-size: 18px;
      line-height: 1.3333333;
    }
    .bootstrap-switch.bootstrap-switch-disabled,
    .bootstrap-switch.bootstrap-switch-readonly,
    .bootstrap-switch.bootstrap-switch-indeterminate {
      cursor: default !important;
    }
    .bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-handle-on,
    .bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-handle-off,
    .bootstrap-switch.bootstrap-switch-disabled .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-readonly .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-indeterminate .bootstrap-switch-label {
      opacity: 0.5;
      filter: alpha(opacity=50);
      cursor: default !important;
    }
    .bootstrap-switch.bootstrap-switch-animate .bootstrap-switch-container {
      -webkit-transition: margin-left 0.5s;
      -o-transition: margin-left 0.5s;
      transition: margin-left 0.5s;
    }
    .bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-on {
      border-bottom-left-radius: 0;
      border-top-left-radius: 0;
      border-bottom-right-radius: 3px;
      border-top-right-radius: 3px;
    }
    .bootstrap-switch.bootstrap-switch-inverse .bootstrap-switch-handle-off {
      border-bottom-right-radius: 0;
      border-top-right-radius: 0;
      border-bottom-left-radius: 3px;
      border-top-left-radius: 3px;
    }
    .bootstrap-switch.bootstrap-switch-focused {
      border-color: #66afe9;
      outline: 0;
      -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
      box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
    }
    .bootstrap-switch.bootstrap-switch-on .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-inverse.bootstrap-switch-off .bootstrap-switch-label {
      border-bottom-right-radius: 3px;
      border-top-right-radius: 3px;
    }
    .bootstrap-switch.bootstrap-switch-off .bootstrap-switch-label,
    .bootstrap-switch.bootstrap-switch-inverse.bootstrap-switch-on .bootstrap-switch-label {
      border-bottom-left-radius: 3px;
      border-top-left-radius: 3px;
    }
  admin-Public-Admin-plugins-bootstrap-switch-js-bootstrap-switch.js: |
    /**
      * bootstrap-switch - Turn checkboxes and radio buttons into toggle switches.
      *
      * @version v3.3.4
      * @homepage https://bttstrp.github.io/bootstrap-switch
      * @author Mattia Larentis <mattia@larentis.eu> (http://larentis.eu)
      * @license Apache-2.0
      */

    (function (global, factory) {
      if (typeof define === "function" && define.amd) {
        define(['jquery'], factory);
      } else if (typeof exports !== "undefined") {
        factory(require('jquery'));
      } else {
        var mod = {
          exports: {}
        };
        factory(global.jquery);
        global.bootstrapSwitch = mod.exports;
      }
    })(this, function (_jquery) {
      'use strict';

      var _jquery2 = _interopRequireDefault(_jquery);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var $ = _jquery2.default || window.jQuery || window.$;

      var BootstrapSwitch = function () {
        function BootstrapSwitch(element) {
          var _this = this;

          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          _classCallCheck(this, BootstrapSwitch);

          this.$element = $(element);
          this.options = $.extend({}, $.fn.bootstrapSwitch.defaults, this._getElementOptions(), options);
          this.prevOptions = {};
          this.$wrapper = $('<div>', {
            class: function _class() {
              var classes = [];
              classes.push(_this.options.state ? 'on' : 'off');
              if (_this.options.size) {
                classes.push(_this.options.size);
              }
              if (_this.options.disabled) {
                classes.push('disabled');
              }
              if (_this.options.readonly) {
                classes.push('readonly');
              }
              if (_this.options.indeterminate) {
                classes.push('indeterminate');
              }
              if (_this.options.inverse) {
                classes.push('inverse');
              }
              if (_this.$element.attr('id')) {
                classes.push('id-' + _this.$element.attr('id'));
              }
              return classes.map(_this._getClass.bind(_this)).concat([_this.options.baseClass], _this._getClasses(_this.options.wrapperClass)).join(' ');
            }
          });
          this.$container = $('<div>', { class: this._getClass('container') });
          this.$on = $('<span>', {
            html: this.options.onText,
            class: this._getClass('handle-on') + ' ' + this._getClass(this.options.onColor)
          });
          this.$off = $('<span>', {
            html: this.options.offText,
            class: this._getClass('handle-off') + ' ' + this._getClass(this.options.offColor)
          });
          this.$label = $('<span>', {
            html: this.options.labelText,
            class: this._getClass('label')
          });

          this.$element.on('init.bootstrapSwitch', this.options.onInit.bind(this, element));
          this.$element.on('switchChange.bootstrapSwitch', function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            if (_this.options.onSwitchChange.apply(element, args) === false) {
              if (_this.$element.is(':radio')) {
                $('[name="' + _this.$element.attr('name') + '"]').trigger('previousState.bootstrapSwitch', true);
              } else {
                _this.$element.trigger('previousState.bootstrapSwitch', true);
              }
            }
          });

          this.$container = this.$element.wrap(this.$container).parent();
          this.$wrapper = this.$container.wrap(this.$wrapper).parent();
          this.$element.before(this.options.inverse ? this.$off : this.$on).before(this.$label).before(this.options.inverse ? this.$on : this.$off);

          if (this.options.indeterminate) {
            this.$element.prop('indeterminate', true);
          }

          this._init();
          this._elementHandlers();
          this._handleHandlers();
          this._labelHandlers();
          this._formHandler();
          this._externalLabelHandler();
          this.$element.trigger('init.bootstrapSwitch', this.options.state);
        }

        _createClass(BootstrapSwitch, [{
          key: 'setPrevOptions',
          value: function setPrevOptions() {
            this.prevOptions = _extends({}, this.options);
          }
        }, {
          key: 'state',
          value: function state(value, skip) {
            if (typeof value === 'undefined') {
              return this.options.state;
            }
            if (this.options.disabled || this.options.readonly || this.options.state && !this.options.radioAllOff && this.$element.is(':radio')) {
              return this.$element;
            }
            if (this.$element.is(':radio')) {
              $('[name="' + this.$element.attr('name') + '"]').trigger('setPreviousOptions.bootstrapSwitch');
            } else {
              this.$element.trigger('setPreviousOptions.bootstrapSwitch');
            }
            if (this.options.indeterminate) {
              this.indeterminate(false);
            }
            this.$element.prop('checked', Boolean(value)).trigger('change.bootstrapSwitch', skip);
            return this.$element;
          }
        }, {
          key: 'toggleState',
          value: function toggleState(skip) {
            if (this.options.disabled || this.options.readonly) {
              return this.$element;
            }
            if (this.options.indeterminate) {
              this.indeterminate(false);
              return this.state(true);
            } else {
              return this.$element.prop('checked', !this.options.state).trigger('change.bootstrapSwitch', skip);
            }
          }
        }, {
          key: 'size',
          value: function size(value) {
            if (typeof value === 'undefined') {
              return this.options.size;
            }
            if (this.options.size != null) {
              this.$wrapper.removeClass(this._getClass(this.options.size));
            }
            if (value) {
              this.$wrapper.addClass(this._getClass(value));
            }
            this._width();
            this._containerPosition();
            this.options.size = value;
            return this.$element;
          }
        }, {
          key: 'animate',
          value: function animate(value) {
            if (typeof value === 'undefined') {
              return this.options.animate;
            }
            if (this.options.animate === Boolean(value)) {
              return this.$element;
            }
            return this.toggleAnimate();
          }
        }, {
          key: 'toggleAnimate',
          value: function toggleAnimate() {
            this.options.animate = !this.options.animate;
            this.$wrapper.toggleClass(this._getClass('animate'));
            return this.$element;
          }
        }, {
          key: 'disabled',
          value: function disabled(value) {
            if (typeof value === 'undefined') {
              return this.options.disabled;
            }
            if (this.options.disabled === Boolean(value)) {
              return this.$element;
            }
            return this.toggleDisabled();
          }
        }, {
          key: 'toggleDisabled',
          value: function toggleDisabled() {
            this.options.disabled = !this.options.disabled;
            this.$element.prop('disabled', this.options.disabled);
            this.$wrapper.toggleClass(this._getClass('disabled'));
            return this.$element;
          }
        }, {
          key: 'readonly',
          value: function readonly(value) {
            if (typeof value === 'undefined') {
              return this.options.readonly;
            }
            if (this.options.readonly === Boolean(value)) {
              return this.$element;
            }
            return this.toggleReadonly();
          }
        }, {
          key: 'toggleReadonly',
          value: function toggleReadonly() {
            this.options.readonly = !this.options.readonly;
            this.$element.prop('readonly', this.options.readonly);
            this.$wrapper.toggleClass(this._getClass('readonly'));
            return this.$element;
          }
        }, {
          key: 'indeterminate',
          value: function indeterminate(value) {
            if (typeof value === 'undefined') {
              return this.options.indeterminate;
            }
            if (this.options.indeterminate === Boolean(value)) {
              return this.$element;
            }
            return this.toggleIndeterminate();
          }
        }, {
          key: 'toggleIndeterminate',
          value: function toggleIndeterminate() {
            this.options.indeterminate = !this.options.indeterminate;
            this.$element.prop('indeterminate', this.options.indeterminate);
            this.$wrapper.toggleClass(this._getClass('indeterminate'));
            this._containerPosition();
            return this.$element;
          }
        }, {
          key: 'inverse',
          value: function inverse(value) {
            if (typeof value === 'undefined') {
              return this.options.inverse;
            }
            if (this.options.inverse === Boolean(value)) {
              return this.$element;
            }
            return this.toggleInverse();
          }
        }, {
          key: 'toggleInverse',
          value: function toggleInverse() {
            this.$wrapper.toggleClass(this._getClass('inverse'));
            var $on = this.$on.clone(true);
            var $off = this.$off.clone(true);
            this.$on.replaceWith($off);
            this.$off.replaceWith($on);
            this.$on = $off;
            this.$off = $on;
            this.options.inverse = !this.options.inverse;
            return this.$element;
          }
        }, {
          key: 'onColor',
          value: function onColor(value) {
            if (typeof value === 'undefined') {
              return this.options.onColor;
            }
            if (this.options.onColor) {
              this.$on.removeClass(this._getClass(this.options.onColor));
            }
            this.$on.addClass(this._getClass(value));
            this.options.onColor = value;
            return this.$element;
          }
        }, {
          key: 'offColor',
          value: function offColor(value) {
            if (typeof value === 'undefined') {
              return this.options.offColor;
            }
            if (this.options.offColor) {
              this.$off.removeClass(this._getClass(this.options.offColor));
            }
            this.$off.addClass(this._getClass(value));
            this.options.offColor = value;
            return this.$element;
          }
        }, {
          key: 'onText',
          value: function onText(value) {
            if (typeof value === 'undefined') {
              return this.options.onText;
            }
            this.$on.html(value);
            this._width();
            this._containerPosition();
            this.options.onText = value;
            return this.$element;
          }
        }, {
          key: 'offText',
          value: function offText(value) {
            if (typeof value === 'undefined') {
              return this.options.offText;
            }
            this.$off.html(value);
            this._width();
            this._containerPosition();
            this.options.offText = value;
            return this.$element;
          }
        }, {
          key: 'labelText',
          value: function labelText(value) {
            if (typeof value === 'undefined') {
              return this.options.labelText;
            }
            this.$label.html(value);
            this._width();
            this.options.labelText = value;
            return this.$element;
          }
        }, {
          key: 'handleWidth',
          value: function handleWidth(value) {
            if (typeof value === 'undefined') {
              return this.options.handleWidth;
            }
            this.options.handleWidth = value;
            this._width();
            this._containerPosition();
            return this.$element;
          }
        }, {
          key: 'labelWidth',
          value: function labelWidth(value) {
            if (typeof value === 'undefined') {
              return this.options.labelWidth;
            }
            this.options.labelWidth = value;
            this._width();
            this._containerPosition();
            return this.$element;
          }
        }, {
          key: 'baseClass',
          value: function baseClass(value) {
            return this.options.baseClass;
          }
        }, {
          key: 'wrapperClass',
          value: function wrapperClass(value) {
            if (typeof value === 'undefined') {
              return this.options.wrapperClass;
            }
            if (!value) {
              value = $.fn.bootstrapSwitch.defaults.wrapperClass;
            }
            this.$wrapper.removeClass(this._getClasses(this.options.wrapperClass).join(' '));
            this.$wrapper.addClass(this._getClasses(value).join(' '));
            this.options.wrapperClass = value;
            return this.$element;
          }
        }, {
          key: 'radioAllOff',
          value: function radioAllOff(value) {
            if (typeof value === 'undefined') {
              return this.options.radioAllOff;
            }
            var val = Boolean(value);
            if (this.options.radioAllOff === val) {
              return this.$element;
            }
            this.options.radioAllOff = val;
            return this.$element;
          }
        }, {
          key: 'onInit',
          value: function onInit(value) {
            if (typeof value === 'undefined') {
              return this.options.onInit;
            }
            if (!value) {
              value = $.fn.bootstrapSwitch.defaults.onInit;
            }
            this.options.onInit = value;
            return this.$element;
          }
        }, {
          key: 'onSwitchChange',
          value: function onSwitchChange(value) {
            if (typeof value === 'undefined') {
              return this.options.onSwitchChange;
            }
            if (!value) {
              value = $.fn.bootstrapSwitch.defaults.onSwitchChange;
            }
            this.options.onSwitchChange = value;
            return this.$element;
          }
        }, {
          key: 'destroy',
          value: function destroy() {
            var $form = this.$element.closest('form');
            if ($form.length) {
              $form.off('reset.bootstrapSwitch').removeData('bootstrap-switch');
            }
            this.$container.children().not(this.$element).remove();
            this.$element.unwrap().unwrap().off('.bootstrapSwitch').removeData('bootstrap-switch');
            return this.$element;
          }
        }, {
          key: '_getElementOptions',
          value: function _getElementOptions() {
            return {
              state: this.$element.is(':checked'),
              size: this.$element.data('size'),
              animate: this.$element.data('animate'),
              disabled: this.$element.is(':disabled'),
              readonly: this.$element.is('[readonly]'),
              indeterminate: this.$element.data('indeterminate'),
              inverse: this.$element.data('inverse'),
              radioAllOff: this.$element.data('radio-all-off'),
              onColor: this.$element.data('on-color'),
              offColor: this.$element.data('off-color'),
              onText: this.$element.data('on-text'),
              offText: this.$element.data('off-text'),
              labelText: this.$element.data('label-text'),
              handleWidth: this.$element.data('handle-width'),
              labelWidth: this.$element.data('label-width'),
              baseClass: this.$element.data('base-class'),
              wrapperClass: this.$element.data('wrapper-class')
            };
          }
        }, {
          key: '_width',
          value: function _width() {
            var _this2 = this;

            var $handles = this.$on.add(this.$off).add(this.$label).css('width', '');
            var handleWidth = this.options.handleWidth === 'auto' ? Math.round(Math.max(this.$on.width(), this.$off.width())) : this.options.handleWidth;
            $handles.width(handleWidth);
            this.$label.width(function (index, width) {
              if (_this2.options.labelWidth !== 'auto') {
                return _this2.options.labelWidth;
              }
              if (width < handleWidth) {
                return handleWidth;
              }
              return width;
            });
            this._handleWidth = this.$on.outerWidth();
            this._labelWidth = this.$label.outerWidth();
            this.$container.width(this._handleWidth * 2 + this._labelWidth);
            return this.$wrapper.width(this._handleWidth + this._labelWidth);
          }
        }, {
          key: '_containerPosition',
          value: function _containerPosition() {
            var _this3 = this;

            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.state;
            var callback = arguments[1];

            this.$container.css('margin-left', function () {
              var values = [0, '-' + _this3._handleWidth + 'px'];
              if (_this3.options.indeterminate) {
                return '-' + _this3._handleWidth / 2 + 'px';
              }
              if (state) {
                if (_this3.options.inverse) {
                  return values[1];
                } else {
                  return values[0];
                }
              } else {
                if (_this3.options.inverse) {
                  return values[0];
                } else {
                  return values[1];
                }
              }
            });
          }
        }, {
          key: '_init',
          value: function _init() {
            var _this4 = this;

            var init = function init() {
              _this4.setPrevOptions();
              _this4._width();
              _this4._containerPosition();
              setTimeout(function () {
                if (_this4.options.animate) {
                  return _this4.$wrapper.addClass(_this4._getClass('animate'));
                }
              }, 50);
            };
            if (this.$wrapper.is(':visible')) {
              init();
              return;
            }
            var initInterval = window.setInterval(function () {
              if (_this4.$wrapper.is(':visible')) {
                init();
                return window.clearInterval(initInterval);
              }
            }, 50);
          }
        }, {
          key: '_elementHandlers',
          value: function _elementHandlers() {
            var _this5 = this;

            return this.$element.on({
              'setPreviousOptions.bootstrapSwitch': this.setPrevOptions.bind(this),

              'previousState.bootstrapSwitch': function previousStateBootstrapSwitch() {
                _this5.options = _this5.prevOptions;
                if (_this5.options.indeterminate) {
                  _this5.$wrapper.addClass(_this5._getClass('indeterminate'));
                }
                _this5.$element.prop('checked', _this5.options.state).trigger('change.bootstrapSwitch', true);
              },

              'change.bootstrapSwitch': function changeBootstrapSwitch(event, skip) {
                event.preventDefault();
                event.stopImmediatePropagation();
                var state = _this5.$element.is(':checked');
                _this5._containerPosition(state);
                if (state === _this5.options.state) {
                  return;
                }
                _this5.options.state = state;
                _this5.$wrapper.toggleClass(_this5._getClass('off')).toggleClass(_this5._getClass('on'));
                if (!skip) {
                  if (_this5.$element.is(':radio')) {
                    $('[name="' + _this5.$element.attr('name') + '"]').not(_this5.$element).prop('checked', false).trigger('change.bootstrapSwitch', true);
                  }
                  _this5.$element.trigger('switchChange.bootstrapSwitch', [state]);
                }
              },

              'focus.bootstrapSwitch': function focusBootstrapSwitch(event) {
                event.preventDefault();
                _this5.$wrapper.addClass(_this5._getClass('focused'));
              },

              'blur.bootstrapSwitch': function blurBootstrapSwitch(event) {
                event.preventDefault();
                _this5.$wrapper.removeClass(_this5._getClass('focused'));
              },

              'keydown.bootstrapSwitch': function keydownBootstrapSwitch(event) {
                if (!event.which || _this5.options.disabled || _this5.options.readonly) {
                  return;
                }
                if (event.which === 37 || event.which === 39) {
                  event.preventDefault();
                  event.stopImmediatePropagation();
                  _this5.state(event.which === 39);
                }
              }
            });
          }
        }, {
          key: '_handleHandlers',
          value: function _handleHandlers() {
            var _this6 = this;

            this.$on.on('click.bootstrapSwitch', function (event) {
              event.preventDefault();
              event.stopPropagation();
              _this6.state(false);
              return _this6.$element.trigger('focus.bootstrapSwitch');
            });
            return this.$off.on('click.bootstrapSwitch', function (event) {
              event.preventDefault();
              event.stopPropagation();
              _this6.state(true);
              return _this6.$element.trigger('focus.bootstrapSwitch');
            });
          }
        }, {
          key: '_labelHandlers',
          value: function _labelHandlers() {
            var _this7 = this;

            var handlers = {
              click: function click(event) {
                event.stopPropagation();
              },


              'mousedown.bootstrapSwitch touchstart.bootstrapSwitch': function mousedownBootstrapSwitchTouchstartBootstrapSwitch(event) {
                if (_this7._dragStart || _this7.options.disabled || _this7.options.readonly) {
                  return;
                }
                event.preventDefault();
                event.stopPropagation();
                _this7._dragStart = (event.pageX || event.originalEvent.touches[0].pageX) - parseInt(_this7.$container.css('margin-left'), 10);
                if (_this7.options.animate) {
                  _this7.$wrapper.removeClass(_this7._getClass('animate'));
                }
                _this7.$element.trigger('focus.bootstrapSwitch');
              },

              'mousemove.bootstrapSwitch touchmove.bootstrapSwitch': function mousemoveBootstrapSwitchTouchmoveBootstrapSwitch(event) {
                if (_this7._dragStart == null) {
                  return;
                }
                var difference = (event.pageX || event.originalEvent.touches[0].pageX) - _this7._dragStart;
                event.preventDefault();
                if (difference < -_this7._handleWidth || difference > 0) {
                  return;
                }
                _this7._dragEnd = difference;
                _this7.$container.css('margin-left', _this7._dragEnd + 'px');
              },

              'mouseup.bootstrapSwitch touchend.bootstrapSwitch': function mouseupBootstrapSwitchTouchendBootstrapSwitch(event) {
                if (!_this7._dragStart) {
                  return;
                }
                event.preventDefault();
                if (_this7.options.animate) {
                  _this7.$wrapper.addClass(_this7._getClass('animate'));
                }
                if (_this7._dragEnd) {
                  var state = _this7._dragEnd > -(_this7._handleWidth / 2);
                  _this7._dragEnd = false;
                  _this7.state(_this7.options.inverse ? !state : state);
                } else {
                  _this7.state(!_this7.options.state);
                }
                _this7._dragStart = false;
              },

              'mouseleave.bootstrapSwitch': function mouseleaveBootstrapSwitch() {
                _this7.$label.trigger('mouseup.bootstrapSwitch');
              }
            };
            this.$label.on(handlers);
          }
        }, {
          key: '_externalLabelHandler',
          value: function _externalLabelHandler() {
            var _this8 = this;

            var $externalLabel = this.$element.closest('label');
            $externalLabel.on('click', function (event) {
              event.preventDefault();
              event.stopImmediatePropagation();
              if (event.target === $externalLabel[0]) {
                _this8.toggleState();
              }
            });
          }
        }, {
          key: '_formHandler',
          value: function _formHandler() {
            var $form = this.$element.closest('form');
            if ($form.data('bootstrap-switch')) {
              return;
            }
            $form.on('reset.bootstrapSwitch', function () {
              window.setTimeout(function () {
                $form.find('input').filter(function () {
                  return $(this).data('bootstrap-switch');
                }).each(function () {
                  return $(this).bootstrapSwitch('state', this.checked);
                });
              }, 1);
            }).data('bootstrap-switch', true);
          }
        }, {
          key: '_getClass',
          value: function _getClass(name) {
            return this.options.baseClass + '-' + name;
          }
        }, {
          key: '_getClasses',
          value: function _getClasses(classes) {
            if (!$.isArray(classes)) {
              return [this._getClass(classes)];
            }
            return classes.map(this._getClass.bind(this));
          }
        }]);

        return BootstrapSwitch;
      }();

      $.fn.bootstrapSwitch = function (option) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        function reducer(ret, next) {
          var $this = $(next);
          var existingData = $this.data('bootstrap-switch');
          var data = existingData || new BootstrapSwitch(next, option);
          if (!existingData) {
            $this.data('bootstrap-switch', data);
          }
          if (typeof option === 'string') {
            return data[option].apply(data, args);
          }
          return ret;
        }
        return Array.prototype.reduce.call(this, reducer, this);
      };
      $.fn.bootstrapSwitch.Constructor = BootstrapSwitch;
      $.fn.bootstrapSwitch.defaults = {
        state: true,
        size: null,
        animate: true,
        disabled: false,
        readonly: false,
        indeterminate: false,
        inverse: false,
        radioAllOff: false,
        onColor: 'primary',
        offColor: 'default',
        onText: 'ON',
        offText: 'OFF',
        labelText: '&nbsp',
        handleWidth: 'auto',
        labelWidth: 'auto',
        baseClass: 'bootstrap-switch',
        wrapperClass: 'wrapper',
        onInit: function onInit() {},
        onSwitchChange: function onSwitchChange() {}
      };
    });
  admin-Public-Admin-plugins-bootstrap-switch-js-bootstrap-switch.min.js: |
    /**
      * bootstrap-switch - Turn checkboxes and radio buttons into toggle switches.
      *
      * @version v3.3.4
      * @homepage https://bttstrp.github.io/bootstrap-switch
      * @author Mattia Larentis <mattia@larentis.eu> (http://larentis.eu)
      * @license Apache-2.0
      */

    (function(a,b){if('function'==typeof define&&define.amd)define(['jquery'],b);else if('undefined'!=typeof exports)b(require('jquery'));else{b(a.jquery),a.bootstrapSwitch={exports:{}}.exports}})(this,function(a){'use strict';function c(j,k){if(!(j instanceof k))throw new TypeError('Cannot call a class as a function')}var d=function(j){return j&&j.__esModule?j:{default:j}}(a),e=Object.assign||function(j){for(var l,k=1;k<arguments.length;k++)for(var m in l=arguments[k],l)Object.prototype.hasOwnProperty.call(l,m)&&(j[m]=l[m]);return j},f=function(){function j(k,l){for(var n,m=0;m<l.length;m++)n=l[m],n.enumerable=n.enumerable||!1,n.configurable=!0,'value'in n&&(n.writable=!0),Object.defineProperty(k,n.key,n)}return function(k,l,m){return l&&j(k.prototype,l),m&&j(k,m),k}}(),g=d.default||window.jQuery||window.$,h=function(){function j(k){var l=this,m=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};c(this,j),this.$element=g(k),this.options=g.extend({},g.fn.bootstrapSwitch.defaults,this._getElementOptions(),m),this.prevOptions={},this.$wrapper=g('<div>',{class:function(){var o=[];return o.push(l.options.state?'on':'off'),l.options.size&&o.push(l.options.size),l.options.disabled&&o.push('disabled'),l.options.readonly&&o.push('readonly'),l.options.indeterminate&&o.push('indeterminate'),l.options.inverse&&o.push('inverse'),l.$element.attr('id')&&o.push('id-'+l.$element.attr('id')),o.map(l._getClass.bind(l)).concat([l.options.baseClass],l._getClasses(l.options.wrapperClass)).join(' ')}}),this.$container=g('<div>',{class:this._getClass('container')}),this.$on=g('<span>',{html:this.options.onText,class:this._getClass('handle-on')+' '+this._getClass(this.options.onColor)}),this.$off=g('<span>',{html:this.options.offText,class:this._getClass('handle-off')+' '+this._getClass(this.options.offColor)}),this.$label=g('<span>',{html:this.options.labelText,class:this._getClass('label')}),this.$element.on('init.bootstrapSwitch',this.options.onInit.bind(this,k)),this.$element.on('switchChange.bootstrapSwitch',function(){for(var n=arguments.length,o=Array(n),p=0;p<n;p++)o[p]=arguments[p];!1===l.options.onSwitchChange.apply(k,o)&&(l.$element.is(':radio')?g('[name="'+l.$element.attr('name')+'"]').trigger('previousState.bootstrapSwitch',!0):l.$element.trigger('previousState.bootstrapSwitch',!0))}),this.$container=this.$element.wrap(this.$container).parent(),this.$wrapper=this.$container.wrap(this.$wrapper).parent(),this.$element.before(this.options.inverse?this.$off:this.$on).before(this.$label).before(this.options.inverse?this.$on:this.$off),this.options.indeterminate&&this.$element.prop('indeterminate',!0),this._init(),this._elementHandlers(),this._handleHandlers(),this._labelHandlers(),this._formHandler(),this._externalLabelHandler(),this.$element.trigger('init.bootstrapSwitch',this.options.state)}return f(j,[{key:'setPrevOptions',value:function(){this.prevOptions=e({},this.options)}},{key:'state',value:function(l,m){return'undefined'==typeof l?this.options.state:this.options.disabled||this.options.readonly||this.options.state&&!this.options.radioAllOff&&this.$element.is(':radio')?this.$element:(this.$element.is(':radio')?g('[name="'+this.$element.attr('name')+'"]').trigger('setPreviousOptions.bootstrapSwitch'):this.$element.trigger('setPreviousOptions.bootstrapSwitch'),this.options.indeterminate&&this.indeterminate(!1),this.$element.prop('checked',!!l).trigger('change.bootstrapSwitch',m),this.$element)}},{key:'toggleState',value:function(l){return this.options.disabled||this.options.readonly?this.$element:this.options.indeterminate?(this.indeterminate(!1),this.state(!0)):this.$element.prop('checked',!this.options.state).trigger('change.bootstrapSwitch',l)}},{key:'size',value:function(l){return'undefined'==typeof l?this.options.size:(null!=this.options.size&&this.$wrapper.removeClass(this._getClass(this.options.size)),l&&this.$wrapper.addClass(this._getClass(l)),this._width(),this._containerPosition(),this.options.size=l,this.$element)}},{key:'animate',value:function(l){return'undefined'==typeof l?this.options.animate:this.options.animate===!!l?this.$element:this.toggleAnimate()}},{key:'toggleAnimate',value:function(){return this.options.animate=!this.options.animate,this.$wrapper.toggleClass(this._getClass('animate')),this.$element}},{key:'disabled',value:function(l){return'undefined'==typeof l?this.options.disabled:this.options.disabled===!!l?this.$element:this.toggleDisabled()}},{key:'toggleDisabled',value:function(){return this.options.disabled=!this.options.disabled,this.$element.prop('disabled',this.options.disabled),this.$wrapper.toggleClass(this._getClass('disabled')),this.$element}},{key:'readonly',value:function(l){return'undefined'==typeof l?this.options.readonly:this.options.readonly===!!l?this.$element:this.toggleReadonly()}},{key:'toggleReadonly',value:function(){return this.options.readonly=!this.options.readonly,this.$element.prop('readonly',this.options.readonly),this.$wrapper.toggleClass(this._getClass('readonly')),this.$element}},{key:'indeterminate',value:function(l){return'undefined'==typeof l?this.options.indeterminate:this.options.indeterminate===!!l?this.$element:this.toggleIndeterminate()}},{key:'toggleIndeterminate',value:function(){return this.options.indeterminate=!this.options.indeterminate,this.$element.prop('indeterminate',this.options.indeterminate),this.$wrapper.toggleClass(this._getClass('indeterminate')),this._containerPosition(),this.$element}},{key:'inverse',value:function(l){return'undefined'==typeof l?this.options.inverse:this.options.inverse===!!l?this.$element:this.toggleInverse()}},{key:'toggleInverse',value:function(){this.$wrapper.toggleClass(this._getClass('inverse'));var l=this.$on.clone(!0),m=this.$off.clone(!0);return this.$on.replaceWith(m),this.$off.replaceWith(l),this.$on=m,this.$off=l,this.options.inverse=!this.options.inverse,this.$element}},{key:'onColor',value:function(l){return'undefined'==typeof l?this.options.onColor:(this.options.onColor&&this.$on.removeClass(this._getClass(this.options.onColor)),this.$on.addClass(this._getClass(l)),this.options.onColor=l,this.$element)}},{key:'offColor',value:function(l){return'undefined'==typeof l?this.options.offColor:(this.options.offColor&&this.$off.removeClass(this._getClass(this.options.offColor)),this.$off.addClass(this._getClass(l)),this.options.offColor=l,this.$element)}},{key:'onText',value:function(l){return'undefined'==typeof l?this.options.onText:(this.$on.html(l),this._width(),this._containerPosition(),this.options.onText=l,this.$element)}},{key:'offText',value:function(l){return'undefined'==typeof l?this.options.offText:(this.$off.html(l),this._width(),this._containerPosition(),this.options.offText=l,this.$element)}},{key:'labelText',value:function(l){return'undefined'==typeof l?this.options.labelText:(this.$label.html(l),this._width(),this.options.labelText=l,this.$element)}},{key:'handleWidth',value:function(l){return'undefined'==typeof l?this.options.handleWidth:(this.options.handleWidth=l,this._width(),this._containerPosition(),this.$element)}},{key:'labelWidth',value:function(l){return'undefined'==typeof l?this.options.labelWidth:(this.options.labelWidth=l,this._width(),this._containerPosition(),this.$element)}},{key:'baseClass',value:function(){return this.options.baseClass}},{key:'wrapperClass',value:function(l){return'undefined'==typeof l?this.options.wrapperClass:(l||(l=g.fn.bootstrapSwitch.defaults.wrapperClass),this.$wrapper.removeClass(this._getClasses(this.options.wrapperClass).join(' ')),this.$wrapper.addClass(this._getClasses(l).join(' ')),this.options.wrapperClass=l,this.$element)}},{key:'radioAllOff',value:function(l){if('undefined'==typeof l)return this.options.radioAllOff;var m=!!l;return this.options.radioAllOff===m?this.$element:(this.options.radioAllOff=m,this.$element)}},{key:'onInit',value:function(l){return'undefined'==typeof l?this.options.onInit:(l||(l=g.fn.bootstrapSwitch.defaults.onInit),this.options.onInit=l,this.$element)}},{key:'onSwitchChange',value:function(l){return'undefined'==typeof l?this.options.onSwitchChange:(l||(l=g.fn.bootstrapSwitch.defaults.onSwitchChange),this.options.onSwitchChange=l,this.$element)}},{key:'destroy',value:function(){var l=this.$element.closest('form');return l.length&&l.off('reset.bootstrapSwitch').removeData('bootstrap-switch'),this.$container.children().not(this.$element).remove(),this.$element.unwrap().unwrap().off('.bootstrapSwitch').removeData('bootstrap-switch'),this.$element}},{key:'_getElementOptions',value:function(){return{state:this.$element.is(':checked'),size:this.$element.data('size'),animate:this.$element.data('animate'),disabled:this.$element.is(':disabled'),readonly:this.$element.is('[readonly]'),indeterminate:this.$element.data('indeterminate'),inverse:this.$element.data('inverse'),radioAllOff:this.$element.data('radio-all-off'),onColor:this.$element.data('on-color'),offColor:this.$element.data('off-color'),onText:this.$element.data('on-text'),offText:this.$element.data('off-text'),labelText:this.$element.data('label-text'),handleWidth:this.$element.data('handle-width'),labelWidth:this.$element.data('label-width'),baseClass:this.$element.data('base-class'),wrapperClass:this.$element.data('wrapper-class')}}},{key:'_width',value:function(){var l=this,m=this.$on.add(this.$off).add(this.$label).css('width',''),n='auto'===this.options.handleWidth?Math.round(Math.max(this.$on.width(),this.$off.width())):this.options.handleWidth;return m.width(n),this.$label.width(function(o,p){return'auto'===l.options.labelWidth?p<n?n:p:l.options.labelWidth}),this._handleWidth=this.$on.outerWidth(),this._labelWidth=this.$label.outerWidth(),this.$container.width(2*this._handleWidth+this._labelWidth),this.$wrapper.width(this._handleWidth+this._labelWidth)}},{key:'_containerPosition',value:function(){var l=this,m=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.options.state,n=arguments[1];this.$container.css('margin-left',function(){var o=[0,'-'+l._handleWidth+'px'];return l.options.indeterminate?'-'+l._handleWidth/2+'px':m?l.options.inverse?o[1]:o[0]:l.options.inverse?o[0]:o[1]})}},{key:'_init',value:function(){var l=this,m=function(){l.setPrevOptions(),l._width(),l._containerPosition(),setTimeout(function(){if(l.options.animate)return l.$wrapper.addClass(l._getClass('animate'))},50)};if(this.$wrapper.is(':visible'))return void m();var n=window.setInterval(function(){if(l.$wrapper.is(':visible'))return m(),window.clearInterval(n)},50)}},{key:'_elementHandlers',value:function(){var l=this;return this.$element.on({'setPreviousOptions.bootstrapSwitch':this.setPrevOptions.bind(this),'previousState.bootstrapSwitch':function(){l.options=l.prevOptions,l.options.indeterminate&&l.$wrapper.addClass(l._getClass('indeterminate')),l.$element.prop('checked',l.options.state).trigger('change.bootstrapSwitch',!0)},'change.bootstrapSwitch':function(n,o){n.preventDefault(),n.stopImmediatePropagation();var p=l.$element.is(':checked');l._containerPosition(p),p===l.options.state||(l.options.state=p,l.$wrapper.toggleClass(l._getClass('off')).toggleClass(l._getClass('on')),!o&&(l.$element.is(':radio')&&g('[name="'+l.$element.attr('name')+'"]').not(l.$element).prop('checked',!1).trigger('change.bootstrapSwitch',!0),l.$element.trigger('switchChange.bootstrapSwitch',[p])))},'focus.bootstrapSwitch':function(n){n.preventDefault(),l.$wrapper.addClass(l._getClass('focused'))},'blur.bootstrapSwitch':function(n){n.preventDefault(),l.$wrapper.removeClass(l._getClass('focused'))},'keydown.bootstrapSwitch':function(n){!n.which||l.options.disabled||l.options.readonly||(37===n.which||39===n.which)&&(n.preventDefault(),n.stopImmediatePropagation(),l.state(39===n.which))}})}},{key:'_handleHandlers',value:function(){var l=this;return this.$on.on('click.bootstrapSwitch',function(m){return m.preventDefault(),m.stopPropagation(),l.state(!1),l.$element.trigger('focus.bootstrapSwitch')}),this.$off.on('click.bootstrapSwitch',function(m){return m.preventDefault(),m.stopPropagation(),l.state(!0),l.$element.trigger('focus.bootstrapSwitch')})}},{key:'_labelHandlers',value:function(){var l=this;this.$label.on({click:function(o){o.stopPropagation()},'mousedown.bootstrapSwitch touchstart.bootstrapSwitch':function(o){l._dragStart||l.options.disabled||l.options.readonly||(o.preventDefault(),o.stopPropagation(),l._dragStart=(o.pageX||o.originalEvent.touches[0].pageX)-parseInt(l.$container.css('margin-left'),10),l.options.animate&&l.$wrapper.removeClass(l._getClass('animate')),l.$element.trigger('focus.bootstrapSwitch'))},'mousemove.bootstrapSwitch touchmove.bootstrapSwitch':function(o){if(null!=l._dragStart){var p=(o.pageX||o.originalEvent.touches[0].pageX)-l._dragStart;o.preventDefault(),p<-l._handleWidth||0<p||(l._dragEnd=p,l.$container.css('margin-left',l._dragEnd+'px'))}},'mouseup.bootstrapSwitch touchend.bootstrapSwitch':function(o){if(l._dragStart){if(o.preventDefault(),l.options.animate&&l.$wrapper.addClass(l._getClass('animate')),l._dragEnd){var p=l._dragEnd>-(l._handleWidth/2);l._dragEnd=!1,l.state(l.options.inverse?!p:p)}else l.state(!l.options.state);l._dragStart=!1}},'mouseleave.bootstrapSwitch':function(){l.$label.trigger('mouseup.bootstrapSwitch')}})}},{key:'_externalLabelHandler',value:function(){var l=this,m=this.$element.closest('label');m.on('click',function(n){n.preventDefault(),n.stopImmediatePropagation(),n.target===m[0]&&l.toggleState()})}},{key:'_formHandler',value:function(){var l=this.$element.closest('form');l.data('bootstrap-switch')||l.on('reset.bootstrapSwitch',function(){window.setTimeout(function(){l.find('input').filter(function(){return g(this).data('bootstrap-switch')}).each(function(){return g(this).bootstrapSwitch('state',this.checked)})},1)}).data('bootstrap-switch',!0)}},{key:'_getClass',value:function(l){return this.options.baseClass+'-'+l}},{key:'_getClasses',value:function(l){return g.isArray(l)?l.map(this._getClass.bind(this)):[this._getClass(l)]}}]),j}();g.fn.bootstrapSwitch=function(j){for(var l=arguments.length,m=Array(1<l?l-1:0),n=1;n<l;n++)m[n-1]=arguments[n];return Array.prototype.reduce.call(this,function(o,p){var q=g(p),r=q.data('bootstrap-switch'),s=r||new h(p,j);return r||q.data('bootstrap-switch',s),'string'==typeof j?s[j].apply(s,m):o},this)},g.fn.bootstrapSwitch.Constructor=h,g.fn.bootstrapSwitch.defaults={state:!0,size:null,animate:!0,disabled:!1,readonly:!1,indeterminate:!1,inverse:!1,radioAllOff:!1,onColor:'primary',offColor:'default',onText:'ON',offText:'OFF',labelText:'&nbsp',handleWidth:'auto',labelWidth:'auto',baseClass:'bootstrap-switch',wrapperClass:'wrapper',onInit:function(){},onSwitchChange:function(){}}});
  admin-Public-Admin-plugins-chart.js-Chart.bundle.js: "/*!\n * Chart.js v2.9.4\n
    * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under
    the MIT License\n */\n(function (global, factory) {\ntypeof exports === 'object'
    && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define
    === 'function' && define.amd ? define(factory) :\n(global = global || self, global.Chart
    = factory());\n}(this, (function () { 'use strict';\n\nvar commonjsGlobal = typeof
    globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self
    : {};\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are
    not currently supported by rollup-plugin-commonjs');\n}\n\nfunction createCommonjsModule(fn,
    module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nfunction
    getCjsExportFromNamespace (n) {\n\treturn n && n['default'] || n;\n}\n\nvar colorName
    = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\":
    [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255,
    255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\":
    [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\":
    [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184,
    135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\":
    [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100,
    149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\":
    [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\":
    [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100,
    0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\":
    [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255,
    140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\":
    [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\":
    [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47,
    79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0,
    211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\":
    [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30,
    144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250,
    240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\":
    [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215,
    0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\":
    [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\":
    [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205,
    92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\":
    [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255,
    240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250,
    205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\":
    [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\":
    [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211,
    211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160,
    122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206,
    250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119,
    136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255,
    255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\":
    [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\":
    [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186,
    85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60,
    179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\":
    [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\":
    [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245,
    255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228,
    181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\":
    [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142,
    35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\":
    [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\":
    [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\":
    [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255,
    218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\":
    [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128,
    0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\":
    [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139,
    69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\":
    [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82,
    45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\":
    [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112,
    128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\":
    [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\":
    [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224,
    208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\":
    [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255,
    255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\nvar conversions = createCommonjsModule(function
    (module) {\n/* MIT license */\n\n\n// NOTE: conversions should only return primitive
    values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//
    \      do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords
    = {};\nfor (var key in colorName) {\n\tif (colorName.hasOwnProperty(key)) {\n\t\treverseKeywords[colorName[key]]
    = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels:
    'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb:
    {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz:
    {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels:
    3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels:
    1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256:
    {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple:
    {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n//
    hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model))
    {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing
    channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model]))
    {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif
    (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new
    Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels
    = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete
    convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model],
    'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels',
    {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0]
    / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r,
    g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar
    s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th
    = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t}
    else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h *
    60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif
    (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max +
    min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100,
    l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar
    bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar
    b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r,
    g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif
    (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif
    = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t}
    else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v)
    {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t}
    else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts
    * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r =
    rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar
    w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r,
    Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk =
    function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b =
    rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r,
    1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k)
    || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100,
    k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n
    * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0],
    2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword
    = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn
    reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor
    (var keyword in colorName) {\n\t\tif (colorName.hasOwnProperty(keyword)) {\n\t\t\tvar
    value = colorName[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar
    distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if
    so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance
    = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn
    currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn
    colorName[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0]
    / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr
    = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g >
    0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045
    ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124)
    + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar
    z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100,
    z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar
    x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx
    /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1
    / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787
    * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16
    / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn
    [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar
    s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar
    rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val,
    val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l
    + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i =
    0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif
    (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2
    - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if
    (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval
    = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv
    = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2]
    / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl
    *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv
    = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn
    [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0]
    / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h)
    % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q =
    255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch
    (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v,
    p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase
    4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl
    = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2]
    / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl
    = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1)
    ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n//
    http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb)
    {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar
    ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant
    be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6
    * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1
    - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar
    g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g
    = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r =
    wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4:
    r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn
    [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar
    c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar
    k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c *
    (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1,
    y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb
    = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z
    = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372)
    + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x
    * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t?
    ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t?
    ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t?
    ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0,
    r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn
    [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar
    x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx
    /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1
    / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787
    * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16
    / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn
    [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar
    a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16)
    / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar
    x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y
    - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz
    = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz
    *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar
    l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar
    c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0)
    {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab
    = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar
    a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb
    = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function
    (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value
    = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue
    = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar
    ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t|
    Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn
    ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we
    already know the value and don't need to get\n\t// it converted for us.\n\treturn
    convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256
    = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t//
    we use the extended greyscale palette here, with the exception of\n\t// black
    and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g ===
    b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn
    231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar
    ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255
    * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb
    = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color
    === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor
    = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult
    = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g =
    (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn
    [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif
    (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs
    -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem
    = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g,
    b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0])
    & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2])
    & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length)
    + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif
    (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif
    (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function
    (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer =
    parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer
    >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg
    = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b
    = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r,
    g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma
    < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif
    (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b)
    / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t}
    else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn
    [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function
    (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar
    f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s
    * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn
    [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s
    = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif
    (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f *
    100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar
    c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g
    * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1)
    * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi))
    {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase
    1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0]
    = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1]
    = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2]
    = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg
    = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1]
    + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function
    (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g *
    (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn
    [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c
    = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar
    s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l
    >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s *
    100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar
    g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100,
    (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] /
    100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif
    (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb
    = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) *
    255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn
    [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb
    = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0]
    / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn
    [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100,
    gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab
    = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function
    (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer =
    (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn
    '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function
    (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n});\nvar
    conversions_1 = conversions.rgb;\nvar conversions_2 = conversions.hsl;\nvar conversions_3
    = conversions.hsv;\nvar conversions_4 = conversions.hwb;\nvar conversions_5 =
    conversions.cmyk;\nvar conversions_6 = conversions.xyz;\nvar conversions_7 = conversions.lab;\nvar
    conversions_8 = conversions.lch;\nvar conversions_9 = conversions.hex;\nvar conversions_10
    = conversions.keyword;\nvar conversions_11 = conversions.ansi16;\nvar conversions_12
    = conversions.ansi256;\nvar conversions_13 = conversions.hcg;\nvar conversions_14
    = conversions.apple;\nvar conversions_15 = conversions.gray;\n\n/*\n\tthis function
    routes a model to all other models.\n\n\tall functions that are routed have a
    property `.conversion` attached\n\tto the returned synthetic function. This property
    is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor
    models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction
    buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar
    models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i
    < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t//
    micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn
    graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel)
    {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue
    -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar
    current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor
    (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar
    node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance
    = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn
    graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn
    to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path
    = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar
    cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn
    = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion
    = path;\n\treturn fn;\n}\n\nvar route = function (fromModel) {\n\tvar graph =
    deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor
    (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar
    node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible
    conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel]
    = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\nvar convert
    = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar
    wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn
    args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn
    fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion'
    in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction
    wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined
    || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1)
    {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result
    = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see
    notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif
    (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i <
    len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn
    result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion'
    in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function
    (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel],
    'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel],
    'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar
    routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel)
    {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw
    = wrapRaw(fn);\n\t});\n});\n\nvar colorConvert = convert;\n\nvar colorName$1 =
    {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\":
    [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255,
    255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\":
    [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\":
    [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184,
    135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\":
    [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100,
    149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\":
    [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\":
    [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100,
    0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\":
    [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255,
    140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\":
    [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\":
    [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47,
    79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0,
    211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\":
    [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30,
    144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250,
    240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\":
    [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215,
    0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\":
    [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\":
    [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205,
    92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\":
    [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255,
    240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250,
    205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\":
    [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\":
    [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211,
    211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160,
    122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206,
    250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119,
    136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255,
    255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\":
    [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\":
    [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186,
    85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60,
    179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\":
    [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\":
    [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245,
    255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228,
    181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\":
    [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142,
    35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\":
    [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\":
    [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\":
    [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255,
    218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\":
    [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128,
    0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\":
    [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139,
    69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\":
    [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82,
    45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\":
    [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112,
    128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\":
    [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\":
    [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224,
    208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\":
    [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255,
    255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\n/* MIT license */\n\n\nvar
    colorString = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n
    \  getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString:
    hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString:
    percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n
    \  hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n};\n\nfunction
    getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3,4})$/i,\n
    \      hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n
    \      per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n
    \      keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match
    = string.match(abbr),\n       hexAlpha = \"\";\n   if (match) {\n      match =
    match[1];\n      hexAlpha = match[3];\n      for (var i = 0; i < rgb.length; i++)
    {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n      if (hexAlpha)
    {\n         a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) /
    100;\n      }\n   }\n   else if (match = string.match(hex)) {\n      hexAlpha
    = match[2];\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++)
    {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n      if
    (hexAlpha) {\n         a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) /
    100;\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var
    i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n
    \     a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per))
    {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i
    + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match
    = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return
    [0, 0, 0, 0];\n      }\n      rgb = colorName$1[match[1]];\n      if (!rgb) {\n
    \        return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n
    \     rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a =
    1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return
    rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n
    \  var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n
    \  var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n
    \     var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]),
    0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha)
    ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string)
    {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n
    \  var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n
    \     var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]),
    0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha)
    ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string)
    {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction
    getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0,
    3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals)
    {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return
    vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n
    \  }\n}\n\n// generators\nfunction hexString(rgba, a) {\n   var a = (a !== undefined
    && rgba.length === 3) ? a : rgba[3];\n   return \"#\" + hexDouble(rgba[0]) \n
    \             + hexDouble(rgba[1])\n              + hexDouble(rgba[2])\n              +
    (\n                 (a >= 0 && a < 1)\n                 ? hexDouble(Math.round(a
    * 255))\n                 : \"\"\n              );\n}\n\nfunction rgbString(rgba,
    alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba,
    alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]
    + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined)
    {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\"
    + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha +
    \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3]
    && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r
    = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n
    \      b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \"
    + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var
    r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n
    \      b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" +
    g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla,
    alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla,
    alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2]
    + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined)
    {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\"
    + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha
    + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no
    alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction
    hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3]
    !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1]
    + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ?
    \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0,
    3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min,
    num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n
    \ return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse
    color names\nvar reverseNames = {};\nfor (var name in colorName$1) {\n   reverseNames[colorName$1[name]]
    = name;\n}\n\n/* MIT license */\n\n\n\nvar Color = function (obj) {\n\tif (obj
    instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn
    new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0,
    0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk:
    [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif
    (typeof obj === 'string') {\n\t\tvals = colorString.getRgba(obj);\n\t\tif (vals)
    {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = colorString.getHsla(obj))
    {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = colorString.getHwb(obj))
    {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object')
    {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb',
    vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl',
    vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv',
    vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb',
    vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk',
    vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn
    this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl:
    function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function
    () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn
    this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk',
    arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray:
    function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn
    this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif
    (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn
    values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray:
    function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray:
    function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha:
    function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha',
    val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb',
    0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1,
    val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue:
    function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360
    + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation:
    function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness:
    function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv:
    function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness:
    function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness:
    function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function
    (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val)
    {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val)
    {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val)
    {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val)
    {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function
    () {\n\t\treturn colorString.hexString(this.values.rgb);\n\t},\n\trgbString: function
    () {\n\t\treturn colorString.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString:
    function () {\n\t\treturn colorString.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString:
    function () {\n\t\treturn colorString.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString:
    function () {\n\t\treturn colorString.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString:
    function () {\n\t\treturn colorString.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString:
    function () {\n\t\treturn colorString.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword:
    function () {\n\t\treturn colorString.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber:
    function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1]
    << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar
    rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length;
    i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan
    / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 *
    lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2)
    {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar
    lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05)
    / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel:
    function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio
    >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA'
    : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar
    rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] *
    114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn
    !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var
    i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb',
    rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl =
    this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn
    this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2]
    -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate:
    function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl',
    hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl
    = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn
    this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1]
    += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken:
    function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb',
    hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t//
    http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar
    val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb',
    [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar
    alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn
    this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha',
    alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees)
    {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0]
    = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t
    * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t
    */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2
    = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w =
    2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w
    * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn
    this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1
    * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha()
    * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn
    this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone
    creates a dependency to Buffer when using browserify,\n\t\t// making the final
    build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming
    that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except
    'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar
    target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source)
    {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype
    = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop]
    = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop]
    = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:',
    value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces
    = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv:
    ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk:
    ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb:
    [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360,
    100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function
    (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0;
    i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif
    (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255,
    b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space,
    vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes
    = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space
    === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10,
    10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t}
    else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor
    (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha
    = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red:
    10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i
    < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha
    = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined
    ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar
    capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i
    = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i],
    values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert
    to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !==
    space) {\n\t\t\tvalues[sname] = colorConvert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn
    true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals =
    args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t//
    color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space,
    vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index,
    val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t//
    color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index])
    {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index]
    = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof
    window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nvar chartjsColor = Color;\n\nfunction
    isValidKey(key) {\r\n\treturn ['__proto__', 'prototype', 'constructor'].indexOf(key)
    === -1;\r\n}\r\n\r\n/**\r\n * @namespace Chart.helpers\r\n */\r\nvar helpers =
    {\r\n\t/**\r\n\t * An empty function that can be used, for example, for optional
    callback.\r\n\t */\r\n\tnoop: function() {},\r\n\r\n\t/**\r\n\t * Returns a unique
    id, sequentially generated from a global variable.\r\n\t * @returns {number}\r\n\t
    * @function\r\n\t */\r\n\tuid: (function() {\r\n\t\tvar id = 0;\r\n\t\treturn
    function() {\r\n\t\t\treturn id++;\r\n\t\t};\r\n\t}()),\r\n\r\n\t/**\r\n\t * Returns
    true if `value` is neither null nor undefined, else returns false.\r\n\t * @param
    {*} value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @since 2.7.0\r\n\t
    */\r\n\tisNullOrUndef: function(value) {\r\n\t\treturn value === null || typeof
    value === 'undefined';\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is
    an array (including typed arrays), else returns false.\r\n\t * @param {*} value
    - The value to test.\r\n\t * @returns {boolean}\r\n\t * @function\r\n\t */\r\n\tisArray:
    function(value) {\r\n\t\tif (Array.isArray && Array.isArray(value)) {\r\n\t\t\treturn
    true;\r\n\t\t}\r\n\t\tvar type = Object.prototype.toString.call(value);\r\n\t\tif
    (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\r\n\t\t\treturn
    true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true
    if `value` is an object (excluding null), else returns false.\r\n\t * @param {*}
    value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @since 2.7.0\r\n\t
    */\r\n\tisObject: function(value) {\r\n\t\treturn value !== null && Object.prototype.toString.call(value)
    === '[object Object]';\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is
    a finite number, else returns false\r\n\t * @param {*} value  - The value to test.\r\n\t
    * @returns {boolean}\r\n\t */\r\n\tisFinite: function(value) {\r\n\t\treturn (typeof
    value === 'number' || value instanceof Number) && isFinite(value);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns `value` if defined, else returns `defaultValue`.\r\n\t * @param {*}
    value - The value to return if defined.\r\n\t * @param {*} defaultValue - The
    value to return if `value` is undefined.\r\n\t * @returns {*}\r\n\t */\r\n\tvalueOrDefault:
    function(value, defaultValue) {\r\n\t\treturn typeof value === 'undefined' ? defaultValue
    : value;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns value at the given `index` in array
    if defined, else returns `defaultValue`.\r\n\t * @param {Array} value - The array
    to lookup for value at `index`.\r\n\t * @param {number} index - The index in `value`
    to lookup for value.\r\n\t * @param {*} defaultValue - The value to return if
    `value[index]` is undefined.\r\n\t * @returns {*}\r\n\t */\r\n\tvalueAtIndexOrDefault:
    function(value, index, defaultValue) {\r\n\t\treturn helpers.valueOrDefault(helpers.isArray(value)
    ? value[index] : value, defaultValue);\r\n\t},\r\n\r\n\t/**\r\n\t * Calls `fn`
    with the given `args` in the scope defined by `thisArg` and returns the\r\n\t
    * value returned by `fn`. If `fn` is not a function, this method returns undefined.\r\n\t
    * @param {function} fn - The function to call.\r\n\t * @param {Array|undefined|null}
    args - The arguments with which `fn` should be called.\r\n\t * @param {object}
    [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @returns
    {*}\r\n\t */\r\n\tcallback: function(fn, args, thisArg) {\r\n\t\tif (fn && typeof
    fn.call === 'function') {\r\n\t\t\treturn fn.apply(thisArg, args);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Note(SB) for performance sake, this method should only be used when loopable
    type\r\n\t * is unknown or in none intensive code (not called often and small
    loopable). Else\r\n\t * it's preferable to use a regular for() loop and save extra
    function calls.\r\n\t * @param {object|Array} loopable - The object or array to
    be iterated.\r\n\t * @param {function} fn - The function to call for each item.\r\n\t
    * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t
    * @param {boolean} [reverse] - If true, iterates backward on the loopable.\r\n\t
    */\r\n\teach: function(loopable, fn, thisArg, reverse) {\r\n\t\tvar i, len, keys;\r\n\t\tif
    (helpers.isArray(loopable)) {\r\n\t\t\tlen = loopable.length;\r\n\t\t\tif (reverse)
    {\r\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i],
    i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\t\tfn.call(thisArg,
    loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (helpers.isObject(loopable))
    {\r\n\t\t\tkeys = Object.keys(loopable);\r\n\t\t\tlen = keys.length;\r\n\t\t\tfor
    (i = 0; i < len; i++) {\r\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns true if the `a0` and `a1` arrays have the same content, else returns
    false.\r\n\t * @see https://stackoverflow.com/a/14853974\r\n\t * @param {Array}
    a0 - The array to compare\r\n\t * @param {Array} a1 - The array to compare\r\n\t
    * @returns {boolean}\r\n\t */\r\n\tarrayEquals: function(a0, a1) {\r\n\t\tvar
    i, ilen, v0, v1;\r\n\r\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\r\n\t\t\treturn
    false;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n\t\t\tv0
    = a0[i];\r\n\t\t\tv1 = a1[i];\r\n\r\n\t\t\tif (v0 instanceof Array && v1 instanceof
    Array) {\r\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}
    else if (v0 !== v1) {\r\n\t\t\t\t// NOTE: two different object instances will
    never be equal: {x:20} != {x:20}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    true;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a deep copy of `source` without keeping
    references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t
    * @returns {*}\r\n\t */\r\n\tclone: function(source) {\r\n\t\tif (helpers.isArray(source))
    {\r\n\t\t\treturn source.map(helpers.clone);\r\n\t\t}\r\n\r\n\t\tif (helpers.isObject(source))
    {\r\n\t\t\tvar target = Object.create(source);\r\n\t\t\tvar keys = Object.keys(source);\r\n\t\t\tvar
    klen = keys.length;\r\n\t\t\tvar k = 0;\r\n\r\n\t\t\tfor (; k < klen; ++k) {\r\n\t\t\t\ttarget[keys[k]]
    = helpers.clone(source[keys[k]]);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\treturn
    source;\r\n\t},\r\n\r\n\t/**\r\n\t * The default merger when Chart.helpers.merge
    is called without merger option.\r\n\t * Note(SB): also used by mergeConfig and
    mergeScaleConfig as fallback.\r\n\t * @private\r\n\t */\r\n\t_merger: function(key,
    target, source, options) {\r\n\t\tif (!isValidKey(key)) {\r\n\t\t\t// We want
    to ensure we do not copy prototypes over\r\n\t\t\t// as this can pollute global
    namespaces\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tval = target[key];\r\n\t\tvar
    sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval))
    {\r\n\t\t\thelpers.merge(tval, sval, options);\r\n\t\t} else {\r\n\t\t\ttarget[key]
    = helpers.clone(sval);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Merges source[key]
    in target[key] only if target[key] is undefined.\r\n\t * @private\r\n\t */\r\n\t_mergerIf:
    function(key, target, source) {\r\n\t\tif (!isValidKey(key)) {\r\n\t\t\t// We
    want to ensure we do not copy prototypes over\r\n\t\t\t// as this can pollute
    global namespaces\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tval = target[key];\r\n\t\tvar
    sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval))
    {\r\n\t\t\thelpers.mergeIf(tval, sval);\r\n\t\t} else if (!target.hasOwnProperty(key))
    {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Recursively deep copies `source` properties into `target` with the given `options`.\r\n\t
    * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t
    * @param {object} target - The target object in which all sources are merged into.\r\n\t
    * @param {object|object[]} source - Object(s) to merge into `target`.\r\n\t *
    @param {object} [options] - Merging options:\r\n\t * @param {function} [options.merger]
    - The merge method (key, target, source, options)\r\n\t * @returns {object} The
    `target` object.\r\n\t */\r\n\tmerge: function(target, source, options) {\r\n\t\tvar
    sources = helpers.isArray(source) ? source : [source];\r\n\t\tvar ilen = sources.length;\r\n\t\tvar
    merge, i, keys, klen, k;\r\n\r\n\t\tif (!helpers.isObject(target)) {\r\n\t\t\treturn
    target;\r\n\t\t}\r\n\r\n\t\toptions = options || {};\r\n\t\tmerge = options.merger
    || helpers._merger;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tsource =
    sources[i];\r\n\t\t\tif (!helpers.isObject(source)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tkeys
    = Object.keys(source);\r\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k)
    {\r\n\t\t\t\tmerge(keys[k], target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    target;\r\n\t},\r\n\r\n\t/**\r\n\t * Recursively deep copies `source` properties
    into `target` *only* if not defined in target.\r\n\t * IMPORTANT: `target` is
    not cloned and will be updated with `source` properties.\r\n\t * @param {object}
    target - The target object in which all sources are merged into.\r\n\t * @param
    {object|object[]} source - Object(s) to merge into `target`.\r\n\t * @returns
    {object} The `target` object.\r\n\t */\r\n\tmergeIf: function(target, source)
    {\r\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\r\n\t},\r\n\r\n\t/**\r\n\t
    * Applies the contents of two or more objects together into the first object.\r\n\t
    * @param {object} target - The target object in which all objects are merged into.\r\n\t
    * @param {object} arg1 - Object containing additional properties to merge in target.\r\n\t
    * @param {object} argN - Additional objects containing properties to merge in
    target.\r\n\t * @returns {object} The `target` object.\r\n\t */\r\n\textend: Object.assign
    || function(target) {\r\n\t\treturn helpers.merge(target, [].slice.call(arguments,
    1), {\r\n\t\t\tmerger: function(key, dst, src) {\r\n\t\t\t\tdst[key] = src[key];\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t
    * Basic javascript inheritance based on the model created in Backbone.js\r\n\t
    */\r\n\tinherits: function(extensions) {\r\n\t\tvar me = this;\r\n\t\tvar ChartElement
    = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor
    : function() {\r\n\t\t\treturn me.apply(this, arguments);\r\n\t\t};\r\n\r\n\t\tvar
    Surrogate = function() {\r\n\t\t\tthis.constructor = ChartElement;\r\n\t\t};\r\n\r\n\t\tSurrogate.prototype
    = me.prototype;\r\n\t\tChartElement.prototype = new Surrogate();\r\n\t\tChartElement.extend
    = helpers.inherits;\r\n\r\n\t\tif (extensions) {\r\n\t\t\thelpers.extend(ChartElement.prototype,
    extensions);\r\n\t\t}\r\n\r\n\t\tChartElement.__super__ = me.prototype;\r\n\t\treturn
    ChartElement;\r\n\t},\r\n\r\n\t_deprecated: function(scope, value, previous, current)
    {\r\n\t\tif (value !== undefined) {\r\n\t\t\tconsole.warn(scope + ': \"' + previous
    +\r\n\t\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar
    helpers_core = helpers;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward
    compatibility, use Chart.helpers.callback instead.\r\n * @function Chart.helpers.callCallback\r\n
    * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nhelpers.callCallback = helpers.callback;\r\n\r\n/**\r\n * Provided for backward
    compatibility, use Array.prototype.indexOf instead.\r\n * Array.prototype.indexOf
    compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\r\n * @function Chart.helpers.indexOf\r\n
    * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nhelpers.indexOf = function(array, item, fromIndex) {\r\n\treturn Array.prototype.indexOf.call(array,
    item, fromIndex);\r\n};\r\n\r\n/**\r\n * Provided for backward compatibility,
    use Chart.helpers.valueOrDefault instead.\r\n * @function Chart.helpers.getValueOrDefault\r\n
    * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nhelpers.getValueOrDefault = helpers.valueOrDefault;\r\n\r\n/**\r\n * Provided
    for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\r\n
    * @function Chart.helpers.getValueAtIndexOrDefault\r\n * @deprecated since version
    2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.getValueAtIndexOrDefault
    = helpers.valueAtIndexOrDefault;\n\n/**\r\n * Easing functions adapted from Robert
    Penner's easing equations.\r\n * @namespace Chart.helpers.easingEffects\r\n *
    @see http://www.robertpenner.com/easing/\r\n */\r\nvar effects = {\r\n\tlinear:
    function(t) {\r\n\t\treturn t;\r\n\t},\r\n\r\n\teaseInQuad: function(t) {\r\n\t\treturn
    t * t;\r\n\t},\r\n\r\n\teaseOutQuad: function(t) {\r\n\t\treturn -t * (t - 2);\r\n\t},\r\n\r\n\teaseInOutQuad:
    function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t;\r\n\t\t}\r\n\t\treturn
    -0.5 * ((--t) * (t - 2) - 1);\r\n\t},\r\n\r\n\teaseInCubic: function(t) {\r\n\t\treturn
    t * t * t;\r\n\t},\r\n\r\n\teaseOutCubic: function(t) {\r\n\t\treturn (t = t -
    1) * t * t + 1;\r\n\t},\r\n\r\n\teaseInOutCubic: function(t) {\r\n\t\tif ((t /=
    0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t;\r\n\t\t}\r\n\t\treturn 0.5 * ((t
    -= 2) * t * t + 2);\r\n\t},\r\n\r\n\teaseInQuart: function(t) {\r\n\t\treturn
    t * t * t * t;\r\n\t},\r\n\r\n\teaseOutQuart: function(t) {\r\n\t\treturn -((t
    = t - 1) * t * t * t - 1);\r\n\t},\r\n\r\n\teaseInOutQuart: function(t) {\r\n\t\tif
    ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t * t;\r\n\t\t}\r\n\t\treturn
    -0.5 * ((t -= 2) * t * t * t - 2);\r\n\t},\r\n\r\n\teaseInQuint: function(t) {\r\n\t\treturn
    t * t * t * t * t;\r\n\t},\r\n\r\n\teaseOutQuint: function(t) {\r\n\t\treturn
    (t = t - 1) * t * t * t * t + 1;\r\n\t},\r\n\r\n\teaseInOutQuint: function(t)
    {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t * t * t;\r\n\t\t}\r\n\t\treturn
    0.5 * ((t -= 2) * t * t * t * t + 2);\r\n\t},\r\n\r\n\teaseInSine: function(t)
    {\r\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\r\n\t},\r\n\r\n\teaseOutSine:
    function(t) {\r\n\t\treturn Math.sin(t * (Math.PI / 2));\r\n\t},\r\n\r\n\teaseInOutSine:
    function(t) {\r\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\r\n\t},\r\n\r\n\teaseInExpo:
    function(t) {\r\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\r\n\t},\r\n\r\n\teaseOutExpo:
    function(t) {\r\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\r\n\t},\r\n\r\n\teaseInOutExpo:
    function(t) {\r\n\t\tif (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t ===
    1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn
    0.5 * Math.pow(2, 10 * (t - 1));\r\n\t\t}\r\n\t\treturn 0.5 * (-Math.pow(2, -10
    * --t) + 2);\r\n\t},\r\n\r\n\teaseInCirc: function(t) {\r\n\t\tif (t >= 1) {\r\n\t\t\treturn
    t;\r\n\t\t}\r\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\r\n\t},\r\n\r\n\teaseOutCirc:
    function(t) {\r\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\r\n\t},\r\n\r\n\teaseInOutCirc:
    function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn -0.5 * (Math.sqrt(1
    - t * t) - 1);\r\n\t\t}\r\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\r\n\t},\r\n\r\n\teaseInElastic:
    function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif
    (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn
    1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.3;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta
    = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1
    / a);\r\n\t\t}\r\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t -
    s) * (2 * Math.PI) / p));\r\n\t},\r\n\r\n\teaseOutElastic: function(t) {\r\n\t\tvar
    s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif (t === 0) {\r\n\t\t\treturn
    0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp
    = 0.3;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta = 1;\r\n\t\t\ts = p / 4;\r\n\t\t}
    else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\r\n\t\t}\r\n\t\treturn
    a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\r\n\t},\r\n\r\n\teaseInOutElastic:
    function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif
    (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif ((t /= 0.5) === 2) {\r\n\t\t\treturn
    1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.45;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta
    = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1
    / a);\r\n\t\t}\r\n\t\tif (t < 1) {\r\n\t\t\treturn -0.5 * (a * Math.pow(2, 10
    * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\r\n\t\t}\r\n\t\treturn a
    * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 +
    1;\r\n\t},\r\n\teaseInBack: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\treturn
    t * t * ((s + 1) * t - s);\r\n\t},\r\n\r\n\teaseOutBack: function(t) {\r\n\t\tvar
    s = 1.70158;\r\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\r\n\t},\r\n\r\n\teaseInOutBack:
    function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn
    0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n\t\t}\r\n\t\treturn 0.5 * ((t
    -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n\t},\r\n\r\n\teaseInBounce:
    function(t) {\r\n\t\treturn 1 - effects.easeOutBounce(1 - t);\r\n\t},\r\n\r\n\teaseOutBounce:
    function(t) {\r\n\t\tif (t < (1 / 2.75)) {\r\n\t\t\treturn 7.5625 * t * t;\r\n\t\t}\r\n\t\tif
    (t < (2 / 2.75)) {\r\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\r\n\t\t}\r\n\t\tif
    (t < (2.5 / 2.75)) {\r\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\r\n\t\t}\r\n\t\treturn
    7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\r\n\t},\r\n\r\n\teaseInOutBounce:
    function(t) {\r\n\t\tif (t < 0.5) {\r\n\t\t\treturn effects.easeInBounce(t * 2)
    * 0.5;\r\n\t\t}\r\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\r\n\t}\r\n};\r\n\r\nvar
    helpers_easing = {\r\n\teffects: effects\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\r\n
    * @function Chart.helpers.easingEffects\r\n * @deprecated since version 2.7.0\r\n
    * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.easingEffects
    = effects;\n\nvar PI = Math.PI;\r\nvar RAD_PER_DEG = PI / 180;\r\nvar DOUBLE_PI
    = PI * 2;\r\nvar HALF_PI = PI / 2;\r\nvar QUARTER_PI = PI / 4;\r\nvar TWO_THIRDS_PI
    = PI * 2 / 3;\r\n\r\n/**\r\n * @namespace Chart.helpers.canvas\r\n */\r\nvar exports$1
    = {\r\n\t/**\r\n\t * Clears the entire canvas associated to the given `chart`.\r\n\t
    * @param {Chart} chart - The chart for which to clear the canvas.\r\n\t */\r\n\tclear:
    function(chart) {\r\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with
    a\r\n\t * given size (width, height) and the same `radius` for all corners.\r\n\t
    * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n\t * @param
    {number} x - The x axis of the coordinate for the rectangle starting point.\r\n\t
    * @param {number} y - The y axis of the coordinate for the rectangle starting
    point.\r\n\t * @param {number} width - The rectangle's width.\r\n\t * @param {number}
    height - The rectangle's height.\r\n\t * @param {number} radius - The rounded
    amount (in pixels) for the four corners.\r\n\t * @todo handle `radius` as top-left,
    top-right, bottom-right, bottom-left array/object?\r\n\t */\r\n\troundedRect:
    function(ctx, x, y, width, height, radius) {\r\n\t\tif (radius) {\r\n\t\t\tvar
    r = Math.min(radius, height / 2, width / 2);\r\n\t\t\tvar left = x + r;\r\n\t\t\tvar
    top = y + r;\r\n\t\t\tvar right = x + width - r;\r\n\t\t\tvar bottom = y + height
    - r;\r\n\r\n\t\t\tctx.moveTo(x, top);\r\n\t\t\tif (left < right && top < bottom)
    {\r\n\t\t\t\tctx.arc(left, top, r, -PI, -HALF_PI);\r\n\t\t\t\tctx.arc(right, top,
    r, -HALF_PI, 0);\r\n\t\t\t\tctx.arc(right, bottom, r, 0, HALF_PI);\r\n\t\t\t\tctx.arc(left,
    bottom, r, HALF_PI, PI);\r\n\t\t\t} else if (left < right) {\r\n\t\t\t\tctx.moveTo(left,
    y);\r\n\t\t\t\tctx.arc(right, top, r, -HALF_PI, HALF_PI);\r\n\t\t\t\tctx.arc(left,
    top, r, HALF_PI, PI + HALF_PI);\r\n\t\t\t} else if (top < bottom) {\r\n\t\t\t\tctx.arc(left,
    top, r, -PI, 0);\r\n\t\t\t\tctx.arc(left, bottom, r, 0, PI);\r\n\t\t\t} else {\r\n\t\t\t\tctx.arc(left,
    top, r, -PI, PI);\r\n\t\t\t}\r\n\t\t\tctx.closePath();\r\n\t\t\tctx.moveTo(x,
    y);\r\n\t\t} else {\r\n\t\t\tctx.rect(x, y, width, height);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawPoint:
    function(ctx, style, radius, x, y, rotation) {\r\n\t\tvar type, xOffset, yOffset,
    size, cornerRadius;\r\n\t\tvar rad = (rotation || 0) * RAD_PER_DEG;\r\n\r\n\t\tif
    (style && typeof style === 'object') {\r\n\t\t\ttype = style.toString();\r\n\t\t\tif
    (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]')
    {\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.translate(x, y);\r\n\t\t\t\tctx.rotate(rad);\r\n\t\t\t\tctx.drawImage(style,
    -style.width / 2, -style.height / 2, style.width, style.height);\r\n\t\t\t\tctx.restore();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (isNaN(radius) || radius <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\r\n\t\tswitch
    (style) {\r\n\t\t// Default includes circle\r\n\t\tdefault:\r\n\t\t\tctx.arc(x,
    y, radius, 0, DOUBLE_PI);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'triangle':\r\n\t\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad)
    * radius);\r\n\t\t\trad += TWO_THIRDS_PI;\r\n\t\t\tctx.lineTo(x + Math.sin(rad)
    * radius, y - Math.cos(rad) * radius);\r\n\t\t\trad += TWO_THIRDS_PI;\r\n\t\t\tctx.lineTo(x
    + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'rectRounded':\r\n\t\t\t// NOTE: the rounded rect implementation changed to use
    `arc` instead of\r\n\t\t\t// `quadraticCurveTo` since it generates better results
    when rect is\r\n\t\t\t// almost a circle. 0.516 (instead of 0.5) produces results
    with visually\r\n\t\t\t// closer proportion to the previous impl and it is inscribed
    in the\r\n\t\t\t// circle with `radius`. For more details, see the following PRs:\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/5597\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5858\r\n\t\t\tcornerRadius
    = radius * 0.516;\r\n\t\t\tsize = radius - cornerRadius;\r\n\t\t\txOffset = Math.cos(rad
    + QUARTER_PI) * size;\r\n\t\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\r\n\t\t\tctx.arc(x
    - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n\t\t\tctx.arc(x
    + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n\t\t\tctx.arc(x
    + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n\t\t\tctx.arc(x
    - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'rect':\r\n\t\t\tif (!rotation) {\r\n\t\t\t\tsize = Math.SQRT1_2 * radius;\r\n\t\t\t\tctx.rect(x
    - size, y - size, 2 * size, 2 * size);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trad
    += QUARTER_PI;\r\n\t\t\t/* falls through */\r\n\t\tcase 'rectRot':\r\n\t\t\txOffset
    = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x
    - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x
    + xOffset, y + yOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'crossRot':\r\n\t\t\trad += QUARTER_PI;\r\n\t\t\t/* falls through */\r\n\t\tcase
    'cross':\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad)
    * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x
    + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x
    - yOffset, y + xOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'star':\r\n\t\t\txOffset
    = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x
    - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x
    + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\trad
    += QUARTER_PI;\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad)
    * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x
    + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x
    - yOffset, y + xOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'line':\r\n\t\t\txOffset
    = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x
    - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tbreak;\r\n\t\tcase
    'dash':\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t\tctx.lineTo(x + Math.cos(rad) * radius,
    y + Math.sin(rad) * radius);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tctx.fill();\r\n\t\tctx.stroke();\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns true if the point is inside the rectangle\r\n\t * @param {object} point
    - The point to test\r\n\t * @param {object} area - The rectangle\r\n\t * @returns
    {boolean}\r\n\t * @private\r\n\t */\r\n\t_isPointInArea: function(point, area)
    {\r\n\t\tvar epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n\r\n\t\treturn
    point.x > area.left - epsilon && point.x < area.right + epsilon &&\r\n\t\t\tpoint.y
    > area.top - epsilon && point.y < area.bottom + epsilon;\r\n\t},\r\n\r\n\tclipArea:
    function(ctx, area) {\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(area.left,
    area.top, area.right - area.left, area.bottom - area.top);\r\n\t\tctx.clip();\r\n\t},\r\n\r\n\tunclipArea:
    function(ctx) {\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tlineTo: function(ctx, previous,
    target, flip) {\r\n\t\tvar stepped = target.steppedLine;\r\n\t\tif (stepped) {\r\n\t\t\tif
    (stepped === 'middle') {\r\n\t\t\t\tvar midpoint = (previous.x + target.x) / 2.0;\r\n\t\t\t\tctx.lineTo(midpoint,
    flip ? target.y : previous.y);\r\n\t\t\t\tctx.lineTo(midpoint, flip ? previous.y
    : target.y);\r\n\t\t\t} else if ((stepped === 'after' && !flip) || (stepped !==
    'after' && flip)) {\r\n\t\t\t\tctx.lineTo(previous.x, target.y);\r\n\t\t\t} else
    {\r\n\t\t\t\tctx.lineTo(target.x, previous.y);\r\n\t\t\t}\r\n\t\t\tctx.lineTo(target.x,
    target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!target.tension) {\r\n\t\t\tctx.lineTo(target.x,
    target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.bezierCurveTo(\r\n\t\t\tflip
    ? previous.controlPointPreviousX : previous.controlPointNextX,\r\n\t\t\tflip ?
    previous.controlPointPreviousY : previous.controlPointNextY,\r\n\t\t\tflip ? target.controlPointNextX
    : target.controlPointPreviousX,\r\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\r\n\t\t\ttarget.x,\r\n\t\t\ttarget.y);\r\n\t}\r\n};\r\n\r\nvar
    helpers_canvas = exports$1;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for
    backward compatibility, use Chart.helpers.canvas.clear instead.\r\n * @namespace
    Chart.helpers.clear\r\n * @deprecated since version 2.7.0\r\n * @todo remove at
    version 3\r\n * @private\r\n */\r\nhelpers_core.clear = exports$1.clear;\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\r\n
    * @namespace Chart.helpers.drawRoundedRectangle\r\n * @deprecated since version
    2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.drawRoundedRectangle
    = function(ctx) {\r\n\tctx.beginPath();\r\n\texports$1.roundedRect.apply(exports$1,
    arguments);\r\n};\n\nvar defaults = {\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_set:
    function(scope, values) {\r\n\t\treturn helpers_core.merge(this[scope] || (this[scope]
    = {}), values);\r\n\t}\r\n};\r\n\r\n// TODO(v3): remove 'global' from namespace.
    \ all default are global and\r\n// there's inconsistency around which options
    are under 'global'\r\ndefaults._set('global', {\r\n\tdefaultColor: 'rgba(0,0,0,0.1)',\r\n\tdefaultFontColor:
    '#666',\r\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n\tdefaultFontSize:
    12,\r\n\tdefaultFontStyle: 'normal',\r\n\tdefaultLineHeight: 1.2,\r\n\tshowLines:
    true\r\n});\r\n\r\nvar core_defaults = defaults;\n\nvar valueOrDefault = helpers_core.valueOrDefault;\r\n\r\n/**\r\n
    * Converts the given font object into a CSS font string.\r\n * @param {object}
    font - A font object.\r\n * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n
    * @private\r\n */\r\nfunction toFontString(font) {\r\n\tif (!font || helpers_core.isNullOrUndef(font.size)
    || helpers_core.isNullOrUndef(font.family)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn
    (font.style ? font.style + ' ' : '')\r\n\t\t+ (font.weight ? font.weight + ' '
    : '')\r\n\t\t+ font.size + 'px '\r\n\t\t+ font.family;\r\n}\r\n\r\n/**\r\n * @alias
    Chart.helpers.options\r\n * @namespace\r\n */\r\nvar helpers_options = {\r\n\t/**\r\n\t
    * Converts the given line height `value` in pixels for a specific font `size`.\r\n\t
    * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%',
    '1.6em').\r\n\t * @param {number} size - The font size (in pixels) used to resolve
    relative `value`.\r\n\t * @returns {number} The effective line height in pixels
    (size * 1.2 if value is invalid).\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\r\n\t
    * @since 2.7.0\r\n\t */\r\n\ttoLineHeight: function(value, size) {\r\n\t\tvar
    matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\r\n\t\tif
    (!matches || matches[1] === 'normal') {\r\n\t\t\treturn size * 1.2;\r\n\t\t}\r\n\r\n\t\tvalue
    = +matches[2];\r\n\r\n\t\tswitch (matches[3]) {\r\n\t\tcase 'px':\r\n\t\t\treturn
    value;\r\n\t\tcase '%':\r\n\t\t\tvalue /= 100;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn
    size * value;\r\n\t},\r\n\r\n\t/**\r\n\t * Converts the given value into a padding
    object with pre-computed width/height.\r\n\t * @param {number|object} value -
    If a number, set the value to all TRBL component,\r\n\t *  else, if and object,
    use defined properties and sets undefined ones to 0.\r\n\t * @returns {object}
    The padding values (top, right, bottom, left, width, height)\r\n\t * @since 2.7.0\r\n\t
    */\r\n\ttoPadding: function(value) {\r\n\t\tvar t, r, b, l;\r\n\r\n\t\tif (helpers_core.isObject(value))
    {\r\n\t\t\tt = +value.top || 0;\r\n\t\t\tr = +value.right || 0;\r\n\t\t\tb = +value.bottom
    || 0;\r\n\t\t\tl = +value.left || 0;\r\n\t\t} else {\r\n\t\t\tt = r = b = l =
    +value || 0;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttop: t,\r\n\t\t\tright: r,\r\n\t\t\tbottom:
    b,\r\n\t\t\tleft: l,\r\n\t\t\theight: t + b,\r\n\t\t\twidth: l + r\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * Parses font options and returns the font object.\r\n\t * @param {object} options
    - A object that contains font options to be parsed.\r\n\t * @return {object} The
    font object.\r\n\t * @todo Support font.* options and renamed to toFont().\r\n\t
    * @private\r\n\t */\r\n\t_parseFont: function(options) {\r\n\t\tvar globalDefaults
    = core_defaults.global;\r\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\r\n\t\tvar
    font = {\r\n\t\t\tfamily: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\r\n\t\t\tlineHeight:
    helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight),
    size),\r\n\t\t\tsize: size,\r\n\t\t\tstyle: valueOrDefault(options.fontStyle,
    globalDefaults.defaultFontStyle),\r\n\t\t\tweight: null,\r\n\t\t\tstring: ''\r\n\t\t};\r\n\r\n\t\tfont.string
    = toFontString(font);\r\n\t\treturn font;\r\n\t},\r\n\r\n\t/**\r\n\t * Evaluates
    the given `inputs` sequentially and returns the first defined value.\r\n\t * @param
    {Array} inputs - An array of values, falling back to the last value.\r\n\t * @param
    {object} [context] - If defined and the current value is a function, the value\r\n\t
    * is called with `context` as first argument and the result becomes the new input.\r\n\t
    * @param {number} [index] - If defined and the current value is an array, the
    value\r\n\t * at `index` become the new input.\r\n\t * @param {object} [info]
    - object to return information about resolution in\r\n\t * @param {boolean} [info.cacheable]
    - Will be set to `false` if option is not cacheable.\r\n\t * @since 2.7.0\r\n\t
    */\r\n\tresolve: function(inputs, context, index, info) {\r\n\t\tvar cacheable
    = true;\r\n\t\tvar i, ilen, value;\r\n\r\n\t\tfor (i = 0, ilen = inputs.length;
    i < ilen; ++i) {\r\n\t\t\tvalue = inputs[i];\r\n\t\t\tif (value === undefined)
    {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (context !== undefined && typeof
    value === 'function') {\r\n\t\t\t\tvalue = value(context);\r\n\t\t\t\tcacheable
    = false;\r\n\t\t\t}\r\n\t\t\tif (index !== undefined && helpers_core.isArray(value))
    {\r\n\t\t\t\tvalue = value[index];\r\n\t\t\t\tcacheable = false;\r\n\t\t\t}\r\n\t\t\tif
    (value !== undefined) {\r\n\t\t\t\tif (info && !cacheable) {\r\n\t\t\t\t\tinfo.cacheable
    = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\n/**\r\n
    * @alias Chart.helpers.math\r\n * @namespace\r\n */\r\nvar exports$2 = {\r\n\t/**\r\n\t
    * Returns an array of factors sorted from 1 to sqrt(value)\r\n\t * @private\r\n\t
    */\r\n\t_factorize: function(value) {\r\n\t\tvar result = [];\r\n\t\tvar sqrt
    = Math.sqrt(value);\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 1; i < sqrt; i++) {\r\n\t\t\tif
    (value % i === 0) {\r\n\t\t\t\tresult.push(i);\r\n\t\t\t\tresult.push(value /
    i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sqrt === (sqrt | 0)) { // if value is a square
    number\r\n\t\t\tresult.push(sqrt);\r\n\t\t}\r\n\r\n\t\tresult.sort(function(a,
    b) {\r\n\t\t\treturn a - b;\r\n\t\t}).pop();\r\n\t\treturn result;\r\n\t},\r\n\r\n\tlog10:
    Math.log10 || function(x) {\r\n\t\tvar exponent = Math.log(x) * Math.LOG10E; //
    Math.LOG10E = 1 / Math.LN10.\r\n\t\t// Check for whole powers of 10,\r\n\t\t//
    which due to floating point rounding error should be corrected.\r\n\t\tvar powerOf10
    = Math.round(exponent);\r\n\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\r\n\r\n\t\treturn
    isPowerOf10 ? powerOf10 : exponent;\r\n\t}\r\n};\r\n\r\nvar helpers_math = exports$2;\r\n\r\n//
    DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.math.log10
    instead.\r\n * @namespace Chart.helpers.log10\r\n * @deprecated since version
    2.9.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.log10
    = exports$2.log10;\n\nvar getRtlAdapter = function(rectX, width) {\r\n\treturn
    {\r\n\t\tx: function(x) {\r\n\t\t\treturn rectX + rectX + width - x;\r\n\t\t},\r\n\t\tsetWidth:
    function(w) {\r\n\t\t\twidth = w;\r\n\t\t},\r\n\t\ttextAlign: function(align)
    {\r\n\t\t\tif (align === 'center') {\r\n\t\t\t\treturn align;\r\n\t\t\t}\r\n\t\t\treturn
    align === 'right' ? 'left' : 'right';\r\n\t\t},\r\n\t\txPlus: function(x, value)
    {\r\n\t\t\treturn x - value;\r\n\t\t},\r\n\t\tleftForLtr: function(x, itemWidth)
    {\r\n\t\t\treturn x - itemWidth;\r\n\t\t},\r\n\t};\r\n};\r\n\r\nvar getLtrAdapter
    = function() {\r\n\treturn {\r\n\t\tx: function(x) {\r\n\t\t\treturn x;\r\n\t\t},\r\n\t\tsetWidth:
    function(w) { // eslint-disable-line no-unused-vars\r\n\t\t},\r\n\t\ttextAlign:
    function(align) {\r\n\t\t\treturn align;\r\n\t\t},\r\n\t\txPlus: function(x, value)
    {\r\n\t\t\treturn x + value;\r\n\t\t},\r\n\t\tleftForLtr: function(x, _itemWidth)
    { // eslint-disable-line no-unused-vars\r\n\t\t\treturn x;\r\n\t\t},\r\n\t};\r\n};\r\n\r\nvar
    getAdapter = function(rtl, rectX, width) {\r\n\treturn rtl ? getRtlAdapter(rectX,
    width) : getLtrAdapter();\r\n};\r\n\r\nvar overrideTextDirection = function(ctx,
    direction) {\r\n\tvar style, original;\r\n\tif (direction === 'ltr' || direction
    === 'rtl') {\r\n\t\tstyle = ctx.canvas.style;\r\n\t\toriginal = [\r\n\t\t\tstyle.getPropertyValue('direction'),\r\n\t\t\tstyle.getPropertyPriority('direction'),\r\n\t\t];\r\n\r\n\t\tstyle.setProperty('direction',
    direction, 'important');\r\n\t\tctx.prevTextDirection = original;\r\n\t}\r\n};\r\n\r\nvar
    restoreTextDirection = function(ctx) {\r\n\tvar original = ctx.prevTextDirection;\r\n\tif
    (original !== undefined) {\r\n\t\tdelete ctx.prevTextDirection;\r\n\t\tctx.canvas.style.setProperty('direction',
    original[0], original[1]);\r\n\t}\r\n};\r\n\r\nvar helpers_rtl = {\r\n\tgetRtlAdapter:
    getAdapter,\r\n\toverrideTextDirection: overrideTextDirection,\r\n\trestoreTextDirection:
    restoreTextDirection,\r\n};\n\nvar helpers$1 = helpers_core;\r\nvar easing = helpers_easing;\r\nvar
    canvas = helpers_canvas;\r\nvar options = helpers_options;\r\nvar math = helpers_math;\r\nvar
    rtl = helpers_rtl;\nhelpers$1.easing = easing;\nhelpers$1.canvas = canvas;\nhelpers$1.options
    = options;\nhelpers$1.math = math;\nhelpers$1.rtl = rtl;\n\nfunction interpolate(start,
    view, model, ease) {\r\n\tvar keys = Object.keys(model);\r\n\tvar i, ilen, key,
    actual, origin, target, type, c0, c1;\r\n\r\n\tfor (i = 0, ilen = keys.length;
    i < ilen; ++i) {\r\n\t\tkey = keys[i];\r\n\r\n\t\ttarget = model[key];\r\n\r\n\t\t//
    if a value is added to the model after pivot() has been called, the view\r\n\t\t//
    doesn't contain it, so let's initialize the view to the target value.\r\n\t\tif
    (!view.hasOwnProperty(key)) {\r\n\t\t\tview[key] = target;\r\n\t\t}\r\n\r\n\t\tactual
    = view[key];\r\n\r\n\t\tif (actual === target || key[0] === '_') {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif
    (!start.hasOwnProperty(key)) {\r\n\t\t\tstart[key] = actual;\r\n\t\t}\r\n\r\n\t\torigin
    = start[key];\r\n\r\n\t\ttype = typeof target;\r\n\r\n\t\tif (type === typeof
    origin) {\r\n\t\t\tif (type === 'string') {\r\n\t\t\t\tc0 = chartjsColor(origin);\r\n\t\t\t\tif
    (c0.valid) {\r\n\t\t\t\t\tc1 = chartjsColor(target);\r\n\t\t\t\t\tif (c1.valid)
    {\r\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}
    else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\r\n\t\t\t\tview[key]
    = origin + (target - origin) * ease;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tview[key]
    = target;\r\n\t}\r\n}\r\n\r\nvar Element = function(configuration) {\r\n\thelpers$1.extend(this,
    configuration);\r\n\tthis.initialize.apply(this, arguments);\r\n};\r\n\r\nhelpers$1.extend(Element.prototype,
    {\r\n\t_type: undefined,\r\n\r\n\tinitialize: function() {\r\n\t\tthis.hidden
    = false;\r\n\t},\r\n\r\n\tpivot: function() {\r\n\t\tvar me = this;\r\n\t\tif
    (!me._view) {\r\n\t\t\tme._view = helpers$1.extend({}, me._model);\r\n\t\t}\r\n\t\tme._start
    = {};\r\n\t\treturn me;\r\n\t},\r\n\r\n\ttransition: function(ease) {\r\n\t\tvar
    me = this;\r\n\t\tvar model = me._model;\r\n\t\tvar start = me._start;\r\n\t\tvar
    view = me._view;\r\n\r\n\t\t// No animation -> No Transition\r\n\t\tif (!model
    || ease === 1) {\r\n\t\t\tme._view = helpers$1.extend({}, model);\r\n\t\t\tme._start
    = null;\r\n\t\t\treturn me;\r\n\t\t}\r\n\r\n\t\tif (!view) {\r\n\t\t\tview = me._view
    = {};\r\n\t\t}\r\n\r\n\t\tif (!start) {\r\n\t\t\tstart = me._start = {};\r\n\t\t}\r\n\r\n\t\tinterpolate(start,
    view, model, ease);\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\ttooltipPosition: function()
    {\r\n\t\treturn {\r\n\t\t\tx: this._model.x,\r\n\t\t\ty: this._model.y\r\n\t\t};\r\n\t},\r\n\r\n\thasValue:
    function() {\r\n\t\treturn helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\r\n\t}\r\n});\r\n\r\nElement.extend
    = helpers$1.inherits;\r\n\r\nvar core_element = Element;\n\nvar exports$3 = core_element.extend({\r\n\tchart:
    null, // the animation associated chart instance\r\n\tcurrentStep: 0, // the current
    animation step\r\n\tnumSteps: 60, // default number of steps\r\n\teasing: '',
    // the easing to use for this animation\r\n\trender: null, // render function
    used by the animation service\r\n\r\n\tonAnimationProgress: null, // user specified
    callback to fire on each step of the animation\r\n\tonAnimationComplete: null,
    // user specified callback to fire when the animation finishes\r\n});\r\n\r\nvar
    core_animation = exports$3;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for
    backward compatibility, use Chart.Animation instead\r\n * @prop Chart.Animation#animationObject\r\n
    * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n */\r\nObject.defineProperty(exports$3.prototype,
    'animationObject', {\r\n\tget: function() {\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.Animation#chart instead\r\n *
    @prop Chart.Animation#chartInstance\r\n * @deprecated since version 2.6.0\r\n
    * @todo remove at version 3\r\n */\r\nObject.defineProperty(exports$3.prototype,
    'chartInstance', {\r\n\tget: function() {\r\n\t\treturn this.chart;\r\n\t},\r\n\tset:
    function(value) {\r\n\t\tthis.chart = value;\r\n\t}\r\n});\n\ncore_defaults._set('global',
    {\r\n\tanimation: {\r\n\t\tduration: 1000,\r\n\t\teasing: 'easeOutQuart',\r\n\t\tonProgress:
    helpers$1.noop,\r\n\t\tonComplete: helpers$1.noop\r\n\t}\r\n});\r\n\r\nvar core_animations
    = {\r\n\tanimations: [],\r\n\trequest: null,\r\n\r\n\t/**\r\n\t * @param {Chart}
    chart - The chart to animate.\r\n\t * @param {Chart.Animation} animation - The
    animation that we will animate.\r\n\t * @param {number} duration - The animation
    duration in ms.\r\n\t * @param {boolean} lazy - if true, the chart is not marked
    as animating to enable more responsive interactions\r\n\t */\r\n\taddAnimation:
    function(chart, animation, duration, lazy) {\r\n\t\tvar animations = this.animations;\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tanimation.chart = chart;\r\n\t\tanimation.startTime = Date.now();\r\n\t\tanimation.duration
    = duration;\r\n\r\n\t\tif (!lazy) {\r\n\t\t\tchart.animating = true;\r\n\t\t}\r\n\r\n\t\tfor
    (i = 0, ilen = animations.length; i < ilen; ++i) {\r\n\t\t\tif (animations[i].chart
    === chart) {\r\n\t\t\t\tanimations[i] = animation;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tanimations.push(animation);\r\n\r\n\t\t//
    If there are no animations queued, manually kickstart a digest, for lack of a
    better word\r\n\t\tif (animations.length === 1) {\r\n\t\t\tthis.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\tcancelAnimation:
    function(chart) {\r\n\t\tvar index = helpers$1.findIndex(this.animations, function(animation)
    {\r\n\t\t\treturn animation.chart === chart;\r\n\t\t});\r\n\r\n\t\tif (index !==
    -1) {\r\n\t\t\tthis.animations.splice(index, 1);\r\n\t\t\tchart.animating = false;\r\n\t\t}\r\n\t},\r\n\r\n\trequestAnimationFrame:
    function() {\r\n\t\tvar me = this;\r\n\t\tif (me.request === null) {\r\n\t\t\t//
    Skip animation frame requests until the active one is executed.\r\n\t\t\t// This
    can happen when processing mouse events, e.g. 'mousemove'\r\n\t\t\t// and 'mouseout'
    events will trigger multiple renders.\r\n\t\t\tme.request = helpers$1.requestAnimFrame.call(window,
    function() {\r\n\t\t\t\tme.request = null;\r\n\t\t\t\tme.startDigest();\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tstartDigest: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tme.advance();\r\n\r\n\t\t//
    Do we have more stuff to animate?\r\n\t\tif (me.animations.length > 0) {\r\n\t\t\tme.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tadvance: function() {\r\n\t\tvar animations = this.animations;\r\n\t\tvar
    animation, chart, numSteps, nextStep;\r\n\t\tvar i = 0;\r\n\r\n\t\t// 1 animation
    per chart, so we are looping charts here\r\n\t\twhile (i < animations.length)
    {\r\n\t\t\tanimation = animations[i];\r\n\t\t\tchart = animation.chart;\r\n\t\t\tnumSteps
    = animation.numSteps;\r\n\r\n\t\t\t// Make sure that currentStep starts at 1\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/6104\r\n\t\t\tnextStep = Math.floor((Date.now()
    - animation.startTime) / animation.duration * numSteps) + 1;\r\n\t\t\tanimation.currentStep
    = Math.min(nextStep, numSteps);\r\n\r\n\t\t\thelpers$1.callback(animation.render,
    [chart, animation], chart);\r\n\t\t\thelpers$1.callback(animation.onAnimationProgress,
    [animation], chart);\r\n\r\n\t\t\tif (animation.currentStep >= numSteps) {\r\n\t\t\t\thelpers$1.callback(animation.onAnimationComplete,
    [animation], chart);\r\n\t\t\t\tchart.animating = false;\r\n\t\t\t\tanimations.splice(i,
    1);\r\n\t\t\t} else {\r\n\t\t\t\t++i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\nvar
    resolve = helpers$1.options.resolve;\r\n\r\nvar arrayEvents = ['push', 'pop',
    'shift', 'splice', 'unshift'];\r\n\r\n/**\r\n * Hooks the array methods that add
    or remove values ('push', pop', 'shift', 'splice',\r\n * 'unshift') and notify
    the listener AFTER the array has been altered. Listeners are\r\n * called on the
    'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\r\n */\r\nfunction
    listenArrayEvents(array, listener) {\r\n\tif (array._chartjs) {\r\n\t\tarray._chartjs.listeners.push(listener);\r\n\t\treturn;\r\n\t}\r\n\r\n\tObject.defineProperty(array,
    '_chartjs', {\r\n\t\tconfigurable: true,\r\n\t\tenumerable: false,\r\n\t\tvalue:
    {\r\n\t\t\tlisteners: [listener]\r\n\t\t}\r\n\t});\r\n\r\n\tarrayEvents.forEach(function(key)
    {\r\n\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\r\n\t\tvar
    base = array[key];\r\n\r\n\t\tObject.defineProperty(array, key, {\r\n\t\t\tconfigurable:
    true,\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: function() {\r\n\t\t\t\tvar
    args = Array.prototype.slice.call(arguments);\r\n\t\t\t\tvar res = base.apply(this,
    args);\r\n\r\n\t\t\t\thelpers$1.each(array._chartjs.listeners, function(object)
    {\r\n\t\t\t\t\tif (typeof object[method] === 'function') {\r\n\t\t\t\t\t\tobject[method].apply(object,
    args);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn res;\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n
    * Removes the given array event listener and cleanup extra attached properties
    (such as\r\n * the _chartjs stub and overridden methods) if array doesn't have
    any more listeners.\r\n */\r\nfunction unlistenArrayEvents(array, listener) {\r\n\tvar
    stub = array._chartjs;\r\n\tif (!stub) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar listeners
    = stub.listeners;\r\n\tvar index = listeners.indexOf(listener);\r\n\tif (index
    !== -1) {\r\n\t\tlisteners.splice(index, 1);\r\n\t}\r\n\r\n\tif (listeners.length
    > 0) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tarrayEvents.forEach(function(key) {\r\n\t\tdelete
    array[key];\r\n\t});\r\n\r\n\tdelete array._chartjs;\r\n}\r\n\r\n// Base class
    for all dataset controllers (line, bar, etc)\r\nvar DatasetController = function(chart,
    datasetIndex) {\r\n\tthis.initialize(chart, datasetIndex);\r\n};\r\n\r\nhelpers$1.extend(DatasetController.prototype,
    {\r\n\r\n\t/**\r\n\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\r\n\t
    * @type {Chart.core.element}\r\n\t */\r\n\tdatasetElementType: null,\r\n\r\n\t/**\r\n\t
    * Element type used to generate a meta data (e.g. Chart.element.Point).\r\n\t
    * @type {Chart.core.element}\r\n\t */\r\n\tdataElementType: null,\r\n\r\n\t/**\r\n\t
    * Dataset element option keys to be resolved in _resolveDatasetElementOptions.\r\n\t
    * A derived controller may override this to resolve controller-specific options.\r\n\t
    * The keys defined here are for backward compatibility for legend styles.\r\n\t
    * @private\r\n\t */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderColor',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'borderWidth'\r\n\t],\r\n\r\n\t/**\r\n\t
    * Data element option keys to be resolved in _resolveDataElementOptions.\r\n\t
    * A derived controller may override this to resolve controller-specific options.\r\n\t
    * The keys defined here are for backward compatibility for legend styles.\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'pointStyle'\r\n\t],\r\n\r\n\tinitialize:
    function(chart, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tme.chart = chart;\r\n\t\tme.index
    = datasetIndex;\r\n\t\tme.linkScales();\r\n\t\tme.addElements();\r\n\t\tme._type
    = me.getMeta().type;\r\n\t},\r\n\r\n\tupdateIndex: function(datasetIndex) {\r\n\t\tthis.index
    = datasetIndex;\r\n\t},\r\n\r\n\tlinkScales: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar chart = me.chart;\r\n\t\tvar scales = chart.scales;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar scalesOpts = chart.options.scales;\r\n\r\n\t\tif
    (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {\r\n\t\t\tmeta.xAxisID
    = dataset.xAxisID || scalesOpts.xAxes[0].id;\r\n\t\t}\r\n\t\tif (meta.yAxisID
    === null || !(meta.yAxisID in scales) || dataset.yAxisID) {\r\n\t\t\tmeta.yAxisID
    = dataset.yAxisID || scalesOpts.yAxes[0].id;\r\n\t\t}\r\n\t},\r\n\r\n\tgetDataset:
    function() {\r\n\t\treturn this.chart.data.datasets[this.index];\r\n\t},\r\n\r\n\tgetMeta:
    function() {\r\n\t\treturn this.chart.getDatasetMeta(this.index);\r\n\t},\r\n\r\n\tgetScaleForId:
    function(scaleID) {\r\n\t\treturn this.chart.scales[scaleID];\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.getMeta().yAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.getMeta().xAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScale: function() {\r\n\t\treturn this.getScaleForId(this._getValueScaleId());\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScale: function() {\r\n\t\treturn this.getScaleForId(this._getIndexScaleId());\r\n\t},\r\n\r\n\treset:
    function() {\r\n\t\tthis._update(true);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tdestroy: function() {\r\n\t\tif (this._data) {\r\n\t\t\tunlistenArrayEvents(this._data,
    this);\r\n\t\t}\r\n\t},\r\n\r\n\tcreateMetaDataset: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar type = me.datasetElementType;\r\n\t\treturn type && new type({\r\n\t\t\t_chart:
    me.chart,\r\n\t\t\t_datasetIndex: me.index\r\n\t\t});\r\n\t},\r\n\r\n\tcreateMetaData:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar type = me.dataElementType;\r\n\t\treturn
    type && new type({\r\n\t\t\t_chart: me.chart,\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index:
    index\r\n\t\t});\r\n\t},\r\n\r\n\taddElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar data = me.getDataset().data || [];\r\n\t\tvar
    metaData = meta.data;\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = data.length;
    i < ilen; ++i) {\r\n\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\r\n\t\t}\r\n\r\n\t\tmeta.dataset
    = meta.dataset || me.createMetaDataset();\r\n\t},\r\n\r\n\taddElementAndReset:
    function(index) {\r\n\t\tvar element = this.createMetaData(index);\r\n\t\tthis.getMeta().data.splice(index,
    0, element);\r\n\t\tthis.updateElement(element, index, true);\r\n\t},\r\n\r\n\tbuildOrUpdateElements:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar
    data = dataset.data || (dataset.data = []);\r\n\r\n\t\t// In order to correctly
    handle data addition/deletion animation (an thus simulate\r\n\t\t// real-time
    charts), we need to monitor these data modifications and synchronize\r\n\t\t//
    the internal meta data accordingly.\r\n\t\tif (me._data !== data) {\r\n\t\t\tif
    (me._data) {\r\n\t\t\t\t// This case happens when the user replaced the data array
    instance.\r\n\t\t\t\tunlistenArrayEvents(me._data, me);\r\n\t\t\t}\r\n\r\n\t\t\tif
    (data && Object.isExtensible(data)) {\r\n\t\t\t\tlistenArrayEvents(data, me);\r\n\t\t\t}\r\n\t\t\tme._data
    = data;\r\n\t\t}\r\n\r\n\t\t// Re-sync meta data in case the user replaced the
    data array or if we missed\r\n\t\t// any updates and so make sure that we handle
    number of datapoints changing.\r\n\t\tme.resyncElements();\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the merged user-supplied and default dataset-level options\r\n\t * @private\r\n\t
    */\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tme._config = helpers$1.merge(Object.create(null),
    [\r\n\t\t\tme.chart.options.datasets[me._type],\r\n\t\t\tme.getDataset(),\r\n\t\t],
    {\r\n\t\t\tmerger: function(key, target, source) {\r\n\t\t\t\tif (key !== '_meta'
    && key !== 'data') {\r\n\t\t\t\t\thelpers$1._merger(key, target, source);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_update:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tme._configure();\r\n\t\tme._cachedDataOpts
    = null;\r\n\t\tme.update(reset);\r\n\t},\r\n\r\n\tupdate: helpers$1.noop,\r\n\r\n\ttransition:
    function(easingValue) {\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar elements
    = meta.data || [];\r\n\t\tvar ilen = elements.length;\r\n\t\tvar i = 0;\r\n\r\n\t\tfor
    (; i < ilen; ++i) {\r\n\t\t\telements[i].transition(easingValue);\r\n\t\t}\r\n\r\n\t\tif
    (meta.dataset) {\r\n\t\t\tmeta.dataset.transition(easingValue);\r\n\t\t}\r\n\t},\r\n\r\n\tdraw:
    function() {\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar elements = meta.data
    || [];\r\n\t\tvar ilen = elements.length;\r\n\t\tvar i = 0;\r\n\r\n\t\tif (meta.dataset)
    {\r\n\t\t\tmeta.dataset.draw();\r\n\t\t}\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\telements[i].draw();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns a set of predefined style properties that should be used to represent
    the dataset\r\n\t * or the data if the index is specified\r\n\t * @param {number}
    index - data index\r\n\t * @return {IStyleInterface} style object\r\n\t */\r\n\tgetStyle:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    dataset = meta.dataset;\r\n\t\tvar style;\r\n\r\n\t\tme._configure();\r\n\t\tif
    (dataset && index === undefined) {\r\n\t\t\tstyle = me._resolveDatasetElementOptions(dataset
    || {});\r\n\t\t} else {\r\n\t\t\tindex = index || 0;\r\n\t\t\tstyle = me._resolveDataElementOptions(meta.data[index]
    || {}, index);\r\n\t\t}\r\n\r\n\t\tif (style.fill === false || style.fill ===
    null) {\r\n\t\t\tstyle.backgroundColor = style.borderColor;\r\n\t\t}\r\n\r\n\t\treturn
    style;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDatasetElementOptions:
    function(element, hover) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasetOpts = me._config;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar
    options = chart.options.elements[me.datasetElementType.prototype._type] || {};\r\n\t\tvar
    elementOptions = me._datasetElementOptions;\r\n\t\tvar values = {};\r\n\t\tvar
    i, ilen, key, readKey;\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart:
    chart,\r\n\t\t\tdataset: me.getDataset(),\r\n\t\t\tdatasetIndex: me.index,\r\n\t\t\thover:
    hover\r\n\t\t};\r\n\r\n\t\tfor (i = 0, ilen = elementOptions.length; i < ilen;
    ++i) {\r\n\t\t\tkey = elementOptions[i];\r\n\t\t\treadKey = hover ? 'hover' +
    key.charAt(0).toUpperCase() + key.slice(1) : key;\r\n\t\t\tvalues[key] = resolve([\r\n\t\t\t\tcustom[readKey],\r\n\t\t\t\tdatasetOpts[readKey],\r\n\t\t\t\toptions[readKey]\r\n\t\t\t],
    context);\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_resolveDataElementOptions: function(element, index) {\r\n\t\tvar me =
    this;\r\n\t\tvar custom = element && element.custom;\r\n\t\tvar cached = me._cachedDataOpts;\r\n\t\tif
    (cached && !custom) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasetOpts = me._config;\r\n\t\tvar options = chart.options.elements[me.dataElementType.prototype._type]
    || {};\r\n\t\tvar elementOptions = me._dataElementOptions;\r\n\t\tvar values =
    {};\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart: chart,\r\n\t\t\tdataIndex:
    index,\r\n\t\t\tdataset: me.getDataset(),\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\t//
    `resolve` sets cacheable to `false` if any option is indexed or scripted\r\n\t\tvar
    info = {cacheable: !custom};\r\n\r\n\t\tvar keys, i, ilen, key;\r\n\r\n\t\tcustom
    = custom || {};\r\n\r\n\t\tif (helpers$1.isArray(elementOptions)) {\r\n\t\t\tfor
    (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\r\n\t\t\t\tkey = elementOptions[i];\r\n\t\t\t\tvalues[key]
    = resolve([\r\n\t\t\t\t\tcustom[key],\r\n\t\t\t\t\tdatasetOpts[key],\r\n\t\t\t\t\toptions[key]\r\n\t\t\t\t],
    context, index, info);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tkeys = Object.keys(elementOptions);\r\n\t\t\tfor
    (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n\t\t\t\tkey = keys[i];\r\n\t\t\t\tvalues[key]
    = resolve([\r\n\t\t\t\t\tcustom[key],\r\n\t\t\t\t\tdatasetOpts[elementOptions[key]],\r\n\t\t\t\t\tdatasetOpts[key],\r\n\t\t\t\t\toptions[key]\r\n\t\t\t\t],
    context, index, info);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (info.cacheable) {\r\n\t\t\tme._cachedDataOpts
    = Object.freeze(values);\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tremoveHoverStyle:
    function(element) {\r\n\t\thelpers$1.merge(element._model, element.$previousStyle
    || {});\r\n\t\tdelete element.$previousStyle;\r\n\t},\r\n\r\n\tsetHoverStyle:
    function(element) {\r\n\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\r\n\t\tvar
    index = element._index;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar model
    = element._model;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\telement.$previousStyle
    = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = resolve([custom.hoverBackgroundColor,
    dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined,
    index);\r\n\t\tmodel.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor,
    getHoverColor(model.borderColor)], undefined, index);\r\n\t\tmodel.borderWidth
    = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth],
    undefined, index);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_removeDatasetHoverStyle:
    function() {\r\n\t\tvar element = this.getMeta().dataset;\r\n\r\n\t\tif (element)
    {\r\n\t\t\tthis.removeHoverStyle(element);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_setDatasetHoverStyle: function() {\r\n\t\tvar element
    = this.getMeta().dataset;\r\n\t\tvar prev = {};\r\n\t\tvar i, ilen, key, keys,
    hoverOptions, model;\r\n\r\n\t\tif (!element) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodel
    = element._model;\r\n\t\thoverOptions = this._resolveDatasetElementOptions(element,
    true);\r\n\r\n\t\tkeys = Object.keys(hoverOptions);\r\n\t\tfor (i = 0, ilen =
    keys.length; i < ilen; ++i) {\r\n\t\t\tkey = keys[i];\r\n\t\t\tprev[key] = model[key];\r\n\t\t\tmodel[key]
    = hoverOptions[key];\r\n\t\t}\r\n\r\n\t\telement.$previousStyle = prev;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tresyncElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar data = me.getDataset().data;\r\n\t\tvar numMeta
    = meta.data.length;\r\n\t\tvar numData = data.length;\r\n\r\n\t\tif (numData <
    numMeta) {\r\n\t\t\tmeta.data.splice(numData, numMeta - numData);\r\n\t\t} else
    if (numData > numMeta) {\r\n\t\t\tme.insertElements(numMeta, numData - numMeta);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tinsertElements: function(start, count) {\r\n\t\tfor (var
    i = 0; i < count; ++i) {\r\n\t\t\tthis.addElementAndReset(start + i);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tonDataPush: function() {\r\n\t\tvar count = arguments.length;\r\n\t\tthis.insertElements(this.getDataset().data.length
    - count, count);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataPop:
    function() {\r\n\t\tthis.getMeta().data.pop();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tonDataShift: function() {\r\n\t\tthis.getMeta().data.shift();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tonDataSplice: function(start, count) {\r\n\t\tthis.getMeta().data.splice(start,
    count);\r\n\t\tthis.insertElements(start, arguments.length - 2);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tonDataUnshift: function() {\r\n\t\tthis.insertElements(0,
    arguments.length);\r\n\t}\r\n});\r\n\r\nDatasetController.extend = helpers$1.inherits;\r\n\r\nvar
    core_datasetController = DatasetController;\n\nvar TAU = Math.PI * 2;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {\r\n\t\tarc: {\r\n\t\t\tbackgroundColor: core_defaults.global.defaultColor,\r\n\t\t\tborderColor:
    '#fff',\r\n\t\t\tborderWidth: 2,\r\n\t\t\tborderAlign: 'center'\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction
    clipArc(ctx, arc) {\r\n\tvar startAngle = arc.startAngle;\r\n\tvar endAngle =
    arc.endAngle;\r\n\tvar pixelMargin = arc.pixelMargin;\r\n\tvar angleMargin = pixelMargin
    / arc.outerRadius;\r\n\tvar x = arc.x;\r\n\tvar y = arc.y;\r\n\r\n\t// Draw an
    inner border by cliping the arc and drawing a double-width border\r\n\t// Enlarge
    the clipping arc by 0.33 pixels to eliminate glitches between borders\r\n\tctx.beginPath();\r\n\tctx.arc(x,
    y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n\tif
    (arc.innerRadius > pixelMargin) {\r\n\t\tangleMargin = pixelMargin / arc.innerRadius;\r\n\t\tctx.arc(x,
    y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin,
    true);\r\n\t} else {\r\n\t\tctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2,
    startAngle - Math.PI / 2);\r\n\t}\r\n\tctx.closePath();\r\n\tctx.clip();\r\n}\r\n\r\nfunction
    drawFullCircleBorders(ctx, vm, arc, inner) {\r\n\tvar endAngle = arc.endAngle;\r\n\tvar
    i;\r\n\r\n\tif (inner) {\r\n\t\tarc.endAngle = arc.startAngle + TAU;\r\n\t\tclipArc(ctx,
    arc);\r\n\t\tarc.endAngle = endAngle;\r\n\t\tif (arc.endAngle === arc.startAngle
    && arc.fullCircles) {\r\n\t\t\tarc.endAngle += TAU;\r\n\t\t\tarc.fullCircles--;\r\n\t\t}\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x,
    arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);\r\n\tfor
    (i = 0; i < arc.fullCircles; ++i) {\r\n\t\tctx.stroke();\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x,
    arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);\r\n\tfor (i = 0;
    i < arc.fullCircles; ++i) {\r\n\t\tctx.stroke();\r\n\t}\r\n}\r\n\r\nfunction drawBorder(ctx,
    vm, arc) {\r\n\tvar inner = vm.borderAlign === 'inner';\r\n\r\n\tif (inner) {\r\n\t\tctx.lineWidth
    = vm.borderWidth * 2;\r\n\t\tctx.lineJoin = 'round';\r\n\t} else {\r\n\t\tctx.lineWidth
    = vm.borderWidth;\r\n\t\tctx.lineJoin = 'bevel';\r\n\t}\r\n\r\n\tif (arc.fullCircles)
    {\r\n\t\tdrawFullCircleBorders(ctx, vm, arc, inner);\r\n\t}\r\n\r\n\tif (inner)
    {\r\n\t\tclipArc(ctx, arc);\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x,
    arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);\r\n\tctx.arc(arc.x, arc.y,
    arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n}\r\n\r\nvar
    element_arc = core_element.extend({\r\n\t_type: 'arc',\r\n\r\n\tinLabelRange:
    function(mouseX) {\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif (vm) {\r\n\t\t\treturn
    (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\r\n\t\t}\r\n\t\treturn
    false;\r\n\t},\r\n\r\n\tinRange: function(chartX, chartY) {\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif
    (vm) {\r\n\t\t\tvar pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x:
    chartX, y: chartY});\r\n\t\t\tvar angle = pointRelativePosition.angle;\r\n\t\t\tvar
    distance = pointRelativePosition.distance;\r\n\r\n\t\t\t// Sanitise angle range\r\n\t\t\tvar
    startAngle = vm.startAngle;\r\n\t\t\tvar endAngle = vm.endAngle;\r\n\t\t\twhile
    (endAngle < startAngle) {\r\n\t\t\t\tendAngle += TAU;\r\n\t\t\t}\r\n\t\t\twhile
    (angle > endAngle) {\r\n\t\t\t\tangle -= TAU;\r\n\t\t\t}\r\n\t\t\twhile (angle
    < startAngle) {\r\n\t\t\t\tangle += TAU;\r\n\t\t\t}\r\n\r\n\t\t\t// Check if within
    the range of the open/close angle\r\n\t\t\tvar betweenAngles = (angle >= startAngle
    && angle <= endAngle);\r\n\t\t\tvar withinRadius = (distance >= vm.innerRadius
    && distance <= vm.outerRadius);\r\n\r\n\t\t\treturn (betweenAngles && withinRadius);\r\n\t\t}\r\n\t\treturn
    false;\r\n\t},\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar
    halfAngle = (vm.startAngle + vm.endAngle) / 2;\r\n\t\tvar halfRadius = (vm.innerRadius
    + vm.outerRadius) / 2;\r\n\t\treturn {\r\n\t\t\tx: vm.x + Math.cos(halfAngle)
    * halfRadius,\r\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\r\n\t\t};\r\n\t},\r\n\r\n\tgetArea:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn Math.PI * ((vm.endAngle
    - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius,
    2));\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar
    centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\r\n\t\tvar
    rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\r\n\r\n\t\treturn
    {\r\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\r\n\t\t\ty: vm.y
    + (Math.sin(centreAngle) * rangeFromCentre)\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function()
    {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar pixelMargin
    = (vm.borderAlign === 'inner') ? 0.33 : 0;\r\n\t\tvar arc = {\r\n\t\t\tx: vm.x,\r\n\t\t\ty:
    vm.y,\r\n\t\t\tinnerRadius: vm.innerRadius,\r\n\t\t\touterRadius: Math.max(vm.outerRadius
    - pixelMargin, 0),\r\n\t\t\tpixelMargin: pixelMargin,\r\n\t\t\tstartAngle: vm.startAngle,\r\n\t\t\tendAngle:
    vm.endAngle,\r\n\t\t\tfullCircles: Math.floor(vm.circumference / TAU)\r\n\t\t};\r\n\t\tvar
    i;\r\n\r\n\t\tctx.save();\r\n\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle
    = vm.borderColor;\r\n\r\n\t\tif (arc.fullCircles) {\r\n\t\t\tarc.endAngle = arc.startAngle
    + TAU;\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.arc(arc.x, arc.y, arc.outerRadius,
    arc.startAngle, arc.endAngle);\r\n\t\t\tctx.arc(arc.x, arc.y, arc.innerRadius,
    arc.endAngle, arc.startAngle, true);\r\n\t\t\tctx.closePath();\r\n\t\t\tfor (i
    = 0; i < arc.fullCircles; ++i) {\r\n\t\t\t\tctx.fill();\r\n\t\t\t}\r\n\t\t\tarc.endAngle
    = arc.startAngle + vm.circumference % TAU;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(arc.x,
    arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\r\n\t\tctx.arc(arc.x, arc.y,
    arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\t\tctx.closePath();\r\n\t\tctx.fill();\r\n\r\n\t\tif
    (vm.borderWidth) {\r\n\t\t\tdrawBorder(ctx, vm, arc);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n});\n\nvar
    valueOrDefault$1 = helpers$1.valueOrDefault;\r\n\r\nvar defaultColor = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {\r\n\t\tline: {\r\n\t\t\ttension: 0.4,\r\n\t\t\tbackgroundColor:
    defaultColor,\r\n\t\t\tborderWidth: 3,\r\n\t\t\tborderColor: defaultColor,\r\n\t\t\tborderCapStyle:
    'butt',\r\n\t\t\tborderDash: [],\r\n\t\t\tborderDashOffset: 0.0,\r\n\t\t\tborderJoinStyle:
    'miter',\r\n\t\t\tcapBezierPoints: true,\r\n\t\t\tfill: true, // do we fill in
    the area between the line and its base axis\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    element_line = core_element.extend({\r\n\t_type: 'line',\r\n\r\n\tdraw: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar vm = me._view;\r\n\t\tvar ctx = me._chart.ctx;\r\n\t\tvar
    spanGaps = vm.spanGaps;\r\n\t\tvar points = me._children.slice(); // clone array\r\n\t\tvar
    globalDefaults = core_defaults.global;\r\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\r\n\t\tvar
    lastDrawnIndex = -1;\r\n\t\tvar closePath = me._loop;\r\n\t\tvar index, previous,
    currentVM;\r\n\r\n\t\tif (!points.length) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif
    (me._loop) {\r\n\t\t\tfor (index = 0; index < points.length; ++index) {\r\n\t\t\t\tprevious
    = helpers$1.previousItem(points, index);\r\n\t\t\t\t// If the line has an open
    path, shift the point array\r\n\t\t\t\tif (!points[index]._view.skip && previous._view.skip)
    {\r\n\t\t\t\t\tpoints = points.slice(index).concat(points.slice(0, index));\r\n\t\t\t\t\tclosePath
    = spanGaps;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If the line
    has a close path, add the first point again\r\n\t\t\tif (closePath) {\r\n\t\t\t\tpoints.push(points[0]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\r\n\t\t//
    Stroke Line Options\r\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\r\n\r\n\t\t//
    IE 9 and 10 do not support line dash\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(vm.borderDash
    || globalOptionLineElements.borderDash);\r\n\t\t}\r\n\r\n\t\tctx.lineDashOffset
    = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\r\n\t\tctx.lineJoin
    = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\r\n\t\tctx.lineWidth
    = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\r\n\t\tctx.strokeStyle
    = vm.borderColor || globalDefaults.defaultColor;\r\n\r\n\t\t// Stroke Line\r\n\t\tctx.beginPath();\r\n\r\n\t\t//
    First point moves to it's starting position no matter what\r\n\t\tcurrentVM =
    points[0]._view;\r\n\t\tif (!currentVM.skip) {\r\n\t\t\tctx.moveTo(currentVM.x,
    currentVM.y);\r\n\t\t\tlastDrawnIndex = 0;\r\n\t\t}\r\n\r\n\t\tfor (index = 1;
    index < points.length; ++index) {\r\n\t\t\tcurrentVM = points[index]._view;\r\n\t\t\tprevious
    = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];\r\n\r\n\t\t\tif
    (!currentVM.skip) {\r\n\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps)
    || lastDrawnIndex === -1) {\r\n\t\t\t\t\t// There was a gap and this is the first
    point after the gap\r\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\t// Line to next point\r\n\t\t\t\t\thelpers$1.canvas.lineTo(ctx,
    previous._view, currentVM);\r\n\t\t\t\t}\r\n\t\t\t\tlastDrawnIndex = index;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (closePath) {\r\n\t\t\tctx.closePath();\r\n\t\t}\r\n\r\n\t\tctx.stroke();\r\n\t\tctx.restore();\r\n\t}\r\n});\n\nvar
    valueOrDefault$2 = helpers$1.valueOrDefault;\r\n\r\nvar defaultColor$1 = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {\r\n\t\tpoint: {\r\n\t\t\tradius: 3,\r\n\t\t\tpointStyle: 'circle',\r\n\t\t\tbackgroundColor:
    defaultColor$1,\r\n\t\t\tborderColor: defaultColor$1,\r\n\t\t\tborderWidth: 1,\r\n\t\t\t//
    Hover\r\n\t\t\thitRadius: 1,\r\n\t\t\thoverRadius: 4,\r\n\t\t\thoverBorderWidth:
    1\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction xRange(mouseX) {\r\n\tvar vm = this._view;\r\n\treturn
    vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\r\n}\r\n\r\nfunction
    yRange(mouseY) {\r\n\tvar vm = this._view;\r\n\treturn vm ? (Math.abs(mouseY -
    vm.y) < vm.radius + vm.hitRadius) : false;\r\n}\r\n\r\nvar element_point = core_element.extend({\r\n\t_type:
    'point',\r\n\r\n\tinRange: function(mouseX, mouseY) {\r\n\t\tvar vm = this._view;\r\n\t\treturn
    vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius
    + vm.radius, 2)) : false;\r\n\t},\r\n\r\n\tinLabelRange: xRange,\r\n\tinXRange:
    xRange,\r\n\tinYRange: yRange,\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar
    vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\t},\r\n\r\n\tgetArea:
    function() {\r\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\r\n\t},\r\n\r\n\ttooltipPosition:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty:
    vm.y,\r\n\t\t\tpadding: vm.radius + vm.borderWidth\r\n\t\t};\r\n\t},\r\n\r\n\tdraw:
    function(chartArea) {\r\n\t\tvar vm = this._view;\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar
    pointStyle = vm.pointStyle;\r\n\t\tvar rotation = vm.rotation;\r\n\t\tvar radius
    = vm.radius;\r\n\t\tvar x = vm.x;\r\n\t\tvar y = vm.y;\r\n\t\tvar globalDefaults
    = core_defaults.global;\r\n\t\tvar defaultColor = globalDefaults.defaultColor;
    // eslint-disable-line no-shadow\r\n\r\n\t\tif (vm.skip) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//
    Clipping for Points.\r\n\t\tif (chartArea === undefined || helpers$1.canvas._isPointInArea(vm,
    chartArea)) {\r\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\r\n\t\t\tctx.lineWidth
    = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\r\n\t\t\tctx.fillStyle
    = vm.backgroundColor || defaultColor;\r\n\t\t\thelpers$1.canvas.drawPoint(ctx,
    pointStyle, radius, x, y, rotation);\r\n\t\t}\r\n\t}\r\n});\n\nvar defaultColor$2
    = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global', {\r\n\telements:
    {\r\n\t\trectangle: {\r\n\t\t\tbackgroundColor: defaultColor$2,\r\n\t\t\tborderColor:
    defaultColor$2,\r\n\t\t\tborderSkipped: 'bottom',\r\n\t\t\tborderWidth: 0\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction
    isVertical(vm) {\r\n\treturn vm && vm.width !== undefined;\r\n}\r\n\r\n/**\r\n
    * Helper function to get the bounds of the bar regardless of the orientation\r\n
    * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of
    the bar\r\n * @private\r\n */\r\nfunction getBarBounds(vm) {\r\n\tvar x1, x2,
    y1, y2, half;\r\n\r\n\tif (isVertical(vm)) {\r\n\t\thalf = vm.width / 2;\r\n\t\tx1
    = vm.x - half;\r\n\t\tx2 = vm.x + half;\r\n\t\ty1 = Math.min(vm.y, vm.base);\r\n\t\ty2
    = Math.max(vm.y, vm.base);\r\n\t} else {\r\n\t\thalf = vm.height / 2;\r\n\t\tx1
    = Math.min(vm.x, vm.base);\r\n\t\tx2 = Math.max(vm.x, vm.base);\r\n\t\ty1 = vm.y
    - half;\r\n\t\ty2 = vm.y + half;\r\n\t}\r\n\r\n\treturn {\r\n\t\tleft: x1,\r\n\t\ttop:
    y1,\r\n\t\tright: x2,\r\n\t\tbottom: y2\r\n\t};\r\n}\r\n\r\nfunction swap(orig,
    v1, v2) {\r\n\treturn orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\n\r\nfunction
    parseBorderSkipped(vm) {\r\n\tvar edge = vm.borderSkipped;\r\n\tvar res = {};\r\n\r\n\tif
    (!edge) {\r\n\t\treturn res;\r\n\t}\r\n\r\n\tif (vm.horizontal) {\r\n\t\tif (vm.base
    > vm.x) {\r\n\t\t\tedge = swap(edge, 'left', 'right');\r\n\t\t}\r\n\t} else if
    (vm.base < vm.y) {\r\n\t\tedge = swap(edge, 'bottom', 'top');\r\n\t}\r\n\r\n\tres[edge]
    = true;\r\n\treturn res;\r\n}\r\n\r\nfunction parseBorderWidth(vm, maxW, maxH)
    {\r\n\tvar value = vm.borderWidth;\r\n\tvar skip = parseBorderSkipped(vm);\r\n\tvar
    t, r, b, l;\r\n\r\n\tif (helpers$1.isObject(value)) {\r\n\t\tt = +value.top ||
    0;\r\n\t\tr = +value.right || 0;\r\n\t\tb = +value.bottom || 0;\r\n\t\tl = +value.left
    || 0;\r\n\t} else {\r\n\t\tt = r = b = l = +value || 0;\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tt: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,\r\n\t\tr: skip.right
    || (r < 0) ? 0 : r > maxW ? maxW : r,\r\n\t\tb: skip.bottom || (b < 0) ? 0 : b
    > maxH ? maxH : b,\r\n\t\tl: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l\r\n\t};\r\n}\r\n\r\nfunction
    boundingRects(vm) {\r\n\tvar bounds = getBarBounds(vm);\r\n\tvar width = bounds.right
    - bounds.left;\r\n\tvar height = bounds.bottom - bounds.top;\r\n\tvar border =
    parseBorderWidth(vm, width / 2, height / 2);\r\n\r\n\treturn {\r\n\t\touter: {\r\n\t\t\tx:
    bounds.left,\r\n\t\t\ty: bounds.top,\r\n\t\t\tw: width,\r\n\t\t\th: height\r\n\t\t},\r\n\t\tinner:
    {\r\n\t\t\tx: bounds.left + border.l,\r\n\t\t\ty: bounds.top + border.t,\r\n\t\t\tw:
    width - border.l - border.r,\r\n\t\t\th: height - border.t - border.b\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction
    inRange(vm, x, y) {\r\n\tvar skipX = x === null;\r\n\tvar skipY = y === null;\r\n\tvar
    bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);\r\n\r\n\treturn bounds\r\n\t\t&&
    (skipX || x >= bounds.left && x <= bounds.right)\r\n\t\t&& (skipY || y >= bounds.top
    && y <= bounds.bottom);\r\n}\r\n\r\nvar element_rectangle = core_element.extend({\r\n\t_type:
    'rectangle',\r\n\r\n\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar
    vm = this._view;\r\n\t\tvar rects = boundingRects(vm);\r\n\t\tvar outer = rects.outer;\r\n\t\tvar
    inner = rects.inner;\r\n\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.fillRect(outer.x,
    outer.y, outer.w, outer.h);\r\n\r\n\t\tif (outer.w === inner.w && outer.h ===
    inner.h) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(outer.x,
    outer.y, outer.w, outer.h);\r\n\t\tctx.clip();\r\n\t\tctx.fillStyle = vm.borderColor;\r\n\t\tctx.rect(inner.x,
    inner.y, inner.w, inner.h);\r\n\t\tctx.fill('evenodd');\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\theight:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn vm.base - vm.y;\r\n\t},\r\n\r\n\tinRange:
    function(mouseX, mouseY) {\r\n\t\treturn inRange(this._view, mouseX, mouseY);\r\n\t},\r\n\r\n\tinLabelRange:
    function(mouseX, mouseY) {\r\n\t\tvar vm = this._view;\r\n\t\treturn isVertical(vm)\r\n\t\t\t?
    inRange(vm, mouseX, null)\r\n\t\t\t: inRange(vm, null, mouseY);\r\n\t},\r\n\r\n\tinXRange:
    function(mouseX) {\r\n\t\treturn inRange(this._view, mouseX, null);\r\n\t},\r\n\r\n\tinYRange:
    function(mouseY) {\r\n\t\treturn inRange(this._view, null, mouseY);\r\n\t},\r\n\r\n\tgetCenterPoint:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar x, y;\r\n\t\tif (isVertical(vm))
    {\r\n\t\t\tx = vm.x;\r\n\t\t\ty = (vm.y + vm.base) / 2;\r\n\t\t} else {\r\n\t\t\tx
    = (vm.x + vm.base) / 2;\r\n\t\t\ty = vm.y;\r\n\t\t}\r\n\r\n\t\treturn {x: x, y:
    y};\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\tvar vm = this._view;\r\n\r\n\t\treturn
    isVertical(vm)\r\n\t\t\t? vm.width * Math.abs(vm.y - vm.base)\r\n\t\t\t: vm.height
    * Math.abs(vm.x - vm.base);\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar
    vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\t}\r\n});\n\nvar
    elements = {};\r\nvar Arc = element_arc;\r\nvar Line = element_line;\r\nvar Point
    = element_point;\r\nvar Rectangle = element_rectangle;\nelements.Arc = Arc;\nelements.Line
    = Line;\nelements.Point = Point;\nelements.Rectangle = Rectangle;\n\nvar deprecated
    = helpers$1._deprecated;\r\nvar valueOrDefault$3 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('bar',
    {\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes:
    [{\r\n\t\t\ttype: 'category',\r\n\t\t\toffset: true,\r\n\t\t\tgridLines: {\r\n\t\t\t\toffsetGridLines:
    true\r\n\t\t\t}\r\n\t\t}],\r\n\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global',
    {\r\n\tdatasets: {\r\n\t\tbar: {\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage:
    0.9\r\n\t\t}\r\n\t}\r\n});\r\n\r\n/**\r\n * Computes the \"optimal\" sample size
    to maintain bars equally sized while preventing overlap.\r\n * @private\r\n */\r\nfunction
    computeMinSampleSize(scale, pixels) {\r\n\tvar min = scale._length;\r\n\tvar prev,
    curr, i, ilen;\r\n\r\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\r\n\t\tmin
    = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\r\n\t}\r\n\r\n\tfor (i =
    0, ilen = scale.getTicks().length; i < ilen; ++i) {\r\n\t\tcurr = scale.getPixelForTick(i);\r\n\t\tmin
    = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;\r\n\t\tprev = curr;\r\n\t}\r\n\r\n\treturn
    min;\r\n}\r\n\r\n/**\r\n * Computes an \"ideal\" category based on the absolute
    bar thickness or, if undefined or null,\r\n * uses the smallest interval (see
    computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently
    always generates bars equally sized (until we introduce scriptable options?).\r\n
    * @private\r\n */\r\nfunction computeFitCategoryTraits(index, ruler, options)
    {\r\n\tvar thickness = options.barThickness;\r\n\tvar count = ruler.stackCount;\r\n\tvar
    curr = ruler.pixels[index];\r\n\tvar min = helpers$1.isNullOrUndef(thickness)\r\n\t\t?
    computeMinSampleSize(ruler.scale, ruler.pixels)\r\n\t\t: -1;\r\n\tvar size, ratio;\r\n\r\n\tif
    (helpers$1.isNullOrUndef(thickness)) {\r\n\t\tsize = min * options.categoryPercentage;\r\n\t\tratio
    = options.barPercentage;\r\n\t} else {\r\n\t\t// When bar thickness is enforced,
    category and bar percentages are ignored.\r\n\t\t// Note(SB): we could add support
    for relative bar thickness (e.g. barThickness: '50%')\r\n\t\t// and deprecate
    barPercentage since this value is ignored when thickness is absolute.\r\n\t\tsize
    = thickness * count;\r\n\t\tratio = 1;\r\n\t}\r\n\r\n\treturn {\r\n\t\tchunk:
    size / count,\r\n\t\tratio: ratio,\r\n\t\tstart: curr - (size / 2)\r\n\t};\r\n}\r\n\r\n/**\r\n
    * Computes an \"optimal\" category that globally arranges bars side by side (no
    gap when\r\n * percentage options are 1), based on the previous and following
    categories. This mode\r\n * generates bars with different widths when data are
    not evenly spaced.\r\n * @private\r\n */\r\nfunction computeFlexCategoryTraits(index,
    ruler, options) {\r\n\tvar pixels = ruler.pixels;\r\n\tvar curr = pixels[index];\r\n\tvar
    prev = index > 0 ? pixels[index - 1] : null;\r\n\tvar next = index < pixels.length
    - 1 ? pixels[index + 1] : null;\r\n\tvar percent = options.categoryPercentage;\r\n\tvar
    start, size;\r\n\r\n\tif (prev === null) {\r\n\t\t// first data: its size is double
    based on the next point or,\r\n\t\t// if it's also the last data, we use the scale
    size.\r\n\t\tprev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n\t}\r\n\r\n\tif
    (next === null) {\r\n\t\t// last data: its size is also double based on the previous
    point.\r\n\t\tnext = curr + curr - prev;\r\n\t}\r\n\r\n\tstart = curr - (curr
    - Math.min(prev, next)) / 2 * percent;\r\n\tsize = Math.abs(next - prev) / 2 *
    percent;\r\n\r\n\treturn {\r\n\t\tchunk: size / ruler.stackCount,\r\n\t\tratio:
    options.barPercentage,\r\n\t\tstart: start\r\n\t};\r\n}\r\n\r\nvar controller_bar
    = core_datasetController.extend({\r\n\r\n\tdataElementType: elements.Rectangle,\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderSkipped',\r\n\t\t'borderWidth',\r\n\t\t'barPercentage',\r\n\t\t'barThickness',\r\n\t\t'categoryPercentage',\r\n\t\t'maxBarThickness',\r\n\t\t'minBarLength'\r\n\t],\r\n\r\n\tinitialize:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar meta, scaleOpts;\r\n\r\n\t\tcore_datasetController.prototype.initialize.apply(me,
    arguments);\r\n\r\n\t\tmeta = me.getMeta();\r\n\t\tmeta.stack = me.getDataset().stack;\r\n\t\tmeta.bar
    = true;\r\n\r\n\t\tscaleOpts = me._getIndexScale().options;\r\n\t\tdeprecated('bar
    chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');\r\n\t\tdeprecated('bar
    chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');\r\n\t\tdeprecated('bar
    chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');\r\n\t\tdeprecated('bar
    chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength',
    'dataset.minBarLength');\r\n\t\tdeprecated('bar chart', scaleOpts.maxBarThickness,
    'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');\r\n\t},\r\n\r\n\tupdate:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar rects = me.getMeta().data;\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tme._ruler = me.getRuler();\r\n\r\n\t\tfor (i = 0, ilen = rects.length;
    i < ilen; ++i) {\r\n\t\t\tme.updateElement(rects[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(rectangle, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar options = me._resolveDataElementOptions(rectangle,
    index);\r\n\r\n\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\trectangle._yScale
    = me.getScaleForId(meta.yAxisID);\r\n\t\trectangle._datasetIndex = me.index;\r\n\t\trectangle._index
    = index;\r\n\t\trectangle._model = {\r\n\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\tborderColor:
    options.borderColor,\r\n\t\t\tborderSkipped: options.borderSkipped,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\tdatasetLabel: dataset.label,\r\n\t\t\tlabel: me.chart.data.labels[index]\r\n\t\t};\r\n\r\n\t\tif
    (helpers$1.isArray(dataset.data[index])) {\r\n\t\t\trectangle._model.borderSkipped
    = null;\r\n\t\t}\r\n\r\n\t\tme._updateElementGeometry(rectangle, index, reset,
    options);\r\n\r\n\t\trectangle.pivot();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_updateElementGeometry: function(rectangle, index, reset, options) {\r\n\t\tvar
    me = this;\r\n\t\tvar model = rectangle._model;\r\n\t\tvar vscale = me._getValueScale();\r\n\t\tvar
    base = vscale.getBasePixel();\r\n\t\tvar horizontal = vscale.isHorizontal();\r\n\t\tvar
    ruler = me._ruler || me.getRuler();\r\n\t\tvar vpixels = me.calculateBarValuePixels(me.index,
    index, options);\r\n\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index,
    ruler, options);\r\n\r\n\t\tmodel.horizontal = horizontal;\r\n\t\tmodel.base =
    reset ? base : vpixels.base;\r\n\t\tmodel.x = horizontal ? reset ? base : vpixels.head
    : ipixels.center;\r\n\t\tmodel.y = horizontal ? ipixels.center : reset ? base
    : vpixels.head;\r\n\t\tmodel.height = horizontal ? ipixels.size : undefined;\r\n\t\tmodel.width
    = horizontal ? undefined : ipixels.size;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns
    the stacks based on groups and bar visibility.\r\n\t * @param {number} [last]
    - The dataset index\r\n\t * @returns {string[]} The list of stack IDs\r\n\t *
    @private\r\n\t */\r\n\t_getStacks: function(last) {\r\n\t\tvar me = this;\r\n\t\tvar
    scale = me._getIndexScale();\r\n\t\tvar metasets = scale._getMatchingVisibleMetas(me._type);\r\n\t\tvar
    stacked = scale.options.stacked;\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar
    stacks = [];\r\n\t\tvar i, meta;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tmeta
    = metasets[i];\r\n\t\t\t// stacked   | meta.stack\r\n\t\t\t//           | found
    | not found | undefined\r\n\t\t\t// false     |   x   |     x     |     x\r\n\t\t\t//
    true      |       |     x     |\r\n\t\t\t// undefined |       |     x     |     x\r\n\t\t\tif
    (stacked === false || stacks.indexOf(meta.stack) === -1 ||\r\n\t\t\t\t(stacked
    === undefined && meta.stack === undefined)) {\r\n\t\t\t\tstacks.push(meta.stack);\r\n\t\t\t}\r\n\t\t\tif
    (meta.index === last) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    stacks;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the effective number of stacks based
    on groups and bar visibility.\r\n\t * @private\r\n\t */\r\n\tgetStackCount: function()
    {\r\n\t\treturn this._getStacks().length;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns
    the stack index for the given dataset based on groups and bar visibility.\r\n\t
    * @param {number} [datasetIndex] - The dataset index\r\n\t * @param {string} [name]
    - The stack name to find\r\n\t * @returns {number} The stack index\r\n\t * @private\r\n\t
    */\r\n\tgetStackIndex: function(datasetIndex, name) {\r\n\t\tvar stacks = this._getStacks(datasetIndex);\r\n\t\tvar
    index = (name !== undefined)\r\n\t\t\t? stacks.indexOf(name)\r\n\t\t\t: -1; //
    indexOf returns -1 if element is not present\r\n\r\n\t\treturn (index === -1)\r\n\t\t\t?
    stacks.length - 1\r\n\t\t\t: index;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tgetRuler: function() {\r\n\t\tvar me = this;\r\n\t\tvar scale = me._getIndexScale();\r\n\t\tvar
    pixels = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = me.getMeta().data.length;
    i < ilen; ++i) {\r\n\t\t\tpixels.push(scale.getPixelForValue(null, i, me.index));\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tpixels: pixels,\r\n\t\t\tstart: scale._startPixel,\r\n\t\t\tend: scale._endPixel,\r\n\t\t\tstackCount:
    me.getStackCount(),\r\n\t\t\tscale: scale\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * Note: pixel values are not clamped to the scale area.\r\n\t * @private\r\n\t
    */\r\n\tcalculateBarValuePixels: function(datasetIndex, index, options) {\r\n\t\tvar
    me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar scale = me._getValueScale();\r\n\t\tvar
    isHorizontal = scale.isHorizontal();\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar
    metasets = scale._getMatchingVisibleMetas(me._type);\r\n\t\tvar value = scale._parseValue(datasets[datasetIndex].data[index]);\r\n\t\tvar
    minBarLength = options.minBarLength;\r\n\t\tvar stacked = scale.options.stacked;\r\n\t\tvar
    stack = me.getMeta().stack;\r\n\t\tvar start = value.start === undefined ? 0 :
    value.max >= 0 && value.min >= 0 ? value.min : value.max;\r\n\t\tvar length =
    value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max
    - value.min : value.min - value.max;\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar
    i, imeta, ivalue, base, head, size, stackLength;\r\n\r\n\t\tif (stacked || (stacked
    === undefined && stack !== undefined)) {\r\n\t\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\t\timeta
    = metasets[i];\r\n\r\n\t\t\t\tif (imeta.index === datasetIndex) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif
    (imeta.stack === stack) {\r\n\t\t\t\t\tstackLength = scale._parseValue(datasets[imeta.index].data[index]);\r\n\t\t\t\t\tivalue
    = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 &&
    stackLength.max >= 0 ? stackLength.max : stackLength.min;\r\n\r\n\t\t\t\t\tif
    ((value.min < 0 && ivalue < 0) || (value.max >= 0 && ivalue > 0)) {\r\n\t\t\t\t\t\tstart
    += ivalue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbase = scale.getPixelForValue(start);\r\n\t\thead
    = scale.getPixelForValue(start + length);\r\n\t\tsize = head - base;\r\n\r\n\t\tif
    (minBarLength !== undefined && Math.abs(size) < minBarLength) {\r\n\t\t\tsize
    = minBarLength;\r\n\t\t\tif (length >= 0 && !isHorizontal || length < 0 && isHorizontal)
    {\r\n\t\t\t\thead = base - minBarLength;\r\n\t\t\t} else {\r\n\t\t\t\thead = base
    + minBarLength;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tbase:
    base,\r\n\t\t\thead: head,\r\n\t\t\tcenter: head + size / 2\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tcalculateBarIndexPixels: function(datasetIndex, index,
    ruler, options) {\r\n\t\tvar me = this;\r\n\t\tvar range = options.barThickness
    === 'flex'\r\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\r\n\t\t\t:
    computeFitCategoryTraits(index, ruler, options);\r\n\r\n\t\tvar stackIndex = me.getStackIndex(datasetIndex,
    me.getMeta().stack);\r\n\t\tvar center = range.start + (range.chunk * stackIndex)
    + (range.chunk / 2);\r\n\t\tvar size = Math.min(\r\n\t\t\tvalueOrDefault$3(options.maxBarThickness,
    Infinity),\r\n\t\t\trange.chunk * range.ratio);\r\n\r\n\t\treturn {\r\n\t\t\tbase:
    center - size / 2,\r\n\t\t\thead: center + size / 2,\r\n\t\t\tcenter: center,\r\n\t\t\tsize:
    size\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar scale = me._getValueScale();\r\n\t\tvar rects = me.getMeta().data;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar ilen = rects.length;\r\n\t\tvar i = 0;\r\n\r\n\t\thelpers$1.canvas.clipArea(chart.ctx,
    chart.chartArea);\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tvar val = scale._parseValue(dataset.data[i]);\r\n\t\t\tif
    (!isNaN(val.min) && !isNaN(val.max)) {\r\n\t\t\t\trects[i].draw();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers$1.canvas.unclipArea(chart.ctx);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_resolveDataElementOptions: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me,
    arguments));\r\n\t\tvar indexOpts = me._getIndexScale().options;\r\n\t\tvar valueOpts
    = me._getValueScale().options;\r\n\r\n\t\tvalues.barPercentage = valueOrDefault$3(indexOpts.barPercentage,
    values.barPercentage);\r\n\t\tvalues.barThickness = valueOrDefault$3(indexOpts.barThickness,
    values.barThickness);\r\n\t\tvalues.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage,
    values.categoryPercentage);\r\n\t\tvalues.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness,
    values.maxBarThickness);\r\n\t\tvalues.minBarLength = valueOrDefault$3(valueOpts.minBarLength,
    values.minBarLength);\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n});\n\nvar valueOrDefault$4
    = helpers$1.valueOrDefault;\r\nvar resolve$1 = helpers$1.options.resolve;\r\n\r\ncore_defaults._set('bubble',
    {\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes:
    [{\r\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\r\n\t\t\tposition:
    'bottom',\r\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the
    scale\r\n\t\t}],\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition:
    'left',\r\n\t\t\tid: 'y-axis-0'\r\n\t\t}]\r\n\t},\r\n\r\n\ttooltips: {\r\n\t\tcallbacks:
    {\r\n\t\t\ttitle: function() {\r\n\t\t\t\t// Title doesn't make sense for scatter
    since we format the data as a point\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel:
    function(item, data) {\r\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label
    || '';\r\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\r\n\t\t\t\treturn
    datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r +
    ')';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_bubble = core_datasetController.extend({\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tdataElementType: elements.Point,\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t\t'hoverRadius',\r\n\t\t'hitRadius',\r\n\t\t'pointStyle',\r\n\t\t'rotation'\r\n\t],\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar points = meta.data;\r\n\r\n\t\t// Update Points\r\n\t\thelpers$1.each(points,
    function(point, index) {\r\n\t\t\tme.updateElement(point, index, reset);\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tupdateElement: function(point, index, reset) {\r\n\t\tvar
    me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar custom = point.custom ||
    {};\r\n\t\tvar xScale = me.getScaleForId(meta.xAxisID);\r\n\t\tvar yScale = me.getScaleForId(meta.yAxisID);\r\n\t\tvar
    options = me._resolveDataElementOptions(point, index);\r\n\t\tvar data = me.getDataset().data[index];\r\n\t\tvar
    dsIndex = me.index;\r\n\r\n\t\tvar x = reset ? xScale.getPixelForDecimal(0.5)
    : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\r\n\t\tvar
    y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\r\n\r\n\t\tpoint._xScale
    = xScale;\r\n\t\tpoint._yScale = yScale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex
    = dsIndex;\r\n\t\tpoint._index = index;\r\n\t\tpoint._model = {\r\n\t\t\tbackgroundColor:
    options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\thitRadius: options.hitRadius,\r\n\t\t\tpointStyle:
    options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tradius: reset
    ? 0 : options.radius,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\tx:
    x,\r\n\t\t\ty: y,\r\n\t\t};\r\n\r\n\t\tpoint.pivot();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model =
    point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor =
    helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor:
    model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor
    = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor
    = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth
    = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius
    = options.radius + options.hoverRadius;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_resolveDataElementOptions: function(point, index) {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar custom = point.custom
    || {};\r\n\t\tvar data = dataset.data[index] || {};\r\n\t\tvar values = core_datasetController.prototype._resolveDataElementOptions.apply(me,
    arguments);\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart:
    chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset: dataset,\r\n\t\t\tdatasetIndex:
    me.index\r\n\t\t};\r\n\r\n\t\t// In case values were cached (and thus frozen),
    we need to clone the values\r\n\t\tif (me._cachedDataOpts === values) {\r\n\t\t\tvalues
    = helpers$1.extend({}, values);\r\n\t\t}\r\n\r\n\t\t// Custom radius resolution\r\n\t\tvalues.radius
    = resolve$1([\r\n\t\t\tcustom.radius,\r\n\t\t\tdata.r,\r\n\t\t\tme._config.radius,\r\n\t\t\tchart.options.elements.point.radius\r\n\t\t],
    context, index);\r\n\r\n\t\treturn values;\r\n\t}\r\n});\n\nvar valueOrDefault$5
    = helpers$1.valueOrDefault;\r\n\r\nvar PI$1 = Math.PI;\r\nvar DOUBLE_PI$1 = PI$1
    * 2;\r\nvar HALF_PI$1 = PI$1 / 2;\r\n\r\ncore_defaults._set('doughnut', {\r\n\tanimation:
    {\r\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\r\n\t\tanimateRotate:
    true,\r\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\r\n\t\tanimateScale:
    false\r\n\t},\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\tlegendCallback:
    function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar data
    = chart.data;\r\n\t\tvar datasets = data.datasets;\r\n\t\tvar labels = data.labels;\r\n\t\tvar
    i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id
    + '-legend');\r\n\t\tif (datasets.length) {\r\n\t\t\tfor (i = 0, ilen = datasets[0].data.length;
    i < ilen; ++i) {\r\n\t\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\t\tlistItemSpan
    = listItem.appendChild(document.createElement('span'));\r\n\t\t\t\tlistItemSpan.style.backgroundColor
    = datasets[0].backgroundColor[i];\r\n\t\t\t\tif (labels[i]) {\r\n\t\t\t\t\tlistItem.appendChild(document.createTextNode(labels[i]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    list.outerHTML;\r\n\t},\r\n\tlegend: {\r\n\t\tlabels: {\r\n\t\t\tgenerateLabels:
    function(chart) {\r\n\t\t\t\tvar data = chart.data;\r\n\t\t\t\tif (data.labels.length
    && data.datasets.length) {\r\n\t\t\t\t\treturn data.labels.map(function(label,
    i) {\r\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\r\n\t\t\t\t\t\tvar style
    = meta.controller.getStyle(i);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttext:
    label,\r\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\t\tstrokeStyle:
    style.borderColor,\r\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\t\thidden:
    isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\r\n\r\n\t\t\t\t\t\t\t//
    Extra data used for toggling the correct item\r\n\t\t\t\t\t\t\tindex: i\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn
    [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar
    index = legendItem.index;\r\n\t\t\tvar chart = this.chart;\r\n\t\t\tvar i, ilen,
    meta;\r\n\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i <
    ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\t// toggle visibility
    of index if exists\r\n\t\t\t\tif (meta.data[index]) {\r\n\t\t\t\t\tmeta.data[index].hidden
    = !meta.data[index].hidden;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tchart.update();\r\n\t\t}\r\n\t},\r\n\r\n\t//
    The percentage of the chart that we cut out of the middle.\r\n\tcutoutPercentage:
    50,\r\n\r\n\t// The rotation of the chart, where the first data arc begins.\r\n\trotation:
    -HALF_PI$1,\r\n\r\n\t// The total circumference of the chart.\r\n\tcircumference:
    DOUBLE_PI$1,\r\n\r\n\t// Need to override these to give a nice default\r\n\ttooltips:
    {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel:
    function(tooltipItem, data) {\r\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\r\n\t\t\t\tvar
    value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\r\n\r\n\t\t\t\tif
    (helpers$1.isArray(dataLabel)) {\r\n\t\t\t\t\t// show value on first line of multiline
    label\r\n\t\t\t\t\t// need to clone because we are changing the value\r\n\t\t\t\t\tdataLabel
    = dataLabel.slice();\r\n\t\t\t\t\tdataLabel[0] += value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdataLabel
    += value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn dataLabel;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    controller_doughnut = core_datasetController.extend({\r\n\r\n\tdataElementType:
    elements.Arc,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'borderAlign',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t],\r\n\r\n\t//
    Get index of the dataset in relation to the visible datasets. This allows determining
    the inner and outer radius correctly\r\n\tgetRingIndex: function(datasetIndex)
    {\r\n\t\tvar ringIndex = 0;\r\n\r\n\t\tfor (var j = 0; j < datasetIndex; ++j)
    {\r\n\t\t\tif (this.chart.isDatasetVisible(j)) {\r\n\t\t\t\t++ringIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    ringIndex;\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar
    ratioX = 1;\r\n\t\tvar ratioY = 1;\r\n\t\tvar offsetX = 0;\r\n\t\tvar offsetY
    = 0;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar arcs = meta.data;\r\n\t\tvar cutout
    = opts.cutoutPercentage / 100 || 0;\r\n\t\tvar circumference = opts.circumference;\r\n\t\tvar
    chartWeight = me._getRingWeight(me.index);\r\n\t\tvar maxWidth, maxHeight, i,
    ilen;\r\n\r\n\t\t// If the chart's circumference isn't a full circle, calculate
    size as a ratio of the width/height of the arc\r\n\t\tif (circumference < DOUBLE_PI$1)
    {\r\n\t\t\tvar startAngle = opts.rotation % DOUBLE_PI$1;\r\n\t\t\tstartAngle +=
    startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;\r\n\t\t\tvar
    endAngle = startAngle + circumference;\r\n\t\t\tvar startX = Math.cos(startAngle);\r\n\t\t\tvar
    startY = Math.sin(startAngle);\r\n\t\t\tvar endX = Math.cos(endAngle);\r\n\t\t\tvar
    endY = Math.sin(endAngle);\r\n\t\t\tvar contains0 = (startAngle <= 0 && endAngle
    >= 0) || endAngle >= DOUBLE_PI$1;\r\n\t\t\tvar contains90 = (startAngle <= HALF_PI$1
    && endAngle >= HALF_PI$1) || endAngle >= DOUBLE_PI$1 + HALF_PI$1;\r\n\t\t\tvar
    contains180 = startAngle === -PI$1 || endAngle >= PI$1;\r\n\t\t\tvar contains270
    = (startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1) || endAngle >= PI$1 + HALF_PI$1;\r\n\t\t\tvar
    minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);\r\n\t\t\tvar
    minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);\r\n\t\t\tvar
    maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);\r\n\t\t\tvar
    maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);\r\n\t\t\tratioX
    = (maxX - minX) / 2;\r\n\t\t\tratioY = (maxY - minY) / 2;\r\n\t\t\toffsetX = -(maxX
    + minX) / 2;\r\n\t\t\toffsetY = -(maxY + minY) / 2;\r\n\t\t}\r\n\r\n\t\tfor (i
    = 0, ilen = arcs.length; i < ilen; ++i) {\r\n\t\t\tarcs[i]._options = me._resolveDataElementOptions(arcs[i],
    i);\r\n\t\t}\r\n\r\n\t\tchart.borderWidth = me.getMaxBorderWidth();\r\n\t\tmaxWidth
    = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;\r\n\t\tmaxHeight
    = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;\r\n\t\tchart.outerRadius
    = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n\t\tchart.innerRadius = Math.max(chart.outerRadius
    * cutout, 0);\r\n\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius)
    / (me._getVisibleDatasetWeightTotal() || 1);\r\n\t\tchart.offsetX = offsetX *
    chart.outerRadius;\r\n\t\tchart.offsetY = offsetY * chart.outerRadius;\r\n\r\n\t\tmeta.total
    = me.calculateTotal();\r\n\r\n\t\tme.outerRadius = chart.outerRadius - chart.radiusLength
    * me._getRingWeightOffset(me.index);\r\n\t\tme.innerRadius = Math.max(me.outerRadius
    - chart.radiusLength * chartWeight, 0);\r\n\r\n\t\tfor (i = 0, ilen = arcs.length;
    i < ilen; ++i) {\r\n\t\t\tme.updateElement(arcs[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(arc, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar animationOpts
    = opts.animation;\r\n\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\r\n\t\tvar
    centerY = (chartArea.top + chartArea.bottom) / 2;\r\n\t\tvar startAngle = opts.rotation;
    // non reset case handled later\r\n\t\tvar endAngle = opts.rotation; // non reset
    case handled later\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar circumference
    = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index])
    * (opts.circumference / DOUBLE_PI$1);\r\n\t\tvar innerRadius = reset && animationOpts.animateScale
    ? 0 : me.innerRadius;\r\n\t\tvar outerRadius = reset && animationOpts.animateScale
    ? 0 : me.outerRadius;\r\n\t\tvar options = arc._options || {};\r\n\r\n\t\thelpers$1.extend(arc,
    {\r\n\t\t\t// Utility\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index: index,\r\n\r\n\t\t\t//
    Desired view properties\r\n\t\t\t_model: {\r\n\t\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\t\tborderColor:
    options.borderColor,\r\n\t\t\t\tborderWidth: options.borderWidth,\r\n\t\t\t\tborderAlign:
    options.borderAlign,\r\n\t\t\t\tx: centerX + chart.offsetX,\r\n\t\t\t\ty: centerY
    + chart.offsetY,\r\n\t\t\t\tstartAngle: startAngle,\r\n\t\t\t\tendAngle: endAngle,\r\n\t\t\t\tcircumference:
    circumference,\r\n\t\t\t\touterRadius: outerRadius,\r\n\t\t\t\tinnerRadius: innerRadius,\r\n\t\t\t\tlabel:
    helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar
    model = arc._model;\r\n\r\n\t\t// Set correct angles if not resetting\r\n\t\tif
    (!reset || !animationOpts.animateRotate) {\r\n\t\t\tif (index === 0) {\r\n\t\t\t\tmodel.startAngle
    = opts.rotation;\r\n\t\t\t} else {\r\n\t\t\t\tmodel.startAngle = me.getMeta().data[index
    - 1]._model.endAngle;\r\n\t\t\t}\r\n\r\n\t\t\tmodel.endAngle = model.startAngle
    + model.circumference;\r\n\t\t}\r\n\r\n\t\tarc.pivot();\r\n\t},\r\n\r\n\tcalculateTotal:
    function() {\r\n\t\tvar dataset = this.getDataset();\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar
    total = 0;\r\n\t\tvar value;\r\n\r\n\t\thelpers$1.each(meta.data, function(element,
    index) {\r\n\t\t\tvalue = dataset.data[index];\r\n\t\t\tif (!isNaN(value) && !element.hidden)
    {\r\n\t\t\t\ttotal += Math.abs(value);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t/* if
    (total === 0) {\r\n\t\t\ttotal = NaN;\r\n\t\t}*/\r\n\r\n\t\treturn total;\r\n\t},\r\n\r\n\tcalculateCircumference:
    function(value) {\r\n\t\tvar total = this.getMeta().total;\r\n\t\tif (total >
    0 && !isNaN(value)) {\r\n\t\t\treturn DOUBLE_PI$1 * (Math.abs(value) / total);\r\n\t\t}\r\n\t\treturn
    0;\r\n\t},\r\n\r\n\t// gets the max border or hover width to properly scale pie
    charts\r\n\tgetMaxBorderWidth: function(arcs) {\r\n\t\tvar me = this;\r\n\t\tvar
    max = 0;\r\n\t\tvar chart = me.chart;\r\n\t\tvar i, ilen, meta, arc, controller,
    options, borderWidth, hoverWidth;\r\n\r\n\t\tif (!arcs) {\r\n\t\t\t// Find the
    outmost visible dataset\r\n\t\t\tfor (i = 0, ilen = chart.data.datasets.length;
    i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tmeta
    = chart.getDatasetMeta(i);\r\n\t\t\t\t\tarcs = meta.data;\r\n\t\t\t\t\tif (i !==
    me.index) {\r\n\t\t\t\t\t\tcontroller = meta.controller;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (!arcs) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length;
    i < ilen; ++i) {\r\n\t\t\tarc = arcs[i];\r\n\t\t\tif (controller) {\r\n\t\t\t\tcontroller._configure();\r\n\t\t\t\toptions
    = controller._resolveDataElementOptions(arc, i);\r\n\t\t\t} else {\r\n\t\t\t\toptions
    = arc._options;\r\n\t\t\t}\r\n\t\t\tif (options.borderAlign !== 'inner') {\r\n\t\t\t\tborderWidth
    = options.borderWidth;\r\n\t\t\t\thoverWidth = options.hoverBorderWidth;\r\n\r\n\t\t\t\tmax
    = borderWidth > max ? borderWidth : max;\r\n\t\t\t\tmax = hoverWidth > max ? hoverWidth
    : max;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn max;\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t
    */\r\n\tsetHoverStyle: function(arc) {\r\n\t\tvar model = arc._model;\r\n\t\tvar
    options = arc._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tarc.$previousStyle
    = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor,
    getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault$5(options.hoverBorderColor,
    getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault$5(options.hoverBorderWidth,
    options.borderWidth);\r\n\t},\r\n\r\n\t/**\r\n\t * Get radius length offset of
    the dataset in relation to the visible datasets weights. This allows determining
    the inner and outer radius correctly\r\n\t * @private\r\n\t */\r\n\t_getRingWeightOffset:
    function(datasetIndex) {\r\n\t\tvar ringWeightOffset = 0;\r\n\r\n\t\tfor (var
    i = 0; i < datasetIndex; ++i) {\r\n\t\t\tif (this.chart.isDatasetVisible(i)) {\r\n\t\t\t\tringWeightOffset
    += this._getRingWeight(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ringWeightOffset;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getRingWeight: function(dataSetIndex) {\r\n\t\treturn
    Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the sum of all visibile data set weights.  This value can be 0.\r\n\t
    * @private\r\n\t */\r\n\t_getVisibleDatasetWeightTotal: function() {\r\n\t\treturn
    this._getRingWeightOffset(this.chart.data.datasets.length);\r\n\t}\r\n});\n\ncore_defaults._set('horizontalBar',
    {\r\n\thover: {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t},\r\n\r\n\tscales:
    {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\r\n\t\tyAxes:
    [{\r\n\t\t\ttype: 'category',\r\n\t\t\tposition: 'left',\r\n\t\t\toffset: true,\r\n\t\t\tgridLines:
    {\r\n\t\t\t\toffsetGridLines: true\r\n\t\t\t}\r\n\t\t}]\r\n\t},\r\n\r\n\telements:
    {\r\n\t\trectangle: {\r\n\t\t\tborderSkipped: 'left'\r\n\t\t}\r\n\t},\r\n\r\n\ttooltips:
    {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global',
    {\r\n\tdatasets: {\r\n\t\thorizontalBar: {\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage:
    0.9\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_horizontalBar = controller_bar.extend({\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.getMeta().xAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.getMeta().yAxisID;\r\n\t}\r\n});\n\nvar
    valueOrDefault$6 = helpers$1.valueOrDefault;\r\nvar resolve$2 = helpers$1.options.resolve;\r\nvar
    isPointInArea = helpers$1.canvas._isPointInArea;\r\n\r\ncore_defaults._set('line',
    {\r\n\tshowLines: true,\r\n\tspanGaps: false,\r\n\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales:
    {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'category',\r\n\t\t\tid: 'x-axis-0'\r\n\t\t}],\r\n\t\tyAxes:
    [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tid: 'y-axis-0'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\nfunction
    scaleClip(scale, halfBorderWidth) {\r\n\tvar tickOpts = scale && scale.options.ticks
    || {};\r\n\tvar reverse = tickOpts.reverse;\r\n\tvar min = tickOpts.min === undefined
    ? halfBorderWidth : 0;\r\n\tvar max = tickOpts.max === undefined ? halfBorderWidth
    : 0;\r\n\treturn {\r\n\t\tstart: reverse ? max : min,\r\n\t\tend: reverse ? min
    : max\r\n\t};\r\n}\r\n\r\nfunction defaultClip(xScale, yScale, borderWidth) {\r\n\tvar
    halfBorderWidth = borderWidth / 2;\r\n\tvar x = scaleClip(xScale, halfBorderWidth);\r\n\tvar
    y = scaleClip(yScale, halfBorderWidth);\r\n\r\n\treturn {\r\n\t\ttop: y.end,\r\n\t\tright:
    x.end,\r\n\t\tbottom: y.start,\r\n\t\tleft: x.start\r\n\t};\r\n}\r\n\r\nfunction
    toClip(value) {\r\n\tvar t, r, b, l;\r\n\r\n\tif (helpers$1.isObject(value)) {\r\n\t\tt
    = value.top;\r\n\t\tr = value.right;\r\n\t\tb = value.bottom;\r\n\t\tl = value.left;\r\n\t}
    else {\r\n\t\tt = r = b = l = value;\r\n\t}\r\n\r\n\treturn {\r\n\t\ttop: t,\r\n\t\tright:
    r,\r\n\t\tbottom: b,\r\n\t\tleft: l\r\n\t};\r\n}\r\n\r\n\r\nvar controller_line
    = core_datasetController.extend({\r\n\r\n\tdatasetElementType: elements.Line,\r\n\r\n\tdataElementType:
    elements.Point,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_datasetElementOptions:
    [\r\n\t\t'backgroundColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderColor',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'borderWidth',\r\n\t\t'cubicInterpolationMode',\r\n\t\t'fill'\r\n\t],\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: {\r\n\t\tbackgroundColor: 'pointBackgroundColor',\r\n\t\tborderColor:
    'pointBorderColor',\r\n\t\tborderWidth: 'pointBorderWidth',\r\n\t\thitRadius:
    'pointHitRadius',\r\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\r\n\t\thoverBorderColor:
    'pointHoverBorderColor',\r\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\r\n\t\thoverRadius:
    'pointHoverRadius',\r\n\t\tpointStyle: 'pointStyle',\r\n\t\tradius: 'pointRadius',\r\n\t\trotation:
    'pointRotation'\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar line = meta.dataset;\r\n\t\tvar points = meta.data
    || [];\r\n\t\tvar options = me.chart.options;\r\n\t\tvar config = me._config;\r\n\t\tvar
    showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tme._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\tme._yScale
    = me.getScaleForId(meta.yAxisID);\r\n\r\n\t\t// Update Line\r\n\t\tif (showLine)
    {\r\n\t\t\t// Compatibility: If the properties are defined with only the old name,
    use those values\r\n\t\t\tif (config.tension !== undefined && config.lineTension
    === undefined) {\r\n\t\t\t\tconfig.lineTension = config.tension;\r\n\t\t\t}\r\n\r\n\t\t\t//
    Utility\r\n\t\t\tline._scale = me._yScale;\r\n\t\t\tline._datasetIndex = me.index;\r\n\t\t\t//
    Data\r\n\t\t\tline._children = points;\r\n\t\t\t// Model\r\n\t\t\tline._model
    = me._resolveDatasetElementOptions(line);\r\n\r\n\t\t\tline.pivot();\r\n\t\t}\r\n\r\n\t\t//
    Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i],
    i, reset);\r\n\t\t}\r\n\r\n\t\tif (showLine && line._model.tension !== 0) {\r\n\t\t\tme.updateBezierControlPoints();\r\n\t\t}\r\n\r\n\t\t//
    Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i <
    ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    custom = point.custom || {};\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar
    datasetIndex = me.index;\r\n\t\tvar value = dataset.data[index];\r\n\t\tvar xScale
    = me._xScale;\r\n\t\tvar yScale = me._yScale;\r\n\t\tvar lineModel = meta.dataset._model;\r\n\t\tvar
    x, y;\r\n\r\n\t\tvar options = me._resolveDataElementOptions(point, index);\r\n\r\n\t\tx
    = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\r\n\t\ty
    = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\r\n\r\n\t\t//
    Utility\r\n\t\tpoint._xScale = xScale;\r\n\t\tpoint._yScale = yScale;\r\n\t\tpoint._options
    = options;\r\n\t\tpoint._datasetIndex = datasetIndex;\r\n\t\tpoint._index = index;\r\n\r\n\t\t//
    Desired view properties\r\n\t\tpoint._model = {\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t\tskip:
    custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\t// Appearance\r\n\t\t\tradius: options.radius,\r\n\t\t\tpointStyle:
    options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tbackgroundColor:
    options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\ttension: valueOrDefault$6(custom.tension, lineModel
    ? lineModel.tension : 0),\r\n\t\t\tsteppedLine: lineModel ? lineModel.steppedLine
    : false,\r\n\t\t\t// Tooltip\r\n\t\t\thitRadius: options.hitRadius\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function(element) {\r\n\t\tvar
    me = this;\r\n\t\tvar config = me._config;\r\n\t\tvar custom = element.custom
    || {};\r\n\t\tvar options = me.chart.options;\r\n\t\tvar lineOptions = options.elements.line;\r\n\t\tvar
    values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me,
    arguments);\r\n\r\n\t\t// The default behavior of lines is to break at null values,
    according\r\n\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\r\n\t\t//
    This option gives lines the ability to span gaps\r\n\t\tvalues.spanGaps = valueOrDefault$6(config.spanGaps,
    options.spanGaps);\r\n\t\tvalues.tension = valueOrDefault$6(config.lineTension,
    lineOptions.tension);\r\n\t\tvalues.steppedLine = resolve$2([custom.steppedLine,
    config.steppedLine, lineOptions.stepped]);\r\n\t\tvalues.clip = toClip(valueOrDefault$6(config.clip,
    defaultClip(me._xScale, me._yScale, values.borderWidth)));\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tcalculatePointY:
    function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar chart
    = me.chart;\r\n\t\tvar yScale = me._yScale;\r\n\t\tvar sumPos = 0;\r\n\t\tvar
    sumNeg = 0;\r\n\t\tvar i, ds, dsMeta, stackedRightValue, rightValue, metasets,
    ilen;\r\n\r\n\t\tif (yScale.options.stacked) {\r\n\t\t\trightValue = +yScale.getRightValue(value);\r\n\t\t\tmetasets
    = chart._getSortedVisibleDatasetMetas();\r\n\t\t\tilen = metasets.length;\r\n\r\n\t\t\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\t\t\tdsMeta = metasets[i];\r\n\t\t\t\tif (dsMeta.index
    === datasetIndex) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tds = chart.data.datasets[dsMeta.index];\r\n\t\t\t\tif
    (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {\r\n\t\t\t\t\tstackedRightValue
    = +yScale.getRightValue(ds.data[index]);\r\n\t\t\t\t\tif (stackedRightValue <
    0) {\r\n\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsumPos
    += stackedRightValue || 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif
    (rightValue < 0) {\r\n\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\r\n\t\t\t}\r\n\t\t\treturn
    yScale.getPixelForValue(sumPos + rightValue);\r\n\t\t}\r\n\t\treturn yScale.getPixelForValue(value);\r\n\t},\r\n\r\n\tupdateBezierControlPoints:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta
    = me.getMeta();\r\n\t\tvar lineModel = meta.dataset._model;\r\n\t\tvar area =
    chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model,
    controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps
    option is used\r\n\t\tif (lineModel.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt)
    {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction
    capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif
    (lineModel.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers$1.splineCurveMonotone(points);\r\n\t\t}
    else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel
    = points[i]._model;\r\n\t\t\t\tcontrolPoints = helpers$1.splineCurve(\r\n\t\t\t\t\thelpers$1.previousItem(points,
    i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers$1.nextItem(points, i)._model,\r\n\t\t\t\t\tlineModel.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX
    = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX
    = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length;
    i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tif (isPointInArea(model,
    area)) {\r\n\t\t\t\t\tif (i > 0 && isPointInArea(points[i - 1]._model, area))
    {\r\n\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX,
    area.left, area.right);\r\n\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY,
    area.top, area.bottom);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i < points.length - 1
    && isPointInArea(points[i + 1]._model, area)) {\r\n\t\t\t\t\t\tmodel.controlPointNextX
    = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\t\t\tmodel.controlPointNextY
    = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdraw:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta
    = me.getMeta();\r\n\t\tvar points = meta.data || [];\r\n\t\tvar area = chart.chartArea;\r\n\t\tvar
    canvas = chart.canvas;\r\n\t\tvar i = 0;\r\n\t\tvar ilen = points.length;\r\n\t\tvar
    clip;\r\n\r\n\t\tif (me._showLine) {\r\n\t\t\tclip = meta.dataset._model.clip;\r\n\r\n\t\t\thelpers$1.canvas.clipArea(chart.ctx,
    {\r\n\t\t\t\tleft: clip.left === false ? 0 : area.left - clip.left,\r\n\t\t\t\tright:
    clip.right === false ? canvas.width : area.right + clip.right,\r\n\t\t\t\ttop:
    clip.top === false ? 0 : area.top - clip.top,\r\n\t\t\t\tbottom: clip.bottom ===
    false ? canvas.height : area.bottom + clip.bottom\r\n\t\t\t});\r\n\r\n\t\t\tmeta.dataset.draw();\r\n\r\n\t\t\thelpers$1.canvas.unclipArea(chart.ctx);\r\n\t\t}\r\n\r\n\t\t//
    Draw the points\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tpoints[i].draw(area);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model =
    point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor =
    helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor:
    model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor
    = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor
    = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth
    = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius
    = valueOrDefault$6(options.hoverRadius, options.radius);\r\n\t},\r\n});\n\nvar
    resolve$3 = helpers$1.options.resolve;\r\n\r\ncore_defaults._set('polarArea',
    {\r\n\tscale: {\r\n\t\ttype: 'radialLinear',\r\n\t\tangleLines: {\r\n\t\t\tdisplay:
    false\r\n\t\t},\r\n\t\tgridLines: {\r\n\t\t\tcircular: true\r\n\t\t},\r\n\t\tpointLabels:
    {\r\n\t\t\tdisplay: false\r\n\t\t},\r\n\t\tticks: {\r\n\t\t\tbeginAtZero: true\r\n\t\t}\r\n\t},\r\n\r\n\t//
    Boolean - Whether to animate the rotation of the chart\r\n\tanimation: {\r\n\t\tanimateRotate:
    true,\r\n\t\tanimateScale: true\r\n\t},\r\n\r\n\tstartAngle: -0.5 * Math.PI,\r\n\tlegendCallback:
    function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar data
    = chart.data;\r\n\t\tvar datasets = data.datasets;\r\n\t\tvar labels = data.labels;\r\n\t\tvar
    i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id
    + '-legend');\r\n\t\tif (datasets.length) {\r\n\t\t\tfor (i = 0, ilen = datasets[0].data.length;
    i < ilen; ++i) {\r\n\t\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\t\tlistItemSpan
    = listItem.appendChild(document.createElement('span'));\r\n\t\t\t\tlistItemSpan.style.backgroundColor
    = datasets[0].backgroundColor[i];\r\n\t\t\t\tif (labels[i]) {\r\n\t\t\t\t\tlistItem.appendChild(document.createTextNode(labels[i]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    list.outerHTML;\r\n\t},\r\n\tlegend: {\r\n\t\tlabels: {\r\n\t\t\tgenerateLabels:
    function(chart) {\r\n\t\t\t\tvar data = chart.data;\r\n\t\t\t\tif (data.labels.length
    && data.datasets.length) {\r\n\t\t\t\t\treturn data.labels.map(function(label,
    i) {\r\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\r\n\t\t\t\t\t\tvar style
    = meta.controller.getStyle(i);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttext:
    label,\r\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\t\tstrokeStyle:
    style.borderColor,\r\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\t\thidden:
    isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\r\n\r\n\t\t\t\t\t\t\t//
    Extra data used for toggling the correct item\r\n\t\t\t\t\t\t\tindex: i\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn
    [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar
    index = legendItem.index;\r\n\t\t\tvar chart = this.chart;\r\n\t\t\tvar i, ilen,
    meta;\r\n\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i <
    ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tmeta.data[index].hidden
    = !meta.data[index].hidden;\r\n\t\t\t}\r\n\r\n\t\t\tchart.update();\r\n\t\t}\r\n\t},\r\n\r\n\t//
    Need to override these to give a nice default\r\n\ttooltips: {\r\n\t\tcallbacks:
    {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel:
    function(item, data) {\r\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    controller_polarArea = core_datasetController.extend({\r\n\r\n\tdataElementType:
    elements.Arc,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'borderAlign',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t],\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\tupdate:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar start = me.chart.options.startAngle || 0;\r\n\t\tvar
    starts = me._starts = [];\r\n\t\tvar angles = me._angles = [];\r\n\t\tvar arcs
    = meta.data;\r\n\t\tvar i, ilen, angle;\r\n\r\n\t\tme._updateRadius();\r\n\r\n\t\tmeta.count
    = me.countVisibleElements();\r\n\r\n\t\tfor (i = 0, ilen = dataset.data.length;
    i < ilen; i++) {\r\n\t\t\tstarts[i] = start;\r\n\t\t\tangle = me._computeAngle(i);\r\n\t\t\tangles[i]
    = angle;\r\n\t\t\tstart += angle;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length;
    i < ilen; ++i) {\r\n\t\t\tarcs[i]._options = me._resolveDataElementOptions(arcs[i],
    i);\r\n\t\t\tme.updateElement(arcs[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_updateRadius: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar
    minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n\r\n\t\tchart.outerRadius
    = Math.max(minSize / 2, 0);\r\n\t\tchart.innerRadius = Math.max(opts.cutoutPercentage
    ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n\t\tchart.radiusLength
    = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\r\n\r\n\t\tme.outerRadius
    = chart.outerRadius - (chart.radiusLength * me.index);\r\n\t\tme.innerRadius =
    me.outerRadius - chart.radiusLength;\r\n\t},\r\n\r\n\tupdateElement: function(arc,
    index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar opts = chart.options;\r\n\t\tvar animationOpts
    = opts.animation;\r\n\t\tvar scale = chart.scale;\r\n\t\tvar labels = chart.data.labels;\r\n\r\n\t\tvar
    centerX = scale.xCenter;\r\n\t\tvar centerY = scale.yCenter;\r\n\r\n\t\t// var
    negHalfPI = -0.5 * Math.PI;\r\n\t\tvar datasetStartAngle = opts.startAngle;\r\n\t\tvar
    distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\t\tvar
    startAngle = me._starts[index];\r\n\t\tvar endAngle = startAngle + (arc.hidden
    ? 0 : me._angles[index]);\r\n\r\n\t\tvar resetRadius = animationOpts.animateScale
    ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\t\tvar options
    = arc._options || {};\r\n\r\n\t\thelpers$1.extend(arc, {\r\n\t\t\t// Utility\r\n\t\t\t_datasetIndex:
    me.index,\r\n\t\t\t_index: index,\r\n\t\t\t_scale: scale,\r\n\r\n\t\t\t// Desired
    view properties\r\n\t\t\t_model: {\r\n\t\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\t\tborderColor:
    options.borderColor,\r\n\t\t\t\tborderWidth: options.borderWidth,\r\n\t\t\t\tborderAlign:
    options.borderAlign,\r\n\t\t\t\tx: centerX,\r\n\t\t\t\ty: centerY,\r\n\t\t\t\tinnerRadius:
    0,\r\n\t\t\t\touterRadius: reset ? resetRadius : distance,\r\n\t\t\t\tstartAngle:
    reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\r\n\t\t\t\tendAngle:
    reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\r\n\t\t\t\tlabel:
    helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tarc.pivot();\r\n\t},\r\n\r\n\tcountVisibleElements:
    function() {\r\n\t\tvar dataset = this.getDataset();\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar
    count = 0;\r\n\r\n\t\thelpers$1.each(meta.data, function(element, index) {\r\n\t\t\tif
    (!isNaN(dataset.data[index]) && !element.hidden) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn
    count;\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tsetHoverStyle: function(arc)
    {\r\n\t\tvar model = arc._model;\r\n\t\tvar options = arc._options;\r\n\t\tvar
    getHoverColor = helpers$1.getHoverColor;\r\n\t\tvar valueOrDefault = helpers$1.valueOrDefault;\r\n\r\n\t\tarc.$previousStyle
    = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault(options.hoverBackgroundColor,
    getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault(options.hoverBorderColor,
    getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault(options.hoverBorderWidth,
    options.borderWidth);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeAngle:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar count = this.getMeta().count;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar meta = me.getMeta();\r\n\r\n\t\tif (isNaN(dataset.data[index])
    || meta.data[index].hidden) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Scriptable
    options\r\n\t\tvar context = {\r\n\t\t\tchart: me.chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset:
    dataset,\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\treturn resolve$3([\r\n\t\t\tme.chart.options.elements.arc.angle,\r\n\t\t\t(2
    * Math.PI) / count\r\n\t\t], context, index);\r\n\t}\r\n});\n\ncore_defaults._set('pie',
    helpers$1.clone(core_defaults.doughnut));\r\ncore_defaults._set('pie', {\r\n\tcutoutPercentage:
    0\r\n});\r\n\r\n// Pie charts are Doughnut chart with different defaults\r\nvar
    controller_pie = controller_doughnut;\n\nvar valueOrDefault$7 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('radar',
    {\r\n\tspanGaps: false,\r\n\tscale: {\r\n\t\ttype: 'radialLinear'\r\n\t},\r\n\telements:
    {\r\n\t\tline: {\r\n\t\t\tfill: 'start',\r\n\t\t\ttension: 0 // no bezier in radar\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    controller_radar = core_datasetController.extend({\r\n\tdatasetElementType: elements.Line,\r\n\r\n\tdataElementType:
    elements.Point,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderWidth',\r\n\t\t'borderColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'fill'\r\n\t],\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: {\r\n\t\tbackgroundColor: 'pointBackgroundColor',\r\n\t\tborderColor:
    'pointBorderColor',\r\n\t\tborderWidth: 'pointBorderWidth',\r\n\t\thitRadius:
    'pointHitRadius',\r\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\r\n\t\thoverBorderColor:
    'pointHoverBorderColor',\r\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\r\n\t\thoverRadius:
    'pointHoverRadius',\r\n\t\tpointStyle: 'pointStyle',\r\n\t\tradius: 'pointRadius',\r\n\t\trotation:
    'pointRotation'\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScaleId:
    function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\tupdate:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    line = meta.dataset;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar scale = me.chart.scale;\r\n\t\tvar
    config = me._config;\r\n\t\tvar i, ilen;\r\n\r\n\t\t// Compatibility: If the properties
    are defined with only the old name, use those values\r\n\t\tif (config.tension
    !== undefined && config.lineTension === undefined) {\r\n\t\t\tconfig.lineTension
    = config.tension;\r\n\t\t}\r\n\r\n\t\t// Utility\r\n\t\tline._scale = scale;\r\n\t\tline._datasetIndex
    = me.index;\r\n\t\t// Data\r\n\t\tline._children = points;\r\n\t\tline._loop =
    true;\r\n\t\t// Model\r\n\t\tline._model = me._resolveDatasetElementOptions(line);\r\n\r\n\t\tline.pivot();\r\n\r\n\t\t//
    Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i],
    i, reset);\r\n\t\t}\r\n\r\n\t\t// Update bezier control points\r\n\t\tme.updateBezierControlPoints();\r\n\r\n\t\t//
    Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i <
    ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar custom = point.custom
    || {};\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar scale = me.chart.scale;\r\n\t\tvar
    pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\r\n\t\tvar
    options = me._resolveDataElementOptions(point, index);\r\n\t\tvar lineModel =
    me.getMeta().dataset._model;\r\n\t\tvar x = reset ? scale.xCenter : pointPosition.x;\r\n\t\tvar
    y = reset ? scale.yCenter : pointPosition.y;\r\n\r\n\t\t// Utility\r\n\t\tpoint._scale
    = scale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex = me.index;\r\n\t\tpoint._index
    = index;\r\n\r\n\t\t// Desired view properties\r\n\t\tpoint._model = {\r\n\t\t\tx:
    x, // value not used in dataset scale, but we want a consistent API between scales\r\n\t\t\ty:
    y,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\t// Appearance\r\n\t\t\tradius:
    options.radius,\r\n\t\t\tpointStyle: options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tbackgroundColor:
    options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\ttension: valueOrDefault$7(custom.tension, lineModel
    ? lineModel.tension : 0),\r\n\r\n\t\t\t// Tooltip\r\n\t\t\thitRadius: options.hitRadius\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar config = me._config;\r\n\t\tvar options = me.chart.options;\r\n\t\tvar
    values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me,
    arguments);\r\n\r\n\t\tvalues.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);\r\n\t\tvalues.tension
    = valueOrDefault$7(config.lineTension, options.elements.line.tension);\r\n\r\n\t\treturn
    values;\r\n\t},\r\n\r\n\tupdateBezierControlPoints: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar
    points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\t//
    Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif
    (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt)
    {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction
    capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor
    (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints
    = helpers$1.splineCurve(\r\n\t\t\t\thelpers$1.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers$1.nextItem(points,
    i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent
    the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX
    = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY
    = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX
    = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY
    = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r\n\r\n\tsetHoverStyle:
    function(point) {\r\n\t\tvar model = point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar
    getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor:
    model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor
    = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor
    = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth
    = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius
    = valueOrDefault$7(options.hoverRadius, options.radius);\r\n\t}\r\n});\n\ncore_defaults._set('scatter',
    {\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes:
    [{\r\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\r\n\t\t\ttype:
    'linear',    // scatter should not use a category axis\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\t\tyAxes:
    [{\r\n\t\t\tid: 'y-axis-1',\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'left'\r\n\t\t}]\r\n\t},\r\n\r\n\ttooltips:
    {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';     //
    doesn't make sense for scatter since data are formatted as a point\r\n\t\t\t},\r\n\t\t\tlabel:
    function(item) {\r\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global',
    {\r\n\tdatasets: {\r\n\t\tscatter: {\r\n\t\t\tshowLine: false\r\n\t\t}\r\n\t}\r\n});\r\n\r\n//
    Scatter charts use line controllers\r\nvar controller_scatter = controller_line;\n\n//
    NOTE export a map in which the key represents the controller type, not\r\n// the
    class, and so must be CamelCase in order to be correctly retrieved\r\n// by the
    controller in core.controller.js (`controllers[meta.type]`).\r\n\r\nvar controllers
    = {\r\n\tbar: controller_bar,\r\n\tbubble: controller_bubble,\r\n\tdoughnut: controller_doughnut,\r\n\thorizontalBar:
    controller_horizontalBar,\r\n\tline: controller_line,\r\n\tpolarArea: controller_polarArea,\r\n\tpie:
    controller_pie,\r\n\tradar: controller_radar,\r\n\tscatter: controller_scatter\r\n};\n\n/**\r\n
    * Helper function to get relative position for an event\r\n * @param {Event|IEvent}
    event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n
    * @returns {object} the event position\r\n */\r\nfunction getRelativePosition(e,
    chart) {\r\n\tif (e.native) {\r\n\t\treturn {\r\n\t\t\tx: e.x,\r\n\t\t\ty: e.y\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    helpers$1.getRelativePosition(e, chart);\r\n}\r\n\r\n/**\r\n * Helper function
    to traverse all of the visible elements in the chart\r\n * @param {Chart} chart
    - the chart\r\n * @param {function} handler - the callback to execute for each
    visible item\r\n */\r\nfunction parseVisibleItems(chart, handler) {\r\n\tvar metasets
    = chart._getSortedVisibleDatasetMetas();\r\n\tvar metadata, i, j, ilen, jlen,
    element;\r\n\r\n\tfor (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n\t\tmetadata
    = metasets[i].data;\r\n\t\tfor (j = 0, jlen = metadata.length; j < jlen; ++j)
    {\r\n\t\t\telement = metadata[j];\r\n\t\t\tif (!element._view.skip) {\r\n\t\t\t\thandler(element);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n
    * Helper function to get the items that intersect the event position\r\n * @param
    {ChartElement[]} items - elements to filter\r\n * @param {object} position - the
    point to be nearest to\r\n * @return {ChartElement[]} the nearest items\r\n */\r\nfunction
    getIntersectItems(chart, position) {\r\n\tvar elements = [];\r\n\r\n\tparseVisibleItems(chart,
    function(element) {\r\n\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn
    elements;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the
    event position considering all visible items in teh chart\r\n * @param {Chart}
    chart - the chart to look at elements from\r\n * @param {object} position - the
    point to be nearest to\r\n * @param {boolean} intersect - if true, only consider
    items that intersect the position\r\n * @param {function} distanceMetric - function
    to provide the distance between points\r\n * @return {ChartElement[]} the nearest
    items\r\n */\r\nfunction getNearestItems(chart, position, intersect, distanceMetric)
    {\r\n\tvar minDistance = Number.POSITIVE_INFINITY;\r\n\tvar nearestItems = [];\r\n\r\n\tparseVisibleItems(chart,
    function(element) {\r\n\t\tif (intersect && !element.inRange(position.x, position.y))
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar center = element.getCenterPoint();\r\n\t\tvar
    distance = distanceMetric(position, center);\r\n\t\tif (distance < minDistance)
    {\r\n\t\t\tnearestItems = [element];\r\n\t\t\tminDistance = distance;\r\n\t\t}
    else if (distance === minDistance) {\r\n\t\t\t// Can have multiple items at the
    same distance in which case we sort by size\r\n\t\t\tnearestItems.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn
    nearestItems;\r\n}\r\n\r\n/**\r\n * Get a distance metric function for two points
    based on the\r\n * axis mode setting\r\n * @param {string} axis - the axis mode.
    x|y|xy\r\n */\r\nfunction getDistanceMetricForAxis(axis) {\r\n\tvar useX = axis.indexOf('x')
    !== -1;\r\n\tvar useY = axis.indexOf('y') !== -1;\r\n\r\n\treturn function(pt1,
    pt2) {\r\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n\t\tvar deltaY
    = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n\t\treturn Math.sqrt(Math.pow(deltaX,
    2) + Math.pow(deltaY, 2));\r\n\t};\r\n}\r\n\r\nfunction indexMode(chart, e, options)
    {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for
    index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar
    distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect
    ? getIntersectItems(chart, position) : getNearestItems(chart, position, false,
    distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn
    [];\r\n\t}\r\n\r\n\tchart._getSortedVisibleDatasetMetas().forEach(function(meta)
    {\r\n\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t// don't count items
    that are skipped (null data)\r\n\t\tif (element && !element._view.skip) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn
    elements;\r\n}\r\n\r\n/**\r\n * @interface IInteractionOptions\r\n */\r\n/**\r\n
    * If true, only consider items that intersect the point\r\n * @name IInterfaceOptions#boolean\r\n
    * @type Boolean\r\n */\r\n\r\n/**\r\n * Contains interaction related functions\r\n
    * @namespace Chart.Interaction\r\n */\r\nvar core_interaction = {\r\n\t// Helper
    function for different modes\r\n\tmodes: {\r\n\t\tsingle: function(chart, e) {\r\n\t\t\tvar
    position = getRelativePosition(e, chart);\r\n\t\t\tvar elements = [];\r\n\r\n\t\t\tparseVisibleItems(chart,
    function(element) {\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\telements.push(element);\r\n\t\t\t\t\treturn
    elements;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn elements.slice(0, 1);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * @function Chart.Interaction.modes.label\r\n\t\t * @deprecated since version
    2.4.0\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\tlabel:
    indexMode,\r\n\r\n\t\t/**\r\n\t\t * Returns items at the same index. If the options.intersect
    parameter is true, we only return items if we intersect something\r\n\t\t * If
    the options.intersect mode is false, we find the nearest item and return the items
    at the same index as that item\r\n\t\t * @function Chart.Interaction.modes.index\r\n\t\t
    * @since v2.4.0\r\n\t\t * @param {Chart} chart - the chart we are returning items
    from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param
    {IInteractionOptions} options - options to use during interaction\r\n\t\t * @return
    {Chart.Element[]} Array of elements that are under the point. If none are found,
    an empty array is returned\r\n\t\t */\r\n\t\tindex: indexMode,\r\n\r\n\t\t/**\r\n\t\t
    * Returns items in the same dataset. If the options.intersect parameter is true,
    we only return items if we intersect something\r\n\t\t * If the options.intersect
    is false, we find the nearest item and return the items in that dataset\r\n\t\t
    * @function Chart.Interaction.modes.dataset\r\n\t\t * @param {Chart} chart - the
    chart we are returning items from\r\n\t\t * @param {Event} e - the event we are
    find things at\r\n\t\t * @param {IInteractionOptions} options - options to use
    during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that
    are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tdataset:
    function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis
    = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar
    items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart,
    position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems
    = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn
    items;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @function Chart.Interaction.modes.x-axis\r\n\t\t
    * @deprecated since version 2.4.0. Use index mode and intersect == true\r\n\t\t
    * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\t'x-axis': function(chart,
    e) {\r\n\t\t\treturn indexMode(chart, e, {intersect: false});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * Point mode returns all elements that hit test based on the event position\r\n\t\t
    * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t *
    @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param
    {Event} e - the event we are find things at\r\n\t\t * @return {Chart.Element[]}
    Array of elements that are under the point. If none are found, an empty array
    is returned\r\n\t\t */\r\n\t\tpoint: function(chart, e) {\r\n\t\t\tvar position
    = getRelativePosition(e, chart);\r\n\t\t\treturn getIntersectItems(chart, position);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t
    * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param
    {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions}
    options - options to use\r\n\t\t * @return {Chart.Element[]} Array of elements
    that are under the point. If none are found, an empty array is returned\r\n\t\t
    */\r\n\t\tnearest: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e,
    chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric
    = getDistanceMetricForAxis(options.axis);\r\n\t\t\treturn getNearestItems(chart,
    position, options.intersect, distanceMetric);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * x mode returns the elements that hit-test at the current x coordinate\r\n\t\t
    * @function Chart.Interaction.modes.x\r\n\t\t * @param {Chart} chart - the chart
    we are returning items from\r\n\t\t * @param {Event} e - the event we are find
    things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t
    * @return {Chart.Element[]} Array of elements that are under the point. If none
    are found, an empty array is returned\r\n\t\t */\r\n\t\tx: function(chart, e,
    options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar
    items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart,
    function(element) {\r\n\t\t\t\tif (element.inXRange(position.x)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif
    (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t//
    If we want to trigger on an intersect and we don't have any items\r\n\t\t\t//
    that intersect the position, return nothing\r\n\t\t\tif (options.intersect &&
    !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * y mode returns the elements that hit-test at the current y coordinate\r\n\t\t
    * @function Chart.Interaction.modes.y\r\n\t\t * @param {Chart} chart - the chart
    we are returning items from\r\n\t\t * @param {Event} e - the event we are find
    things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t
    * @return {Chart.Element[]} Array of elements that are under the point. If none
    are found, an empty array is returned\r\n\t\t */\r\n\t\ty: function(chart, e,
    options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar
    items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart,
    function(element) {\r\n\t\t\t\tif (element.inYRange(position.y)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif
    (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t//
    If we want to trigger on an intersect and we don't have any items\r\n\t\t\t//
    that intersect the position, return nothing\r\n\t\t\tif (options.intersect &&
    !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t}\r\n\t}\r\n};\n\nvar
    extend = helpers$1.extend;\r\n\r\nfunction filterByPosition(array, position) {\r\n\treturn
    helpers$1.where(array, function(v) {\r\n\t\treturn v.pos === position;\r\n\t});\r\n}\r\n\r\nfunction
    sortByWeight(array, reverse) {\r\n\treturn array.sort(function(a, b) {\r\n\t\tvar
    v0 = reverse ? b : a;\r\n\t\tvar v1 = reverse ? a : b;\r\n\t\treturn v0.weight
    === v1.weight ?\r\n\t\t\tv0.index - v1.index :\r\n\t\t\tv0.weight - v1.weight;\r\n\t});\r\n}\r\n\r\nfunction
    wrapBoxes(boxes) {\r\n\tvar layoutBoxes = [];\r\n\tvar i, ilen, box;\r\n\r\n\tfor
    (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n\t\tbox = boxes[i];\r\n\t\tlayoutBoxes.push({\r\n\t\t\tindex:
    i,\r\n\t\t\tbox: box,\r\n\t\t\tpos: box.position,\r\n\t\t\thorizontal: box.isHorizontal(),\r\n\t\t\tweight:
    box.weight\r\n\t\t});\r\n\t}\r\n\treturn layoutBoxes;\r\n}\r\n\r\nfunction setLayoutDims(layouts,
    params) {\r\n\tvar i, ilen, layout;\r\n\tfor (i = 0, ilen = layouts.length; i
    < ilen; ++i) {\r\n\t\tlayout = layouts[i];\r\n\t\t// store width used instead
    of chartArea.w in fitBoxes\r\n\t\tlayout.width = layout.horizontal\r\n\t\t\t?
    layout.box.fullWidth && params.availableWidth\r\n\t\t\t: params.vBoxMaxWidth;\r\n\t\t//
    store height used instead of chartArea.h in fitBoxes\r\n\t\tlayout.height = layout.horizontal
    && params.hBoxMaxHeight;\r\n\t}\r\n}\r\n\r\nfunction buildLayoutBoxes(boxes) {\r\n\tvar
    layoutBoxes = wrapBoxes(boxes);\r\n\tvar left = sortByWeight(filterByPosition(layoutBoxes,
    'left'), true);\r\n\tvar right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n\tvar
    top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n\tvar bottom
    = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n\r\n\treturn {\r\n\t\tleftAndTop:
    left.concat(top),\r\n\t\trightAndBottom: right.concat(bottom),\r\n\t\tchartArea:
    filterByPosition(layoutBoxes, 'chartArea'),\r\n\t\tvertical: left.concat(right),\r\n\t\thorizontal:
    top.concat(bottom)\r\n\t};\r\n}\r\n\r\nfunction getCombinedMax(maxPadding, chartArea,
    a, b) {\r\n\treturn Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b],
    chartArea[b]);\r\n}\r\n\r\nfunction updateDims(chartArea, params, layout) {\r\n\tvar
    box = layout.box;\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\tvar newWidth,
    newHeight;\r\n\r\n\tif (layout.size) {\r\n\t\t// this layout was already counted
    for, lets first reduce old size\r\n\t\tchartArea[layout.pos] -= layout.size;\r\n\t}\r\n\tlayout.size
    = layout.horizontal ? box.height : box.width;\r\n\tchartArea[layout.pos] += layout.size;\r\n\r\n\tif
    (box.getPadding) {\r\n\t\tvar boxPadding = box.getPadding();\r\n\t\tmaxPadding.top
    = Math.max(maxPadding.top, boxPadding.top);\r\n\t\tmaxPadding.left = Math.max(maxPadding.left,
    boxPadding.left);\r\n\t\tmaxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n\t\tmaxPadding.right
    = Math.max(maxPadding.right, boxPadding.right);\r\n\t}\r\n\r\n\tnewWidth = params.outerWidth
    - getCombinedMax(maxPadding, chartArea, 'left', 'right');\r\n\tnewHeight = params.outerHeight
    - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');\r\n\r\n\tif (newWidth
    !== chartArea.w || newHeight !== chartArea.h) {\r\n\t\tchartArea.w = newWidth;\r\n\t\tchartArea.h
    = newHeight;\r\n\r\n\t\t// return true if chart area changed in layout's direction\r\n\t\tvar
    sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];\r\n\t\treturn
    sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));\r\n\t}\r\n}\r\n\r\nfunction
    handleMaxPadding(chartArea) {\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\r\n\tfunction
    updatePos(pos) {\r\n\t\tvar change = Math.max(maxPadding[pos] - chartArea[pos],
    0);\r\n\t\tchartArea[pos] += change;\r\n\t\treturn change;\r\n\t}\r\n\tchartArea.y
    += updatePos('top');\r\n\tchartArea.x += updatePos('left');\r\n\tupdatePos('right');\r\n\tupdatePos('bottom');\r\n}\r\n\r\nfunction
    getMargins(horizontal, chartArea) {\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\r\n\tfunction
    marginForPositions(positions) {\r\n\t\tvar margin = {left: 0, top: 0, right: 0,
    bottom: 0};\r\n\t\tpositions.forEach(function(pos) {\r\n\t\t\tmargin[pos] = Math.max(chartArea[pos],
    maxPadding[pos]);\r\n\t\t});\r\n\t\treturn margin;\r\n\t}\r\n\r\n\treturn horizontal\r\n\t\t?
    marginForPositions(['left', 'right'])\r\n\t\t: marginForPositions(['top', 'bottom']);\r\n}\r\n\r\nfunction
    fitBoxes(boxes, chartArea, params) {\r\n\tvar refitBoxes = [];\r\n\tvar i, ilen,
    layout, box, refit, changed;\r\n\r\n\tfor (i = 0, ilen = boxes.length; i < ilen;
    ++i) {\r\n\t\tlayout = boxes[i];\r\n\t\tbox = layout.box;\r\n\r\n\t\tbox.update(\r\n\t\t\tlayout.width
    || chartArea.w,\r\n\t\t\tlayout.height || chartArea.h,\r\n\t\t\tgetMargins(layout.horizontal,
    chartArea)\r\n\t\t);\r\n\t\tif (updateDims(chartArea, params, layout)) {\r\n\t\t\tchanged
    = true;\r\n\t\t\tif (refitBoxes.length) {\r\n\t\t\t\t// Dimensions changed and
    there were non full width boxes before this\r\n\t\t\t\t// -> we have to refit
    those\r\n\t\t\t\trefit = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!box.fullWidth)
    { // fullWidth boxes don't need to be re-fitted in any case\r\n\t\t\trefitBoxes.push(layout);\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;\r\n}\r\n\r\nfunction
    placeBoxes(boxes, chartArea, params) {\r\n\tvar userPadding = params.padding;\r\n\tvar
    x = chartArea.x;\r\n\tvar y = chartArea.y;\r\n\tvar i, ilen, layout, box;\r\n\r\n\tfor
    (i = 0, ilen = boxes.length; i < ilen; ++i) {\r\n\t\tlayout = boxes[i];\r\n\t\tbox
    = layout.box;\r\n\t\tif (layout.horizontal) {\r\n\t\t\tbox.left = box.fullWidth
    ? userPadding.left : chartArea.left;\r\n\t\t\tbox.right = box.fullWidth ? params.outerWidth
    - userPadding.right : chartArea.left + chartArea.w;\r\n\t\t\tbox.top = y;\r\n\t\t\tbox.bottom
    = y + box.height;\r\n\t\t\tbox.width = box.right - box.left;\r\n\t\t\ty = box.bottom;\r\n\t\t}
    else {\r\n\t\t\tbox.left = x;\r\n\t\t\tbox.right = x + box.width;\r\n\t\t\tbox.top
    = chartArea.top;\r\n\t\t\tbox.bottom = chartArea.top + chartArea.h;\r\n\t\t\tbox.height
    = box.bottom - box.top;\r\n\t\t\tx = box.right;\r\n\t\t}\r\n\t}\r\n\r\n\tchartArea.x
    = x;\r\n\tchartArea.y = y;\r\n}\r\n\r\ncore_defaults._set('global', {\r\n\tlayout:
    {\r\n\t\tpadding: {\r\n\t\t\ttop: 0,\r\n\t\t\tright: 0,\r\n\t\t\tbottom: 0,\r\n\t\t\tleft:
    0\r\n\t\t}\r\n\t}\r\n});\r\n\r\n/**\r\n * @interface ILayoutItem\r\n * @prop {string}
    position - The position of the item in the chart layout. Possible values are\r\n
    * 'left', 'top', 'right', 'bottom', and 'chartArea'\r\n * @prop {number} weight
    - The weight used to sort the item. Higher weights are further away from the chart
    area\r\n * @prop {boolean} fullWidth - if true, and the item is horizontal, then
    push vertical boxes down\r\n * @prop {function} isHorizontal - returns true if
    the layout item is horizontal (ie. top or bottom)\r\n * @prop {function} update
    - Takes two parameters: width and height. Returns size of item\r\n * @prop {function}
    getPadding -  Returns an object with padding on the edges\r\n * @prop {number}
    width - Width of item. Must be valid after update()\r\n * @prop {number} height
    - Height of item. Must be valid after update()\r\n * @prop {number} left - Left
    edge of the item. Set by layout system and cannot be used in update\r\n * @prop
    {number} top - Top edge of the item. Set by layout system and cannot be used in
    update\r\n * @prop {number} right - Right edge of the item. Set by layout system
    and cannot be used in update\r\n * @prop {number} bottom - Bottom edge of the
    item. Set by layout system and cannot be used in update\r\n */\r\n\r\n// The layout
    service is very self explanatory.  It's responsible for the layout within a chart.\r\n//
    Scales, Legends and Plugins all rely on the layout service and can easily register
    to be placed anywhere they need\r\n// It is this service's responsibility of carrying
    out that layout.\r\nvar core_layouts = {\r\n\tdefaults: {},\r\n\r\n\t/**\r\n\t
    * Register a box to a chart.\r\n\t * A box is simply a reference to an object
    that requires layout. eg. Scales, Legend, Title.\r\n\t * @param {Chart} chart
    - the chart to use\r\n\t * @param {ILayoutItem} item - the item to add to be layed
    out\r\n\t */\r\n\taddBox: function(chart, item) {\r\n\t\tif (!chart.boxes) {\r\n\t\t\tchart.boxes
    = [];\r\n\t\t}\r\n\r\n\t\t// initialize item with default values\r\n\t\titem.fullWidth
    = item.fullWidth || false;\r\n\t\titem.position = item.position || 'top';\r\n\t\titem.weight
    = item.weight || 0;\r\n\t\titem._layers = item._layers || function() {\r\n\t\t\treturn
    [{\r\n\t\t\t\tz: 0,\r\n\t\t\t\tdraw: function() {\r\n\t\t\t\t\titem.draw.apply(item,
    arguments);\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t};\r\n\r\n\t\tchart.boxes.push(item);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Remove a layoutItem from a chart\r\n\t * @param {Chart} chart - the chart to
    remove the box from\r\n\t * @param {ILayoutItem} layoutItem - the item to remove
    from the layout\r\n\t */\r\n\tremoveBox: function(chart, layoutItem) {\r\n\t\tvar
    index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n\t\tif (index !==
    -1) {\r\n\t\t\tchart.boxes.splice(index, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Sets (or updates) options on the given `item`.\r\n\t * @param {Chart} chart
    - the chart in which the item lives (or will be added to)\r\n\t * @param {ILayoutItem}
    item - the item to configure with the given options\r\n\t * @param {object} options
    - the new item options.\r\n\t */\r\n\tconfigure: function(chart, item, options)
    {\r\n\t\tvar props = ['fullWidth', 'position', 'weight'];\r\n\t\tvar ilen = props.length;\r\n\t\tvar
    i = 0;\r\n\t\tvar prop;\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tprop = props[i];\r\n\t\t\tif
    (options.hasOwnProperty(prop)) {\r\n\t\t\t\titem[prop] = options[prop];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Fits boxes of the given chart into the given size by having each box measure
    itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart -
    the chart\r\n\t * @param {number} width - the width to fit into\r\n\t * @param
    {number} height - the height to fit into\r\n\t */\r\n\tupdate: function(chart,
    width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar
    layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers$1.options.toPadding(layoutOptions.padding);\r\n\r\n\t\tvar
    availableWidth = width - padding.width;\r\n\t\tvar availableHeight = height -
    padding.height;\r\n\t\tvar boxes = buildLayoutBoxes(chart.boxes);\r\n\t\tvar verticalBoxes
    = boxes.vertical;\r\n\t\tvar horizontalBoxes = boxes.horizontal;\r\n\r\n\t\t//
    Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t//
    Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left
    axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom
    axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead
    of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box
    locations only, when trying to register a chartArea location that is already taken,\r\n\t\t//
    an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t//
    |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//
    |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t//
    |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|
    \                          |----|    |\r\n\t\t// |    |    |                                     |
    \   |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t//
    |    |    |                                     |    |\r\n\t\t// |    |    |----|
    \                          |----|    |\r\n\t\t// |    |    | C3 |                           |
    C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t//
    |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//
    |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\r\n\t\tvar
    params = Object.freeze({\r\n\t\t\touterWidth: width,\r\n\t\t\touterHeight: height,\r\n\t\t\tpadding:
    padding,\r\n\t\t\tavailableWidth: availableWidth,\r\n\t\t\tvBoxMaxWidth: availableWidth
    / 2 / verticalBoxes.length,\r\n\t\t\thBoxMaxHeight: availableHeight / 2\r\n\t\t});\r\n\t\tvar
    chartArea = extend({\r\n\t\t\tmaxPadding: extend({}, padding),\r\n\t\t\tw: availableWidth,\r\n\t\t\th:
    availableHeight,\r\n\t\t\tx: padding.left,\r\n\t\t\ty: padding.top\r\n\t\t}, padding);\r\n\r\n\t\tsetLayoutDims(verticalBoxes.concat(horizontalBoxes),
    params);\r\n\r\n\t\t// First fit vertical boxes\r\n\t\tfitBoxes(verticalBoxes,
    chartArea, params);\r\n\r\n\t\t// Then fit horizontal boxes\r\n\t\tif (fitBoxes(horizontalBoxes,
    chartArea, params)) {\r\n\t\t\t// if the area changed, re-fit vertical boxes\r\n\t\t\tfitBoxes(verticalBoxes,
    chartArea, params);\r\n\t\t}\r\n\r\n\t\thandleMaxPadding(chartArea);\r\n\r\n\t\t//
    Finally place the boxes to correct coordinates\r\n\t\tplaceBoxes(boxes.leftAndTop,
    chartArea, params);\r\n\r\n\t\t// Move to opposite side of chart\r\n\t\tchartArea.x
    += chartArea.w;\r\n\t\tchartArea.y += chartArea.h;\r\n\r\n\t\tplaceBoxes(boxes.rightAndBottom,
    chartArea, params);\r\n\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: chartArea.left,\r\n\t\t\ttop:
    chartArea.top,\r\n\t\t\tright: chartArea.left + chartArea.w,\r\n\t\t\tbottom:
    chartArea.top + chartArea.h\r\n\t\t};\r\n\r\n\t\t// Finally update boxes in chartArea
    (radial scale for example)\r\n\t\thelpers$1.each(boxes.chartArea, function(layout)
    {\r\n\t\t\tvar box = layout.box;\r\n\t\t\textend(box, chart.chartArea);\r\n\t\t\tbox.update(chartArea.w,
    chartArea.h);\r\n\t\t});\r\n\t}\r\n};\n\n/**\r\n * Platform fallback implementation
    (minimal).\r\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\r\n
    */\r\n\r\nvar platform_basic = {\r\n\tacquireContext: function(item) {\r\n\t\tif
    (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas
    (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\treturn
    item && item.getContext('2d') || null;\r\n\t}\r\n};\n\nvar platform_dom = \"/*\\r\\n
    * DOM element rendering detection\\r\\n * https://davidwalsh.name/detect-node-insertion\\r\\n
    */\\r\\n@keyframes chartjs-render-animation {\\r\\n\\tfrom { opacity: 0.99; }\\r\\n\\tto
    { opacity: 1; }\\r\\n}\\r\\n\\r\\n.chartjs-render-monitor {\\r\\n\\tanimation:
    chartjs-render-animation 0.001s;\\r\\n}\\r\\n\\r\\n/*\\r\\n * DOM element resizing
    detection\\r\\n * https://github.com/marcj/css-element-queries\\r\\n */\\r\\n.chartjs-size-monitor,\\r\\n.chartjs-size-monitor-expand,\\r\\n.chartjs-size-monitor-shrink
    {\\r\\n\\tposition: absolute;\\r\\n\\tdirection: ltr;\\r\\n\\tleft: 0;\\r\\n\\ttop:
    0;\\r\\n\\tright: 0;\\r\\n\\tbottom: 0;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events:
    none;\\r\\n\\tvisibility: hidden;\\r\\n\\tz-index: -1;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-expand
    > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 1000000px;\\r\\n\\theight:
    1000000px;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-shrink
    > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 200%;\\r\\n\\theight: 200%;\\r\\n\\tleft:
    0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\";\n\nvar platform_dom$1 = /*#__PURE__*/Object.freeze({\n__proto__:
    null,\n'default': platform_dom\n});\n\nvar stylesheet = getCjsExportFromNamespace(platform_dom$1);\n\nvar
    EXPANDO_KEY = '$chartjs';\r\nvar CSS_PREFIX = 'chartjs-';\r\nvar CSS_SIZE_MONITOR
    = CSS_PREFIX + 'size-monitor';\r\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\r\nvar
    CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\r\nvar ANIMATION_START_EVENTS
    = ['animationstart', 'webkitAnimationStart'];\r\n\r\n/**\r\n * DOM event types
    -> Chart.js event types.\r\n * Note: only events with different types are mapped.\r\n
    * @see https://developer.mozilla.org/en-US/docs/Web/Events\r\n */\r\nvar EVENT_TYPES
    = {\r\n\ttouchstart: 'mousedown',\r\n\ttouchmove: 'mousemove',\r\n\ttouchend:
    'mouseup',\r\n\tpointerenter: 'mouseenter',\r\n\tpointerdown: 'mousedown',\r\n\tpointermove:
    'mousemove',\r\n\tpointerup: 'mouseup',\r\n\tpointerleave: 'mouseout',\r\n\tpointerout:
    'mouseout'\r\n};\r\n\r\n/**\r\n * The \"used\" size is the final value of a dimension
    property after all calculations have\r\n * been performed. This method uses the
    computed style of `element` but returns undefined\r\n * if the computed style
    is not expressed in pixels. That can happen in some cases where\r\n * `element`
    has a size relative to its parent and this last one is not yet displayed,\r\n
    * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n
    * @returns {number} Size in pixels or undefined if unknown.\r\n */\r\nfunction
    readUsedSize(element, property) {\r\n\tvar value = helpers$1.getStyle(element,
    property);\r\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n\treturn
    matches ? Number(matches[1]) : undefined;\r\n}\r\n\r\n/**\r\n * Initializes the
    canvas style and render size without modifying the canvas display size,\r\n *
    since responsiveness is handled by the controller.resize() method. The config
    is used\r\n * to determine the aspect ratio to apply in case no explicit height
    has been specified.\r\n */\r\nfunction initCanvas(canvas, config) {\r\n\tvar style
    = canvas.style;\r\n\r\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width:
    in the first case it\r\n\t// returns null or '' if no explicit value has been
    set to the canvas attribute.\r\n\tvar renderHeight = canvas.getAttribute('height');\r\n\tvar
    renderWidth = canvas.getAttribute('width');\r\n\r\n\t// Chart.js modifies some
    canvas values that we want to restore on destroy\r\n\tcanvas[EXPANDO_KEY] = {\r\n\t\tinitial:
    {\r\n\t\t\theight: renderHeight,\r\n\t\t\twidth: renderWidth,\r\n\t\t\tstyle:
    {\r\n\t\t\t\tdisplay: style.display,\r\n\t\t\t\theight: style.height,\r\n\t\t\t\twidth:
    style.width\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Force canvas to display as
    block to avoid extra space caused by inline\r\n\t// elements, which would interfere
    with the responsive resize process.\r\n\t// https://github.com/chartjs/Chart.js/issues/2538\r\n\tstyle.display
    = style.display || 'block';\r\n\r\n\tif (renderWidth === null || renderWidth ===
    '') {\r\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\r\n\t\tif (displayWidth
    !== undefined) {\r\n\t\t\tcanvas.width = displayWidth;\r\n\t\t}\r\n\t}\r\n\r\n\tif
    (renderHeight === null || renderHeight === '') {\r\n\t\tif (canvas.style.height
    === '') {\r\n\t\t\t// If no explicit render height and style height, let's apply
    the aspect ratio,\r\n\t\t\t// which one can be specified by the user but also
    by charts as default option\r\n\t\t\t// (i.e. options.aspectRatio). If not specified,
    use canvas aspect ratio of 2.\r\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio
    || 2);\r\n\t\t} else {\r\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\r\n\t\t\tif
    (displayWidth !== undefined) {\r\n\t\t\t\tcanvas.height = displayHeight;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    canvas;\r\n}\r\n\r\n/**\r\n * Detects support for options object argument in addEventListener.\r\n
    * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n
    * @private\r\n */\r\nvar supportsEventListenerOptions = (function() {\r\n\tvar
    supports = false;\r\n\ttry {\r\n\t\tvar options = Object.defineProperty({}, 'passive',
    {\r\n\t\t\t// eslint-disable-next-line getter-return\r\n\t\t\tget: function()
    {\r\n\t\t\t\tsupports = true;\r\n\t\t\t}\r\n\t\t});\r\n\t\twindow.addEventListener('e',
    null, options);\r\n\t} catch (e) {\r\n\t\t// continue regardless of error\r\n\t}\r\n\treturn
    supports;\r\n}());\r\n\r\n// Default passive to true as expected by Chrome for
    'touchstart' and 'touchend' events.\r\n// https://github.com/chartjs/Chart.js/issues/4287\r\nvar
    eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n\r\nfunction
    addListener(node, type, listener) {\r\n\tnode.addEventListener(type, listener,
    eventListenerOptions);\r\n}\r\n\r\nfunction removeListener(node, type, listener)
    {\r\n\tnode.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction
    createEvent(type, chart, x, y, nativeEvent) {\r\n\treturn {\r\n\t\ttype: type,\r\n\t\tchart:
    chart,\r\n\t\tnative: nativeEvent || null,\r\n\t\tx: x !== undefined ? x : null,\r\n\t\ty:
    y !== undefined ? y : null,\r\n\t};\r\n}\r\n\r\nfunction fromNativeEvent(event,
    chart) {\r\n\tvar type = EVENT_TYPES[event.type] || event.type;\r\n\tvar pos =
    helpers$1.getRelativePosition(event, chart);\r\n\treturn createEvent(type, chart,
    pos.x, pos.y, event);\r\n}\r\n\r\nfunction throttled(fn, thisArg) {\r\n\tvar ticking
    = false;\r\n\tvar args = [];\r\n\r\n\treturn function() {\r\n\t\targs = Array.prototype.slice.call(arguments);\r\n\t\tthisArg
    = thisArg || this;\r\n\r\n\t\tif (!ticking) {\r\n\t\t\tticking = true;\r\n\t\t\thelpers$1.requestAnimFrame.call(window,
    function() {\r\n\t\t\t\tticking = false;\r\n\t\t\t\tfn.apply(thisArg, args);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction
    createDiv(cls) {\r\n\tvar el = document.createElement('div');\r\n\tel.className
    = cls || '';\r\n\treturn el;\r\n}\r\n\r\n// Implementation based on https://github.com/marcj/css-element-queries\r\nfunction
    createResizer(handler) {\r\n\tvar maxSize = 1000000;\r\n\r\n\t// NOTE(SB) Don't
    use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar
    resizer = createDiv(CSS_SIZE_MONITOR);\r\n\tvar expand = createDiv(CSS_SIZE_MONITOR
    + '-expand');\r\n\tvar shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\r\n\r\n\texpand.appendChild(createDiv());\r\n\tshrink.appendChild(createDiv());\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset
    = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft
    = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll =
    function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddListener(expand,
    'scroll', onScroll.bind(expand, 'expand'));\r\n\taddListener(shrink, 'scroll',
    onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r\n\r\n// https://davidwalsh.name/detect-node-insertion\r\nfunction
    watchForRender(node, handler) {\r\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY]
    = {});\r\n\tvar proxy = expando.renderProxy = function(e) {\r\n\t\tif (e.animationName
    === CSS_RENDER_ANIMATION) {\r\n\t\t\thandler();\r\n\t\t}\r\n\t};\r\n\r\n\thelpers$1.each(ANIMATION_START_EVENTS,
    function(type) {\r\n\t\taddListener(node, type, proxy);\r\n\t});\r\n\r\n\t// #4737:
    Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\r\n\t//
    is removed then added back immediately (same animation frame?). Accessing the\r\n\t//
    `offsetParent` property will force a reflow and re-evaluate the CSS animation.\r\n\t//
    https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\r\n\t// https://github.com/chartjs/Chart.js/issues/4737\r\n\texpando.reflow
    = !!node.offsetParent;\r\n\r\n\tnode.classList.add(CSS_RENDER_MONITOR);\r\n}\r\n\r\nfunction
    unwatchForRender(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar
    proxy = expando.renderProxy;\r\n\r\n\tif (proxy) {\r\n\t\thelpers$1.each(ANIMATION_START_EVENTS,
    function(type) {\r\n\t\t\tremoveListener(node, type, proxy);\r\n\t\t});\r\n\r\n\t\tdelete
    expando.renderProxy;\r\n\t}\r\n\r\n\tnode.classList.remove(CSS_RENDER_MONITOR);\r\n}\r\n\r\nfunction
    addResizeListener(node, listener, chart) {\r\n\tvar expando = node[EXPANDO_KEY]
    || (node[EXPANDO_KEY] = {});\r\n\r\n\t// Let's keep track of this added resizer
    and thus avoid DOM query when removing it.\r\n\tvar resizer = expando.resizer
    = createResizer(throttled(function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\tvar
    container = chart.options.maintainAspectRatio && node.parentNode;\r\n\t\t\tvar
    w = container ? container.clientWidth : 0;\r\n\t\t\tlistener(createEvent('resize',
    chart));\r\n\t\t\tif (container && container.clientWidth < w && chart.canvas)
    {\r\n\t\t\t\t// If the container size shrank during chart resize, let's assume\r\n\t\t\t\t//
    scrollbar appeared. So we resize again with the scrollbar visible -\r\n\t\t\t\t//
    effectively making chart smaller and the scrollbar hidden again.\r\n\t\t\t\t//
    Because we are inside `throttled`, and currently `ticking`, scroll\r\n\t\t\t\t//
    events are ignored during this whole 2 resize process.\r\n\t\t\t\t// If we assumed
    wrong and something else happened, we are resizing\r\n\t\t\t\t// twice in a frame
    (potential performance issue)\r\n\t\t\t\tlistener(createEvent('resize', chart));\r\n\t\t\t}\r\n\t\t}\r\n\t}));\r\n\r\n\t//
    The resizer needs to be attached to the node parent, so we first need to be\r\n\t//
    sure that `node` is attached to the DOM before injecting the resizer element.\r\n\twatchForRender(node,
    function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\tvar container = node.parentNode;\r\n\t\t\tif
    (container && container !== resizer.parentNode) {\r\n\t\t\t\tcontainer.insertBefore(resizer,
    container.firstChild);\r\n\t\t\t}\r\n\r\n\t\t\t// The container size might have
    changed, let's reset the resizer state.\r\n\t\t\tresizer._reset();\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction
    removeResizeListener(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar
    resizer = expando.resizer;\r\n\r\n\tdelete expando.resizer;\r\n\tunwatchForRender(node);\r\n\r\n\tif
    (resizer && resizer.parentNode) {\r\n\t\tresizer.parentNode.removeChild(resizer);\r\n\t}\r\n}\r\n\r\n/**\r\n
    * Injects CSS styles inline if the styles are not already present.\r\n * @param
    {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.\r\n * @param
    {string} css - the CSS to be injected.\r\n */\r\nfunction injectCSS(rootNode,
    css) {\r\n\t// https://stackoverflow.com/q/3922139\r\n\tvar expando = rootNode[EXPANDO_KEY]
    || (rootNode[EXPANDO_KEY] = {});\r\n\tif (!expando.containsStyles) {\r\n\t\texpando.containsStyles
    = true;\r\n\t\tcss = '/* Chart.js */\\n' + css;\r\n\t\tvar style = document.createElement('style');\r\n\t\tstyle.setAttribute('type',
    'text/css');\r\n\t\tstyle.appendChild(document.createTextNode(css));\r\n\t\trootNode.appendChild(style);\r\n\t}\r\n}\r\n\r\nvar
    platform_dom$2 = {\r\n\t/**\r\n\t * When `true`, prevents the automatic injection
    of the stylesheet required to\r\n\t * correctly detect when the chart is added
    to the DOM and then resized. This\r\n\t * switch has been added to allow external
    stylesheet (`dist/Chart(.min)?.js`)\r\n\t * to be manually imported to make this
    library compatible with any CSP.\r\n\t * See https://github.com/chartjs/Chart.js/issues/5208\r\n\t
    */\r\n\tdisableCSSInjection: false,\r\n\r\n\t/**\r\n\t * This property holds whether
    this platform is enabled for the current environment.\r\n\t * Currently used by
    platform.js to select the proper implementation.\r\n\t * @private\r\n\t */\r\n\t_enabled:
    typeof window !== 'undefined' && typeof document !== 'undefined',\r\n\r\n\t/**\r\n\t
    * Initializes resources that depend on platform options.\r\n\t * @param {HTMLCanvasElement}
    canvas - The Canvas element.\r\n\t * @private\r\n\t */\r\n\t_ensureLoaded: function(canvas)
    {\r\n\t\tif (!this.disableCSSInjection) {\r\n\t\t\t// If the canvas is in a shadow
    DOM, then the styles must also be inserted\r\n\t\t\t// into the same shadow DOM.\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/5763\r\n\t\t\tvar root = canvas.getRootNode
    ? canvas.getRootNode() : document;\r\n\t\t\tvar targetNode = root.host ? root
    : document.head;\r\n\t\t\tinjectCSS(targetNode, stylesheet);\r\n\t\t}\r\n\t},\r\n\r\n\tacquireContext:
    function(item, config) {\r\n\t\tif (typeof item === 'string') {\r\n\t\t\titem
    = document.getElementById(item);\r\n\t\t} else if (item.length) {\r\n\t\t\t//
    Support for array based queries (such as jQuery)\r\n\t\t\titem = item[0];\r\n\t\t}\r\n\r\n\t\tif
    (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas
    (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\t// To
    prevent canvas fingerprinting, some add-ons undefine the getContext\r\n\t\t//
    method, for example: https://github.com/kkapsner/CanvasBlocker\r\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\r\n\t\tvar
    context = item && item.getContext && item.getContext('2d');\r\n\r\n\t\t// `instanceof
    HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\r\n\t\t// inside
    an iframe or when running in a protected environment. We could guess the\r\n\t\t//
    types from their toString() value but let's keep things flexible and assume it's\r\n\t\t//
    a sufficient condition if the item has a context2D which has item as `canvas`.\r\n\t\t//
    https://github.com/chartjs/Chart.js/issues/3887\r\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\r\n\t\t//
    https://github.com/chartjs/Chart.js/issues/4152\r\n\t\tif (context && context.canvas
    === item) {\r\n\t\t\t// Load platform resources on first chart creation, to make
    it possible to\r\n\t\t\t// import the library before setting platform options.\r\n\t\t\tthis._ensureLoaded(item);\r\n\t\t\tinitCanvas(item,
    config);\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\treleaseContext:
    function(context) {\r\n\t\tvar canvas = context.canvas;\r\n\t\tif (!canvas[EXPANDO_KEY])
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\r\n\t\t['height',
    'width'].forEach(function(prop) {\r\n\t\t\tvar value = initial[prop];\r\n\t\t\tif
    (helpers$1.isNullOrUndef(value)) {\r\n\t\t\t\tcanvas.removeAttribute(prop);\r\n\t\t\t}
    else {\r\n\t\t\t\tcanvas.setAttribute(prop, value);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.each(initial.style
    || {}, function(value, key) {\r\n\t\t\tcanvas.style[key] = value;\r\n\t\t});\r\n\r\n\t\t//
    The canvas render size might have been changed (and thus the state stack discarded),\r\n\t\t//
    we can't use save() and restore() to restore the initial state. So make sure that
    at\r\n\t\t// least the canvas context is reset to the default state by setting
    the canvas width.\r\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\r\n\t\t//
    eslint-disable-next-line no-self-assign\r\n\t\tcanvas.width = canvas.width;\r\n\r\n\t\tdelete
    canvas[EXPANDO_KEY];\r\n\t},\r\n\r\n\taddEventListener: function(chart, type,
    listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif (type === 'resize') {\r\n\t\t\t//
    Note: the resize event is not supported on all browsers.\r\n\t\t\taddResizeListener(canvas,
    listener, chart);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar expando = listener[EXPANDO_KEY]
    || (listener[EXPANDO_KEY] = {});\r\n\t\tvar proxies = expando.proxies || (expando.proxies
    = {});\r\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\r\n\t\t\tlistener(fromNativeEvent(event,
    chart));\r\n\t\t};\r\n\r\n\t\taddListener(canvas, type, proxy);\r\n\t},\r\n\r\n\tremoveEventListener:
    function(chart, type, listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif
    (type === 'resize') {\r\n\t\t\t// Note: the resize event is not supported on all
    browsers.\r\n\t\t\tremoveResizeListener(canvas);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar
    expando = listener[EXPANDO_KEY] || {};\r\n\t\tvar proxies = expando.proxies ||
    {};\r\n\t\tvar proxy = proxies[chart.id + '_' + type];\r\n\t\tif (!proxy) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tremoveListener(canvas,
    type, proxy);\r\n\t}\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for
    backward compatibility, use EventTarget.addEventListener instead.\r\n * EventTarget.addEventListener
    compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\r\n
    * @function Chart.helpers.addEvent\r\n * @deprecated since version 2.7.0\r\n *
    @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.addEvent = addListener;\r\n\r\n/**\r\n
    * Provided for backward compatibility, use EventTarget.removeEventListener instead.\r\n
    * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+,
    IE9+\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\r\n
    * @function Chart.helpers.removeEvent\r\n * @deprecated since version 2.7.0\r\n
    * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.removeEvent = removeListener;\n\n//
    @TODO Make possible to select another platform at build time.\r\nvar implementation
    = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\r\n\r\n/**\r\n *
    @namespace Chart.platform\r\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\r\n
    * @since 2.4.0\r\n */\r\nvar platform = helpers$1.extend({\r\n\t/**\r\n\t * @since
    2.7.0\r\n\t */\r\n\tinitialize: function() {},\r\n\r\n\t/**\r\n\t * Called at
    chart construction time, returns a context2d instance implementing\r\n\t * the
    [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\r\n\t
    * @param {*} item - The native item from which to acquire context (platform specific)\r\n\t
    * @param {object} options - The chart options\r\n\t * @returns {CanvasRenderingContext2D}
    context2d instance\r\n\t */\r\n\tacquireContext: function() {},\r\n\r\n\t/**\r\n\t
    * Called at chart destruction time, releases any resources associated to the context\r\n\t
    * previously returned by the acquireContext() method.\r\n\t * @param {CanvasRenderingContext2D}
    context - The context2d instance\r\n\t * @returns {boolean} true if the method
    succeeded, else false\r\n\t */\r\n\treleaseContext: function() {},\r\n\r\n\t/**\r\n\t
    * Registers the specified listener on the given chart.\r\n\t * @param {Chart}
    chart - Chart from which to listen for event\r\n\t * @param {string} type - The
    ({@link IEvent}) type to listen for\r\n\t * @param {function} listener - Receives
    a notification (an object that implements\r\n\t * the {@link IEvent} interface)
    when an event of the specified type occurs.\r\n\t */\r\n\taddEventListener: function()
    {},\r\n\r\n\t/**\r\n\t * Removes the specified listener previously registered
    with addEventListener.\r\n\t * @param {Chart} chart - Chart from which to remove
    the listener\r\n\t * @param {string} type - The ({@link IEvent}) type to remove\r\n\t
    * @param {function} listener - The listener function to remove from the event
    target.\r\n\t */\r\n\tremoveEventListener: function() {}\r\n\r\n}, implementation);\n\ncore_defaults._set('global',
    {\r\n\tplugins: {}\r\n});\r\n\r\n/**\r\n * The plugin service singleton\r\n *
    @namespace Chart.plugins\r\n * @since 2.1.0\r\n */\r\nvar core_plugins = {\r\n\t/**\r\n\t
    * Globally registered plugins.\r\n\t * @private\r\n\t */\r\n\t_plugins: [],\r\n\r\n\t/**\r\n\t
    * This identifier is used to invalidate the descriptors cache attached to each
    chart\r\n\t * when a global plugin is registered or unregistered. In this case,
    the cache ID is\r\n\t * incremented and descriptors are regenerated during following
    API calls.\r\n\t * @private\r\n\t */\r\n\t_cacheId: 0,\r\n\r\n\t/**\r\n\t * Registers
    the given plugin(s) if not already registered.\r\n\t * @param {IPlugin[]|IPlugin}
    plugins plugin instance(s).\r\n\t */\r\n\tregister: function(plugins) {\r\n\t\tvar
    p = this._plugins;\r\n\t\t([]).concat(plugins).forEach(function(plugin) {\r\n\t\t\tif
    (p.indexOf(plugin) === -1) {\r\n\t\t\t\tp.push(plugin);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Unregisters the given plugin(s) only if registered.\r\n\t * @param {IPlugin[]|IPlugin}
    plugins plugin instance(s).\r\n\t */\r\n\tunregister: function(plugins) {\r\n\t\tvar
    p = this._plugins;\r\n\t\t([]).concat(plugins).forEach(function(plugin) {\r\n\t\t\tvar
    idx = p.indexOf(plugin);\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\tp.splice(idx, 1);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Remove all registered plugins.\r\n\t * @since 2.1.5\r\n\t */\r\n\tclear: function()
    {\r\n\t\tthis._plugins = [];\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the number of registered plugins?\r\n\t * @returns {number}\r\n\t *
    @since 2.1.5\r\n\t */\r\n\tcount: function() {\r\n\t\treturn this._plugins.length;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns all registered plugin instances.\r\n\t * @returns {IPlugin[]} array
    of plugin objects.\r\n\t * @since 2.1.5\r\n\t */\r\n\tgetAll: function() {\r\n\t\treturn
    this._plugins;\r\n\t},\r\n\r\n\t/**\r\n\t * Calls enabled plugins for `chart`
    on the specified hook and with the given args.\r\n\t * This method immediately
    returns as soon as a plugin explicitly returns false. The\r\n\t * returned value
    can be used, for instance, to interrupt the current action.\r\n\t * @param {Chart}
    chart - The chart instance for which plugins should be called.\r\n\t * @param
    {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t
    * @param {Array} [args] - Extra arguments to apply to the hook call.\r\n\t * @returns
    {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n\tnotify:
    function(chart, hook, args) {\r\n\t\tvar descriptors = this.descriptors(chart);\r\n\t\tvar
    ilen = descriptors.length;\r\n\t\tvar i, descriptor, plugin, params, method;\r\n\r\n\t\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\t\tdescriptor = descriptors[i];\r\n\t\t\tplugin
    = descriptor.plugin;\r\n\t\t\tmethod = plugin[hook];\r\n\t\t\tif (typeof method
    === 'function') {\r\n\t\t\t\tparams = [chart].concat(args || []);\r\n\t\t\t\tparams.push(descriptor.options);\r\n\t\t\t\tif
    (method.apply(plugin, params) === false) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    true;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns descriptors of enabled plugins for
    the given chart.\r\n\t * @returns {object[]} [{ plugin, options }]\r\n\t * @private\r\n\t
    */\r\n\tdescriptors: function(chart) {\r\n\t\tvar cache = chart.$plugins || (chart.$plugins
    = {});\r\n\t\tif (cache.id === this._cacheId) {\r\n\t\t\treturn cache.descriptors;\r\n\t\t}\r\n\r\n\t\tvar
    plugins = [];\r\n\t\tvar descriptors = [];\r\n\t\tvar config = (chart && chart.config)
    || {};\r\n\t\tvar options = (config.options && config.options.plugins) || {};\r\n\r\n\t\tthis._plugins.concat(config.plugins
    || []).forEach(function(plugin) {\r\n\t\t\tvar idx = plugins.indexOf(plugin);\r\n\t\t\tif
    (idx !== -1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar id = plugin.id;\r\n\t\t\tvar
    opts = options[id];\r\n\t\t\tif (opts === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (opts === true) {\r\n\t\t\t\topts = helpers$1.clone(core_defaults.global.plugins[id]);\r\n\t\t\t}\r\n\r\n\t\t\tplugins.push(plugin);\r\n\t\t\tdescriptors.push({\r\n\t\t\t\tplugin:
    plugin,\r\n\t\t\t\toptions: opts || {}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tcache.descriptors
    = descriptors;\r\n\t\tcache.id = this._cacheId;\r\n\t\treturn descriptors;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Invalidates cache for the given chart: descriptors hold a reference on plugin
    option,\r\n\t * but in some cases, this reference can be changed by the user when
    updating options.\r\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t
    * @private\r\n\t */\r\n\t_invalidate: function(chart) {\r\n\t\tdelete chart.$plugins;\r\n\t}\r\n};\n\nvar
    core_scaleService = {\r\n\t// Scale registration object. Extensions can register
    new scale types (such as log or DB scales) and then\r\n\t// use the new chart
    options to grab the correct scale\r\n\tconstructors: {},\r\n\t// Use a registration
    function so that we can move to an ES6 map when we no longer need to support\r\n\t//
    old browsers\r\n\r\n\t// Scale config defaults\r\n\tdefaults: {},\r\n\tregisterScaleType:
    function(type, scaleConstructor, scaleDefaults) {\r\n\t\tthis.constructors[type]
    = scaleConstructor;\r\n\t\tthis.defaults[type] = helpers$1.clone(scaleDefaults);\r\n\t},\r\n\tgetScaleConstructor:
    function(type) {\r\n\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type]
    : undefined;\r\n\t},\r\n\tgetScaleDefaults: function(type) {\r\n\t\t// Return
    the scale defaults merged with the global settings so that we always use the latest
    ones\r\n\t\treturn this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null),
    [core_defaults.scale, this.defaults[type]]) : {};\r\n\t},\r\n\tupdateScaleDefaults:
    function(type, additions) {\r\n\t\tvar me = this;\r\n\t\tif (me.defaults.hasOwnProperty(type))
    {\r\n\t\t\tme.defaults[type] = helpers$1.extend(me.defaults[type], additions);\r\n\t\t}\r\n\t},\r\n\taddScalesToLayout:
    function(chart) {\r\n\t\t// Adds each scale to the chart.boxes array to be sized
    accordingly\r\n\t\thelpers$1.each(chart.scales, function(scale) {\r\n\t\t\t//
    Set ILayoutItem parameters for backwards compatibility\r\n\t\t\tscale.fullWidth
    = scale.options.fullWidth;\r\n\t\t\tscale.position = scale.options.position;\r\n\t\t\tscale.weight
    = scale.options.weight;\r\n\t\t\tcore_layouts.addBox(chart, scale);\r\n\t\t});\r\n\t}\r\n};\n\nvar
    valueOrDefault$8 = helpers$1.valueOrDefault;\r\nvar getRtlHelper = helpers$1.rtl.getRtlAdapter;\r\n\r\ncore_defaults._set('global',
    {\r\n\ttooltips: {\r\n\t\tenabled: true,\r\n\t\tcustom: null,\r\n\t\tmode: 'nearest',\r\n\t\tposition:
    'average',\r\n\t\tintersect: true,\r\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\r\n\t\ttitleFontStyle:
    'bold',\r\n\t\ttitleSpacing: 2,\r\n\t\ttitleMarginBottom: 6,\r\n\t\ttitleFontColor:
    '#fff',\r\n\t\ttitleAlign: 'left',\r\n\t\tbodySpacing: 2,\r\n\t\tbodyFontColor:
    '#fff',\r\n\t\tbodyAlign: 'left',\r\n\t\tfooterFontStyle: 'bold',\r\n\t\tfooterSpacing:
    2,\r\n\t\tfooterMarginTop: 6,\r\n\t\tfooterFontColor: '#fff',\r\n\t\tfooterAlign:
    'left',\r\n\t\tyPadding: 6,\r\n\t\txPadding: 6,\r\n\t\tcaretPadding: 2,\r\n\t\tcaretSize:
    5,\r\n\t\tcornerRadius: 6,\r\n\t\tmultiKeyBackground: '#fff',\r\n\t\tdisplayColors:
    true,\r\n\t\tborderColor: 'rgba(0,0,0,0)',\r\n\t\tborderWidth: 0,\r\n\t\tcallbacks:
    {\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeTitle: helpers$1.noop,\r\n\t\t\ttitle:
    function(tooltipItems, data) {\r\n\t\t\t\tvar title = '';\r\n\t\t\t\tvar labels
    = data.labels;\r\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\r\n\r\n\t\t\t\tif
    (tooltipItems.length > 0) {\r\n\t\t\t\t\tvar item = tooltipItems[0];\r\n\t\t\t\t\tif
    (item.label) {\r\n\t\t\t\t\t\ttitle = item.label;\r\n\t\t\t\t\t} else if (item.xLabel)
    {\r\n\t\t\t\t\t\ttitle = item.xLabel;\r\n\t\t\t\t\t} else if (labelCount > 0 &&
    item.index < labelCount) {\r\n\t\t\t\t\t\ttitle = labels[item.index];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn
    title;\r\n\t\t\t},\r\n\t\t\tafterTitle: helpers$1.noop,\r\n\r\n\t\t\t// Args are:
    (tooltipItems, data)\r\n\t\t\tbeforeBody: helpers$1.noop,\r\n\r\n\t\t\t// Args
    are: (tooltipItem, data)\r\n\t\t\tbeforeLabel: helpers$1.noop,\r\n\t\t\tlabel:
    function(tooltipItem, data) {\r\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label
    || '';\r\n\r\n\t\t\t\tif (label) {\r\n\t\t\t\t\tlabel += ': ';\r\n\t\t\t\t}\r\n\t\t\t\tif
    (!helpers$1.isNullOrUndef(tooltipItem.value)) {\r\n\t\t\t\t\tlabel += tooltipItem.value;\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\tlabel += tooltipItem.yLabel;\r\n\t\t\t\t}\r\n\t\t\t\treturn
    label;\r\n\t\t\t},\r\n\t\t\tlabelColor: function(tooltipItem, chart) {\r\n\t\t\t\tvar
    meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n\t\t\t\tvar activeElement
    = meta.data[tooltipItem.index];\r\n\t\t\t\tvar view = activeElement._view;\r\n\t\t\t\treturn
    {\r\n\t\t\t\t\tborderColor: view.borderColor,\r\n\t\t\t\t\tbackgroundColor: view.backgroundColor\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\tlabelTextColor:
    function() {\r\n\t\t\t\treturn this._options.bodyFontColor;\r\n\t\t\t},\r\n\t\t\tafterLabel:
    helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tafterBody:
    helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeFooter:
    helpers$1.noop,\r\n\t\t\tfooter: helpers$1.noop,\r\n\t\t\tafterFooter: helpers$1.noop\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    positioners = {\r\n\t/**\r\n\t * Average mode places the tooltip at the average
    position of the elements shown\r\n\t * @function Chart.Tooltip.positioners.average\r\n\t
    * @param elements {ChartElement[]} the elements being displayed in the tooltip\r\n\t
    * @returns {object} tooltip position\r\n\t */\r\n\taverage: function(elements)
    {\r\n\t\tif (!elements.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar
    i, len;\r\n\t\tvar x = 0;\r\n\t\tvar y = 0;\r\n\t\tvar count = 0;\r\n\r\n\t\tfor
    (i = 0, len = elements.length; i < len; ++i) {\r\n\t\t\tvar el = elements[i];\r\n\t\t\tif
    (el && el.hasValue()) {\r\n\t\t\t\tvar pos = el.tooltipPosition();\r\n\t\t\t\tx
    += pos.x;\r\n\t\t\t\ty += pos.y;\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tx: x / count,\r\n\t\t\ty: y / count\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * Gets the tooltip position nearest of the item nearest to the event position\r\n\t
    * @function Chart.Tooltip.positioners.nearest\r\n\t * @param elements {Chart.Element[]}
    the tooltip elements\r\n\t * @param eventPosition {object} the position of the
    event in canvas coordinates\r\n\t * @returns {object} the tooltip position\r\n\t
    */\r\n\tnearest: function(elements, eventPosition) {\r\n\t\tvar x = eventPosition.x;\r\n\t\tvar
    y = eventPosition.y;\r\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\r\n\t\tvar
    i, len, nearestElement;\r\n\r\n\t\tfor (i = 0, len = elements.length; i < len;
    ++i) {\r\n\t\t\tvar el = elements[i];\r\n\t\t\tif (el && el.hasValue()) {\r\n\t\t\t\tvar
    center = el.getCenterPoint();\r\n\t\t\t\tvar d = helpers$1.distanceBetweenPoints(eventPosition,
    center);\r\n\r\n\t\t\t\tif (d < minDistance) {\r\n\t\t\t\t\tminDistance = d;\r\n\t\t\t\t\tnearestElement
    = el;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (nearestElement) {\r\n\t\t\tvar
    tp = nearestElement.tooltipPosition();\r\n\t\t\tx = tp.x;\r\n\t\t\ty = tp.y;\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tx: x,\r\n\t\t\ty: y\r\n\t\t};\r\n\t}\r\n};\r\n\r\n// Helper to push
    or concat based on if the 2nd parameter is an array or not\r\nfunction pushOrConcat(base,
    toPush) {\r\n\tif (toPush) {\r\n\t\tif (helpers$1.isArray(toPush)) {\r\n\t\t\t//
    base = base.concat(toPush);\r\n\t\t\tArray.prototype.push.apply(base, toPush);\r\n\t\t}
    else {\r\n\t\t\tbase.push(toPush);\r\n\t\t}\r\n\t}\r\n\r\n\treturn base;\r\n}\r\n\r\n/**\r\n
    * Returns array of strings split by newline\r\n * @param {string} value - The
    value to split by newline.\r\n * @returns {string[]} value if newline present
    - Returned from String split() method\r\n * @function\r\n */\r\nfunction splitNewlines(str)
    {\r\n\tif ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n')
    > -1) {\r\n\t\treturn str.split('\\n');\r\n\t}\r\n\treturn str;\r\n}\r\n\r\n\r\n/**\r\n
    * Private helper to create a tooltip item model\r\n * @param element - the chart
    element (point, arc, bar) to create the tooltip item for\r\n * @return new tooltip
    item\r\n */\r\nfunction createTooltipItem(element) {\r\n\tvar xScale = element._xScale;\r\n\tvar
    yScale = element._yScale || element._scale; // handle radar || polarArea charts\r\n\tvar
    index = element._index;\r\n\tvar datasetIndex = element._datasetIndex;\r\n\tvar
    controller = element._chart.getDatasetMeta(datasetIndex).controller;\r\n\tvar
    indexScale = controller._getIndexScale();\r\n\tvar valueScale = controller._getValueScale();\r\n\r\n\treturn
    {\r\n\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tyLabel:
    yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tlabel: indexScale
    ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tvalue: valueScale
    ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tindex: index,\r\n\t\tdatasetIndex:
    datasetIndex,\r\n\t\tx: element._model.x,\r\n\t\ty: element._model.y\r\n\t};\r\n}\r\n\r\n/**\r\n
    * Helper to get the reset model for the tooltip\r\n * @param tooltipOpts {object}
    the tooltip options\r\n */\r\nfunction getBaseModel(tooltipOpts) {\r\n\tvar globalDefaults
    = core_defaults.global;\r\n\r\n\treturn {\r\n\t\t// Positioning\r\n\t\txPadding:
    tooltipOpts.xPadding,\r\n\t\tyPadding: tooltipOpts.yPadding,\r\n\t\txAlign: tooltipOpts.xAlign,\r\n\t\tyAlign:
    tooltipOpts.yAlign,\r\n\r\n\t\t// Drawing direction and text direction\r\n\t\trtl:
    tooltipOpts.rtl,\r\n\t\ttextDirection: tooltipOpts.textDirection,\r\n\r\n\t\t//
    Body\r\n\t\tbodyFontColor: tooltipOpts.bodyFontColor,\r\n\t\t_bodyFontFamily:
    valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_bodyFontStyle:
    valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\r\n\t\t_bodyAlign:
    tooltipOpts.bodyAlign,\r\n\t\tbodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize,
    globalDefaults.defaultFontSize),\r\n\t\tbodySpacing: tooltipOpts.bodySpacing,\r\n\r\n\t\t//
    Title\r\n\t\ttitleFontColor: tooltipOpts.titleFontColor,\r\n\t\t_titleFontFamily:
    valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_titleFontStyle:
    valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\r\n\t\ttitleFontSize:
    valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\r\n\t\t_titleAlign:
    tooltipOpts.titleAlign,\r\n\t\ttitleSpacing: tooltipOpts.titleSpacing,\r\n\t\ttitleMarginBottom:
    tooltipOpts.titleMarginBottom,\r\n\r\n\t\t// Footer\r\n\t\tfooterFontColor: tooltipOpts.footerFontColor,\r\n\t\t_footerFontFamily:
    valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_footerFontStyle:
    valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\r\n\t\tfooterFontSize:
    valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\r\n\t\t_footerAlign:
    tooltipOpts.footerAlign,\r\n\t\tfooterSpacing: tooltipOpts.footerSpacing,\r\n\t\tfooterMarginTop:
    tooltipOpts.footerMarginTop,\r\n\r\n\t\t// Appearance\r\n\t\tcaretSize: tooltipOpts.caretSize,\r\n\t\tcornerRadius:
    tooltipOpts.cornerRadius,\r\n\t\tbackgroundColor: tooltipOpts.backgroundColor,\r\n\t\topacity:
    0,\r\n\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\r\n\t\tdisplayColors:
    tooltipOpts.displayColors,\r\n\t\tborderColor: tooltipOpts.borderColor,\r\n\t\tborderWidth:
    tooltipOpts.borderWidth\r\n\t};\r\n}\r\n\r\n/**\r\n * Get the size of the tooltip\r\n
    */\r\nfunction getTooltipSize(tooltip, model) {\r\n\tvar ctx = tooltip._chart.ctx;\r\n\r\n\tvar
    height = model.yPadding * 2; // Tooltip Padding\r\n\tvar width = 0;\r\n\r\n\t//
    Count of all lines in the body\r\n\tvar body = model.body;\r\n\tvar combinedBodyLength
    = body.reduce(function(count, bodyItem) {\r\n\t\treturn count + bodyItem.before.length
    + bodyItem.lines.length + bodyItem.after.length;\r\n\t}, 0);\r\n\tcombinedBodyLength
    += model.beforeBody.length + model.afterBody.length;\r\n\r\n\tvar titleLineCount
    = model.title.length;\r\n\tvar footerLineCount = model.footer.length;\r\n\tvar
    titleFontSize = model.titleFontSize;\r\n\tvar bodyFontSize = model.bodyFontSize;\r\n\tvar
    footerFontSize = model.footerFontSize;\r\n\r\n\theight += titleLineCount * titleFontSize;
    // Title Lines\r\n\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing
    : 0; // Title Line Spacing\r\n\theight += titleLineCount ? model.titleMarginBottom
    : 0; // Title's bottom Margin\r\n\theight += combinedBodyLength * bodyFontSize;
    // Body Lines\r\n\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing
    : 0; // Body Line Spacing\r\n\theight += footerLineCount ? model.footerMarginTop
    : 0; // Footer Margin\r\n\theight += footerLineCount * (footerFontSize); // Footer
    Lines\r\n\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing
    : 0; // Footer Line Spacing\r\n\r\n\t// Title width\r\n\tvar widthPadding = 0;\r\n\tvar
    maxLineWidth = function(line) {\r\n\t\twidth = Math.max(width, ctx.measureText(line).width
    + widthPadding);\r\n\t};\r\n\r\n\tctx.font = helpers$1.fontString(titleFontSize,
    model._titleFontStyle, model._titleFontFamily);\r\n\thelpers$1.each(model.title,
    maxLineWidth);\r\n\r\n\t// Body width\r\n\tctx.font = helpers$1.fontString(bodyFontSize,
    model._bodyFontStyle, model._bodyFontFamily);\r\n\thelpers$1.each(model.beforeBody.concat(model.afterBody),
    maxLineWidth);\r\n\r\n\t// Body lines may include some extra width due to the
    color box\r\n\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\r\n\thelpers$1.each(body,
    function(bodyItem) {\r\n\t\thelpers$1.each(bodyItem.before, maxLineWidth);\r\n\t\thelpers$1.each(bodyItem.lines,
    maxLineWidth);\r\n\t\thelpers$1.each(bodyItem.after, maxLineWidth);\r\n\t});\r\n\r\n\t//
    Reset back to 0\r\n\twidthPadding = 0;\r\n\r\n\t// Footer width\r\n\tctx.font
    = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\r\n\thelpers$1.each(model.footer,
    maxLineWidth);\r\n\r\n\t// Add padding\r\n\twidth += 2 * model.xPadding;\r\n\r\n\treturn
    {\r\n\t\twidth: width,\r\n\t\theight: height\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper
    to get the alignment of a tooltip given the size\r\n */\r\nfunction determineAlignment(tooltip,
    size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar
    chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign
    = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t}
    else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar
    lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; //
    functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar
    yf; // function to get the y alignment if the tooltip goes outside of the left
    or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar
    midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center')
    {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x)
    {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn
    x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >=
    (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x)
    {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf
    = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding
    < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif
    (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and
    goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign
    = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x))
    {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside
    left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign
    = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn
    {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign
    ? opts.yAlign : yAlign\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper to get the location
    a tooltip needs to be placed at given the initial position (via the vm) and the
    size and alignment\r\n */\r\nfunction getBackgroundPoint(vm, size, alignment,
    chart) {\r\n\t// Background Position\r\n\tvar x = vm.x;\r\n\tvar y = vm.y;\r\n\r\n\tvar
    caretSize = vm.caretSize;\r\n\tvar caretPadding = vm.caretPadding;\r\n\tvar cornerRadius
    = vm.cornerRadius;\r\n\tvar xAlign = alignment.xAlign;\r\n\tvar yAlign = alignment.yAlign;\r\n\tvar
    paddingAndSize = caretSize + caretPadding;\r\n\tvar radiusAndPadding = cornerRadius
    + caretPadding;\r\n\r\n\tif (xAlign === 'right') {\r\n\t\tx -= size.width;\r\n\t}
    else if (xAlign === 'center') {\r\n\t\tx -= (size.width / 2);\r\n\t\tif (x + size.width
    > chart.width) {\r\n\t\t\tx = chart.width - size.width;\r\n\t\t}\r\n\t\tif (x
    < 0) {\r\n\t\t\tx = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (yAlign === 'top') {\r\n\t\ty
    += paddingAndSize;\r\n\t} else if (yAlign === 'bottom') {\r\n\t\ty -= size.height
    + paddingAndSize;\r\n\t} else {\r\n\t\ty -= (size.height / 2);\r\n\t}\r\n\r\n\tif
    (yAlign === 'center') {\r\n\t\tif (xAlign === 'left') {\r\n\t\t\tx += paddingAndSize;\r\n\t\t}
    else if (xAlign === 'right') {\r\n\t\t\tx -= paddingAndSize;\r\n\t\t}\r\n\t} else
    if (xAlign === 'left') {\r\n\t\tx -= radiusAndPadding;\r\n\t} else if (xAlign
    === 'right') {\r\n\t\tx += radiusAndPadding;\r\n\t}\r\n\r\n\treturn {\r\n\t\tx:
    x,\r\n\t\ty: y\r\n\t};\r\n}\r\n\r\nfunction getAlignedX(vm, align) {\r\n\treturn
    align === 'center'\r\n\t\t? vm.x + vm.width / 2\r\n\t\t: align === 'right'\r\n\t\t\t?
    vm.x + vm.width - vm.xPadding\r\n\t\t\t: vm.x + vm.xPadding;\r\n}\r\n\r\n/**\r\n
    * Helper to build before and after body lines\r\n */\r\nfunction getBeforeAfterBodyLines(callback)
    {\r\n\treturn pushOrConcat([], splitNewlines(callback));\r\n}\r\n\r\nvar exports$4
    = core_element.extend({\r\n\tinitialize: function() {\r\n\t\tthis._model = getBaseModel(this._options);\r\n\t\tthis._lastActive
    = [];\r\n\t},\r\n\r\n\t// Get the title\r\n\t// Args are: (tooltipItem, data)\r\n\tgetTitle:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks
    = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me,
    arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar
    afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines =
    [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines
    = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines,
    splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r\n\r\n\t// Args
    are: (tooltipItem, data)\r\n\tgetBeforeBody: function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this,
    arguments));\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetBody: function(tooltipItems,
    data) {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\t\tvar
    bodyItems = [];\r\n\r\n\t\thelpers$1.each(tooltipItems, function(tooltipItem)
    {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter:
    []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me,
    tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me,
    tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me,
    tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r\n\r\n\t\treturn
    bodyItems;\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetAfterBody:
    function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this,
    arguments));\r\n\t},\r\n\r\n\t// Get the footer and beforeFooter and afterFooter
    lines\r\n\t// Args are: (tooltipItem, data)\r\n\tgetFooter: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter
    = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me,
    arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar
    lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines
    = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines,
    splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r\n\r\n\tupdate:
    function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t//
    Need to regenerate the model because its faster than using extend and it is necessary
    due to the optimization in Chart.Element.transition\r\n\t\t// that does _view
    = _model if ease === 1. This causes the 2nd tooltip update to set properties in
    both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar
    existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar
    active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case
    where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar
    alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar
    backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar
    tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar
    tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar
    i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar
    labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition
    = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar
    tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t//
    If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif
    (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn
    opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided
    a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort)
    {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn
    opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine
    colors for boxes\r\n\t\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me,
    tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me,
    tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title
    = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems,
    data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody
    = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems,
    data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y
    = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors
    = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t//
    data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need
    to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this,
    model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t//
    Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize,
    alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign
    = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y
    = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height
    = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points
    to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model
    = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me,
    model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tdrawCaret: function(tooltipPoint,
    size) {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar
    caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\r\n\r\n\t\tctx.lineTo(caretPosition.x1,
    caretPosition.y1);\r\n\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n\t\tctx.lineTo(caretPosition.x3,
    caretPosition.y3);\r\n\t},\r\n\tgetCaretPosition: function(tooltipPoint, size,
    vm) {\r\n\t\tvar x1, x2, x3, y1, y2, y3;\r\n\t\tvar caretSize = vm.caretSize;\r\n\t\tvar
    cornerRadius = vm.cornerRadius;\r\n\t\tvar xAlign = vm.xAlign;\r\n\t\tvar yAlign
    = vm.yAlign;\r\n\t\tvar ptX = tooltipPoint.x;\r\n\t\tvar ptY = tooltipPoint.y;\r\n\t\tvar
    width = size.width;\r\n\t\tvar height = size.height;\r\n\r\n\t\tif (yAlign ===
    'center') {\r\n\t\t\ty2 = ptY + (height / 2);\r\n\r\n\t\t\tif (xAlign === 'left')
    {\r\n\t\t\t\tx1 = ptX;\r\n\t\t\t\tx2 = x1 - caretSize;\r\n\t\t\t\tx3 = x1;\r\n\r\n\t\t\t\ty1
    = y2 + caretSize;\r\n\t\t\t\ty3 = y2 - caretSize;\r\n\t\t\t} else {\r\n\t\t\t\tx1
    = ptX + width;\r\n\t\t\t\tx2 = x1 + caretSize;\r\n\t\t\t\tx3 = x1;\r\n\r\n\t\t\t\ty1
    = y2 - caretSize;\r\n\t\t\t\ty3 = y2 + caretSize;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif
    (xAlign === 'left') {\r\n\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\r\n\t\t\t\tx1
    = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t} else if (xAlign ===
    'right') {\r\n\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\r\n\t\t\t\tx1
    = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t} else {\r\n\t\t\t\tx2
    = vm.caretX;\r\n\t\t\t\tx1 = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t}\r\n\t\t\tif
    (yAlign === 'top') {\r\n\t\t\t\ty1 = ptY;\r\n\t\t\t\ty2 = y1 - caretSize;\r\n\t\t\t\ty3
    = y1;\r\n\t\t\t} else {\r\n\t\t\t\ty1 = ptY + height;\r\n\t\t\t\ty2 = y1 + caretSize;\r\n\t\t\t\ty3
    = y1;\r\n\t\t\t\t// invert drawing order\r\n\t\t\t\tvar tmp = x3;\r\n\t\t\t\tx3
    = x1;\r\n\t\t\t\tx1 = tmp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {x1: x1, x2: x2,
    x3: x3, y1: y1, y2: y2, y3: y3};\r\n\t},\r\n\r\n\tdrawTitle: function(pt, vm,
    ctx) {\r\n\t\tvar title = vm.title;\r\n\t\tvar length = title.length;\r\n\t\tvar
    titleFontSize, titleSpacing, i;\r\n\r\n\t\tif (length) {\r\n\t\t\tvar rtlHelper
    = getRtlHelper(vm.rtl, vm.x, vm.width);\r\n\r\n\t\t\tpt.x = getAlignedX(vm, vm._titleAlign);\r\n\r\n\t\t\tctx.textAlign
    = rtlHelper.textAlign(vm._titleAlign);\r\n\t\t\tctx.textBaseline = 'middle';\r\n\r\n\t\t\ttitleFontSize
    = vm.titleFontSize;\r\n\t\t\ttitleSpacing = vm.titleSpacing;\r\n\r\n\t\t\tctx.fillStyle
    = vm.titleFontColor;\r\n\t\t\tctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle,
    vm._titleFontFamily);\r\n\r\n\t\t\tfor (i = 0; i < length; ++i) {\r\n\t\t\t\tctx.fillText(title[i],
    rtlHelper.x(pt.x), pt.y + titleFontSize / 2);\r\n\t\t\t\tpt.y += titleFontSize
    + titleSpacing; // Line Height and spacing\r\n\r\n\t\t\t\tif (i + 1 === length)
    {\r\n\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin,
    remove spacing\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdrawBody: function(pt,
    vm, ctx) {\r\n\t\tvar bodyFontSize = vm.bodyFontSize;\r\n\t\tvar bodySpacing =
    vm.bodySpacing;\r\n\t\tvar bodyAlign = vm._bodyAlign;\r\n\t\tvar body = vm.body;\r\n\t\tvar
    drawColorBoxes = vm.displayColors;\r\n\t\tvar xLinePadding = 0;\r\n\t\tvar colorX
    = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\r\n\r\n\t\tvar rtlHelper = getRtlHelper(vm.rtl,
    vm.x, vm.width);\r\n\r\n\t\tvar fillLineOfText = function(line) {\r\n\t\t\tctx.fillText(line,
    rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);\r\n\t\t\tpt.y += bodyFontSize
    + bodySpacing;\r\n\t\t};\r\n\r\n\t\tvar bodyItem, textColor, labelColors, lines,
    i, j, ilen, jlen;\r\n\t\tvar bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n\r\n\t\tctx.textAlign
    = bodyAlign;\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.font = helpers$1.fontString(bodyFontSize,
    vm._bodyFontStyle, vm._bodyFontFamily);\r\n\r\n\t\tpt.x = getAlignedX(vm, bodyAlignForCalculation);\r\n\r\n\t\t//
    Before body lines\r\n\t\tctx.fillStyle = vm.bodyFontColor;\r\n\t\thelpers$1.each(vm.beforeBody,
    fillLineOfText);\r\n\r\n\t\txLinePadding = drawColorBoxes && bodyAlignForCalculation
    !== 'right'\r\n\t\t\t? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize
    + 2)\r\n\t\t\t: 0;\r\n\r\n\t\t// Draw body lines now\r\n\t\tfor (i = 0, ilen =
    body.length; i < ilen; ++i) {\r\n\t\t\tbodyItem = body[i];\r\n\t\t\ttextColor
    = vm.labelTextColors[i];\r\n\t\t\tlabelColors = vm.labelColors[i];\r\n\r\n\t\t\tctx.fillStyle
    = textColor;\r\n\t\t\thelpers$1.each(bodyItem.before, fillLineOfText);\r\n\r\n\t\t\tlines
    = bodyItem.lines;\r\n\t\t\tfor (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n\t\t\t\t//
    Draw Legend-like boxes if needed\r\n\t\t\t\tif (drawColorBoxes) {\r\n\t\t\t\t\tvar
    rtlColorX = rtlHelper.x(colorX);\r\n\r\n\t\t\t\t\t// Fill a white rect so that
    colours merge nicely if the opacity is < 1\r\n\t\t\t\t\tctx.fillStyle = vm.legendColorBackground;\r\n\t\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(rtlColorX,
    bodyFontSize), pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Border\r\n\t\t\t\t\tctx.lineWidth
    = 1;\r\n\t\t\t\t\tctx.strokeStyle = labelColors.borderColor;\r\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(rtlColorX,
    bodyFontSize), pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Inner square\r\n\t\t\t\t\tctx.fillStyle
    = labelColors.backgroundColor;\r\n\t\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX,
    1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\r\n\t\t\t\t\tctx.fillStyle
    = textColor;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfillLineOfText(lines[j]);\r\n\t\t\t}\r\n\r\n\t\t\thelpers$1.each(bodyItem.after,
    fillLineOfText);\r\n\t\t}\r\n\r\n\t\t// Reset back to 0 for after body\r\n\t\txLinePadding
    = 0;\r\n\r\n\t\t// After body lines\r\n\t\thelpers$1.each(vm.afterBody, fillLineOfText);\r\n\t\tpt.y
    -= bodySpacing; // Remove last body spacing\r\n\t},\r\n\r\n\tdrawFooter: function(pt,
    vm, ctx) {\r\n\t\tvar footer = vm.footer;\r\n\t\tvar length = footer.length;\r\n\t\tvar
    footerFontSize, i;\r\n\r\n\t\tif (length) {\r\n\t\t\tvar rtlHelper = getRtlHelper(vm.rtl,
    vm.x, vm.width);\r\n\r\n\t\t\tpt.x = getAlignedX(vm, vm._footerAlign);\r\n\t\t\tpt.y
    += vm.footerMarginTop;\r\n\r\n\t\t\tctx.textAlign = rtlHelper.textAlign(vm._footerAlign);\r\n\t\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\t\tfooterFontSize = vm.footerFontSize;\r\n\r\n\t\t\tctx.fillStyle
    = vm.footerFontColor;\r\n\t\t\tctx.font = helpers$1.fontString(footerFontSize,
    vm._footerFontStyle, vm._footerFontFamily);\r\n\r\n\t\t\tfor (i = 0; i < length;
    ++i) {\r\n\t\t\t\tctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize
    / 2);\r\n\t\t\t\tpt.y += footerFontSize + vm.footerSpacing;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdrawBackground:
    function(pt, vm, ctx, tooltipSize) {\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle
    = vm.borderColor;\r\n\t\tctx.lineWidth = vm.borderWidth;\r\n\t\tvar xAlign = vm.xAlign;\r\n\t\tvar
    yAlign = vm.yAlign;\r\n\t\tvar x = pt.x;\r\n\t\tvar y = pt.y;\r\n\t\tvar width
    = tooltipSize.width;\r\n\t\tvar height = tooltipSize.height;\r\n\t\tvar radius
    = vm.cornerRadius;\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(x + radius, y);\r\n\t\tif
    (yAlign === 'top') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x
    + width - radius, y);\r\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y +
    radius);\r\n\t\tif (yAlign === 'center' && xAlign === 'right') {\r\n\t\t\tthis.drawCaret(pt,
    tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + width, y + height - radius);\r\n\t\tctx.quadraticCurveTo(x
    + width, y + height, x + width - radius, y + height);\r\n\t\tif (yAlign === 'bottom')
    {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + radius,
    y + height);\r\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n\t\tif
    (yAlign === 'center' && xAlign === 'left') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x,
    y + radius);\r\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\r\n\t\tctx.closePath();\r\n\r\n\t\tctx.fill();\r\n\r\n\t\tif
    (vm.borderWidth > 0) {\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\tdraw:
    function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif
    (vm.opacity === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth:
    vm.width,\r\n\t\t\theight: vm.height\r\n\t\t};\r\n\t\tvar pt = {\r\n\t\t\tx: vm.x,\r\n\t\t\ty:
    vm.y\r\n\t\t};\r\n\r\n\t\t// IE11/Edge does not like very small opacities, so
    snap to 0\r\n\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\r\n\r\n\t\t//
    Truthy/falsey value for empty tooltip\r\n\t\tvar hasTooltipContent = vm.title.length
    || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\r\n\r\n\t\tif
    (this._options.enabled && hasTooltipContent) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.globalAlpha
    = opacity;\r\n\r\n\t\t\t// Draw Background\r\n\t\t\tthis.drawBackground(pt, vm,
    ctx, tooltipSize);\r\n\r\n\t\t\t// Draw Title, Body, and Footer\r\n\t\t\tpt.y
    += vm.yPadding;\r\n\r\n\t\t\thelpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);\r\n\r\n\t\t\t//
    Titles\r\n\t\t\tthis.drawTitle(pt, vm, ctx);\r\n\r\n\t\t\t// Body\r\n\t\t\tthis.drawBody(pt,
    vm, ctx);\r\n\r\n\t\t\t// Footer\r\n\t\t\tthis.drawFooter(pt, vm, ctx);\r\n\r\n\t\t\thelpers$1.rtl.restoreTextDirection(ctx,
    vm.textDirection);\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event - The event to
    handle\r\n\t * @returns {boolean} true if the tooltip changed\r\n\t */\r\n\thandleEvent:
    function(e) {\r\n\t\tvar me = this;\r\n\t\tvar options = me._options;\r\n\t\tvar
    changed = false;\r\n\r\n\t\tme._lastActive = me._lastActive || [];\r\n\r\n\t\t//
    Find Active Elements for tooltips\r\n\t\tif (e.type === 'mouseout') {\r\n\t\t\tme._active
    = [];\r\n\t\t} else {\r\n\t\t\tme._active = me._chart.getElementsAtEventForMode(e,
    options.mode, options);\r\n\t\t\tif (options.reverse) {\r\n\t\t\t\tme._active.reverse();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//
    Remember Last Actives\r\n\t\tchanged = !helpers$1.arrayEquals(me._active, me._lastActive);\r\n\r\n\t\t//
    Only handle target event on tooltip change\r\n\t\tif (changed) {\r\n\t\t\tme._lastActive
    = me._active;\r\n\r\n\t\t\tif (options.enabled || options.custom) {\r\n\t\t\t\tme._eventPosition
    = {\r\n\t\t\t\t\tx: e.x,\r\n\t\t\t\t\ty: e.y\r\n\t\t\t\t};\r\n\r\n\t\t\t\tme.update(true);\r\n\t\t\t\tme.pivot();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    changed;\r\n\t}\r\n});\r\n\r\n/**\r\n * @namespace Chart.Tooltip.positioners\r\n
    */\r\nvar positioners_1 = positioners;\r\n\r\nvar core_tooltip = exports$4;\ncore_tooltip.positioners
    = positioners_1;\n\nvar valueOrDefault$9 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {},\r\n\tevents: [\r\n\t\t'mousemove',\r\n\t\t'mouseout',\r\n\t\t'click',\r\n\t\t'touchstart',\r\n\t\t'touchmove'\r\n\t],\r\n\thover:
    {\r\n\t\tonHover: null,\r\n\t\tmode: 'nearest',\r\n\t\tintersect: true,\r\n\t\tanimationDuration:
    400\r\n\t},\r\n\tonClick: null,\r\n\tmaintainAspectRatio: true,\r\n\tresponsive:
    true,\r\n\tresponsiveAnimationDuration: 0\r\n});\r\n\r\n/**\r\n * Recursively
    merge the given config objects representing the `scales` option\r\n * by incorporating
    scale defaults in `xAxes` and `yAxes` array items, then\r\n * returns a deep copy
    of the result, thus doesn't alter inputs.\r\n */\r\nfunction mergeScaleConfig(/*
    config objects ... */) {\r\n\treturn helpers$1.merge(Object.create(null), [].slice.call(arguments),
    {\r\n\t\tmerger: function(key, target, source, options) {\r\n\t\t\tif (key ===
    'xAxes' || key === 'yAxes') {\r\n\t\t\t\tvar slen = source[key].length;\r\n\t\t\t\tvar
    i, type, scale;\r\n\r\n\t\t\t\tif (!target[key]) {\r\n\t\t\t\t\ttarget[key] =
    [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (i = 0; i < slen; ++i) {\r\n\t\t\t\t\tscale
    = source[key][i];\r\n\t\t\t\t\ttype = valueOrDefault$9(scale.type, key === 'xAxes'
    ? 'category' : 'linear');\r\n\r\n\t\t\t\t\tif (i >= target[key].length) {\r\n\t\t\t\t\t\ttarget[key].push({});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif
    (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\r\n\t\t\t\t\t\t//
    new/untyped scale or type changed: let's apply the new defaults\r\n\t\t\t\t\t\t//
    then merge source scale to correctly overwrite the defaults.\r\n\t\t\t\t\t\thelpers$1.merge(target[key][i],
    [core_scaleService.getScaleDefaults(type), scale]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//
    scales type are the same\r\n\t\t\t\t\t\thelpers$1.merge(target[key][i], scale);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}
    else {\r\n\t\t\t\thelpers$1._merger(key, target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n
    * Recursively merge the given config objects as the root options by handling\r\n
    * default scale options for the `scales` and `scale` properties, then returns\r\n
    * a deep copy of the result, thus doesn't alter inputs.\r\n */\r\nfunction mergeConfig(/*
    config objects ... */) {\r\n\treturn helpers$1.merge(Object.create(null), [].slice.call(arguments),
    {\r\n\t\tmerger: function(key, target, source, options) {\r\n\t\t\tvar tval =
    target[key] || Object.create(null);\r\n\t\t\tvar sval = source[key];\r\n\r\n\t\t\tif
    (key === 'scales') {\r\n\t\t\t\t// scale config merging is complex. Add our own
    function here for that\r\n\t\t\t\ttarget[key] = mergeScaleConfig(tval, sval);\r\n\t\t\t}
    else if (key === 'scale') {\r\n\t\t\t\t// used in polar area & radar charts since
    there is only one scale\r\n\t\t\t\ttarget[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type),
    sval]);\r\n\t\t\t} else {\r\n\t\t\t\thelpers$1._merger(key, target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction
    initConfig(config) {\r\n\tconfig = config || Object.create(null);\r\n\r\n\t//
    Do NOT use mergeConfig for the data object because this method merges arrays\r\n\t//
    and so would change references to labels and datasets, preventing data updates.\r\n\tvar
    data = config.data = config.data || {};\r\n\tdata.datasets = data.datasets ||
    [];\r\n\tdata.labels = data.labels || [];\r\n\r\n\tconfig.options = mergeConfig(\r\n\t\tcore_defaults.global,\r\n\t\tcore_defaults[config.type],\r\n\t\tconfig.options
    || {});\r\n\r\n\treturn config;\r\n}\r\n\r\nfunction updateConfig(chart) {\r\n\tvar
    newOptions = chart.options;\r\n\r\n\thelpers$1.each(chart.scales, function(scale)
    {\r\n\t\tcore_layouts.removeBox(chart, scale);\r\n\t});\r\n\r\n\tnewOptions =
    mergeConfig(\r\n\t\tcore_defaults.global,\r\n\t\tcore_defaults[chart.config.type],\r\n\t\tnewOptions);\r\n\r\n\tchart.options
    = chart.config.options = newOptions;\r\n\tchart.ensureScalesHaveIDs();\r\n\tchart.buildOrUpdateScales();\r\n\r\n\t//
    Tooltip\r\n\tchart.tooltip._options = newOptions.tooltips;\r\n\tchart.tooltip.initialize();\r\n}\r\n\r\nfunction
    nextAvailableScaleId(axesOpts, prefix, index) {\r\n\tvar id;\r\n\tvar hasId =
    function(obj) {\r\n\t\treturn obj.id === id;\r\n\t};\r\n\r\n\tdo {\r\n\t\tid =
    prefix + index++;\r\n\t} while (helpers$1.findIndex(axesOpts, hasId) >= 0);\r\n\r\n\treturn
    id;\r\n}\r\n\r\nfunction positionIsHorizontal(position) {\r\n\treturn position
    === 'top' || position === 'bottom';\r\n}\r\n\r\nfunction compare2Level(l1, l2)
    {\r\n\treturn function(a, b) {\r\n\t\treturn a[l1] === b[l1]\r\n\t\t\t? a[l2]
    - b[l2]\r\n\t\t\t: a[l1] - b[l1];\r\n\t};\r\n}\r\n\r\nvar Chart = function(item,
    config) {\r\n\tthis.construct(item, config);\r\n\treturn this;\r\n};\r\n\r\nhelpers$1.extend(Chart.prototype,
    /** @lends Chart */ {\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tconstruct: function(item,
    config) {\r\n\t\tvar me = this;\r\n\r\n\t\tconfig = initConfig(config);\r\n\r\n\t\tvar
    context = platform.acquireContext(item, config);\r\n\t\tvar canvas = context &&
    context.canvas;\r\n\t\tvar height = canvas && canvas.height;\r\n\t\tvar width
    = canvas && canvas.width;\r\n\r\n\t\tme.id = helpers$1.uid();\r\n\t\tme.ctx =
    context;\r\n\t\tme.canvas = canvas;\r\n\t\tme.config = config;\r\n\t\tme.width
    = width;\r\n\t\tme.height = height;\r\n\t\tme.aspectRatio = height ? width / height
    : null;\r\n\t\tme.options = config.options;\r\n\t\tme._bufferedRender = false;\r\n\t\tme._layers
    = [];\r\n\r\n\t\t/**\r\n\t\t * Provided for backward compatibility, Chart and
    Chart.Controller have been merged,\r\n\t\t * the \"instance\" still need to be
    defined since it might be called from plugins.\r\n\t\t * @prop Chart#chart\r\n\t\t
    * @deprecated since version 2.6.0\r\n\t\t * @todo remove at version 3\r\n\t\t
    * @private\r\n\t\t */\r\n\t\tme.chart = me;\r\n\t\tme.controller = me; // chart.chart.controller
    #inception\r\n\r\n\t\t// Add the chart instance to the global namespace\r\n\t\tChart.instances[me.id]
    = me;\r\n\r\n\t\t// Define alias to the config data: `chart.data === chart.config.data`\r\n\t\tObject.defineProperty(me,
    'data', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn me.config.data;\r\n\t\t\t},\r\n\t\t\tset:
    function(value) {\r\n\t\t\t\tme.config.data = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif
    (!context || !canvas) {\r\n\t\t\t// The given item is not a compatible context2d
    element, let's return before finalizing\r\n\t\t\t// the chart initialization but
    after setting basic chart / controller properties that\r\n\t\t\t// can help to
    figure out that the chart is not valid (e.g chart.canvas !== null);\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/2807\r\n\t\t\tconsole.error(\"Failed
    to create chart: can't acquire context from the given item\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme.initialize();\r\n\t\tme.update();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tinitialize: function() {\r\n\t\tvar me = this;\r\n\r\n\t\t//
    Before init plugin notification\r\n\t\tcore_plugins.notify(me, 'beforeInit');\r\n\r\n\t\thelpers$1.retinaScale(me,
    me.options.devicePixelRatio);\r\n\r\n\t\tme.bindEvents();\r\n\r\n\t\tif (me.options.responsive)
    {\r\n\t\t\t// Initial resize before chart draws (must be silent to preserve initial
    animations).\r\n\t\t\tme.resize(true);\r\n\t\t}\r\n\r\n\t\tme.initToolTip();\r\n\r\n\t\t//
    After init plugin notification\r\n\t\tcore_plugins.notify(me, 'afterInit');\r\n\r\n\t\treturn
    me;\r\n\t},\r\n\r\n\tclear: function() {\r\n\t\thelpers$1.canvas.clear(this);\r\n\t\treturn
    this;\r\n\t},\r\n\r\n\tstop: function() {\r\n\t\t// Stops any current animation
    loop occurring\r\n\t\tcore_animations.cancelAnimation(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tresize:
    function(silent) {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    canvas = me.canvas;\r\n\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio)
    || null;\r\n\r\n\t\t// the canvas render width and height will be casted to integers
    so make sure that\r\n\t\t// the canvas display style uses the same integer values
    to avoid blurring effect.\r\n\r\n\t\t// Set to 0 instead of canvas.size because
    the size defaults to 300x150 if the element is collapsed\r\n\t\tvar newWidth =
    Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\r\n\t\tvar newHeight
    = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\r\n\r\n\t\tif
    (me.width === newWidth && me.height === newHeight) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcanvas.width
    = me.width = newWidth;\r\n\t\tcanvas.height = me.height = newHeight;\r\n\t\tcanvas.style.width
    = newWidth + 'px';\r\n\t\tcanvas.style.height = newHeight + 'px';\r\n\r\n\t\thelpers$1.retinaScale(me,
    options.devicePixelRatio);\r\n\r\n\t\tif (!silent) {\r\n\t\t\t// Notify any plugins
    about the resize\r\n\t\t\tvar newSize = {width: newWidth, height: newHeight};\r\n\t\t\tcore_plugins.notify(me,
    'resize', [newSize]);\r\n\r\n\t\t\t// Notify of resize\r\n\t\t\tif (options.onResize)
    {\r\n\t\t\t\toptions.onResize(me, newSize);\r\n\t\t\t}\r\n\r\n\t\t\tme.stop();\r\n\t\t\tme.update({\r\n\t\t\t\tduration:
    options.responsiveAnimationDuration\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\tensureScalesHaveIDs:
    function() {\r\n\t\tvar options = this.options;\r\n\t\tvar scalesOptions = options.scales
    || {};\r\n\t\tvar scaleOptions = options.scale;\r\n\r\n\t\thelpers$1.each(scalesOptions.xAxes,
    function(xAxisOptions, index) {\r\n\t\t\tif (!xAxisOptions.id) {\r\n\t\t\t\txAxisOptions.id
    = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.each(scalesOptions.yAxes,
    function(yAxisOptions, index) {\r\n\t\t\tif (!yAxisOptions.id) {\r\n\t\t\t\tyAxisOptions.id
    = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif
    (scaleOptions) {\r\n\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Builds a map of scale ID to scale object for future lookup.\r\n\t */\r\n\tbuildOrUpdateScales:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    scales = me.scales || {};\r\n\t\tvar items = [];\r\n\t\tvar updated = Object.keys(scales).reduce(function(obj,
    id) {\r\n\t\t\tobj[id] = false;\r\n\t\t\treturn obj;\r\n\t\t}, {});\r\n\r\n\t\tif
    (options.scales) {\r\n\t\t\titems = items.concat(\r\n\t\t\t\t(options.scales.xAxes
    || []).map(function(xAxisOptions) {\r\n\t\t\t\t\treturn {options: xAxisOptions,
    dtype: 'category', dposition: 'bottom'};\r\n\t\t\t\t}),\r\n\t\t\t\t(options.scales.yAxes
    || []).map(function(yAxisOptions) {\r\n\t\t\t\t\treturn {options: yAxisOptions,
    dtype: 'linear', dposition: 'left'};\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif
    (options.scale) {\r\n\t\t\titems.push({\r\n\t\t\t\toptions: options.scale,\r\n\t\t\t\tdtype:
    'radialLinear',\r\n\t\t\t\tisDefault: true,\r\n\t\t\t\tdposition: 'chartArea'\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers$1.each(items,
    function(item) {\r\n\t\t\tvar scaleOptions = item.options;\r\n\t\t\tvar id = scaleOptions.id;\r\n\t\t\tvar
    scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);\r\n\r\n\t\t\tif (positionIsHorizontal(scaleOptions.position)
    !== positionIsHorizontal(item.dposition)) {\r\n\t\t\t\tscaleOptions.position =
    item.dposition;\r\n\t\t\t}\r\n\r\n\t\t\tupdated[id] = true;\r\n\t\t\tvar scale
    = null;\r\n\t\t\tif (id in scales && scales[id].type === scaleType) {\r\n\t\t\t\tscale
    = scales[id];\r\n\t\t\t\tscale.options = scaleOptions;\r\n\t\t\t\tscale.ctx =
    me.ctx;\r\n\t\t\t\tscale.chart = me;\r\n\t\t\t} else {\r\n\t\t\t\tvar scaleClass
    = core_scaleService.getScaleConstructor(scaleType);\r\n\t\t\t\tif (!scaleClass)
    {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tscale = new scaleClass({\r\n\t\t\t\t\tid:
    id,\r\n\t\t\t\t\ttype: scaleType,\r\n\t\t\t\t\toptions: scaleOptions,\r\n\t\t\t\t\tctx:
    me.ctx,\r\n\t\t\t\t\tchart: me\r\n\t\t\t\t});\r\n\t\t\t\tscales[scale.id] = scale;\r\n\t\t\t}\r\n\r\n\t\t\tscale.mergeTicksOptions();\r\n\r\n\t\t\t//
    TODO(SB): I think we should be able to remove this custom case (options.scale)\r\n\t\t\t//
    and consider it as a regular scale part of the \"scales\"\" map only! This would\r\n\t\t\t//
    make the logic easier and remove some useless? custom code.\r\n\t\t\tif (item.isDefault)
    {\r\n\t\t\t\tme.scale = scale;\r\n\t\t\t}\r\n\t\t});\r\n\t\t// clear up discarded
    scales\r\n\t\thelpers$1.each(updated, function(hasUpdated, id) {\r\n\t\t\tif (!hasUpdated)
    {\r\n\t\t\t\tdelete scales[id];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tme.scales = scales;\r\n\r\n\t\tcore_scaleService.addScalesToLayout(this);\r\n\t},\r\n\r\n\tbuildOrUpdateControllers:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar newControllers = [];\r\n\t\tvar
    datasets = me.data.datasets;\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen =
    datasets.length; i < ilen; i++) {\r\n\t\t\tvar dataset = datasets[i];\r\n\t\t\tvar
    meta = me.getDatasetMeta(i);\r\n\t\t\tvar type = dataset.type || me.config.type;\r\n\r\n\t\t\tif
    (meta.type && meta.type !== type) {\r\n\t\t\t\tme.destroyDatasetMeta(i);\r\n\t\t\t\tmeta
    = me.getDatasetMeta(i);\r\n\t\t\t}\r\n\t\t\tmeta.type = type;\r\n\t\t\tmeta.order
    = dataset.order || 0;\r\n\t\t\tmeta.index = i;\r\n\r\n\t\t\tif (meta.controller)
    {\r\n\t\t\t\tmeta.controller.updateIndex(i);\r\n\t\t\t\tmeta.controller.linkScales();\r\n\t\t\t}
    else {\r\n\t\t\t\tvar ControllerClass = controllers[meta.type];\r\n\t\t\t\tif
    (ControllerClass === undefined) {\r\n\t\t\t\t\tthrow new Error('\"' + meta.type
    + '\" is not a chart type.');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmeta.controller = new
    ControllerClass(me, i);\r\n\t\t\t\tnewControllers.push(meta.controller);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    newControllers;\r\n\t},\r\n\r\n\t/**\r\n\t * Reset the elements of all datasets\r\n\t
    * @private\r\n\t */\r\n\tresetElements: function() {\r\n\t\tvar me = this;\r\n\t\thelpers$1.each(me.data.datasets,
    function(dataset, datasetIndex) {\r\n\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\r\n\t\t},
    me);\r\n\t},\r\n\r\n\t/**\r\n\t* Resets the chart back to it's state before the
    initial animation\r\n\t*/\r\n\treset: function() {\r\n\t\tthis.resetElements();\r\n\t\tthis.tooltip.initialize();\r\n\t},\r\n\r\n\tupdate:
    function(config) {\r\n\t\tvar me = this;\r\n\t\tvar i, ilen;\r\n\r\n\t\tif (!config
    || typeof config !== 'object') {\r\n\t\t\t// backwards compatibility\r\n\t\t\tconfig
    = {\r\n\t\t\t\tduration: config,\r\n\t\t\t\tlazy: arguments[1]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tupdateConfig(me);\r\n\r\n\t\t//
    plugins options references might have change, let's invalidate the cache\r\n\t\t//
    https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t\tcore_plugins._invalidate(me);\r\n\r\n\t\tif
    (core_plugins.notify(me, 'beforeUpdate') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//
    In case the entire data object changed\r\n\t\tme.tooltip._data = me.data;\r\n\r\n\t\t//
    Make sure dataset controllers are updated and new controllers are reset\r\n\t\tvar
    newControllers = me.buildOrUpdateControllers();\r\n\r\n\t\t// Make sure all dataset
    controllers have correct meta data counts\r\n\t\tfor (i = 0, ilen = me.data.datasets.length;
    i < ilen; i++) {\r\n\t\t\tme.getDatasetMeta(i).controller.buildOrUpdateElements();\r\n\t\t}\r\n\r\n\t\tme.updateLayout();\r\n\r\n\t\t//
    Can only reset the new controllers after the scales have been updated\r\n\t\tif
    (me.options.animation && me.options.animation.duration) {\r\n\t\t\thelpers$1.each(newControllers,
    function(controller) {\r\n\t\t\t\tcontroller.reset();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tme.updateDatasets();\r\n\r\n\t\t//
    Need to reset tooltip in case it is displayed with elements that are removed\r\n\t\t//
    after update.\r\n\t\tme.tooltip.initialize();\r\n\r\n\t\t// Last active contains
    items that were previously in the tooltip.\r\n\t\t// When we reset the tooltip,
    we need to clear it\r\n\t\tme.lastActive = [];\r\n\r\n\t\t// Do this before render
    so that any plugins that need final scale updates can use it\r\n\t\tcore_plugins.notify(me,
    'afterUpdate');\r\n\r\n\t\tme._layers.sort(compare2Level('z', '_idx'));\r\n\r\n\t\tif
    (me._bufferedRender) {\r\n\t\t\tme._bufferedRequest = {\r\n\t\t\t\tduration: config.duration,\r\n\t\t\t\teasing:
    config.easing,\r\n\t\t\t\tlazy: config.lazy\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tme.render(config);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\r\n\t
    * hook, in which case, plugins will not be called on `afterLayout`.\r\n\t * @private\r\n\t
    */\r\n\tupdateLayout: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tif (core_plugins.notify(me,
    'beforeLayout') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcore_layouts.update(this,
    this.width, this.height);\r\n\r\n\t\tme._layers = [];\r\n\t\thelpers$1.each(me.boxes,
    function(box) {\r\n\t\t\t// _configure is called twice, once in core.scale.update
    and once here.\r\n\t\t\t// Here the boxes are fully updated and at their final
    positions.\r\n\t\t\tif (box._configure) {\r\n\t\t\t\tbox._configure();\r\n\t\t\t}\r\n\t\t\tme._layers.push.apply(me._layers,
    box._layers());\r\n\t\t}, me);\r\n\r\n\t\tme._layers.forEach(function(item, index)
    {\r\n\t\t\titem._idx = index;\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Provided for
    backward compatibility, use `afterLayout` instead.\r\n\t\t * @method IPlugin#afterScaleUpdate\r\n\t\t
    * @deprecated since version 2.5.0\r\n\t\t * @todo remove at version 3\r\n\t\t
    * @private\r\n\t\t */\r\n\t\tcore_plugins.notify(me, 'afterScaleUpdate');\r\n\t\tcore_plugins.notify(me,
    'afterLayout');\r\n\t},\r\n\r\n\t/**\r\n\t * Updates all datasets unless a plugin
    returns `false` to the `beforeDatasetsUpdate`\r\n\t * hook, in which case, plugins
    will not be called on `afterDatasetsUpdate`.\r\n\t * @private\r\n\t */\r\n\tupdateDatasets:
    function() {\r\n\t\tvar me = this;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetsUpdate')
    === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, ilen = me.data.datasets.length;
    i < ilen; ++i) {\r\n\t\t\tme.updateDataset(i);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDatasetsUpdate');\r\n\t},\r\n\r\n\t/**\r\n\t * Updates dataset at index
    unless a plugin returns `false` to the `beforeDatasetUpdate`\r\n\t * hook, in
    which case, plugins will not be called on `afterDatasetUpdate`.\r\n\t * @private\r\n\t
    */\r\n\tupdateDataset: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar meta
    = me.getDatasetMeta(index);\r\n\t\tvar args = {\r\n\t\t\tmeta: meta,\r\n\t\t\tindex:
    index\r\n\t\t};\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetUpdate',
    [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmeta.controller._update();\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDatasetUpdate', [args]);\r\n\t},\r\n\r\n\trender: function(config) {\r\n\t\tvar
    me = this;\r\n\r\n\t\tif (!config || typeof config !== 'object') {\r\n\t\t\t//
    backwards compatibility\r\n\t\t\tconfig = {\r\n\t\t\t\tduration: config,\r\n\t\t\t\tlazy:
    arguments[1]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar animationOptions = me.options.animation;\r\n\t\tvar
    duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);\r\n\t\tvar
    lazy = config.lazy;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeRender') ===
    false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar onComplete = function(animation)
    {\r\n\t\t\tcore_plugins.notify(me, 'afterRender');\r\n\t\t\thelpers$1.callback(animationOptions
    && animationOptions.onComplete, [animation], me);\r\n\t\t};\r\n\r\n\t\tif (animationOptions
    && duration) {\r\n\t\t\tvar animation = new core_animation({\r\n\t\t\t\tnumSteps:
    duration / 16.66, // 60 fps\r\n\t\t\t\teasing: config.easing || animationOptions.easing,\r\n\r\n\t\t\t\trender:
    function(chart, animationObject) {\r\n\t\t\t\t\tvar easingFunction = helpers$1.easing.effects[animationObject.easing];\r\n\t\t\t\t\tvar
    currentStep = animationObject.currentStep;\r\n\t\t\t\t\tvar stepDecimal = currentStep
    / animationObject.numSteps;\r\n\r\n\t\t\t\t\tchart.draw(easingFunction(stepDecimal),
    stepDecimal, currentStep);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tonAnimationProgress: animationOptions.onProgress,\r\n\t\t\t\tonAnimationComplete:
    onComplete\r\n\t\t\t});\r\n\r\n\t\t\tcore_animations.addAnimation(me, animation,
    duration, lazy);\r\n\t\t} else {\r\n\t\t\tme.draw();\r\n\r\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\r\n\t\t\tonComplete(new
    core_animation({numSteps: 0, chart: me}));\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tdraw:
    function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar i, layers;\r\n\r\n\t\tme.clear();\r\n\r\n\t\tif
    (helpers$1.isNullOrUndef(easingValue)) {\r\n\t\t\teasingValue = 1;\r\n\t\t}\r\n\r\n\t\tme.transition(easingValue);\r\n\r\n\t\tif
    (me.width <= 0 || me.height <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (core_plugins.notify(me,
    'beforeDraw', [easingValue]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//
    Because of plugin hooks (before/afterDatasetsDraw), datasets can't\r\n\t\t// currently
    be part of layers. Instead, we draw\r\n\t\t// layers <= 0 before(default, backward
    compat), and the rest after\r\n\t\tlayers = me._layers;\r\n\t\tfor (i = 0; i <
    layers.length && layers[i].z <= 0; ++i) {\r\n\t\t\tlayers[i].draw(me.chartArea);\r\n\t\t}\r\n\r\n\t\tme.drawDatasets(easingValue);\r\n\r\n\t\t//
    Rest of layers\r\n\t\tfor (; i < layers.length; ++i) {\r\n\t\t\tlayers[i].draw(me.chartArea);\r\n\t\t}\r\n\r\n\t\tme._drawTooltip(easingValue);\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDraw', [easingValue]);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\ttransition:
    function(easingValue) {\r\n\t\tvar me = this;\r\n\r\n\t\tfor (var i = 0, ilen
    = (me.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\tif (me.isDatasetVisible(i))
    {\r\n\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.tooltip.transition(easingValue);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getSortedDatasetMetas: function(filterVisible) {\r\n\t\tvar
    me = this;\r\n\t\tvar datasets = me.data.datasets || [];\r\n\t\tvar result = [];\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\r\n\t\t\tif
    (!filterVisible || me.isDatasetVisible(i)) {\r\n\t\t\t\tresult.push(me.getDatasetMeta(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.sort(compare2Level('order',
    'index'));\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_getSortedVisibleDatasetMetas: function() {\r\n\t\treturn this._getSortedDatasetMetas(true);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\r\n\t
    * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\r\n\t
    * @private\r\n\t */\r\n\tdrawDatasets: function(easingValue) {\r\n\t\tvar me =
    this;\r\n\t\tvar metasets, i;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetsDraw',
    [easingValue]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmetasets = me._getSortedVisibleDatasetMetas();\r\n\t\tfor
    (i = metasets.length - 1; i >= 0; --i) {\r\n\t\t\tme.drawDataset(metasets[i],
    easingValue);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'afterDatasetsDraw',
    [easingValue]);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws dataset at index unless a plugin
    returns `false` to the `beforeDatasetDraw`\r\n\t * hook, in which case, plugins
    will not be called on `afterDatasetDraw`.\r\n\t * @private\r\n\t */\r\n\tdrawDataset:
    function(meta, easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar args = {\r\n\t\t\tmeta:
    meta,\r\n\t\t\tindex: meta.index,\r\n\t\t\teasingValue: easingValue\r\n\t\t};\r\n\r\n\t\tif
    (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmeta.controller.draw(easingValue);\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDatasetDraw', [args]);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws tooltip unless
    a plugin returns `false` to the `beforeTooltipDraw`\r\n\t * hook, in which case,
    plugins will not be called on `afterTooltipDraw`.\r\n\t * @private\r\n\t */\r\n\t_drawTooltip:
    function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar tooltip = me.tooltip;\r\n\t\tvar
    args = {\r\n\t\t\ttooltip: tooltip,\r\n\t\t\teasingValue: easingValue\r\n\t\t};\r\n\r\n\t\tif
    (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttooltip.draw();\r\n\r\n\t\tcore_plugins.notify(me,
    'afterTooltipDraw', [args]);\r\n\t},\r\n\r\n\t/**\r\n\t * Get the single element
    that was clicked on\r\n\t * @return An object containing the dataset index and
    element index of the matching element. Also contains the rectangle that was draw\r\n\t
    */\r\n\tgetElementAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.single(this,
    e);\r\n\t},\r\n\r\n\tgetElementsAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.label(this,
    e, {intersect: true});\r\n\t},\r\n\r\n\tgetElementsAtXAxis: function(e) {\r\n\t\treturn
    core_interaction.modes['x-axis'](this, e, {intersect: true});\r\n\t},\r\n\r\n\tgetElementsAtEventForMode:
    function(e, mode, options) {\r\n\t\tvar method = core_interaction.modes[mode];\r\n\t\tif
    (typeof method === 'function') {\r\n\t\t\treturn method(this, e, options);\r\n\t\t}\r\n\r\n\t\treturn
    [];\r\n\t},\r\n\r\n\tgetDatasetAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.dataset(this,
    e, {intersect: true});\r\n\t},\r\n\r\n\tgetDatasetMeta: function(datasetIndex)
    {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.data.datasets[datasetIndex];\r\n\t\tif
    (!dataset._meta) {\r\n\t\t\tdataset._meta = {};\r\n\t\t}\r\n\r\n\t\tvar meta =
    dataset._meta[me.id];\r\n\t\tif (!meta) {\r\n\t\t\tmeta = dataset._meta[me.id]
    = {\r\n\t\t\t\ttype: null,\r\n\t\t\t\tdata: [],\r\n\t\t\t\tdataset: null,\r\n\t\t\t\tcontroller:
    null,\r\n\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\r\n\t\t\t\txAxisID:
    null,\r\n\t\t\t\tyAxisID: null,\r\n\t\t\t\torder: dataset.order || 0,\r\n\t\t\t\tindex:
    datasetIndex\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn meta;\r\n\t},\r\n\r\n\tgetVisibleDatasetCount:
    function() {\r\n\t\tvar count = 0;\r\n\t\tfor (var i = 0, ilen = this.data.datasets.length;
    i < ilen; ++i) {\r\n\t\t\tif (this.isDatasetVisible(i)) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn
    count;\r\n\t},\r\n\r\n\tisDatasetVisible: function(datasetIndex) {\r\n\t\tvar
    meta = this.getDatasetMeta(datasetIndex);\r\n\r\n\t\t// meta.hidden is a per chart
    dataset hidden flag override with 3 states: if true or false,\r\n\t\t// the dataset.hidden
    value is ignored, else if null, the dataset hidden state is returned.\r\n\t\treturn
    typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\r\n\t},\r\n\r\n\tgenerateLegend:
    function() {\r\n\t\treturn this.options.legendCallback(this);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tdestroyDatasetMeta: function(datasetIndex) {\r\n\t\tvar
    id = this.id;\r\n\t\tvar dataset = this.data.datasets[datasetIndex];\r\n\t\tvar
    meta = dataset._meta && dataset._meta[id];\r\n\r\n\t\tif (meta) {\r\n\t\t\tmeta.controller.destroy();\r\n\t\t\tdelete
    dataset._meta[id];\r\n\t\t}\r\n\t},\r\n\r\n\tdestroy: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar canvas = me.canvas;\r\n\t\tvar i, ilen;\r\n\r\n\t\tme.stop();\r\n\r\n\t\t//
    dataset controllers need to cleanup associated data\r\n\t\tfor (i = 0, ilen =
    me.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tme.destroyDatasetMeta(i);\r\n\t\t}\r\n\r\n\t\tif
    (canvas) {\r\n\t\t\tme.unbindEvents();\r\n\t\t\thelpers$1.canvas.clear(me);\r\n\t\t\tplatform.releaseContext(me.ctx);\r\n\t\t\tme.canvas
    = null;\r\n\t\t\tme.ctx = null;\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'destroy');\r\n\r\n\t\tdelete
    Chart.instances[me.id];\r\n\t},\r\n\r\n\ttoBase64Image: function() {\r\n\t\treturn
    this.canvas.toDataURL.apply(this.canvas, arguments);\r\n\t},\r\n\r\n\tinitToolTip:
    function() {\r\n\t\tvar me = this;\r\n\t\tme.tooltip = new core_tooltip({\r\n\t\t\t_chart:
    me,\r\n\t\t\t_chartInstance: me, // deprecated, backward compatibility\r\n\t\t\t_data:
    me.data,\r\n\t\t\t_options: me.options.tooltips\r\n\t\t}, me);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tbindEvents: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    listeners = me._listeners = {};\r\n\t\tvar listener = function() {\r\n\t\t\tme.eventHandler.apply(me,
    arguments);\r\n\t\t};\r\n\r\n\t\thelpers$1.each(me.options.events, function(type)
    {\r\n\t\t\tplatform.addEventListener(me, type, listener);\r\n\t\t\tlisteners[type]
    = listener;\r\n\t\t});\r\n\r\n\t\t// Elements used to detect size change should
    not be injected for non responsive charts.\r\n\t\t// See https://github.com/chartjs/Chart.js/issues/2210\r\n\t\tif
    (me.options.responsive) {\r\n\t\t\tlistener = function() {\r\n\t\t\t\tme.resize();\r\n\t\t\t};\r\n\r\n\t\t\tplatform.addEventListener(me,
    'resize', listener);\r\n\t\t\tlisteners.resize = listener;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tunbindEvents: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    listeners = me._listeners;\r\n\t\tif (!listeners) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tdelete
    me._listeners;\r\n\t\thelpers$1.each(listeners, function(listener, type) {\r\n\t\t\tplatform.removeEventListener(me,
    type, listener);\r\n\t\t});\r\n\t},\r\n\r\n\tupdateHoverStyle: function(elements,
    mode, enabled) {\r\n\t\tvar prefix = enabled ? 'set' : 'remove';\r\n\t\tvar element,
    i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\r\n\t\t\telement
    = elements[i];\r\n\t\t\tif (element) {\r\n\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[prefix
    + 'HoverStyle'](element);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (mode === 'dataset')
    {\r\n\t\t\tthis.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix
    + 'DatasetHoverStyle']();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\teventHandler: function(e) {\r\n\t\tvar me = this;\r\n\t\tvar tooltip =
    me.tooltip;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeEvent', [e]) === false)
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Buffer any update calls so that renders
    do not occur\r\n\t\tme._bufferedRender = true;\r\n\t\tme._bufferedRequest = null;\r\n\r\n\t\tvar
    changed = me.handleEvent(e);\r\n\t\t// for smooth tooltip animations issue #4989\r\n\t\t//
    the tooltip should be the source of change\r\n\t\t// Animation check workaround:\r\n\t\t//
    tooltip._start will be null when tooltip isn't animating\r\n\t\tif (tooltip) {\r\n\t\t\tchanged
    = tooltip._start\r\n\t\t\t\t? tooltip.handleEvent(e)\r\n\t\t\t\t: changed | tooltip.handleEvent(e);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me,
    'afterEvent', [e]);\r\n\r\n\t\tvar bufferedRequest = me._bufferedRequest;\r\n\t\tif
    (bufferedRequest) {\r\n\t\t\t// If we have an update that was triggered, we need
    to do a normal render\r\n\t\t\tme.render(bufferedRequest);\r\n\t\t} else if (changed
    && !me.animating) {\r\n\t\t\t// If entering, leaving, or changing elements, animate
    the change via pivot\r\n\t\t\tme.stop();\r\n\r\n\t\t\t// We only need to render
    at this point. Updating will cause scales to be\r\n\t\t\t// recomputed generating
    flicker & using more memory than necessary.\r\n\t\t\tme.render({\r\n\t\t\t\tduration:
    me.options.hover.animationDuration,\r\n\t\t\t\tlazy: true\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tme._bufferedRender
    = false;\r\n\t\tme._bufferedRequest = null;\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event the event to
    handle\r\n\t * @return {boolean} true if the chart needs to re-render\r\n\t */\r\n\thandleEvent:
    function(e) {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options || {};\r\n\t\tvar
    hoverOptions = options.hover;\r\n\t\tvar changed = false;\r\n\r\n\t\tme.lastActive
    = me.lastActive || [];\r\n\r\n\t\t// Find Active Elements for hover and tooltips\r\n\t\tif
    (e.type === 'mouseout') {\r\n\t\t\tme.active = [];\r\n\t\t} else {\r\n\t\t\tme.active
    = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\r\n\t\t}\r\n\r\n\t\t//
    Invoke onHover hook\r\n\t\t// Need to call with native event here to not break
    backwards compatibility\r\n\t\thelpers$1.callback(options.onHover || options.hover.onHover,
    [e.native, me.active], me);\r\n\r\n\t\tif (e.type === 'mouseup' || e.type ===
    'click') {\r\n\t\t\tif (options.onClick) {\r\n\t\t\t\t// Use e.native here for
    backwards compatibility\r\n\t\t\t\toptions.onClick.call(me, e.native, me.active);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//
    Remove styling for last active (even if it may still be active)\r\n\t\tif (me.lastActive.length)
    {\r\n\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\r\n\t\t}\r\n\r\n\t\t//
    Built in hover styling\r\n\t\tif (me.active.length && hoverOptions.mode) {\r\n\t\t\tme.updateHoverStyle(me.active,
    hoverOptions.mode, true);\r\n\t\t}\r\n\r\n\t\tchanged = !helpers$1.arrayEquals(me.active,
    me.lastActive);\r\n\r\n\t\t// Remember Last Actives\r\n\t\tme.lastActive = me.active;\r\n\r\n\t\treturn
    changed;\r\n\t}\r\n});\r\n\r\n/**\r\n * NOTE(SB) We actually don't use this container
    anymore but we need to keep it\r\n * for backward compatibility. Though, it can
    still be useful for plugins that\r\n * would need to work on multiple charts?!\r\n
    */\r\nChart.instances = {};\r\n\r\nvar core_controller = Chart;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart instead.\r\n * @class Chart.Controller\r\n
    * @deprecated since version 2.6\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nChart.Controller = Chart;\r\n\r\n/**\r\n * Provided for backward compatibility,
    not available anymore.\r\n * @namespace Chart\r\n * @deprecated since version
    2.8\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nChart.types = {};\r\n\r\n/**\r\n
    * Provided for backward compatibility, not available anymore.\r\n * @namespace
    Chart.helpers.configMerge\r\n * @deprecated since version 2.8.0\r\n * @todo remove
    at version 3\r\n * @private\r\n */\r\nhelpers$1.configMerge = mergeConfig;\r\n\r\n/**\r\n
    * Provided for backward compatibility, not available anymore.\r\n * @namespace
    Chart.helpers.scaleMerge\r\n * @deprecated since version 2.8.0\r\n * @todo remove
    at version 3\r\n * @private\r\n */\r\nhelpers$1.scaleMerge = mergeScaleConfig;\n\nvar
    core_helpers = function() {\r\n\r\n\t// -- Basic js utility methods\r\n\r\n\thelpers$1.where
    = function(collection, filterCallback) {\r\n\t\tif (helpers$1.isArray(collection)
    && Array.prototype.filter) {\r\n\t\t\treturn collection.filter(filterCallback);\r\n\t\t}\r\n\t\tvar
    filtered = [];\r\n\r\n\t\thelpers$1.each(collection, function(item) {\r\n\t\t\tif
    (filterCallback(item)) {\r\n\t\t\t\tfiltered.push(item);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn
    filtered;\r\n\t};\r\n\thelpers$1.findIndex = Array.prototype.findIndex ?\r\n\t\tfunction(array,
    callback, scope) {\r\n\t\t\treturn array.findIndex(callback, scope);\r\n\t\t}
    :\r\n\t\tfunction(array, callback, scope) {\r\n\t\t\tscope = scope === undefined
    ? array : scope;\r\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i)
    {\r\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\r\n\t\t\t\t\treturn
    i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\thelpers$1.findNextWhere
    = function(arrayToSearch, filterCallback, startIndex) {\r\n\t\t// Default to start
    of the array\r\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\r\n\t\t\tstartIndex
    = -1;\r\n\t\t}\r\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++)
    {\r\n\t\t\tvar currentItem = arrayToSearch[i];\r\n\t\t\tif (filterCallback(currentItem))
    {\r\n\t\t\t\treturn currentItem;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\thelpers$1.findPreviousWhere
    = function(arrayToSearch, filterCallback, startIndex) {\r\n\t\t// Default to end
    of the array\r\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\r\n\t\t\tstartIndex
    = arrayToSearch.length;\r\n\t\t}\r\n\t\tfor (var i = startIndex - 1; i >= 0; i--)
    {\r\n\t\t\tvar currentItem = arrayToSearch[i];\r\n\t\t\tif (filterCallback(currentItem))
    {\r\n\t\t\t\treturn currentItem;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// -- Math
    methods\r\n\thelpers$1.isNumber = function(n) {\r\n\t\treturn !isNaN(parseFloat(n))
    && isFinite(n);\r\n\t};\r\n\thelpers$1.almostEquals = function(x, y, epsilon)
    {\r\n\t\treturn Math.abs(x - y) < epsilon;\r\n\t};\r\n\thelpers$1.almostWhole
    = function(x, epsilon) {\r\n\t\tvar rounded = Math.round(x);\r\n\t\treturn ((rounded
    - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n\t};\r\n\thelpers$1.max = function(array)
    {\r\n\t\treturn array.reduce(function(max, value) {\r\n\t\t\tif (!isNaN(value))
    {\r\n\t\t\t\treturn Math.max(max, value);\r\n\t\t\t}\r\n\t\t\treturn max;\r\n\t\t},
    Number.NEGATIVE_INFINITY);\r\n\t};\r\n\thelpers$1.min = function(array) {\r\n\t\treturn
    array.reduce(function(min, value) {\r\n\t\t\tif (!isNaN(value)) {\r\n\t\t\t\treturn
    Math.min(min, value);\r\n\t\t\t}\r\n\t\t\treturn min;\r\n\t\t}, Number.POSITIVE_INFINITY);\r\n\t};\r\n\thelpers$1.sign
    = Math.sign ?\r\n\t\tfunction(x) {\r\n\t\t\treturn Math.sign(x);\r\n\t\t} :\r\n\t\tfunction(x)
    {\r\n\t\t\tx = +x; // convert to a number\r\n\t\t\tif (x === 0 || isNaN(x)) {\r\n\t\t\t\treturn
    x;\r\n\t\t\t}\r\n\t\t\treturn x > 0 ? 1 : -1;\r\n\t\t};\r\n\thelpers$1.toRadians
    = function(degrees) {\r\n\t\treturn degrees * (Math.PI / 180);\r\n\t};\r\n\thelpers$1.toDegrees
    = function(radians) {\r\n\t\treturn radians * (180 / Math.PI);\r\n\t};\r\n\r\n\t/**\r\n\t
    * Returns the number of decimal places\r\n\t * i.e. the number of digits after
    the decimal point, of the value of this Number.\r\n\t * @param {number} x - A
    number.\r\n\t * @returns {number} The number of decimal places.\r\n\t * @private\r\n\t
    */\r\n\thelpers$1._decimalPlaces = function(x) {\r\n\t\tif (!helpers$1.isFinite(x))
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar e = 1;\r\n\t\tvar p = 0;\r\n\t\twhile (Math.round(x
    * e) / e !== x) {\r\n\t\t\te *= 10;\r\n\t\t\tp++;\r\n\t\t}\r\n\t\treturn p;\r\n\t};\r\n\r\n\t//
    Gets the angle from vertical upright to the point about a centre.\r\n\thelpers$1.getAngleFromPoint
    = function(centrePoint, anglePoint) {\r\n\t\tvar distanceFromXCenter = anglePoint.x
    - centrePoint.x;\r\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n\t\tvar
    radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter
    + distanceFromYCenter * distanceFromYCenter);\r\n\r\n\t\tvar angle = Math.atan2(distanceFromYCenter,
    distanceFromXCenter);\r\n\r\n\t\tif (angle < (-0.5 * Math.PI)) {\r\n\t\t\tangle
    += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tangle: angle,\r\n\t\t\tdistance: radialDistanceFromCenter\r\n\t\t};\r\n\t};\r\n\thelpers$1.distanceBetweenPoints
    = function(pt1, pt2) {\r\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y
    - pt1.y, 2));\r\n\t};\r\n\r\n\t/**\r\n\t * Provided for backward compatibility,
    not available anymore\r\n\t * @function Chart.helpers.aliasPixel\r\n\t * @deprecated
    since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\thelpers$1.aliasPixel
    = function(pixelWidth) {\r\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\r\n\t};\r\n\r\n\t/**\r\n\t
    * Returns the aligned pixel value to avoid anti-aliasing blur\r\n\t * @param {Chart}
    chart - The chart instance.\r\n\t * @param {number} pixel - A pixel value.\r\n\t
    * @param {number} width - The width of the element.\r\n\t * @returns {number}
    The aligned pixel value.\r\n\t * @private\r\n\t */\r\n\thelpers$1._alignPixel
    = function(chart, pixel, width) {\r\n\t\tvar devicePixelRatio = chart.currentDevicePixelRatio;\r\n\t\tvar
    halfWidth = width / 2;\r\n\t\treturn Math.round((pixel - halfWidth) * devicePixelRatio)
    / devicePixelRatio + halfWidth;\r\n\t};\r\n\r\n\thelpers$1.splineCurve = function(firstPoint,
    middlePoint, afterPoint, t) {\r\n\t\t// Props to Rob Spencer at scaled innovation
    for his post on splining between points\r\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n\r\n\t\t//
    This function must also respect \"skipped\" points\r\n\r\n\t\tvar previous = firstPoint.skip
    ? middlePoint : firstPoint;\r\n\t\tvar current = middlePoint;\r\n\t\tvar next
    = afterPoint.skip ? middlePoint : afterPoint;\r\n\r\n\t\tvar d01 = Math.sqrt(Math.pow(current.x
    - previous.x, 2) + Math.pow(current.y - previous.y, 2));\r\n\t\tvar d12 = Math.sqrt(Math.pow(next.x
    - current.x, 2) + Math.pow(next.y - current.y, 2));\r\n\r\n\t\tvar s01 = d01 /
    (d01 + d12);\r\n\t\tvar s12 = d12 / (d01 + d12);\r\n\r\n\t\t// If all points are
    the same, s01 & s02 will be inf\r\n\t\ts01 = isNaN(s01) ? 0 : s01;\r\n\t\ts12
    = isNaN(s12) ? 0 : s12;\r\n\r\n\t\tvar fa = t * s01; // scaling factor for triangle
    Ta\r\n\t\tvar fb = t * s12;\r\n\r\n\t\treturn {\r\n\t\t\tprevious: {\r\n\t\t\t\tx:
    current.x - fa * (next.x - previous.x),\r\n\t\t\t\ty: current.y - fa * (next.y
    - previous.y)\r\n\t\t\t},\r\n\t\t\tnext: {\r\n\t\t\t\tx: current.x + fb * (next.x
    - previous.x),\r\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\thelpers$1.EPSILON
    = Number.EPSILON || 1e-14;\r\n\thelpers$1.splineCurveMonotone = function(points)
    {\r\n\t\t// This function calculates Bézier control points in a similar way than
    |splineCurve|,\r\n\t\t// but preserves monotonicity of the provided data and ensures
    no local extremums are added\r\n\t\t// between the dataset discrete points due
    to the interpolation.\r\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\r\n\r\n\t\tvar
    pointsWithTangents = (points || []).map(function(point) {\r\n\t\t\treturn {\r\n\t\t\t\tmodel:
    point._model,\r\n\t\t\t\tdeltaK: 0,\r\n\t\t\t\tmK: 0\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\t//
    Calculate slopes (deltaK) and initialize tangents (mK)\r\n\t\tvar pointsLen =
    pointsWithTangents.length;\r\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\r\n\t\tfor
    (i = 0; i < pointsLen; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tif
    (pointCurrent.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpointBefore
    = i > 0 ? pointsWithTangents[i - 1] : null;\r\n\t\t\tpointAfter = i < pointsLen
    - 1 ? pointsWithTangents[i + 1] : null;\r\n\t\t\tif (pointAfter && !pointAfter.model.skip)
    {\r\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\r\n\r\n\t\t\t\t//
    In the case of two points that appear at the same x pixel, slopeDeltaX is 0\r\n\t\t\t\tpointCurrent.deltaK
    = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX
    : 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\r\n\t\t\t\tpointCurrent.mK
    = pointCurrent.deltaK;\r\n\t\t\t} else if (!pointAfter || pointAfter.model.skip)
    {\r\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\r\n\t\t\t} else if (this.sign(pointBefore.deltaK)
    !== this.sign(pointCurrent.deltaK)) {\r\n\t\t\t\tpointCurrent.mK = 0;\r\n\t\t\t}
    else {\r\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK)
    / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Adjust tangents to ensure monotonic properties\r\n\t\tvar
    alphaK, betaK, tauK, squaredMagnitude;\r\n\t\tfor (i = 0; i < pointsLen - 1; ++i)
    {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tpointAfter = pointsWithTangents[i
    + 1];\r\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\r\n\t\t\t\tpointCurrent.mK
    = pointAfter.mK = 0;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\talphaK = pointCurrent.mK
    / pointCurrent.deltaK;\r\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\r\n\t\t\tsquaredMagnitude
    = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n\t\t\tif (squaredMagnitude <= 9)
    {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\r\n\t\t\tpointCurrent.mK
    = alphaK * tauK * pointCurrent.deltaK;\r\n\t\t\tpointAfter.mK = betaK * tauK *
    pointCurrent.deltaK;\r\n\t\t}\r\n\r\n\t\t// Compute control points\r\n\t\tvar
    deltaX;\r\n\t\tfor (i = 0; i < pointsLen; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tif
    (pointCurrent.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpointBefore
    = i > 0 ? pointsWithTangents[i - 1] : null;\r\n\t\t\tpointAfter = i < pointsLen
    - 1 ? pointsWithTangents[i + 1] : null;\r\n\t\t\tif (pointBefore && !pointBefore.model.skip)
    {\r\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\r\n\t\t\t\tpointCurrent.model.controlPointPreviousX
    = pointCurrent.model.x - deltaX;\r\n\t\t\t\tpointCurrent.model.controlPointPreviousY
    = pointCurrent.model.y - deltaX * pointCurrent.mK;\r\n\t\t\t}\r\n\t\t\tif (pointAfter
    && !pointAfter.model.skip) {\r\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x)
    / 3;\r\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x +
    deltaX;\r\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y
    + deltaX * pointCurrent.mK;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\thelpers$1.nextItem
    = function(collection, index, loop) {\r\n\t\tif (loop) {\r\n\t\t\treturn index
    >= collection.length - 1 ? collection[0] : collection[index + 1];\r\n\t\t}\r\n\t\treturn
    index >= collection.length - 1 ? collection[collection.length - 1] : collection[index
    + 1];\r\n\t};\r\n\thelpers$1.previousItem = function(collection, index, loop)
    {\r\n\t\tif (loop) {\r\n\t\t\treturn index <= 0 ? collection[collection.length
    - 1] : collection[index - 1];\r\n\t\t}\r\n\t\treturn index <= 0 ? collection[0]
    : collection[index - 1];\r\n\t};\r\n\t// Implementation of the nice number algorithm
    used in determining where axis labels will go\r\n\thelpers$1.niceNum = function(range,
    round) {\r\n\t\tvar exponent = Math.floor(helpers$1.log10(range));\r\n\t\tvar
    fraction = range / Math.pow(10, exponent);\r\n\t\tvar niceFraction;\r\n\r\n\t\tif
    (round) {\r\n\t\t\tif (fraction < 1.5) {\r\n\t\t\t\tniceFraction = 1;\r\n\t\t\t}
    else if (fraction < 3) {\r\n\t\t\t\tniceFraction = 2;\r\n\t\t\t} else if (fraction
    < 7) {\r\n\t\t\t\tniceFraction = 5;\r\n\t\t\t} else {\r\n\t\t\t\tniceFraction
    = 10;\r\n\t\t\t}\r\n\t\t} else if (fraction <= 1.0) {\r\n\t\t\tniceFraction =
    1;\r\n\t\t} else if (fraction <= 2) {\r\n\t\t\tniceFraction = 2;\r\n\t\t} else
    if (fraction <= 5) {\r\n\t\t\tniceFraction = 5;\r\n\t\t} else {\r\n\t\t\tniceFraction
    = 10;\r\n\t\t}\r\n\r\n\t\treturn niceFraction * Math.pow(10, exponent);\r\n\t};\r\n\t//
    Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\thelpers$1.requestAnimFrame
    = (function() {\r\n\t\tif (typeof window === 'undefined') {\r\n\t\t\treturn function(callback)
    {\r\n\t\t\t\tcallback();\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn window.requestAnimationFrame
    ||\r\n\t\t\twindow.webkitRequestAnimationFrame ||\r\n\t\t\twindow.mozRequestAnimationFrame
    ||\r\n\t\t\twindow.oRequestAnimationFrame ||\r\n\t\t\twindow.msRequestAnimationFrame
    ||\r\n\t\t\tfunction(callback) {\r\n\t\t\t\treturn window.setTimeout(callback,
    1000 / 60);\r\n\t\t\t};\r\n\t}());\r\n\t// -- DOM methods\r\n\thelpers$1.getRelativePosition
    = function(evt, chart) {\r\n\t\tvar mouseX, mouseY;\r\n\t\tvar e = evt.originalEvent
    || evt;\r\n\t\tvar canvas = evt.target || evt.srcElement;\r\n\t\tvar boundingRect
    = canvas.getBoundingClientRect();\r\n\r\n\t\tvar touches = e.touches;\r\n\t\tif
    (touches && touches.length > 0) {\r\n\t\t\tmouseX = touches[0].clientX;\r\n\t\t\tmouseY
    = touches[0].clientY;\r\n\r\n\t\t} else {\r\n\t\t\tmouseX = e.clientX;\r\n\t\t\tmouseY
    = e.clientY;\r\n\t\t}\r\n\r\n\t\t// Scale mouse coordinates into canvas coordinates\r\n\t\t//
    by following the pattern laid out by 'jerryj' in the comments of\r\n\t\t// https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\r\n\t\tvar
    paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\r\n\t\tvar
    paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\r\n\t\tvar
    paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\r\n\t\tvar
    paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\r\n\t\tvar
    width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\r\n\t\tvar
    height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\r\n\r\n\t\t//
    We divide by the current device pixel ratio, because the canvas is scaled up by
    that amount in each direction. However\r\n\t\t// the backend model is in unscaled
    coordinates. Since we are going to deal with our model coordinates, we go back
    here\r\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width)
    * canvas.width / chart.currentDevicePixelRatio);\r\n\t\tmouseY = Math.round((mouseY
    - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\r\n\r\n\t\treturn
    {\r\n\t\t\tx: mouseX,\r\n\t\t\ty: mouseY\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t// Private
    helper function to convert max-width/max-height values that may be percentages
    into a number\r\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\r\n\t\tvar
    valueInPixels;\r\n\t\tif (typeof styleValue === 'string') {\r\n\t\t\tvalueInPixels
    = parseInt(styleValue, 10);\r\n\r\n\t\t\tif (styleValue.indexOf('%') !== -1) {\r\n\t\t\t\t//
    percentage * size in dimension\r\n\t\t\t\tvalueInPixels = valueInPixels / 100
    * node.parentNode[parentProperty];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalueInPixels
    = styleValue;\r\n\t\t}\r\n\r\n\t\treturn valueInPixels;\r\n\t}\r\n\r\n\t/**\r\n\t
    * Returns if the given value contains an effective constraint.\r\n\t * @private\r\n\t
    */\r\n\tfunction isConstrainedValue(value) {\r\n\t\treturn value !== undefined
    && value !== null && value !== 'none';\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the
    max width or height of the given DOM node in a cross-browser compatible fashion\r\n\t
    * @param {HTMLElement} domNode - the node to check the constraint on\r\n\t * @param
    {string} maxStyle - the style that defines the maximum for the direction we are
    using ('max-width' / 'max-height')\r\n\t * @param {string} percentageProperty
    - property of parent to use when calculating width as a percentage\r\n\t * @see
    {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\r\n\t
    */\r\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty)
    {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers$1._getParentNode(domNode);\r\n\t\tvar
    constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer
    = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar
    hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity
    = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn
    Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty)
    : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode,
    percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r\n\t//
    returns Number or undefined if no constraint\r\n\thelpers$1.getConstraintWidth
    = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-width',
    'clientWidth');\r\n\t};\r\n\t// returns Number or undefined if no constraint\r\n\thelpers$1.getConstraintHeight
    = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-height',
    'clientHeight');\r\n\t};\r\n\t/**\r\n\t * @private\r\n \t */\r\n\thelpers$1._calculatePadding
    = function(container, padding, parentDimension) {\r\n\t\tpadding = helpers$1.getStyle(container,
    padding);\r\n\r\n\t\treturn padding.indexOf('%') > -1 ? parentDimension * parseInt(padding,
    10) / 100 : parseInt(padding, 10);\r\n\t};\r\n\t/**\r\n\t * @private\r\n\t */\r\n\thelpers$1._getParentNode
    = function(domNode) {\r\n\t\tvar parent = domNode.parentNode;\r\n\t\tif (parent
    && parent.toString() === '[object ShadowRoot]') {\r\n\t\t\tparent = parent.host;\r\n\t\t}\r\n\t\treturn
    parent;\r\n\t};\r\n\thelpers$1.getMaximumWidth = function(domNode) {\r\n\t\tvar
    container = helpers$1._getParentNode(domNode);\r\n\t\tif (!container) {\r\n\t\t\treturn
    domNode.clientWidth;\r\n\t\t}\r\n\r\n\t\tvar clientWidth = container.clientWidth;\r\n\t\tvar
    paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\r\n\t\tvar
    paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\r\n\r\n\t\tvar
    w = clientWidth - paddingLeft - paddingRight;\r\n\t\tvar cw = helpers$1.getConstraintWidth(domNode);\r\n\t\treturn
    isNaN(cw) ? w : Math.min(w, cw);\r\n\t};\r\n\thelpers$1.getMaximumHeight = function(domNode)
    {\r\n\t\tvar container = helpers$1._getParentNode(domNode);\r\n\t\tif (!container)
    {\r\n\t\t\treturn domNode.clientHeight;\r\n\t\t}\r\n\r\n\t\tvar clientHeight =
    container.clientHeight;\r\n\t\tvar paddingTop = helpers$1._calculatePadding(container,
    'padding-top', clientHeight);\r\n\t\tvar paddingBottom = helpers$1._calculatePadding(container,
    'padding-bottom', clientHeight);\r\n\r\n\t\tvar h = clientHeight - paddingTop
    - paddingBottom;\r\n\t\tvar ch = helpers$1.getConstraintHeight(domNode);\r\n\t\treturn
    isNaN(ch) ? h : Math.min(h, ch);\r\n\t};\r\n\thelpers$1.getStyle = function(el,
    property) {\r\n\t\treturn el.currentStyle ?\r\n\t\t\tel.currentStyle[property]
    :\r\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\r\n\t};\r\n\thelpers$1.retinaScale
    = function(chart, forceRatio) {\r\n\t\tvar pixelRatio = chart.currentDevicePixelRatio
    = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) ||
    1;\r\n\t\tif (pixelRatio === 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar canvas
    = chart.canvas;\r\n\t\tvar height = chart.height;\r\n\t\tvar width = chart.width;\r\n\r\n\t\tcanvas.height
    = height * pixelRatio;\r\n\t\tcanvas.width = width * pixelRatio;\r\n\t\tchart.ctx.scale(pixelRatio,
    pixelRatio);\r\n\r\n\t\t// If no style has been set on the canvas, the render
    size is used as display size,\r\n\t\t// making the chart visually bigger, so let's
    enforce it to the \"correct\" values.\r\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\r\n\t\tif
    (!canvas.style.height && !canvas.style.width) {\r\n\t\t\tcanvas.style.height =
    height + 'px';\r\n\t\t\tcanvas.style.width = width + 'px';\r\n\t\t}\r\n\t};\r\n\t//
    -- Canvas methods\r\n\thelpers$1.fontString = function(pixelSize, fontStyle, fontFamily)
    {\r\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n\t};\r\n\thelpers$1.longestText
    = function(ctx, font, arrayOfThings, cache) {\r\n\t\tcache = cache || {};\r\n\t\tvar
    data = cache.data = cache.data || {};\r\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect
    || [];\r\n\r\n\t\tif (cache.font !== font) {\r\n\t\t\tdata = cache.data = {};\r\n\t\t\tgc
    = cache.garbageCollect = [];\r\n\t\t\tcache.font = font;\r\n\t\t}\r\n\r\n\t\tctx.font
    = font;\r\n\t\tvar longest = 0;\r\n\t\tvar ilen = arrayOfThings.length;\r\n\t\tvar
    i, j, jlen, thing, nestedThing;\r\n\t\tfor (i = 0; i < ilen; i++) {\r\n\t\t\tthing
    = arrayOfThings[i];\r\n\r\n\t\t\t// Undefined strings and arrays should not be
    measured\r\n\t\t\tif (thing !== undefined && thing !== null && helpers$1.isArray(thing)
    !== true) {\r\n\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest,
    thing);\r\n\t\t\t} else if (helpers$1.isArray(thing)) {\r\n\t\t\t\t// if it is
    an array lets measure each element\r\n\t\t\t\t// to do maybe simplify this function
    a bit so we can do this more recursively?\r\n\t\t\t\tfor (j = 0, jlen = thing.length;
    j < jlen; j++) {\r\n\t\t\t\t\tnestedThing = thing[j];\r\n\t\t\t\t\t// Undefined
    strings and arrays should not be measured\r\n\t\t\t\t\tif (nestedThing !== undefined
    && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\r\n\t\t\t\t\t\tlongest
    = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar
    gcLen = gc.length / 2;\r\n\t\tif (gcLen > arrayOfThings.length) {\r\n\t\t\tfor
    (i = 0; i < gcLen; i++) {\r\n\t\t\t\tdelete data[gc[i]];\r\n\t\t\t}\r\n\t\t\tgc.splice(0,
    gcLen);\r\n\t\t}\r\n\t\treturn longest;\r\n\t};\r\n\thelpers$1.measureText = function(ctx,
    data, gc, longest, string) {\r\n\t\tvar textWidth = data[string];\r\n\t\tif (!textWidth)
    {\r\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\r\n\t\t\tgc.push(string);\r\n\t\t}\r\n\t\tif
    (textWidth > longest) {\r\n\t\t\tlongest = textWidth;\r\n\t\t}\r\n\t\treturn longest;\r\n\t};\r\n\r\n\t/**\r\n\t
    * @deprecated\r\n\t */\r\n\thelpers$1.numberOfLabelLines = function(arrayOfThings)
    {\r\n\t\tvar numberOfLines = 1;\r\n\t\thelpers$1.each(arrayOfThings, function(thing)
    {\r\n\t\t\tif (helpers$1.isArray(thing)) {\r\n\t\t\t\tif (thing.length > numberOfLines)
    {\r\n\t\t\t\t\tnumberOfLines = thing.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn
    numberOfLines;\r\n\t};\r\n\r\n\thelpers$1.color = !chartjsColor ?\r\n\t\tfunction(value)
    {\r\n\t\t\tconsole.error('Color.js not found!');\r\n\t\t\treturn value;\r\n\t\t}
    :\r\n\t\tfunction(value) {\r\n\t\t\t/* global CanvasGradient */\r\n\t\t\tif (value
    instanceof CanvasGradient) {\r\n\t\t\t\tvalue = core_defaults.global.defaultColor;\r\n\t\t\t}\r\n\r\n\t\t\treturn
    chartjsColor(value);\r\n\t\t};\r\n\r\n\thelpers$1.getHoverColor = function(colorValue)
    {\r\n\t\t/* global CanvasPattern */\r\n\t\treturn (colorValue instanceof CanvasPattern
    || colorValue instanceof CanvasGradient) ?\r\n\t\t\tcolorValue :\r\n\t\t\thelpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\r\n\t};\r\n};\n\nfunction
    abstract() {\r\n\tthrow new Error(\r\n\t\t'This method is not implemented: either
    no adapter can ' +\r\n\t\t'be found or an incomplete integration was provided.'\r\n\t);\r\n}\r\n\r\n/**\r\n
    * Date adapter (current used by the time scale)\r\n * @namespace Chart._adapters._date\r\n
    * @memberof Chart._adapters\r\n * @private\r\n */\r\n\r\n/**\r\n * Currently supported
    unit string values.\r\n * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\r\n
    * @memberof Chart._adapters._date\r\n * @name Unit\r\n */\r\n\r\n/**\r\n * @class\r\n
    */\r\nfunction DateAdapter(options) {\r\n\tthis.options = options || {};\r\n}\r\n\r\nhelpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */ {\r\n\t/**\r\n\t * Returns a map of time formats for
    the supported formatting units defined\r\n\t * in Unit as well as 'datetime' representing
    a detailed date/time string.\r\n\t * @returns {{string: string}}\r\n\t */\r\n\tformats:
    abstract,\r\n\r\n\t/**\r\n\t * Parses the given `value` and return the associated
    timestamp.\r\n\t * @param {any} value - the value to parse (usually comes from
    the data)\r\n\t * @param {string} [format] - the expected data format\r\n\t *
    @returns {(number|null)}\r\n\t * @function\r\n\t */\r\n\tparse: abstract,\r\n\r\n\t/**\r\n\t
    * Returns the formatted date in the specified `format` for a given `timestamp`.\r\n\t
    * @param {number} timestamp - the timestamp to format\r\n\t * @param {string}
    format - the date/time token\r\n\t * @return {string}\r\n\t * @function\r\n\t
    */\r\n\tformat: abstract,\r\n\r\n\t/**\r\n\t * Adds the specified `amount` of
    `unit` to the given `timestamp`.\r\n\t * @param {number} timestamp - the input
    timestamp\r\n\t * @param {number} amount - the amount to add\r\n\t * @param {Unit}
    unit - the unit as string\r\n\t * @return {number}\r\n\t * @function\r\n\t */\r\n\tadd:
    abstract,\r\n\r\n\t/**\r\n\t * Returns the number of `unit` between the given
    timestamps.\r\n\t * @param {number} max - the input timestamp (reference)\r\n\t
    * @param {number} min - the timestamp to substract\r\n\t * @param {Unit} unit
    - the unit as string\r\n\t * @return {number}\r\n\t * @function\r\n\t */\r\n\tdiff:
    abstract,\r\n\r\n\t/**\r\n\t * Returns start of `unit` for the given `timestamp`.\r\n\t
    * @param {number} timestamp - the input timestamp\r\n\t * @param {Unit} unit -
    the unit as string\r\n\t * @param {number} [weekday] - the ISO day of the week
    with 1 being Monday\r\n\t * and 7 being Sunday (only needed if param *unit* is
    `isoWeek`).\r\n\t * @function\r\n\t */\r\n\tstartOf: abstract,\r\n\r\n\t/**\r\n\t
    * Returns end of `unit` for the given `timestamp`.\r\n\t * @param {number} timestamp
    - the input timestamp\r\n\t * @param {Unit} unit - the unit as string\r\n\t *
    @function\r\n\t */\r\n\tendOf: abstract,\r\n\r\n\t// DEPRECATIONS\r\n\r\n\t/**\r\n\t
    * Provided for backward compatibility for scale.getValueForPixel(),\r\n\t * this
    method should be overridden only by the moment adapter.\r\n\t * @deprecated since
    version 2.8.0\r\n\t * @todo remove at version 3\r\n\t * @private\r\n\t */\r\n\t_create:
    function(value) {\r\n\t\treturn value;\r\n\t}\r\n});\r\n\r\nDateAdapter.override
    = function(members) {\r\n\thelpers$1.extend(DateAdapter.prototype, members);\r\n};\r\n\r\nvar
    _date = DateAdapter;\n\nvar core_adapters = {\n\t_date: _date\n};\n\n/**\r\n *
    Namespace to hold static tick generation functions\r\n * @namespace Chart.Ticks\r\n
    */\r\nvar core_ticks = {\r\n\t/**\r\n\t * Namespace to hold formatters for different
    types of ticks\r\n\t * @namespace Chart.Ticks.formatters\r\n\t */\r\n\tformatters:
    {\r\n\t\t/**\r\n\t\t * Formatter for value labels\r\n\t\t * @method Chart.Ticks.formatters.values\r\n\t\t
    * @param value the value to display\r\n\t\t * @return {string|string[]} the label
    to display\r\n\t\t */\r\n\t\tvalues: function(value) {\r\n\t\t\treturn helpers$1.isArray(value)
    ? value : '' + value;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Formatter for linear
    numeric ticks\r\n\t\t * @method Chart.Ticks.formatters.linear\r\n\t\t * @param
    tickValue {number} the value to be formatted\r\n\t\t * @param index {number} the
    position of the tickValue parameter in the ticks array\r\n\t\t * @param ticks
    {number[]} the list of ticks being converted\r\n\t\t * @return {string} string
    representation of the tickValue parameter\r\n\t\t */\r\n\t\tlinear: function(tickValue,
    index, ticks) {\r\n\t\t\t// If we have lots of ticks, don't use the ones\r\n\t\t\tvar
    delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\r\n\r\n\t\t\t//
    If we have a number like 2.5 as the delta, figure out how many decimal places
    we need\r\n\t\t\tif (Math.abs(delta) > 1) {\r\n\t\t\t\tif (tickValue !== Math.floor(tickValue))
    {\r\n\t\t\t\t\t// not an integer\r\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar
    logDelta = helpers$1.log10(Math.abs(delta));\r\n\t\t\tvar tickString = '';\r\n\r\n\t\t\tif
    (tickValue !== 0) {\r\n\t\t\t\tvar maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length
    - 1]));\r\n\t\t\t\tif (maxTick < 1e-4) { // all ticks are small numbers; use scientific
    notation\r\n\t\t\t\t\tvar logTick = helpers$1.log10(Math.abs(tickValue));\r\n\t\t\t\t\tvar
    numExponential = Math.floor(logTick) - Math.floor(logDelta);\r\n\t\t\t\t\tnumExponential
    = Math.max(Math.min(numExponential, 20), 0);\r\n\t\t\t\t\ttickString = tickValue.toExponential(numExponential);\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\r\n\t\t\t\t\tnumDecimal
    = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\r\n\t\t\t\t\ttickString
    = tickValue.toFixed(numDecimal);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttickString
    = '0'; // never show decimal places for 0\r\n\t\t\t}\r\n\r\n\t\t\treturn tickString;\r\n\t\t},\r\n\r\n\t\tlogarithmic:
    function(tickValue, index, ticks) {\r\n\t\t\tvar remain = tickValue / (Math.pow(10,
    Math.floor(helpers$1.log10(tickValue))));\r\n\r\n\t\t\tif (tickValue === 0) {\r\n\t\t\t\treturn
    '0';\r\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index
    === 0 || index === ticks.length - 1) {\r\n\t\t\t\treturn tickValue.toExponential();\r\n\t\t\t}\r\n\t\t\treturn
    '';\r\n\t\t}\r\n\t}\r\n};\n\nvar isArray = helpers$1.isArray;\r\nvar isNullOrUndef
    = helpers$1.isNullOrUndef;\r\nvar valueOrDefault$a = helpers$1.valueOrDefault;\r\nvar
    valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\r\n\r\ncore_defaults._set('scale',
    {\r\n\tdisplay: true,\r\n\tposition: 'left',\r\n\toffset: false,\r\n\r\n\t// grid
    line settings\r\n\tgridLines: {\r\n\t\tdisplay: true,\r\n\t\tcolor: 'rgba(0,0,0,0.1)',\r\n\t\tlineWidth:
    1,\r\n\t\tdrawBorder: true,\r\n\t\tdrawOnChartArea: true,\r\n\t\tdrawTicks: true,\r\n\t\ttickMarkLength:
    10,\r\n\t\tzeroLineWidth: 1,\r\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\r\n\t\tzeroLineBorderDash:
    [],\r\n\t\tzeroLineBorderDashOffset: 0.0,\r\n\t\toffsetGridLines: false,\r\n\t\tborderDash:
    [],\r\n\t\tborderDashOffset: 0.0\r\n\t},\r\n\r\n\t// scale label\r\n\tscaleLabel:
    {\r\n\t\t// display property\r\n\t\tdisplay: false,\r\n\r\n\t\t// actual label\r\n\t\tlabelString:
    '',\r\n\r\n\t\t// top/bottom padding\r\n\t\tpadding: {\r\n\t\t\ttop: 4,\r\n\t\t\tbottom:
    4\r\n\t\t}\r\n\t},\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\tbeginAtZero:
    false,\r\n\t\tminRotation: 0,\r\n\t\tmaxRotation: 50,\r\n\t\tmirror: false,\r\n\t\tpadding:
    0,\r\n\t\treverse: false,\r\n\t\tdisplay: true,\r\n\t\tautoSkip: true,\r\n\t\tautoSkipPadding:
    0,\r\n\t\tlabelOffset: 0,\r\n\t\t// We pass through arrays to be rendered as multiline
    labels, we convert Others to strings here.\r\n\t\tcallback: core_ticks.formatters.values,\r\n\t\tminor:
    {},\r\n\t\tmajor: {}\r\n\t}\r\n});\r\n\r\n/** Returns a new array containing numItems
    from arr */\r\nfunction sample(arr, numItems) {\r\n\tvar result = [];\r\n\tvar
    increment = arr.length / numItems;\r\n\tvar i = 0;\r\n\tvar len = arr.length;\r\n\r\n\tfor
    (; i < len; i += increment) {\r\n\t\tresult.push(arr[Math.floor(i)]);\r\n\t}\r\n\treturn
    result;\r\n}\r\n\r\nfunction getPixelForGridLine(scale, index, offsetGridLines)
    {\r\n\tvar length = scale.getTicks().length;\r\n\tvar validIndex = Math.min(index,
    length - 1);\r\n\tvar lineValue = scale.getPixelForTick(validIndex);\r\n\tvar
    start = scale._startPixel;\r\n\tvar end = scale._endPixel;\r\n\tvar epsilon =
    1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n\tvar offset;\r\n\r\n\tif
    (offsetGridLines) {\r\n\t\tif (length === 1) {\r\n\t\t\toffset = Math.max(lineValue
    - start, end - lineValue);\r\n\t\t} else if (index === 0) {\r\n\t\t\toffset =
    (scale.getPixelForTick(1) - lineValue) / 2;\r\n\t\t} else {\r\n\t\t\toffset =
    (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n\t\t}\r\n\t\tlineValue
    += validIndex < index ? offset : -offset;\r\n\r\n\t\t// Return undefined if the
    pixel is out of the range\r\n\t\tif (lineValue < start - epsilon || lineValue
    > end + epsilon) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\treturn lineValue;\r\n}\r\n\r\nfunction
    garbageCollect(caches, length) {\r\n\thelpers$1.each(caches, function(cache) {\r\n\t\tvar
    gc = cache.gc;\r\n\t\tvar gcLen = gc.length / 2;\r\n\t\tvar i;\r\n\t\tif (gcLen
    > length) {\r\n\t\t\tfor (i = 0; i < gcLen; ++i) {\r\n\t\t\t\tdelete cache.data[gc[i]];\r\n\t\t\t}\r\n\t\t\tgc.splice(0,
    gcLen);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Returns {width, height, offset}
    objects for the first, last, widest, highest tick\r\n * labels where offset indicates
    the anchor point offset from the top in pixels.\r\n */\r\nfunction computeLabelSizes(ctx,
    tickFonts, ticks, caches) {\r\n\tvar length = ticks.length;\r\n\tvar widths =
    [];\r\n\tvar heights = [];\r\n\tvar offsets = [];\r\n\tvar widestLabelSize = 0;\r\n\tvar
    highestLabelSize = 0;\r\n\tvar i, j, jlen, label, tickFont, fontString, cache,
    lineHeight, width, height, nestedLabel, widest, highest;\r\n\r\n\tfor (i = 0;
    i < length; ++i) {\r\n\t\tlabel = ticks[i].label;\r\n\t\ttickFont = ticks[i].major
    ? tickFonts.major : tickFonts.minor;\r\n\t\tctx.font = fontString = tickFont.string;\r\n\t\tcache
    = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n\t\tlineHeight
    = tickFont.lineHeight;\r\n\t\twidth = height = 0;\r\n\t\t// Undefined labels and
    arrays should not be measured\r\n\t\tif (!isNullOrUndef(label) && !isArray(label))
    {\r\n\t\t\twidth = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);\r\n\t\t\theight
    = lineHeight;\r\n\t\t} else if (isArray(label)) {\r\n\t\t\t// if it is an array
    let's measure each element\r\n\t\t\tfor (j = 0, jlen = label.length; j < jlen;
    ++j) {\r\n\t\t\t\tnestedLabel = label[j];\r\n\t\t\t\t// Undefined labels and arrays
    should not be measured\r\n\t\t\t\tif (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel))
    {\r\n\t\t\t\t\twidth = helpers$1.measureText(ctx, cache.data, cache.gc, width,
    nestedLabel);\r\n\t\t\t\t\theight += lineHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twidths.push(width);\r\n\t\theights.push(height);\r\n\t\toffsets.push(lineHeight
    / 2);\r\n\t\twidestLabelSize = Math.max(width, widestLabelSize);\r\n\t\thighestLabelSize
    = Math.max(height, highestLabelSize);\r\n\t}\r\n\tgarbageCollect(caches, length);\r\n\r\n\twidest
    = widths.indexOf(widestLabelSize);\r\n\thighest = heights.indexOf(highestLabelSize);\r\n\r\n\tfunction
    valueAt(idx) {\r\n\t\treturn {\r\n\t\t\twidth: widths[idx] || 0,\r\n\t\t\theight:
    heights[idx] || 0,\r\n\t\t\toffset: offsets[idx] || 0\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tfirst: valueAt(0),\r\n\t\tlast: valueAt(length - 1),\r\n\t\twidest: valueAt(widest),\r\n\t\thighest:
    valueAt(highest)\r\n\t};\r\n}\r\n\r\nfunction getTickMarkLength(options) {\r\n\treturn
    options.drawTicks ? options.tickMarkLength : 0;\r\n}\r\n\r\nfunction getScaleLabelHeight(options)
    {\r\n\tvar font, padding;\r\n\r\n\tif (!options.display) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfont
    = helpers$1.options._parseFont(options);\r\n\tpadding = helpers$1.options.toPadding(options.padding);\r\n\r\n\treturn
    font.lineHeight + padding.height;\r\n}\r\n\r\nfunction parseFontOptions(options,
    nestedOpts) {\r\n\treturn helpers$1.extend(helpers$1.options._parseFont({\r\n\t\tfontFamily:
    valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),\r\n\t\tfontSize:
    valueOrDefault$a(nestedOpts.fontSize, options.fontSize),\r\n\t\tfontStyle: valueOrDefault$a(nestedOpts.fontStyle,
    options.fontStyle),\r\n\t\tlineHeight: valueOrDefault$a(nestedOpts.lineHeight,
    options.lineHeight)\r\n\t}), {\r\n\t\tcolor: helpers$1.options.resolve([nestedOpts.fontColor,
    options.fontColor, core_defaults.global.defaultFontColor])\r\n\t});\r\n}\r\n\r\nfunction
    parseTickFontOptions(options) {\r\n\tvar minor = parseFontOptions(options, options.minor);\r\n\tvar
    major = options.major.enabled ? parseFontOptions(options, options.major) : minor;\r\n\r\n\treturn
    {minor: minor, major: major};\r\n}\r\n\r\nfunction nonSkipped(ticksToFilter) {\r\n\tvar
    filtered = [];\r\n\tvar item, index, len;\r\n\tfor (index = 0, len = ticksToFilter.length;
    index < len; ++index) {\r\n\t\titem = ticksToFilter[index];\r\n\t\tif (typeof
    item._index !== 'undefined') {\r\n\t\t\tfiltered.push(item);\r\n\t\t}\r\n\t}\r\n\treturn
    filtered;\r\n}\r\n\r\nfunction getEvenSpacing(arr) {\r\n\tvar len = arr.length;\r\n\tvar
    i, diff;\r\n\r\n\tif (len < 2) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor (diff
    = arr[0], i = 1; i < len; ++i) {\r\n\t\tif (arr[i] - arr[i - 1] !== diff) {\r\n\t\t\treturn
    false;\r\n\t\t}\r\n\t}\r\n\treturn diff;\r\n}\r\n\r\nfunction calculateSpacing(majorIndices,
    ticks, axisLength, ticksLimit) {\r\n\tvar evenMajorSpacing = getEvenSpacing(majorIndices);\r\n\tvar
    spacing = (ticks.length - 1) / ticksLimit;\r\n\tvar factors, factor, i, ilen;\r\n\r\n\t//
    If the major ticks are evenly spaced apart, place the minor ticks\r\n\t// so that
    they divide the major ticks into even chunks\r\n\tif (!evenMajorSpacing) {\r\n\t\treturn
    Math.max(spacing, 1);\r\n\t}\r\n\r\n\tfactors = helpers$1.math._factorize(evenMajorSpacing);\r\n\tfor
    (i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n\t\tfactor = factors[i];\r\n\t\tif
    (factor > spacing) {\r\n\t\t\treturn factor;\r\n\t\t}\r\n\t}\r\n\treturn Math.max(spacing,
    1);\r\n}\r\n\r\nfunction getMajorIndices(ticks) {\r\n\tvar result = [];\r\n\tvar
    i, ilen;\r\n\tfor (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n\t\tif (ticks[i].major)
    {\r\n\t\t\tresult.push(i);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction
    skipMajors(ticks, majorIndices, spacing) {\r\n\tvar count = 0;\r\n\tvar next =
    majorIndices[0];\r\n\tvar i, tick;\r\n\r\n\tspacing = Math.ceil(spacing);\r\n\tfor
    (i = 0; i < ticks.length; i++) {\r\n\t\ttick = ticks[i];\r\n\t\tif (i === next)
    {\r\n\t\t\ttick._index = i;\r\n\t\t\tcount++;\r\n\t\t\tnext = majorIndices[count
    * spacing];\r\n\t\t} else {\r\n\t\t\tdelete tick.label;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction
    skip(ticks, spacing, majorStart, majorEnd) {\r\n\tvar start = valueOrDefault$a(majorStart,
    0);\r\n\tvar end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);\r\n\tvar
    count = 0;\r\n\tvar length, i, tick, next;\r\n\r\n\tspacing = Math.ceil(spacing);\r\n\tif
    (majorEnd) {\r\n\t\tlength = majorEnd - majorStart;\r\n\t\tspacing = length /
    Math.floor(length / spacing);\r\n\t}\r\n\r\n\tnext = start;\r\n\r\n\twhile (next
    < 0) {\r\n\t\tcount++;\r\n\t\tnext = Math.round(start + count * spacing);\r\n\t}\r\n\r\n\tfor
    (i = Math.max(start, 0); i < end; i++) {\r\n\t\ttick = ticks[i];\r\n\t\tif (i
    === next) {\r\n\t\t\ttick._index = i;\r\n\t\t\tcount++;\r\n\t\t\tnext = Math.round(start
    + count * spacing);\r\n\t\t} else {\r\n\t\t\tdelete tick.label;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvar
    Scale = core_element.extend({\r\n\r\n\tzeroLineIndex: 0,\r\n\r\n\t/**\r\n\t *
    Get the padding needed for the scale\r\n\t * @method getPadding\r\n\t * @private\r\n\t
    * @returns {Padding} the necessary padding\r\n\t */\r\n\tgetPadding: function()
    {\r\n\t\tvar me = this;\r\n\t\treturn {\r\n\t\t\tleft: me.paddingLeft || 0,\r\n\t\t\ttop:
    me.paddingTop || 0,\r\n\t\t\tright: me.paddingRight || 0,\r\n\t\t\tbottom: me.paddingBottom
    || 0\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the scale tick objects ({label,
    major})\r\n\t * @since 2.7\r\n\t */\r\n\tgetTicks: function() {\r\n\t\treturn
    this._ticks;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\t_getLabels: function()
    {\r\n\t\tvar data = this.chart.data;\r\n\t\treturn this.options.labels || (this.isHorizontal()
    ? data.xLabels : data.yLabels) || data.labels || [];\r\n\t},\r\n\r\n\t// These
    methods are ordered by lifecyle. Utilities then follow.\r\n\t// Any function defined
    here is inherited by all scale types.\r\n\t// Any function can be extended by
    the scale type\r\n\r\n\t/**\r\n\t * Provided for backward compatibility, not available
    anymore\r\n\t * @function Chart.Scale.mergeTicksOptions\r\n\t * @deprecated since
    version 2.8.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\tmergeTicksOptions:
    function() {\r\n\t\t// noop\r\n\t},\r\n\r\n\tbeforeUpdate: function() {\r\n\t\thelpers$1.callback(this.options.beforeUpdate,
    [this]);\r\n\t},\r\n\r\n\t/**\r\n\t * @param {number} maxWidth - the max width
    in pixels\r\n\t * @param {number} maxHeight - the max height in pixels\r\n\t *
    @param {object} margins - the space between the edge of the other scales and edge
    of the chart\r\n\t *   This space comes from two sources:\r\n\t *     - padding
    - space that's required to show the labels at the edges of the scale\r\n\t *     -
    thickness of scales or legends in another orientation\r\n\t */\r\n\tupdate: function(maxWidth,
    maxHeight, margins) {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    sampleSize = tickOpts.sampleSize;\r\n\t\tvar i, ilen, labels, ticks, samplingEnabled;\r\n\r\n\t\t//
    Update Lifecycle - Probably don't want to ever extend or overwrite this function
    ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth
    = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = helpers$1.extend({\r\n\t\t\tleft:
    0,\r\n\t\t\tright: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tbottom: 0\r\n\t\t}, margins);\r\n\r\n\t\tme._ticks
    = null;\r\n\t\tme.ticks = null;\r\n\t\tme._labelSizes = null;\r\n\t\tme._maxLabelLines
    = 0;\r\n\t\tme.longestLabelWidth = 0;\r\n\t\tme.longestTextCache = me.longestTextCache
    || {};\r\n\t\tme._gridLineItems = null;\r\n\t\tme._labelItems = null;\r\n\r\n\t\t//
    Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\r\n\t\t//
    Data min/max\r\n\t\tme.beforeDataLimits();\r\n\t\tme.determineDataLimits();\r\n\t\tme.afterDataLimits();\r\n\r\n\t\t//
    Ticks - `this.ticks` is now DEPRECATED!\r\n\t\t// Internal ticks are now stored
    as objects in the PRIVATE `this._ticks` member\r\n\t\t// and must not be accessed
    directly from outside this class. `this.ticks` being\r\n\t\t// around for long
    time and not marked as private, we can't change its structure\r\n\t\t// without
    unexpected breaking changes. If you need to access the scale ticks,\r\n\t\t//
    use scale.getTicks() instead.\r\n\r\n\t\tme.beforeBuildTicks();\r\n\r\n\t\t//
    New implementations should return an array of objects but for BACKWARD COMPAT,\r\n\t\t//
    we still support no return (`this.ticks` internally set by calling this method).\r\n\t\tticks
    = me.buildTicks() || [];\r\n\r\n\t\t// Allow modification of ticks in callback.\r\n\t\tticks
    = me.afterBuildTicks(ticks) || ticks;\r\n\r\n\t\t// Ensure ticks contains ticks
    in new tick format\r\n\t\tif ((!ticks || !ticks.length) && me.ticks) {\r\n\t\t\tticks
    = [];\r\n\t\t\tfor (i = 0, ilen = me.ticks.length; i < ilen; ++i) {\r\n\t\t\t\tticks.push({\r\n\t\t\t\t\tvalue:
    me.ticks[i],\r\n\t\t\t\t\tmajor: false\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme._ticks
    = ticks;\r\n\r\n\t\t// Compute tick rotation and fit using a sampled subset of
    labels\r\n\t\t// We generally don't need to compute the size of every single label
    for determining scale size\r\n\t\tsamplingEnabled = sampleSize < ticks.length;\r\n\t\tlabels
    = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);\r\n\r\n\t\t//
    _configure is called twice, once here, once from core.controller.updateLayout.\r\n\t\t//
    Here we haven't been positioned yet, but dimensions are correct.\r\n\t\t// Variables
    set in _configure are needed for calculateTickRotation, and\r\n\t\t// it's ok
    that coordinates are not correct there, only dimensions matter.\r\n\t\tme._configure();\r\n\r\n\t\t//
    Tick Rotation\r\n\t\tme.beforeCalculateTickRotation();\r\n\t\tme.calculateTickRotation();\r\n\t\tme.afterCalculateTickRotation();\r\n\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\r\n\t\t//
    Auto-skip\r\n\t\tme._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source
    === 'auto') ? me._autoSkip(ticks) : ticks;\r\n\r\n\t\tif (samplingEnabled) {\r\n\t\t\t//
    Generate labels using all non-skipped ticks\r\n\t\t\tlabels = me._convertTicksToLabels(me._ticksToDraw);\r\n\t\t}\r\n\r\n\t\tme.ticks
    = labels;   // BACKWARD COMPATIBILITY\r\n\r\n\t\t// IMPORTANT: after this point,
    we consider that `this.ticks` will NEVER change!\r\n\r\n\t\tme.afterUpdate();\r\n\r\n\t\t//
    TODO(v3): remove minSize as a public property and return value from all layout
    boxes. It is unused\r\n\t\t// make maxWidth and maxHeight private\r\n\t\treturn
    me.minSize;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_configure: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar reversePixels = me.options.ticks.reverse;\r\n\t\tvar
    startPixel, endPixel;\r\n\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\tstartPixel
    = me.left;\r\n\t\t\tendPixel = me.right;\r\n\t\t} else {\r\n\t\t\tstartPixel =
    me.top;\r\n\t\t\tendPixel = me.bottom;\r\n\t\t\t// by default vertical scales
    are from bottom to top, so pixels are reversed\r\n\t\t\treversePixels = !reversePixels;\r\n\t\t}\r\n\t\tme._startPixel
    = startPixel;\r\n\t\tme._endPixel = endPixel;\r\n\t\tme._reversePixels = reversePixels;\r\n\t\tme._length
    = endPixel - startPixel;\r\n\t},\r\n\r\n\tafterUpdate: function() {\r\n\t\thelpers$1.callback(this.options.afterUpdate,
    [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions: function() {\r\n\t\thelpers$1.callback(this.options.beforeSetDimensions,
    [this]);\r\n\t},\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t//
    Set the unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal())
    {\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left
    = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom
    = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop
    = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\t},\r\n\tafterSetDimensions:
    function() {\r\n\t\thelpers$1.callback(this.options.afterSetDimensions, [this]);\r\n\t},\r\n\r\n\t//
    Data limits\r\n\tbeforeDataLimits: function() {\r\n\t\thelpers$1.callback(this.options.beforeDataLimits,
    [this]);\r\n\t},\r\n\tdetermineDataLimits: helpers$1.noop,\r\n\tafterDataLimits:
    function() {\r\n\t\thelpers$1.callback(this.options.afterDataLimits, [this]);\r\n\t},\r\n\r\n\t//\r\n\tbeforeBuildTicks:
    function() {\r\n\t\thelpers$1.callback(this.options.beforeBuildTicks, [this]);\r\n\t},\r\n\tbuildTicks:
    helpers$1.noop,\r\n\tafterBuildTicks: function(ticks) {\r\n\t\tvar me = this;\r\n\t\t//
    ticks is empty for old axis implementations here\r\n\t\tif (isArray(ticks) &&
    ticks.length) {\r\n\t\t\treturn helpers$1.callback(me.options.afterBuildTicks,
    [me, ticks]);\r\n\t\t}\r\n\t\t// Support old implementations (that modified `this.ticks`
    directly in buildTicks)\r\n\t\tme.ticks = helpers$1.callback(me.options.afterBuildTicks,
    [me, me.ticks]) || me.ticks;\r\n\t\treturn ticks;\r\n\t},\r\n\r\n\tbeforeTickToLabelConversion:
    function() {\r\n\t\thelpers$1.callback(this.options.beforeTickToLabelConversion,
    [this]);\r\n\t},\r\n\tconvertTicksToLabels: function() {\r\n\t\tvar me = this;\r\n\t\t//
    Convert ticks to strings\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tme.ticks
    = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\r\n\t},\r\n\tafterTickToLabelConversion:
    function() {\r\n\t\thelpers$1.callback(this.options.afterTickToLabelConversion,
    [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeCalculateTickRotation: function()
    {\r\n\t\thelpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\r\n\t},\r\n\tcalculateTickRotation:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    tickOpts = options.ticks;\r\n\t\tvar numTicks = me.getTicks().length;\r\n\t\tvar
    minRotation = tickOpts.minRotation || 0;\r\n\t\tvar maxRotation = tickOpts.maxRotation;\r\n\t\tvar
    labelRotation = minRotation;\r\n\t\tvar labelSizes, maxLabelWidth, maxLabelHeight,
    maxWidth, tickWidth, maxHeight, maxLabelDiagonal;\r\n\r\n\t\tif (!me._isVisible()
    || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal())
    {\r\n\t\t\tme.labelRotation = minRotation;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlabelSizes
    = me._getLabelSizes();\r\n\t\tmaxLabelWidth = labelSizes.widest.width;\r\n\t\tmaxLabelHeight
    = labelSizes.highest.height - labelSizes.highest.offset;\r\n\r\n\t\t// Estimate
    the width of each grid based on the canvas width, the maximum\r\n\t\t// label
    width and the number of tick intervals\r\n\t\tmaxWidth = Math.min(me.maxWidth,
    me.chart.width - maxLabelWidth);\r\n\t\ttickWidth = options.offset ? me.maxWidth
    / numTicks : maxWidth / (numTicks - 1);\r\n\r\n\t\t// Allow 3 pixels x2 padding
    either side for label readability\r\n\t\tif (maxLabelWidth + 6 > tickWidth) {\r\n\t\t\ttickWidth
    = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n\t\t\tmaxHeight = me.maxHeight
    - getTickMarkLength(options.gridLines)\r\n\t\t\t\t- tickOpts.padding - getScaleLabelHeight(options.scaleLabel);\r\n\t\t\tmaxLabelDiagonal
    = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n\t\t\tlabelRotation
    = helpers$1.toDegrees(Math.min(\r\n\t\t\t\tMath.asin(Math.min((labelSizes.highest.height
    + 6) / tickWidth, 1)),\r\n\t\t\t\tMath.asin(Math.min(maxHeight / maxLabelDiagonal,
    1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)\r\n\t\t\t));\r\n\t\t\tlabelRotation
    = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n\t\t}\r\n\r\n\t\tme.labelRotation
    = labelRotation;\r\n\t},\r\n\tafterCalculateTickRotation: function() {\r\n\t\thelpers$1.callback(this.options.afterCalculateTickRotation,
    [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeFit: function() {\r\n\t\thelpers$1.callback(this.options.beforeFit,
    [this]);\r\n\t},\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\t// Reset\r\n\t\tvar
    minSize = me.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\t\tvar
    scaleLabelOpts = opts.scaleLabel;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar
    display = me._isVisible();\r\n\t\tvar isBottom = opts.position === 'bottom';\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\r\n\t\t// Width\r\n\t\tif (isHorizontal)
    {\r\n\t\t\tminSize.width = me.maxWidth;\r\n\t\t} else if (display) {\r\n\t\t\tminSize.width
    = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\r\n\t\t}\r\n\r\n\t\t//
    height\r\n\t\tif (!isHorizontal) {\r\n\t\t\tminSize.height = me.maxHeight; //
    fill all the height\r\n\t\t} else if (display) {\r\n\t\t\tminSize.height = getTickMarkLength(gridLineOpts)
    + getScaleLabelHeight(scaleLabelOpts);\r\n\t\t}\r\n\r\n\t\t// Don't bother fitting
    the ticks if we are not showing the labels\r\n\t\tif (tickOpts.display && display)
    {\r\n\t\t\tvar tickFonts = parseTickFontOptions(tickOpts);\r\n\t\t\tvar labelSizes
    = me._getLabelSizes();\r\n\t\t\tvar firstLabelSize = labelSizes.first;\r\n\t\t\tvar
    lastLabelSize = labelSizes.last;\r\n\t\t\tvar widestLabelSize = labelSizes.widest;\r\n\t\t\tvar
    highestLabelSize = labelSizes.highest;\r\n\t\t\tvar lineSpace = tickFonts.minor.lineHeight
    * 0.4;\r\n\t\t\tvar tickPadding = tickOpts.padding;\r\n\r\n\t\t\tif (isHorizontal)
    {\r\n\t\t\t\t// A horizontal axis is more constrained by the height.\r\n\t\t\t\tvar
    isRotated = me.labelRotation !== 0;\r\n\t\t\t\tvar angleRadians = helpers$1.toRadians(me.labelRotation);\r\n\t\t\t\tvar
    cosRotation = Math.cos(angleRadians);\r\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\tvar
    labelHeight = sinRotation * widestLabelSize.width\r\n\t\t\t\t\t+ cosRotation *
    (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0))\r\n\t\t\t\t\t+
    (isRotated ? 0 : lineSpace); // padding\r\n\r\n\t\t\t\tminSize.height = Math.min(me.maxHeight,
    minSize.height + labelHeight + tickPadding);\r\n\r\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0)
    - me.left;\r\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(me.getTicks().length
    - 1);\r\n\t\t\t\tvar paddingLeft, paddingRight;\r\n\r\n\t\t\t\t// Ensure that
    our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n\t\t\t\t//
    which means that the right padding is dominated by the font height\r\n\t\t\t\tif
    (isRotated) {\r\n\t\t\t\t\tpaddingLeft = isBottom ?\r\n\t\t\t\t\t\tcosRotation
    * firstLabelSize.width + sinRotation * firstLabelSize.offset :\r\n\t\t\t\t\t\tsinRotation
    * (firstLabelSize.height - firstLabelSize.offset);\r\n\t\t\t\t\tpaddingRight =
    isBottom ?\r\n\t\t\t\t\t\tsinRotation * (lastLabelSize.height - lastLabelSize.offset)
    :\r\n\t\t\t\t\t\tcosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\tpaddingLeft = firstLabelSize.width / 2;\r\n\t\t\t\t\tpaddingRight
    = lastLabelSize.width / 2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Adjust padding taking
    into account changes in offsets\r\n\t\t\t\t// and add 3 px to move away from canvas
    edges\r\n\t\t\t\tme.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width
    / (me.width - offsetLeft), 0) + 3;\r\n\t\t\t\tme.paddingRight = Math.max((paddingRight
    - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;\r\n\t\t\t} else
    {\r\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\r\n\t\t\t\t//
    dominant factor here, so get that length first and account for padding\r\n\t\t\t\tvar
    labelWidth = tickOpts.mirror ? 0 :\r\n\t\t\t\t\t// use lineSpace for consistency
    with horizontal axis\r\n\t\t\t\t\t// tickPadding is not implemented for horizontal\r\n\t\t\t\t\twidestLabelSize.width
    + tickPadding + lineSpace;\r\n\r\n\t\t\t\tminSize.width = Math.min(me.maxWidth,
    minSize.width + labelWidth);\r\n\r\n\t\t\t\tme.paddingTop = firstLabelSize.height
    / 2;\r\n\t\t\t\tme.paddingBottom = lastLabelSize.height / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.handleMargins();\r\n\r\n\t\tif
    (isHorizontal) {\r\n\t\t\tme.width = me._length = chart.width - me.margins.left
    - me.margins.right;\r\n\t\t\tme.height = minSize.height;\r\n\t\t} else {\r\n\t\t\tme.width
    = minSize.width;\r\n\t\t\tme.height = me._length = chart.height - me.margins.top
    - me.margins.bottom;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Handle margins and
    padding interactions\r\n\t * @private\r\n\t */\r\n\thandleMargins: function()
    {\r\n\t\tvar me = this;\r\n\t\tif (me.margins) {\r\n\t\t\tme.margins.left = Math.max(me.paddingLeft,
    me.margins.left);\r\n\t\t\tme.margins.top = Math.max(me.paddingTop, me.margins.top);\r\n\t\t\tme.margins.right
    = Math.max(me.paddingRight, me.margins.right);\r\n\t\t\tme.margins.bottom = Math.max(me.paddingBottom,
    me.margins.bottom);\r\n\t\t}\r\n\t},\r\n\r\n\tafterFit: function() {\r\n\t\thelpers$1.callback(this.options.afterFit,
    [this]);\r\n\t},\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\tvar
    pos = this.options.position;\r\n\t\treturn pos === 'top' || pos === 'bottom';\r\n\t},\r\n\tisFullWidth:
    function() {\r\n\t\treturn this.options.fullWidth;\r\n\t},\r\n\r\n\t// Get the
    correct value. NaN bad inputs, If the value type is object get the x or y based
    on whether we are horizontal or not\r\n\tgetRightValue: function(rawValue) {\r\n\t\t//
    Null and undefined values first\r\n\t\tif (isNullOrUndef(rawValue)) {\r\n\t\t\treturn
    NaN;\r\n\t\t}\r\n\t\t// isNaN(object) returns true, so make sure NaN is checking
    for a number; Discard Infinite values\r\n\t\tif ((typeof rawValue === 'number'
    || rawValue instanceof Number) && !isFinite(rawValue)) {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\r\n\t\t//
    If it is in fact an object, dive in one more level\r\n\t\tif (rawValue) {\r\n\t\t\tif
    (this.isHorizontal()) {\r\n\t\t\t\tif (rawValue.x !== undefined) {\r\n\t\t\t\t\treturn
    this.getRightValue(rawValue.x);\r\n\t\t\t\t}\r\n\t\t\t} else if (rawValue.y !==
    undefined) {\r\n\t\t\t\treturn this.getRightValue(rawValue.y);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//
    Value is good, return it\r\n\t\treturn rawValue;\r\n\t},\r\n\r\n\t_convertTicksToLabels:
    function(ticks) {\r\n\t\tvar me = this;\r\n\t\tvar labels, i, ilen;\r\n\r\n\t\tme.ticks
    = ticks.map(function(tick) {\r\n\t\t\treturn tick.value;\r\n\t\t});\r\n\r\n\t\tme.beforeTickToLabelConversion();\r\n\r\n\t\t//
    New implementations should return the formatted tick labels but for BACKWARD\r\n\t\t//
    COMPAT, we still support no return (`this.ticks` internally changed by calling\r\n\t\t//
    this method and supposed to contain only string values).\r\n\t\tlabels = me.convertTicksToLabels(ticks)
    || me.ticks;\r\n\r\n\t\tme.afterTickToLabelConversion();\r\n\r\n\t\t// BACKWARD
    COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\r\n\t\tfor
    (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\tticks[i].label = labels[i];\r\n\t\t}\r\n\r\n\t\treturn
    labels;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLabelSizes: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar labelSizes = me._labelSizes;\r\n\r\n\t\tif
    (!labelSizes) {\r\n\t\t\tme._labelSizes = labelSizes = computeLabelSizes(me.ctx,
    parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);\r\n\t\t\tme.longestLabelWidth
    = labelSizes.widest.width;\r\n\t\t}\r\n\r\n\t\treturn labelSizes;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_parseValue: function(value) {\r\n\t\tvar start, end,
    min, max;\r\n\r\n\t\tif (isArray(value)) {\r\n\t\t\tstart = +this.getRightValue(value[0]);\r\n\t\t\tend
    = +this.getRightValue(value[1]);\r\n\t\t\tmin = Math.min(start, end);\r\n\t\t\tmax
    = Math.max(start, end);\r\n\t\t} else {\r\n\t\t\tvalue = +this.getRightValue(value);\r\n\t\t\tstart
    = undefined;\r\n\t\t\tend = value;\r\n\t\t\tmin = value;\r\n\t\t\tmax = value;\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tmin: min,\r\n\t\t\tmax: max,\r\n\t\t\tstart: start,\r\n\t\t\tend: end\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t*
    @private\r\n\t*/\r\n\t_getScaleLabel: function(rawValue) {\r\n\t\tvar v = this._parseValue(rawValue);\r\n\t\tif
    (v.start !== undefined) {\r\n\t\t\treturn '[' + v.start + ', ' + v.end + ']';\r\n\t\t}\r\n\r\n\t\treturn
    +this.getRightValue(rawValue);\r\n\t},\r\n\r\n\t/**\r\n\t * Used to get the value
    to display in the tooltip for the data at the given index\r\n\t * @param index\r\n\t
    * @param datasetIndex\r\n\t */\r\n\tgetLabelForIndex: helpers$1.noop,\r\n\r\n\t/**\r\n\t
    * Returns the location of the given data point. Value can either be an index or
    a numerical value\r\n\t * The coordinate (0, 0) is at the upper-left corner of
    the canvas\r\n\t * @param value\r\n\t * @param index\r\n\t * @param datasetIndex\r\n\t
    */\r\n\tgetPixelForValue: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Used to get the
    data value from a given pixel. This is the inverse of getPixelForValue\r\n\t *
    The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param
    pixel\r\n\t */\r\n\tgetValueForPixel: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Returns
    the location of the tick at the given index\r\n\t * The coordinate (0, 0) is at
    the upper-left corner of the canvas\r\n\t */\r\n\tgetPixelForTick: function(index)
    {\r\n\t\tvar me = this;\r\n\t\tvar offset = me.options.offset;\r\n\t\tvar numTicks
    = me._ticks.length;\r\n\t\tvar tickWidth = 1 / Math.max(numTicks - (offset ? 0
    : 1), 1);\r\n\r\n\t\treturn index < 0 || index > numTicks - 1\r\n\t\t\t? null\r\n\t\t\t:
    me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));\r\n\t},\r\n\r\n\t/**\r\n\t
    * Utility for getting the pixel location of a percentage of scale\r\n\t * The
    coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t */\r\n\tgetPixelForDecimal:
    function(decimal) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (me._reversePixels) {\r\n\t\t\tdecimal
    = 1 - decimal;\r\n\t\t}\r\n\r\n\t\treturn me._startPixel + decimal * me._length;\r\n\t},\r\n\r\n\tgetDecimalForPixel:
    function(pixel) {\r\n\t\tvar decimal = (pixel - this._startPixel) / this._length;\r\n\t\treturn
    this._reversePixels ? 1 - decimal : decimal;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns
    the pixel for the minimum chart value\r\n\t * The coordinate (0, 0) is at the
    upper-left corner of the canvas\r\n\t */\r\n\tgetBasePixel: function() {\r\n\t\treturn
    this.getPixelForValue(this.getBaseValue());\r\n\t},\r\n\r\n\tgetBaseValue: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\r\n\t\treturn
    me.beginAtZero ? 0 :\r\n\t\t\tmin < 0 && max < 0 ? max :\r\n\t\t\tmin > 0 && max
    > 0 ? min :\r\n\t\t\t0;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a subset of ticks
    to be plotted to avoid overlapping labels.\r\n\t * @private\r\n\t */\r\n\t_autoSkip:
    function(ticks) {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    axisLength = me._length;\r\n\t\tvar ticksLimit = tickOpts.maxTicksLimit || axisLength
    / me._tickSize() + 1;\r\n\t\tvar majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks)
    : [];\r\n\t\tvar numMajorIndices = majorIndices.length;\r\n\t\tvar first = majorIndices[0];\r\n\t\tvar
    last = majorIndices[numMajorIndices - 1];\r\n\t\tvar i, ilen, spacing, avgMajorSpacing;\r\n\r\n\t\t//
    If there are too many major ticks to display them all\r\n\t\tif (numMajorIndices
    > ticksLimit) {\r\n\t\t\tskipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);\r\n\t\t\treturn
    nonSkipped(ticks);\r\n\t\t}\r\n\r\n\t\tspacing = calculateSpacing(majorIndices,
    ticks, axisLength, ticksLimit);\r\n\r\n\t\tif (numMajorIndices > 0) {\r\n\t\t\tfor
    (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n\t\t\t\tskip(ticks, spacing,
    majorIndices[i], majorIndices[i + 1]);\r\n\t\t\t}\r\n\t\t\tavgMajorSpacing = numMajorIndices
    > 1 ? (last - first) / (numMajorIndices - 1) : null;\r\n\t\t\tskip(ticks, spacing,
    helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n\t\t\tskip(ticks,
    spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last
    + avgMajorSpacing);\r\n\t\t\treturn nonSkipped(ticks);\r\n\t\t}\r\n\t\tskip(ticks,
    spacing);\r\n\t\treturn nonSkipped(ticks);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_tickSize: function() {\r\n\t\tvar me = this;\r\n\t\tvar optionTicks =
    me.options.ticks;\r\n\r\n\t\t// Calculate space needed by label in axis direction.\r\n\t\tvar
    rot = helpers$1.toRadians(me.labelRotation);\r\n\t\tvar cos = Math.abs(Math.cos(rot));\r\n\t\tvar
    sin = Math.abs(Math.sin(rot));\r\n\r\n\t\tvar labelSizes = me._getLabelSizes();\r\n\t\tvar
    padding = optionTicks.autoSkipPadding || 0;\r\n\t\tvar w = labelSizes ? labelSizes.widest.width
    + padding : 0;\r\n\t\tvar h = labelSizes ? labelSizes.highest.height + padding
    : 0;\r\n\r\n\t\t// Calculate space needed for 1 tick in axis direction.\r\n\t\treturn
    me.isHorizontal()\r\n\t\t\t? h * cos > w * sin ? w / cos : h / sin\r\n\t\t\t:
    h * sin < w * cos ? h / cos : w / sin;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_isVisible: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    display = me.options.display;\r\n\t\tvar i, ilen, meta;\r\n\r\n\t\tif (display
    !== 'auto') {\r\n\t\t\treturn !!display;\r\n\t\t}\r\n\r\n\t\t// When 'auto', the
    scale is visible if at least one associated dataset is visible.\r\n\t\tfor (i
    = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tif (chart.isDatasetVisible(i))
    {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tif (meta.xAxisID === me.id
    || meta.yAxisID === me.id) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    false;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeGridLineItems:
    function(chartArea) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    options = me.options;\r\n\t\tvar gridLines = options.gridLines;\r\n\t\tvar position
    = options.position;\r\n\t\tvar offsetGridLines = gridLines.offsetGridLines;\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\tvar ticks = me._ticksToDraw;\r\n\t\tvar
    ticksLength = ticks.length + (offsetGridLines ? 1 : 0);\r\n\r\n\t\tvar tl = getTickMarkLength(gridLines);\r\n\t\tvar
    items = [];\r\n\t\tvar axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth,
    0, 0) : 0;\r\n\t\tvar axisHalfWidth = axisWidth / 2;\r\n\t\tvar alignPixel = helpers$1._alignPixel;\r\n\t\tvar
    alignBorderValue = function(pixel) {\r\n\t\t\treturn alignPixel(chart, pixel,
    axisWidth);\r\n\t\t};\r\n\t\tvar borderValue, i, tick, lineValue, alignedLineValue;\r\n\t\tvar
    tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;\r\n\r\n\t\tif
    (position === 'top') {\r\n\t\t\tborderValue = alignBorderValue(me.bottom);\r\n\t\t\tty1
    = me.bottom - tl;\r\n\t\t\tty2 = borderValue - axisHalfWidth;\r\n\t\t\ty1 = alignBorderValue(chartArea.top)
    + axisHalfWidth;\r\n\t\t\ty2 = chartArea.bottom;\r\n\t\t} else if (position ===
    'bottom') {\r\n\t\t\tborderValue = alignBorderValue(me.top);\r\n\t\t\ty1 = chartArea.top;\r\n\t\t\ty2
    = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n\t\t\tty1 = borderValue
    + axisHalfWidth;\r\n\t\t\tty2 = me.top + tl;\r\n\t\t} else if (position === 'left')
    {\r\n\t\t\tborderValue = alignBorderValue(me.right);\r\n\t\t\ttx1 = me.right -
    tl;\r\n\t\t\ttx2 = borderValue - axisHalfWidth;\r\n\t\t\tx1 = alignBorderValue(chartArea.left)
    + axisHalfWidth;\r\n\t\t\tx2 = chartArea.right;\r\n\t\t} else {\r\n\t\t\tborderValue
    = alignBorderValue(me.left);\r\n\t\t\tx1 = chartArea.left;\r\n\t\t\tx2 = alignBorderValue(chartArea.right)
    - axisHalfWidth;\r\n\t\t\ttx1 = borderValue + axisHalfWidth;\r\n\t\t\ttx2 = me.left
    + tl;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < ticksLength; ++i) {\r\n\t\t\ttick =
    ticks[i] || {};\r\n\r\n\t\t\t// autoskipper skipped this tick (#4635)\r\n\t\t\tif
    (isNullOrUndef(tick.label) && i < ticks.length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (i === me.zeroLineIndex && options.offset === offsetGridLines) {\r\n\t\t\t\t//
    Draw the first index specially\r\n\t\t\t\tlineWidth = gridLines.zeroLineWidth;\r\n\t\t\t\tlineColor
    = gridLines.zeroLineColor;\r\n\t\t\t\tborderDash = gridLines.zeroLineBorderDash
    || [];\r\n\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\r\n\t\t\t}
    else {\r\n\t\t\t\tlineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);\r\n\t\t\t\tlineColor
    = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');\r\n\t\t\t\tborderDash
    = gridLines.borderDash || [];\r\n\t\t\t\tborderDashOffset = gridLines.borderDashOffset
    || 0.0;\r\n\t\t\t}\r\n\r\n\t\t\tlineValue = getPixelForGridLine(me, tick._index
    || i, offsetGridLines);\r\n\r\n\t\t\t// Skip if the pixel is out of the range\r\n\t\t\tif
    (lineValue === undefined) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\talignedLineValue
    = alignPixel(chart, lineValue, lineWidth);\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\ttx1
    = tx2 = x1 = x2 = alignedLineValue;\r\n\t\t\t} else {\r\n\t\t\t\tty1 = ty2 = y1
    = y2 = alignedLineValue;\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\ttx1:
    tx1,\r\n\t\t\t\tty1: ty1,\r\n\t\t\t\ttx2: tx2,\r\n\t\t\t\tty2: ty2,\r\n\t\t\t\tx1:
    x1,\r\n\t\t\t\ty1: y1,\r\n\t\t\t\tx2: x2,\r\n\t\t\t\ty2: y2,\r\n\t\t\t\twidth:
    lineWidth,\r\n\t\t\t\tcolor: lineColor,\r\n\t\t\t\tborderDash: borderDash,\r\n\t\t\t\tborderDashOffset:
    borderDashOffset,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\titems.ticksLength = ticksLength;\r\n\t\titems.borderValue
    = borderValue;\r\n\r\n\t\treturn items;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_computeLabelItems: function() {\r\n\t\tvar me = this;\r\n\t\tvar options
    = me.options;\r\n\t\tvar optionTicks = options.ticks;\r\n\t\tvar position = options.position;\r\n\t\tvar
    isMirrored = optionTicks.mirror;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tvar
    ticks = me._ticksToDraw;\r\n\t\tvar fonts = parseTickFontOptions(optionTicks);\r\n\t\tvar
    tickPadding = optionTicks.padding;\r\n\t\tvar tl = getTickMarkLength(options.gridLines);\r\n\t\tvar
    rotation = -helpers$1.toRadians(me.labelRotation);\r\n\t\tvar items = [];\r\n\t\tvar
    i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n\r\n\t\tif
    (position === 'top') {\r\n\t\t\ty = me.bottom - tl - tickPadding;\r\n\t\t\ttextAlign
    = !rotation ? 'center' : 'left';\r\n\t\t} else if (position === 'bottom') {\r\n\t\t\ty
    = me.top + tl + tickPadding;\r\n\t\t\ttextAlign = !rotation ? 'center' : 'right';\r\n\t\t}
    else if (position === 'left') {\r\n\t\t\tx = me.right - (isMirrored ? 0 : tl)
    - tickPadding;\r\n\t\t\ttextAlign = isMirrored ? 'left' : 'right';\r\n\t\t} else
    {\r\n\t\t\tx = me.left + (isMirrored ? 0 : tl) + tickPadding;\r\n\t\t\ttextAlign
    = isMirrored ? 'right' : 'left';\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = ticks.length;
    i < ilen; ++i) {\r\n\t\t\ttick = ticks[i];\r\n\t\t\tlabel = tick.label;\r\n\r\n\t\t\t//
    autoskipper skipped this tick (#4635)\r\n\t\t\tif (isNullOrUndef(label)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpixel
    = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;\r\n\t\t\tfont
    = tick.major ? fonts.major : fonts.minor;\r\n\t\t\tlineHeight = font.lineHeight;\r\n\t\t\tlineCount
    = isArray(label) ? label.length : 1;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tx
    = pixel;\r\n\t\t\t\ttextOffset = position === 'top'\r\n\t\t\t\t\t? ((!rotation
    ? 0.5 : 1) - lineCount) * lineHeight\r\n\t\t\t\t\t: (!rotation ? 0.5 : 0) * lineHeight;\r\n\t\t\t}
    else {\r\n\t\t\t\ty = pixel;\r\n\t\t\t\ttextOffset = (1 - lineCount) * lineHeight
    / 2;\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y,\r\n\t\t\t\trotation:
    rotation,\r\n\t\t\t\tlabel: label,\r\n\t\t\t\tfont: font,\r\n\t\t\t\ttextOffset:
    textOffset,\r\n\t\t\t\ttextAlign: textAlign\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn
    items;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawGrid: function(chartArea)
    {\r\n\t\tvar me = this;\r\n\t\tvar gridLines = me.options.gridLines;\r\n\r\n\t\tif
    (!gridLines.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar alignPixel = helpers$1._alignPixel;\r\n\t\tvar axisWidth
    = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\r\n\t\tvar
    items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\r\n\t\tvar
    width, color, i, ilen, item;\r\n\r\n\t\tfor (i = 0, ilen = items.length; i < ilen;
    ++i) {\r\n\t\t\titem = items[i];\r\n\t\t\twidth = item.width;\r\n\t\t\tcolor =
    item.color;\r\n\r\n\t\t\tif (width && color) {\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.lineWidth
    = width;\r\n\t\t\t\tctx.strokeStyle = color;\r\n\t\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t\tctx.setLineDash(item.borderDash);\r\n\t\t\t\t\tctx.lineDashOffset
    = item.borderDashOffset;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.beginPath();\r\n\r\n\t\t\t\tif
    (gridLines.drawTicks) {\r\n\t\t\t\t\tctx.moveTo(item.tx1, item.ty1);\r\n\t\t\t\t\tctx.lineTo(item.tx2,
    item.ty2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (gridLines.drawOnChartArea) {\r\n\t\t\t\t\tctx.moveTo(item.x1,
    item.y1);\r\n\t\t\t\t\tctx.lineTo(item.x2, item.y2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.stroke();\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (axisWidth) {\r\n\t\t\t// Draw the line at the edge of the axis\r\n\t\t\tvar firstLineWidth
    = axisWidth;\r\n\t\t\tvar lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth,
    items.ticksLength - 1, 1);\r\n\t\t\tvar borderValue = items.borderValue;\r\n\t\t\tvar
    x1, x2, y1, y2;\r\n\r\n\t\t\tif (me.isHorizontal()) {\r\n\t\t\t\tx1 = alignPixel(chart,
    me.left, firstLineWidth) - firstLineWidth / 2;\r\n\t\t\t\tx2 = alignPixel(chart,
    me.right, lastLineWidth) + lastLineWidth / 2;\r\n\t\t\t\ty1 = y2 = borderValue;\r\n\t\t\t}
    else {\r\n\t\t\t\ty1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth
    / 2;\r\n\t\t\t\ty2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth
    / 2;\r\n\t\t\t\tx1 = x2 = borderValue;\r\n\t\t\t}\r\n\r\n\t\t\tctx.lineWidth =
    axisWidth;\r\n\t\t\tctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.moveTo(x1,
    y1);\r\n\t\t\tctx.lineTo(x2, y2);\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    optionTicks = me.options.ticks;\r\n\r\n\t\tif (!optionTicks.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar items = me._labelItems || (me._labelItems = me._computeLabelItems());\r\n\t\tvar
    i, j, ilen, jlen, item, tickFont, label, y;\r\n\r\n\t\tfor (i = 0, ilen = items.length;
    i < ilen; ++i) {\r\n\t\t\titem = items[i];\r\n\t\t\ttickFont = item.font;\r\n\r\n\t\t\t//
    Make sure we draw text in the correct color and font\r\n\t\t\tctx.save();\r\n\t\t\tctx.translate(item.x,
    item.y);\r\n\t\t\tctx.rotate(item.rotation);\r\n\t\t\tctx.font = tickFont.string;\r\n\t\t\tctx.fillStyle
    = tickFont.color;\r\n\t\t\tctx.textBaseline = 'middle';\r\n\t\t\tctx.textAlign
    = item.textAlign;\r\n\r\n\t\t\tlabel = item.label;\r\n\t\t\ty = item.textOffset;\r\n\t\t\tif
    (isArray(label)) {\r\n\t\t\t\tfor (j = 0, jlen = label.length; j < jlen; ++j)
    {\r\n\t\t\t\t\t// We just make sure the multiline element is a string here..\r\n\t\t\t\t\tctx.fillText(''
    + label[j], 0, y);\r\n\t\t\t\t\ty += tickFont.lineHeight;\r\n\t\t\t\t}\r\n\t\t\t}
    else {\r\n\t\t\t\tctx.fillText(label, 0, y);\r\n\t\t\t}\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar options = me.options;\r\n\t\tvar scaleLabel = options.scaleLabel;\r\n\r\n\t\tif
    (!scaleLabel.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar scaleLabelFontColor
    = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);\r\n\t\tvar
    scaleLabelFont = helpers$1.options._parseFont(scaleLabel);\r\n\t\tvar scaleLabelPadding
    = helpers$1.options.toPadding(scaleLabel.padding);\r\n\t\tvar halfLineHeight =
    scaleLabelFont.lineHeight / 2;\r\n\t\tvar position = options.position;\r\n\t\tvar
    rotation = 0;\r\n\t\tvar scaleLabelX, scaleLabelY;\r\n\r\n\t\tif (me.isHorizontal())
    {\r\n\t\t\tscaleLabelX = me.left + me.width / 2; // midpoint of the width\r\n\t\t\tscaleLabelY
    = position === 'bottom'\r\n\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\r\n\t\t\t\t:
    me.top + halfLineHeight + scaleLabelPadding.top;\r\n\t\t} else {\r\n\t\t\tvar
    isLeft = position === 'left';\r\n\t\t\tscaleLabelX = isLeft\r\n\t\t\t\t? me.left
    + halfLineHeight + scaleLabelPadding.top\r\n\t\t\t\t: me.right - halfLineHeight
    - scaleLabelPadding.top;\r\n\t\t\tscaleLabelY = me.top + me.height / 2;\r\n\t\t\trotation
    = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(scaleLabelX,
    scaleLabelY);\r\n\t\tctx.rotate(rotation);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline
    = 'middle';\r\n\t\tctx.fillStyle = scaleLabelFontColor; // render in correct colour\r\n\t\tctx.font
    = scaleLabelFont.string;\r\n\t\tctx.fillText(scaleLabel.labelString, 0, 0);\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tdraw:
    function(chartArea) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (!me._isVisible()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme._drawGrid(chartArea);\r\n\t\tme._drawTitle();\r\n\t\tme._drawLabels();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_layers: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    opts = me.options;\r\n\t\tvar tz = opts.ticks && opts.ticks.z || 0;\r\n\t\tvar
    gz = opts.gridLines && opts.gridLines.z || 0;\r\n\r\n\t\tif (!me._isVisible()
    || tz === gz || me.draw !== me._draw) {\r\n\t\t\t// backward compatibility: draw
    has been overridden by custom scale\r\n\t\t\treturn [{\r\n\t\t\t\tz: tz,\r\n\t\t\t\tdraw:
    function() {\r\n\t\t\t\t\tme.draw.apply(me, arguments);\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t}\r\n\r\n\t\treturn
    [{\r\n\t\t\tz: gz,\r\n\t\t\tdraw: function() {\r\n\t\t\t\tme._drawGrid.apply(me,
    arguments);\r\n\t\t\t\tme._drawTitle.apply(me, arguments);\r\n\t\t\t}\r\n\t\t},
    {\r\n\t\t\tz: tz,\r\n\t\t\tdraw: function() {\r\n\t\t\t\tme._drawLabels.apply(me,
    arguments);\r\n\t\t\t}\r\n\t\t}];\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_getMatchingVisibleMetas: function(type) {\r\n\t\tvar me = this;\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\treturn me.chart._getSortedVisibleDatasetMetas()\r\n\t\t\t.filter(function(meta)
    {\r\n\t\t\t\treturn (!type || meta.type === type)\r\n\t\t\t\t\t&& (isHorizontal
    ? meta.xAxisID === me.id : meta.yAxisID === me.id);\r\n\t\t\t});\r\n\t}\r\n});\r\n\r\nScale.prototype._draw
    = Scale.prototype.draw;\r\n\r\nvar core_scale = Scale;\n\nvar isNullOrUndef$1
    = helpers$1.isNullOrUndef;\r\n\r\nvar defaultConfig = {\r\n\tposition: 'bottom'\r\n};\r\n\r\nvar
    scale_category = core_scale.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar labels = me._getLabels();\r\n\t\tvar ticksOpts = me.options.ticks;\r\n\t\tvar
    min = ticksOpts.min;\r\n\t\tvar max = ticksOpts.max;\r\n\t\tvar minIndex = 0;\r\n\t\tvar
    maxIndex = labels.length - 1;\r\n\t\tvar findIndex;\r\n\r\n\t\tif (min !== undefined)
    {\r\n\t\t\t// user specified min value\r\n\t\t\tfindIndex = labels.indexOf(min);\r\n\t\t\tif
    (findIndex >= 0) {\r\n\t\t\t\tminIndex = findIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (max !== undefined) {\r\n\t\t\t// user specified max value\r\n\t\t\tfindIndex
    = labels.indexOf(max);\r\n\t\t\tif (findIndex >= 0) {\r\n\t\t\t\tmaxIndex = findIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.minIndex
    = minIndex;\r\n\t\tme.maxIndex = maxIndex;\r\n\t\tme.min = labels[minIndex];\r\n\t\tme.max
    = labels[maxIndex];\r\n\t},\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me =
    this;\r\n\t\tvar labels = me._getLabels();\r\n\t\tvar minIndex = me.minIndex;\r\n\t\tvar
    maxIndex = me.maxIndex;\r\n\r\n\t\t// If we are viewing some subset of labels,
    slice the original array\r\n\t\tme.ticks = (minIndex === 0 && maxIndex === labels.length
    - 1) ? labels : labels.slice(minIndex, maxIndex + 1);\r\n\t},\r\n\r\n\tgetLabelForIndex:
    function(index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\r\n\t\tif
    (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\r\n\t\t\treturn
    me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\r\n\t\t}\r\n\r\n\t\treturn
    me._getLabels()[index];\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar offset = me.options.offset;\r\n\t\tvar ticks = me.ticks;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif
    (!me.isHorizontal()) {\r\n\t\t\t// For backward compatibility, vertical category
    scale reverse is inverted.\r\n\t\t\tme._reversePixels = !me._reversePixels;\r\n\t\t}\r\n\r\n\t\tif
    (!ticks) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme._startValue = me.minIndex -
    (offset ? 0.5 : 0);\r\n\t\tme._valueRange = Math.max(ticks.length - (offset ?
    0 : 1), 1);\r\n\t},\r\n\r\n\t// Used to get data value locations.  Value can either
    be an index or a numerical value\r\n\tgetPixelForValue: function(value, index,
    datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar valueCategory, labels, idx;\r\n\r\n\t\tif
    (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {\r\n\t\t\tvalue =
    me.chart.data.datasets[datasetIndex].data[index];\r\n\t\t}\r\n\r\n\t\t// If value
    is a data object, then index is the index in the data array,\r\n\t\t// not the
    index of the scale. We need to change that.\r\n\t\tif (!isNullOrUndef$1(value))
    {\r\n\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\r\n\t\t}\r\n\t\tif
    (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\r\n\t\t\tlabels
    = me._getLabels();\r\n\t\t\tvalue = helpers$1.valueOrDefault(valueCategory, value);\r\n\t\t\tidx
    = labels.indexOf(value);\r\n\t\t\tindex = idx !== -1 ? idx : index;\r\n\t\t\tif
    (isNaN(index)) {\r\n\t\t\t\tindex = value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn me.getPixelForDecimal((index
    - me._startValue) / me._valueRange);\r\n\t},\r\n\r\n\tgetPixelForTick: function(index)
    {\r\n\t\tvar ticks = this.ticks;\r\n\t\treturn index < 0 || index > ticks.length
    - 1\r\n\t\t\t? null\r\n\t\t\t: this.getPixelForValue(ticks[index], index + this.minIndex);\r\n\t},\r\n\r\n\tgetValueForPixel:
    function(pixel) {\r\n\t\tvar me = this;\r\n\t\tvar value = Math.round(me._startValue
    + me.getDecimalForPixel(pixel) * me._valueRange);\r\n\t\treturn Math.min(Math.max(value,
    0), me.ticks.length - 1);\r\n\t},\r\n\r\n\tgetBasePixel: function() {\r\n\t\treturn
    this.bottom;\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options, registered
    in src/index.js\r\nvar _defaults = defaultConfig;\nscale_category._defaults =
    _defaults;\n\nvar noop = helpers$1.noop;\r\nvar isNullOrUndef$2 = helpers$1.isNullOrUndef;\r\n\r\n/**\r\n
    * Generate a set of linear ticks\r\n * @param generationOptions the options used
    to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns
    {number[]} array of tick values\r\n */\r\nfunction generateTicks(generationOptions,
    dataRange) {\r\n\tvar ticks = [];\r\n\t// To get a \"nice\" value for the tick
    spacing, we will use the appropriately named\r\n\t// \"nice number\" algorithm.
    See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\r\n\t//
    for details.\r\n\r\n\tvar MIN_SPACING = 1e-14;\r\n\tvar stepSize = generationOptions.stepSize;\r\n\tvar
    unit = stepSize || 1;\r\n\tvar maxNumSpaces = generationOptions.maxTicks - 1;\r\n\tvar
    min = generationOptions.min;\r\n\tvar max = generationOptions.max;\r\n\tvar precision
    = generationOptions.precision;\r\n\tvar rmin = dataRange.min;\r\n\tvar rmax =
    dataRange.max;\r\n\tvar spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces
    / unit) * unit;\r\n\tvar factor, niceMin, niceMax, numSpaces;\r\n\r\n\t// Beyond
    MIN_SPACING floating point numbers being to lose precision\r\n\t// such that we
    can't do the math necessary to generate ticks\r\n\tif (spacing < MIN_SPACING &&
    isNullOrUndef$2(min) && isNullOrUndef$2(max)) {\r\n\t\treturn [rmin, rmax];\r\n\t}\r\n\r\n\tnumSpaces
    = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n\tif (numSpaces >
    maxNumSpaces) {\r\n\t\t// If the calculated num of spaces exceeds maxNumSpaces,
    recalculate it\r\n\t\tspacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces
    / unit) * unit;\r\n\t}\r\n\r\n\tif (stepSize || isNullOrUndef$2(precision)) {\r\n\t\t//
    If a precision is not specified, calculate factor based on spacing\r\n\t\tfactor
    = Math.pow(10, helpers$1._decimalPlaces(spacing));\r\n\t} else {\r\n\t\t// If
    the user specified a precision, round to that number of decimal places\r\n\t\tfactor
    = Math.pow(10, precision);\r\n\t\tspacing = Math.ceil(spacing * factor) / factor;\r\n\t}\r\n\r\n\tniceMin
    = Math.floor(rmin / spacing) * spacing;\r\n\tniceMax = Math.ceil(rmax / spacing)
    * spacing;\r\n\r\n\t// If min, max and stepSize is set and they make an evenly
    spaced scale use it.\r\n\tif (stepSize) {\r\n\t\t// If very close to our whole
    number, use it.\r\n\t\tif (!isNullOrUndef$2(min) && helpers$1.almostWhole(min
    / spacing, spacing / 1000)) {\r\n\t\t\tniceMin = min;\r\n\t\t}\r\n\t\tif (!isNullOrUndef$2(max)
    && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\r\n\t\t\tniceMax =
    max;\r\n\t\t}\r\n\t}\r\n\r\n\tnumSpaces = (niceMax - niceMin) / spacing;\r\n\t//
    If very close to our rounded value, use it.\r\n\tif (helpers$1.almostEquals(numSpaces,
    Math.round(numSpaces), spacing / 1000)) {\r\n\t\tnumSpaces = Math.round(numSpaces);\r\n\t}
    else {\r\n\t\tnumSpaces = Math.ceil(numSpaces);\r\n\t}\r\n\r\n\tniceMin = Math.round(niceMin
    * factor) / factor;\r\n\tniceMax = Math.round(niceMax * factor) / factor;\r\n\tticks.push(isNullOrUndef$2(min)
    ? niceMin : min);\r\n\tfor (var j = 1; j < numSpaces; ++j) {\r\n\t\tticks.push(Math.round((niceMin
    + j * spacing) * factor) / factor);\r\n\t}\r\n\tticks.push(isNullOrUndef$2(max)
    ? niceMax : max);\r\n\r\n\treturn ticks;\r\n}\r\n\r\nvar scale_linearbase = core_scale.extend({\r\n\tgetRightValue:
    function(value) {\r\n\t\tif (typeof value === 'string') {\r\n\t\t\treturn +value;\r\n\t\t}\r\n\t\treturn
    core_scale.prototype.getRightValue.call(this, value);\r\n\t},\r\n\r\n\thandleTickRangeOptions:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts
    = opts.ticks;\r\n\r\n\t\t// If we are forcing it to begin at 0, but 0 will already
    be rendered on the chart,\r\n\t\t// do nothing since that would make the chart
    weird. If the user really wants a weird chart\r\n\t\t// axis, they can manually
    override it\r\n\t\tif (tickOpts.beginAtZero) {\r\n\t\t\tvar minSign = helpers$1.sign(me.min);\r\n\t\t\tvar
    maxSign = helpers$1.sign(me.max);\r\n\r\n\t\t\tif (minSign < 0 && maxSign < 0)
    {\r\n\t\t\t\t// move the top up to 0\r\n\t\t\t\tme.max = 0;\r\n\t\t\t} else if
    (minSign > 0 && maxSign > 0) {\r\n\t\t\t\t// move the bottom down to 0\r\n\t\t\t\tme.min
    = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar setMin = tickOpts.min !== undefined ||
    tickOpts.suggestedMin !== undefined;\r\n\t\tvar setMax = tickOpts.max !== undefined
    || tickOpts.suggestedMax !== undefined;\r\n\r\n\t\tif (tickOpts.min !== undefined)
    {\r\n\t\t\tme.min = tickOpts.min;\r\n\t\t} else if (tickOpts.suggestedMin !==
    undefined) {\r\n\t\t\tif (me.min === null) {\r\n\t\t\t\tme.min = tickOpts.suggestedMin;\r\n\t\t\t}
    else {\r\n\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (tickOpts.max !== undefined) {\r\n\t\t\tme.max = tickOpts.max;\r\n\t\t} else if
    (tickOpts.suggestedMax !== undefined) {\r\n\t\t\tif (me.max === null) {\r\n\t\t\t\tme.max
    = tickOpts.suggestedMax;\r\n\t\t\t} else {\r\n\t\t\t\tme.max = Math.max(me.max,
    tickOpts.suggestedMax);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (setMin !== setMax)
    {\r\n\t\t\t// We set the min or the max but not both.\r\n\t\t\t// So ensure that
    our range is good\r\n\t\t\t// Inverted or 0 length range can happen when\r\n\t\t\t//
    ticks.min is set, and no datasets are visible\r\n\t\t\tif (me.min >= me.max) {\r\n\t\t\t\tif
    (setMin) {\r\n\t\t\t\t\tme.max = me.min + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tme.min
    = me.max - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.min === me.max)
    {\r\n\t\t\tme.max++;\r\n\r\n\t\t\tif (!tickOpts.beginAtZero) {\r\n\t\t\t\tme.min--;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetTickLimit:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    stepSize = tickOpts.stepSize;\r\n\t\tvar maxTicksLimit = tickOpts.maxTicksLimit;\r\n\t\tvar
    maxTicks;\r\n\r\n\t\tif (stepSize) {\r\n\t\t\tmaxTicks = Math.ceil(me.max / stepSize)
    - Math.floor(me.min / stepSize) + 1;\r\n\t\t} else {\r\n\t\t\tmaxTicks = me._computeTickLimit();\r\n\t\t\tmaxTicksLimit
    = maxTicksLimit || 11;\r\n\t\t}\r\n\r\n\t\tif (maxTicksLimit) {\r\n\t\t\tmaxTicks
    = Math.min(maxTicksLimit, maxTicks);\r\n\t\t}\r\n\r\n\t\treturn maxTicks;\r\n\t},\r\n\r\n\t_computeTickLimit:
    function() {\r\n\t\treturn Number.POSITIVE_INFINITY;\r\n\t},\r\n\r\n\thandleDirectionalChanges:
    noop,\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts
    = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\t// Figure out what
    the max number of ticks we can support it is based on the size of\r\n\t\t// the
    axis area. For now, we say that the minimum tick spacing in pixels must be 40\r\n\t\t//
    We also limit the maximum number of ticks to 11 which gives a nice 10 squares
    on\r\n\t\t// the graph. Make sure we always have at least 2 ticks\r\n\t\tvar maxTicks
    = me.getTickLimit();\r\n\t\tmaxTicks = Math.max(2, maxTicks);\r\n\r\n\t\tvar numericGeneratorOptions
    = {\r\n\t\t\tmaxTicks: maxTicks,\r\n\t\t\tmin: tickOpts.min,\r\n\t\t\tmax: tickOpts.max,\r\n\t\t\tprecision:
    tickOpts.precision,\r\n\t\t\tstepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize,
    tickOpts.stepSize)\r\n\t\t};\r\n\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions,
    me);\r\n\r\n\t\tme.handleDirectionalChanges();\r\n\r\n\t\t// At this point, we
    need to update our max and min given the tick values since we have expanded the\r\n\t\t//
    range of the scale\r\n\t\tme.max = helpers$1.max(ticks);\r\n\t\tme.min = helpers$1.min(ticks);\r\n\r\n\t\tif
    (tickOpts.reverse) {\r\n\t\t\tticks.reverse();\r\n\r\n\t\t\tme.start = me.max;\r\n\t\t\tme.end
    = me.min;\r\n\t\t} else {\r\n\t\t\tme.start = me.min;\r\n\t\t\tme.end = me.max;\r\n\t\t}\r\n\t},\r\n\r\n\tconvertTicksToLabels:
    function() {\r\n\t\tvar me = this;\r\n\t\tme.ticksAsNumbers = me.ticks.slice();\r\n\t\tme.zeroLineIndex
    = me.ticks.indexOf(0);\r\n\r\n\t\tcore_scale.prototype.convertTicksToLabels.call(me);\r\n\t},\r\n\r\n\t_configure:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar ticks = me.getTicks();\r\n\t\tvar
    start = me.min;\r\n\t\tvar end = me.max;\r\n\t\tvar offset;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif
    (me.options.offset && ticks.length) {\r\n\t\t\toffset = (end - start) / Math.max(ticks.length
    - 1, 1) / 2;\r\n\t\t\tstart -= offset;\r\n\t\t\tend += offset;\r\n\t\t}\r\n\t\tme._startValue
    = start;\r\n\t\tme._endValue = end;\r\n\t\tme._valueRange = end - start;\r\n\t}\r\n});\n\nvar
    defaultConfig$1 = {\r\n\tposition: 'left',\r\n\tticks: {\r\n\t\tcallback: core_ticks.formatters.linear\r\n\t}\r\n};\r\n\r\nvar
    DEFAULT_MIN = 0;\r\nvar DEFAULT_MAX = 1;\r\n\r\nfunction getOrCreateStack(stacks,
    stacked, meta) {\r\n\tvar key = [\r\n\t\tmeta.type,\r\n\t\t// we have a separate
    stack for stack=undefined datasets when the opts.stacked is undefined\r\n\t\tstacked
    === undefined && meta.stack === undefined ? meta.index : '',\r\n\t\tmeta.stack\r\n\t].join('.');\r\n\r\n\tif
    (stacks[key] === undefined) {\r\n\t\tstacks[key] = {\r\n\t\t\tpos: [],\r\n\t\t\tneg:
    []\r\n\t\t};\r\n\t}\r\n\r\n\treturn stacks[key];\r\n}\r\n\r\nfunction stackData(scale,
    stacks, meta, data) {\r\n\tvar opts = scale.options;\r\n\tvar stacked = opts.stacked;\r\n\tvar
    stack = getOrCreateStack(stacks, stacked, meta);\r\n\tvar pos = stack.pos;\r\n\tvar
    neg = stack.neg;\r\n\tvar ilen = data.length;\r\n\tvar i, value;\r\n\r\n\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\tvalue = scale._parseValue(data[i]);\r\n\t\tif
    (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tpos[i]
    = pos[i] || 0;\r\n\t\tneg[i] = neg[i] || 0;\r\n\r\n\t\tif (opts.relativePoints)
    {\r\n\t\t\tpos[i] = 100;\r\n\t\t} else if (value.min < 0 || value.max < 0) {\r\n\t\t\tneg[i]
    += value.min;\r\n\t\t} else {\r\n\t\t\tpos[i] += value.max;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction
    updateMinMax(scale, meta, data) {\r\n\tvar ilen = data.length;\r\n\tvar i, value;\r\n\r\n\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\tvalue = scale._parseValue(data[i]);\r\n\t\tif
    (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tscale.min
    = Math.min(scale.min, value.min);\r\n\t\tscale.max = Math.max(scale.max, value.max);\r\n\t}\r\n}\r\n\r\nvar
    scale_linear = scale_linearbase.extend({\r\n\tdetermineDataLimits: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasets = chart.data.datasets;\r\n\t\tvar metasets = me._getMatchingVisibleMetas();\r\n\t\tvar
    hasStacks = opts.stacked;\r\n\t\tvar stacks = {};\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar
    i, meta, data, values;\r\n\r\n\t\tme.min = Number.POSITIVE_INFINITY;\r\n\t\tme.max
    = Number.NEGATIVE_INFINITY;\r\n\r\n\t\tif (hasStacks === undefined) {\r\n\t\t\tfor
    (i = 0; !hasStacks && i < ilen; ++i) {\r\n\t\t\t\tmeta = metasets[i];\r\n\t\t\t\thasStacks
    = meta.stack !== undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < ilen;
    ++i) {\r\n\t\t\tmeta = metasets[i];\r\n\t\t\tdata = datasets[meta.index].data;\r\n\t\t\tif
    (hasStacks) {\r\n\t\t\t\tstackData(me, stacks, meta, data);\r\n\t\t\t} else {\r\n\t\t\t\tupdateMinMax(me,
    meta, data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers$1.each(stacks, function(stackValues)
    {\r\n\t\t\tvalues = stackValues.pos.concat(stackValues.neg);\r\n\t\t\tme.min =
    Math.min(me.min, helpers$1.min(values));\r\n\t\t\tme.max = Math.max(me.max, helpers$1.max(values));\r\n\t\t});\r\n\r\n\t\tme.min
    = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\r\n\t\tme.max
    = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\r\n\r\n\t\t//
    Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\r\n\t\tme.handleTickRangeOptions();\r\n\t},\r\n\r\n\t//
    Returns the maximum number of ticks based on the scale dimension\r\n\t_computeTickLimit:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickFont;\r\n\r\n\t\tif (me.isHorizontal())
    {\r\n\t\t\treturn Math.ceil(me.width / 40);\r\n\t\t}\r\n\t\ttickFont = helpers$1.options._parseFont(me.options.ticks);\r\n\t\treturn
    Math.ceil(me.height / tickFont.lineHeight);\r\n\t},\r\n\r\n\t// Called after the
    ticks are built. We need\r\n\thandleDirectionalChanges: function() {\r\n\t\tif
    (!this.isHorizontal()) {\r\n\t\t\t// We are in a vertical orientation. The top
    value is the highest. So reverse the array\r\n\t\t\tthis.ticks.reverse();\r\n\t\t}\r\n\t},\r\n\r\n\tgetLabelForIndex:
    function(index, datasetIndex) {\r\n\t\treturn this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\t//
    Utils\r\n\tgetPixelForValue: function(value) {\r\n\t\tvar me = this;\r\n\t\treturn
    me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);\r\n\t},\r\n\r\n\tgetValueForPixel:
    function(pixel) {\r\n\t\treturn this._startValue + this.getDecimalForPixel(pixel)
    * this._valueRange;\r\n\t},\r\n\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar
    ticks = this.ticksAsNumbers;\r\n\t\tif (index < 0 || index > ticks.length - 1)
    {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this.getPixelForValue(ticks[index]);\r\n\t}\r\n});\r\n\r\n//
    INTERNAL: static default options, registered in src/index.js\r\nvar _defaults$1
    = defaultConfig$1;\nscale_linear._defaults = _defaults$1;\n\nvar valueOrDefault$b
    = helpers$1.valueOrDefault;\r\nvar log10 = helpers$1.math.log10;\r\n\r\n/**\r\n
    * Generate a set of logarithmic ticks\r\n * @param generationOptions the options
    used to generate the ticks\r\n * @param dataRange the range of the data\r\n *
    @returns {number[]} array of tick values\r\n */\r\nfunction generateTicks$1(generationOptions,
    dataRange) {\r\n\tvar ticks = [];\r\n\r\n\tvar tickVal = valueOrDefault$b(generationOptions.min,
    Math.pow(10, Math.floor(log10(dataRange.min))));\r\n\r\n\tvar endExp = Math.floor(log10(dataRange.max));\r\n\tvar
    endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\r\n\tvar exp,
    significand;\r\n\r\n\tif (tickVal === 0) {\r\n\t\texp = Math.floor(log10(dataRange.minNotZero));\r\n\t\tsignificand
    = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\r\n\r\n\t\tticks.push(tickVal);\r\n\t\ttickVal
    = significand * Math.pow(10, exp);\r\n\t} else {\r\n\t\texp = Math.floor(log10(tickVal));\r\n\t\tsignificand
    = Math.floor(tickVal / Math.pow(10, exp));\r\n\t}\r\n\tvar precision = exp < 0
    ? Math.pow(10, Math.abs(exp)) : 1;\r\n\r\n\tdo {\r\n\t\tticks.push(tickVal);\r\n\r\n\t\t++significand;\r\n\t\tif
    (significand === 10) {\r\n\t\t\tsignificand = 1;\r\n\t\t\t++exp;\r\n\t\t\tprecision
    = exp >= 0 ? 1 : precision;\r\n\t\t}\r\n\r\n\t\ttickVal = Math.round(significand
    * Math.pow(10, exp) * precision) / precision;\r\n\t} while (exp < endExp || (exp
    === endExp && significand < endSignificand));\r\n\r\n\tvar lastTick = valueOrDefault$b(generationOptions.max,
    tickVal);\r\n\tticks.push(lastTick);\r\n\r\n\treturn ticks;\r\n}\r\n\r\nvar defaultConfig$2
    = {\r\n\tposition: 'left',\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\tcallback:
    core_ticks.formatters.logarithmic\r\n\t}\r\n};\r\n\r\n// TODO(v3): change this
    to positiveOrDefault\r\nfunction nonNegativeOrDefault(value, defaultValue) {\r\n\treturn
    helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\r\n}\r\n\r\nvar
    scale_logarithmic = core_scale.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasets = chart.data.datasets;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tfunction
    IDMatches(meta) {\r\n\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID
    === me.id;\r\n\t\t}\r\n\t\tvar datasetIndex, meta, value, data, i, ilen;\r\n\r\n\t\t//
    Calculate Range\r\n\t\tme.min = Number.POSITIVE_INFINITY;\r\n\t\tme.max = Number.NEGATIVE_INFINITY;\r\n\t\tme.minNotZero
    = Number.POSITIVE_INFINITY;\r\n\r\n\t\tvar hasStacks = opts.stacked;\r\n\t\tif
    (hasStacks === undefined) {\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length;
    datasetIndex++) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tif
    (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\r\n\t\t\t\t\tmeta.stack
    !== undefined) {\r\n\t\t\t\t\thasStacks = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (opts.stacked || hasStacks) {\r\n\t\t\tvar valuesPerStack = {};\r\n\r\n\t\t\tfor
    (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\r\n\t\t\t\tmeta
    = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tvar key = [\r\n\t\t\t\t\tmeta.type,\r\n\t\t\t\t\t//
    we have a separate stack for stack=undefined datasets when the opts.stacked is
    undefined\r\n\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined)
    ? datasetIndex : ''),\r\n\t\t\t\t\tmeta.stack\r\n\t\t\t\t].join('.');\r\n\r\n\t\t\t\tif
    (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\tif (valuesPerStack[key]
    === undefined) {\r\n\t\t\t\t\t\tvaluesPerStack[key] = [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata
    = datasets[datasetIndex].data;\r\n\t\t\t\t\tfor (i = 0, ilen = data.length; i
    < ilen; i++) {\r\n\t\t\t\t\t\tvar values = valuesPerStack[key];\r\n\t\t\t\t\t\tvalue
    = me._parseValue(data[i]);\r\n\t\t\t\t\t\t// invalid, hidden and negative values
    are ignored\r\n\t\t\t\t\t\tif (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden
    || value.min < 0 || value.max < 0) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[i]
    = values[i] || 0;\r\n\t\t\t\t\t\tvalues[i] += value.max;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\thelpers$1.each(valuesPerStack,
    function(valuesForType) {\r\n\t\t\t\tif (valuesForType.length > 0) {\r\n\t\t\t\t\tvar
    minVal = helpers$1.min(valuesForType);\r\n\t\t\t\t\tvar maxVal = helpers$1.max(valuesForType);\r\n\t\t\t\t\tme.min
    = Math.min(me.min, minVal);\r\n\t\t\t\t\tme.max = Math.max(me.max, maxVal);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}
    else {\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++)
    {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)
    && IDMatches(meta)) {\r\n\t\t\t\t\tdata = datasets[datasetIndex].data;\r\n\t\t\t\t\tfor
    (i = 0, ilen = data.length; i < ilen; i++) {\r\n\t\t\t\t\t\tvalue = me._parseValue(data[i]);\r\n\t\t\t\t\t\t//
    invalid, hidden and negative values are ignored\r\n\t\t\t\t\t\tif (isNaN(value.min)
    || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0)
    {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tme.min = Math.min(value.min,
    me.min);\r\n\t\t\t\t\t\tme.max = Math.max(value.max, me.max);\r\n\r\n\t\t\t\t\t\tif
    (value.min !== 0) {\r\n\t\t\t\t\t\t\tme.minNotZero = Math.min(value.min, me.minNotZero);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.min
    = helpers$1.isFinite(me.min) ? me.min : null;\r\n\t\tme.max = helpers$1.isFinite(me.max)
    ? me.max : null;\r\n\t\tme.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero
    : null;\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max\r\n\t\tthis.handleTickRangeOptions();\r\n\t},\r\n\r\n\thandleTickRangeOptions:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    DEFAULT_MIN = 1;\r\n\t\tvar DEFAULT_MAX = 10;\r\n\r\n\t\tme.min = nonNegativeOrDefault(tickOpts.min,
    me.min);\r\n\t\tme.max = nonNegativeOrDefault(tickOpts.max, me.max);\r\n\r\n\t\tif
    (me.min === me.max) {\r\n\t\t\tif (me.min !== 0 && me.min !== null) {\r\n\t\t\t\tme.min
    = Math.pow(10, Math.floor(log10(me.min)) - 1);\r\n\t\t\t\tme.max = Math.pow(10,
    Math.floor(log10(me.max)) + 1);\r\n\t\t\t} else {\r\n\t\t\t\tme.min = DEFAULT_MIN;\r\n\t\t\t\tme.max
    = DEFAULT_MAX;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (me.min === null) {\r\n\t\t\tme.min
    = Math.pow(10, Math.floor(log10(me.max)) - 1);\r\n\t\t}\r\n\t\tif (me.max ===
    null) {\r\n\t\t\tme.max = me.min !== 0\r\n\t\t\t\t? Math.pow(10, Math.floor(log10(me.min))
    + 1)\r\n\t\t\t\t: DEFAULT_MAX;\r\n\t\t}\r\n\t\tif (me.minNotZero === null) {\r\n\t\t\tif
    (me.min > 0) {\r\n\t\t\t\tme.minNotZero = me.min;\r\n\t\t\t} else if (me.max <
    1) {\r\n\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(log10(me.max)));\r\n\t\t\t}
    else {\r\n\t\t\t\tme.minNotZero = DEFAULT_MIN;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tbuildTicks:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    reverse = !me.isHorizontal();\r\n\r\n\t\tvar generationOptions = {\r\n\t\t\tmin:
    nonNegativeOrDefault(tickOpts.min),\r\n\t\t\tmax: nonNegativeOrDefault(tickOpts.max)\r\n\t\t};\r\n\t\tvar
    ticks = me.ticks = generateTicks$1(generationOptions, me);\r\n\r\n\t\t// At this
    point, we need to update our max and min given the tick values since we have expanded
    the\r\n\t\t// range of the scale\r\n\t\tme.max = helpers$1.max(ticks);\r\n\t\tme.min
    = helpers$1.min(ticks);\r\n\r\n\t\tif (tickOpts.reverse) {\r\n\t\t\treverse =
    !reverse;\r\n\t\t\tme.start = me.max;\r\n\t\t\tme.end = me.min;\r\n\t\t} else
    {\r\n\t\t\tme.start = me.min;\r\n\t\t\tme.end = me.max;\r\n\t\t}\r\n\t\tif (reverse)
    {\r\n\t\t\tticks.reverse();\r\n\t\t}\r\n\t},\r\n\r\n\tconvertTicksToLabels: function()
    {\r\n\t\tthis.tickValues = this.ticks.slice();\r\n\r\n\t\tcore_scale.prototype.convertTicksToLabels.call(this);\r\n\t},\r\n\r\n\t//
    Get the correct tooltip label\r\n\tgetLabelForIndex: function(index, datasetIndex)
    {\r\n\t\treturn this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\tgetPixelForTick:
    function(index) {\r\n\t\tvar ticks = this.tickValues;\r\n\t\tif (index < 0 ||
    index > ticks.length - 1) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this.getPixelForValue(ticks[index]);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the value of the first tick.\r\n\t * @param {number} value - The minimum
    not zero value.\r\n\t * @return {number} The first tick value.\r\n\t * @private\r\n\t
    */\r\n\t_getFirstTickValue: function(value) {\r\n\t\tvar exp = Math.floor(log10(value));\r\n\t\tvar
    significand = Math.floor(value / Math.pow(10, exp));\r\n\r\n\t\treturn significand
    * Math.pow(10, exp);\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me =
    this;\r\n\t\tvar start = me.min;\r\n\t\tvar offset = 0;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif
    (start === 0) {\r\n\t\t\tstart = me._getFirstTickValue(me.minNotZero);\r\n\t\t\toffset
    = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize)
    / me._length;\r\n\t\t}\r\n\r\n\t\tme._startValue = log10(start);\r\n\t\tme._valueOffset
    = offset;\r\n\t\tme._valueRange = (log10(me.max) - log10(start)) / (1 - offset);\r\n\t},\r\n\r\n\tgetPixelForValue:
    function(value) {\r\n\t\tvar me = this;\r\n\t\tvar decimal = 0;\r\n\r\n\t\tvalue
    = +me.getRightValue(value);\r\n\r\n\t\tif (value > me.min && value > 0) {\r\n\t\t\tdecimal
    = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;\r\n\t\t}\r\n\t\treturn
    me.getPixelForDecimal(decimal);\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel)
    {\r\n\t\tvar me = this;\r\n\t\tvar decimal = me.getDecimalForPixel(pixel);\r\n\t\treturn
    decimal === 0 && me.min === 0\r\n\t\t\t? 0\r\n\t\t\t: Math.pow(10, me._startValue
    + (decimal - me._valueOffset) * me._valueRange);\r\n\t}\r\n});\r\n\r\n// INTERNAL:
    static default options, registered in src/index.js\r\nvar _defaults$2 = defaultConfig$2;\nscale_logarithmic._defaults
    = _defaults$2;\n\nvar valueOrDefault$c = helpers$1.valueOrDefault;\r\nvar valueAtIndexOrDefault$1
    = helpers$1.valueAtIndexOrDefault;\r\nvar resolve$4 = helpers$1.options.resolve;\r\n\r\nvar
    defaultConfig$3 = {\r\n\tdisplay: true,\r\n\r\n\t// Boolean - Whether to animate
    scaling the chart from the centre\r\n\tanimate: true,\r\n\tposition: 'chartArea',\r\n\r\n\tangleLines:
    {\r\n\t\tdisplay: true,\r\n\t\tcolor: 'rgba(0,0,0,0.1)',\r\n\t\tlineWidth: 1,\r\n\t\tborderDash:
    [],\r\n\t\tborderDashOffset: 0.0\r\n\t},\r\n\r\n\tgridLines: {\r\n\t\tcircular:
    false\r\n\t},\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\t// Boolean - Show
    a backdrop to the scale label\r\n\t\tshowLabelBackdrop: true,\r\n\r\n\t\t// String
    - The colour of the label backdrop\r\n\t\tbackdropColor: 'rgba(255,255,255,0.75)',\r\n\r\n\t\t//
    Number - The backdrop padding above & below the label in pixels\r\n\t\tbackdropPaddingY:
    2,\r\n\r\n\t\t// Number - The backdrop padding to the side of the label in pixels\r\n\t\tbackdropPaddingX:
    2,\r\n\r\n\t\tcallback: core_ticks.formatters.linear\r\n\t},\r\n\r\n\tpointLabels:
    {\r\n\t\t// Boolean - if true, show point labels\r\n\t\tdisplay: true,\r\n\r\n\t\t//
    Number - Point label font size in pixels\r\n\t\tfontSize: 10,\r\n\r\n\t\t// Function
    - Used to convert point labels\r\n\t\tcallback: function(label) {\r\n\t\t\treturn
    label;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n\tvar
    tickOpts = opts.ticks;\r\n\r\n\tif (tickOpts.display && opts.display) {\r\n\t\treturn
    valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY
    * 2;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nfunction measureLabelSize(ctx, lineHeight,
    label) {\r\n\tif (helpers$1.isArray(label)) {\r\n\t\treturn {\r\n\t\t\tw: helpers$1.longestText(ctx,
    ctx.font, label),\r\n\t\t\th: label.length * lineHeight\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tw: ctx.measureText(label).width,\r\n\t\th: lineHeight\r\n\t};\r\n}\r\n\r\nfunction
    determineLimits(angle, pos, size, min, max) {\r\n\tif (angle === min || angle
    === max) {\r\n\t\treturn {\r\n\t\t\tstart: pos - (size / 2),\r\n\t\t\tend: pos
    + (size / 2)\r\n\t\t};\r\n\t} else if (angle < min || angle > max) {\r\n\t\treturn
    {\r\n\t\t\tstart: pos - size,\r\n\t\t\tend: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tstart: pos,\r\n\t\tend: pos + size\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper
    function to fit a radial linear scale with point labels\r\n */\r\nfunction fitWithPointLabels(scale)
    {\r\n\r\n\t// Right, this is really confusing and there is a lot of maths going
    on here\r\n\t// The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t//\r\n\t//
    Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t//\r\n\t//
    Solution:\r\n\t//\r\n\t// We assume the radius of the polygon is half the size
    of the canvas at first\r\n\t// at each index we check if the text overlaps.\r\n\t//\r\n\t//
    Where it does, we store that angle and that index.\r\n\t//\r\n\t// After finding
    the largest index and angle we calculate how much we need to remove\r\n\t// from
    the shape radius to move the point inwards by that x.\r\n\t//\r\n\t// We average
    the left and right distances to get the maximum shape radius that can fit in the
    box\r\n\t// along with labels.\r\n\t//\r\n\t// Once we have that, we can find
    the centre point for the chart, by taking the x text protrusion\r\n\t// on each
    side, removing that from the size, halving it and adding the left x protrusion
    width.\r\n\t//\r\n\t// This will mean we have a shape fitted to the canvas, as
    large as it can be with the labels\r\n\t// and position it in the most space efficient
    manner\r\n\t//\r\n\t// https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\r\n\tvar
    plFont = helpers$1.options._parseFont(scale.options.pointLabels);\r\n\r\n\t//
    Get maximum radius of the polygon. Either half the height (minus the text width)
    or half the width.\r\n\t// Use this to calculate the offset + change. - Make sure
    L/R protrusion is at least 0 to stop issues with centre points\r\n\tvar furthestLimits
    = {\r\n\t\tl: 0,\r\n\t\tr: scale.width,\r\n\t\tt: 0,\r\n\t\tb: scale.height -
    scale.paddingTop\r\n\t};\r\n\tvar furthestAngles = {};\r\n\tvar i, textSize, pointPosition;\r\n\r\n\tscale.ctx.font
    = plFont.string;\r\n\tscale._pointLabelSizes = [];\r\n\r\n\tvar valueCount = scale.chart.data.labels.length;\r\n\tfor
    (i = 0; i < valueCount; i++) {\r\n\t\tpointPosition = scale.getPointPosition(i,
    scale.drawingArea + 5);\r\n\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight,
    scale.pointLabels[i]);\r\n\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t//
    Add quarter circle to make degree 0 mean top of circle\r\n\t\tvar angleRadians
    = scale.getIndexAngle(i);\r\n\t\tvar angle = helpers$1.toDegrees(angleRadians)
    % 360;\r\n\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w,
    0, 180);\r\n\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h,
    90, 270);\r\n\r\n\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\tfurthestLimits.l
    = hLimits.start;\r\n\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t}\r\n\r\n\t\tif
    (hLimits.end > furthestLimits.r) {\r\n\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\tfurthestAngles.r
    = angleRadians;\r\n\t\t}\r\n\r\n\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\tfurthestLimits.t
    = vLimits.start;\r\n\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t}\r\n\r\n\t\tif
    (vLimits.end > furthestLimits.b) {\r\n\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\tfurthestAngles.b
    = angleRadians;\r\n\t\t}\r\n\t}\r\n\r\n\tscale.setReductions(scale.drawingArea,
    furthestLimits, furthestAngles);\r\n}\r\n\r\nfunction getTextAlignForAngle(angle)
    {\r\n\tif (angle === 0 || angle === 180) {\r\n\t\treturn 'center';\r\n\t} else
    if (angle < 180) {\r\n\t\treturn 'left';\r\n\t}\r\n\r\n\treturn 'right';\r\n}\r\n\r\nfunction
    fillText(ctx, text, position, lineHeight) {\r\n\tvar y = position.y + lineHeight
    / 2;\r\n\tvar i, ilen;\r\n\r\n\tif (helpers$1.isArray(text)) {\r\n\t\tfor (i =
    0, ilen = text.length; i < ilen; ++i) {\r\n\t\t\tctx.fillText(text[i], position.x,
    y);\r\n\t\t\ty += lineHeight;\r\n\t\t}\r\n\t} else {\r\n\t\tctx.fillText(text,
    position.x, y);\r\n\t}\r\n}\r\n\r\nfunction adjustPointPositionForLabelHeight(angle,
    textSize, position) {\r\n\tif (angle === 90 || angle === 270) {\r\n\t\tposition.y
    -= (textSize.h / 2);\r\n\t} else if (angle > 270 || angle < 90) {\r\n\t\tposition.y
    -= textSize.h;\r\n\t}\r\n}\r\n\r\nfunction drawPointLabels(scale) {\r\n\tvar ctx
    = scale.ctx;\r\n\tvar opts = scale.options;\r\n\tvar pointLabelOpts = opts.pointLabels;\r\n\tvar
    tickBackdropHeight = getTickBackdropHeight(opts);\r\n\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse
    ? scale.min : scale.max);\r\n\tvar plFont = helpers$1.options._parseFont(pointLabelOpts);\r\n\r\n\tctx.save();\r\n\r\n\tctx.font
    = plFont.string;\r\n\tctx.textBaseline = 'middle';\r\n\r\n\tfor (var i = scale.chart.data.labels.length
    - 1; i >= 0; i--) {\r\n\t\t// Extra pixels out for some label spacing\r\n\t\tvar
    extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\tvar pointLabelPosition
    = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t// Keep this
    in loop since we may support array properties here\r\n\t\tvar pointLabelFontColor
    = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\r\n\t\tctx.fillStyle
    = pointLabelFontColor;\r\n\r\n\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\tvar
    angle = helpers$1.toDegrees(angleRadians);\r\n\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\tadjustPointPositionForLabelHeight(angle,
    scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\tfillText(ctx, scale.pointLabels[i],
    pointLabelPosition, plFont.lineHeight);\r\n\t}\r\n\tctx.restore();\r\n}\r\n\r\nfunction
    drawRadiusLine(scale, gridLineOpts, radius, index) {\r\n\tvar ctx = scale.ctx;\r\n\tvar
    circular = gridLineOpts.circular;\r\n\tvar valueCount = scale.chart.data.labels.length;\r\n\tvar
    lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\r\n\tvar lineWidth
    = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\r\n\tvar pointPosition;\r\n\r\n\tif
    ((!circular && !valueCount) || !lineColor || !lineWidth) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tctx.save();\r\n\tctx.strokeStyle
    = lineColor;\r\n\tctx.lineWidth = lineWidth;\r\n\tif (ctx.setLineDash) {\r\n\t\tctx.setLineDash(gridLineOpts.borderDash
    || []);\r\n\t\tctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tif
    (circular) {\r\n\t\t// Draw circular arcs between the points\r\n\t\tctx.arc(scale.xCenter,
    scale.yCenter, radius, 0, Math.PI * 2);\r\n\t} else {\r\n\t\t// Draw straight
    lines connecting each index\r\n\t\tpointPosition = scale.getPointPosition(0, radius);\r\n\t\tctx.moveTo(pointPosition.x,
    pointPosition.y);\r\n\r\n\t\tfor (var i = 1; i < valueCount; i++) {\r\n\t\t\tpointPosition
    = scale.getPointPosition(i, radius);\r\n\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\r\n\t\t}\r\n\t}\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n\tctx.restore();\r\n}\r\n\r\nfunction
    numberOrZero(param) {\r\n\treturn helpers$1.isNumber(param) ? param : 0;\r\n}\r\n\r\nvar
    scale_radialLinear = scale_linearbase.extend({\r\n\tsetDimensions: function()
    {\r\n\t\tvar me = this;\r\n\r\n\t\t// Set the unconstrained dimension before label
    rotation\r\n\t\tme.width = me.maxWidth;\r\n\t\tme.height = me.maxHeight;\r\n\t\tme.paddingTop
    = getTickBackdropHeight(me.options) / 2;\r\n\t\tme.xCenter = Math.floor(me.width
    / 2);\r\n\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\r\n\t\tme.drawingArea
    = Math.min(me.height - me.paddingTop, me.width) / 2;\r\n\t},\r\n\r\n\tdetermineDataLimits:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar min
    = Number.POSITIVE_INFINITY;\r\n\t\tvar max = Number.NEGATIVE_INFINITY;\r\n\r\n\t\thelpers$1.each(chart.data.datasets,
    function(dataset, datasetIndex) {\r\n\t\t\tif (chart.isDatasetVisible(datasetIndex))
    {\r\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\r\n\t\t\t\thelpers$1.each(dataset.data,
    function(rawValue, index) {\r\n\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\tif
    (isNaN(value) || meta.data[index].hidden) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmin
    = Math.min(value, min);\r\n\t\t\t\t\tmax = Math.max(value, max);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tme.min
    = (min === Number.POSITIVE_INFINITY ? 0 : min);\r\n\t\tme.max = (max === Number.NEGATIVE_INFINITY
    ? 0 : max);\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max,
    ticks.beginAtZero\r\n\t\tme.handleTickRangeOptions();\r\n\t},\r\n\r\n\t// Returns
    the maximum number of ticks based on the scale dimension\r\n\t_computeTickLimit:
    function() {\r\n\t\treturn Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n\t},\r\n\r\n\tconvertTicksToLabels:
    function() {\r\n\t\tvar me = this;\r\n\r\n\t\tscale_linearbase.prototype.convertTicksToLabels.call(me);\r\n\r\n\t\t//
    Point labels\r\n\t\tme.pointLabels = me.chart.data.labels.map(function() {\r\n\t\t\tvar
    label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);\r\n\t\t\treturn
    label || label === 0 ? label : '';\r\n\t\t});\r\n\t},\r\n\r\n\tgetLabelForIndex:
    function(index, datasetIndex) {\r\n\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\tfit:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\r\n\t\tif
    (opts.display && opts.pointLabels.display) {\r\n\t\t\tfitWithPointLabels(me);\r\n\t\t}
    else {\r\n\t\t\tme.setCenterPoint(0, 0, 0, 0);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Set radius reductions and determine new radius and center point\r\n\t * @private\r\n\t
    */\r\n\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles)
    {\r\n\t\tvar me = this;\r\n\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\tvar
    radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\tvar
    radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\tvar
    radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop),
    0) / Math.cos(furthestAngles.b);\r\n\r\n\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\tradiusReductionRight
    = numberOrZero(radiusReductionRight);\r\n\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\tradiusReductionBottom
    = numberOrZero(radiusReductionBottom);\r\n\r\n\t\tme.drawingArea = Math.min(\r\n\t\t\tMath.floor(largestPossibleRadius
    - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\tMath.floor(largestPossibleRadius
    - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\tme.setCenterPoint(radiusReductionLeft,
    radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t},\r\n\r\n\tsetCenterPoint:
    function(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n\t\tvar
    me = this;\r\n\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\r\n\t\tvar
    maxLeft = leftMovement + me.drawingArea;\r\n\t\tvar maxTop = topMovement + me.drawingArea;\r\n\t\tvar
    maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\r\n\r\n\t\tme.xCenter
    = Math.floor(((maxLeft + maxRight) / 2) + me.left);\r\n\t\tme.yCenter = Math.floor(((maxTop
    + maxBottom) / 2) + me.top + me.paddingTop);\r\n\t},\r\n\r\n\tgetIndexAngle: function(index)
    {\r\n\t\tvar chart = this.chart;\r\n\t\tvar angleMultiplier = 360 / chart.data.labels.length;\r\n\t\tvar
    options = chart.options || {};\r\n\t\tvar startAngle = options.startAngle || 0;\r\n\r\n\t\t//
    Start from the top instead of right, so remove a quarter of the circle\r\n\t\tvar
    angle = (index * angleMultiplier + startAngle) % 360;\r\n\r\n\t\treturn (angle
    < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;\r\n\t},\r\n\r\n\tgetDistanceFromCenterForValue:
    function(value) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (helpers$1.isNullOrUndef(value))
    {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\r\n\t\t// Take into account half font size
    + the yPadding of the top value\r\n\t\tvar scalingFactor = me.drawingArea / (me.max
    - me.min);\r\n\t\tif (me.options.ticks.reverse) {\r\n\t\t\treturn (me.max - value)
    * scalingFactor;\r\n\t\t}\r\n\t\treturn (value - me.min) * scalingFactor;\r\n\t},\r\n\r\n\tgetPointPosition:
    function(index, distanceFromCenter) {\r\n\t\tvar me = this;\r\n\t\tvar thisAngle
    = me.getIndexAngle(index) - (Math.PI / 2);\r\n\t\treturn {\r\n\t\t\tx: Math.cos(thisAngle)
    * distanceFromCenter + me.xCenter,\r\n\t\t\ty: Math.sin(thisAngle) * distanceFromCenter
    + me.yCenter\r\n\t\t};\r\n\t},\r\n\r\n\tgetPointPositionForValue: function(index,
    value) {\r\n\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n\t},\r\n\r\n\tgetBasePosition:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max
    = me.max;\r\n\r\n\t\treturn me.getPointPositionForValue(index || 0,\r\n\t\t\tme.beginAtZero
    ? 0 :\r\n\t\t\tmin < 0 && max < 0 ? max :\r\n\t\t\tmin > 0 && max > 0 ? min :\r\n\t\t\t0);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawGrid: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar
    angleLineOpts = opts.angleLines;\r\n\t\tvar lineWidth = valueOrDefault$c(angleLineOpts.lineWidth,
    gridLineOpts.lineWidth);\r\n\t\tvar lineColor = valueOrDefault$c(angleLineOpts.color,
    gridLineOpts.color);\r\n\t\tvar i, offset, position;\r\n\r\n\t\tif (opts.pointLabels.display)
    {\r\n\t\t\tdrawPointLabels(me);\r\n\t\t}\r\n\r\n\t\tif (gridLineOpts.display)
    {\r\n\t\t\thelpers$1.each(me.ticks, function(label, index) {\r\n\t\t\t\tif (index
    !== 0) {\r\n\t\t\t\t\toffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\t\t\t\t\tdrawRadiusLine(me,
    gridLineOpts, offset, index);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif
    (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.lineWidth
    = lineWidth;\r\n\t\t\tctx.strokeStyle = lineColor;\r\n\t\t\tif (ctx.setLineDash)
    {\r\n\t\t\t\tctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash,
    []]));\r\n\t\t\t\tctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset,
    gridLineOpts.borderDashOffset, 0.0]);\r\n\t\t\t}\r\n\r\n\t\t\tfor (i = me.chart.data.labels.length
    - 1; i >= 0; i--) {\r\n\t\t\t\toffset = me.getDistanceFromCenterForValue(opts.ticks.reverse
    ? me.min : me.max);\r\n\t\t\t\tposition = me.getPointPosition(i, offset);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(me.xCenter,
    me.yCenter);\r\n\t\t\t\tctx.lineTo(position.x, position.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\tif
    (!tickOpts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar startAngle = me.getIndexAngle(0);\r\n\t\tvar
    tickFont = helpers$1.options._parseFont(tickOpts);\r\n\t\tvar tickFontColor =
    valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);\r\n\t\tvar
    offset, width;\r\n\r\n\t\tctx.save();\r\n\t\tctx.font = tickFont.string;\r\n\t\tctx.translate(me.xCenter,
    me.yCenter);\r\n\t\tctx.rotate(startAngle);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\thelpers$1.each(me.ticks, function(label, index) {\r\n\t\t\tif
    (index === 0 && !tickOpts.reverse) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\toffset
    = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\r\n\t\t\tif
    (tickOpts.showLabelBackdrop) {\r\n\t\t\t\twidth = ctx.measureText(label).width;\r\n\t\t\t\tctx.fillStyle
    = tickOpts.backdropColor;\r\n\r\n\t\t\t\tctx.fillRect(\r\n\t\t\t\t\t-width / 2
    - tickOpts.backdropPaddingX,\r\n\t\t\t\t\t-offset - tickFont.size / 2 - tickOpts.backdropPaddingY,\r\n\t\t\t\t\twidth
    + tickOpts.backdropPaddingX * 2,\r\n\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY
    * 2\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tctx.fillStyle = tickFontColor;\r\n\t\t\tctx.fillText(label,
    0, -offset);\r\n\t\t});\r\n\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\t/**\r\n\t *
    @private\r\n\t */\r\n\t_drawTitle: helpers$1.noop\r\n});\r\n\r\n// INTERNAL: static
    default options, registered in src/index.js\r\nvar _defaults$3 = defaultConfig$3;\nscale_radialLinear._defaults
    = _defaults$3;\n\nvar deprecated$1 = helpers$1._deprecated;\r\nvar resolve$5 =
    helpers$1.options.resolve;\r\nvar valueOrDefault$d = helpers$1.valueOrDefault;\r\n\r\n//
    Integer constants are from the ES6 spec.\r\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER
    || -9007199254740991;\r\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\r\n\r\nvar
    INTERVALS = {\r\n\tmillisecond: {\r\n\t\tcommon: true,\r\n\t\tsize: 1,\r\n\t\tsteps:
    1000\r\n\t},\r\n\tsecond: {\r\n\t\tcommon: true,\r\n\t\tsize: 1000,\r\n\t\tsteps:
    60\r\n\t},\r\n\tminute: {\r\n\t\tcommon: true,\r\n\t\tsize: 60000,\r\n\t\tsteps:
    60\r\n\t},\r\n\thour: {\r\n\t\tcommon: true,\r\n\t\tsize: 3600000,\r\n\t\tsteps:
    24\r\n\t},\r\n\tday: {\r\n\t\tcommon: true,\r\n\t\tsize: 86400000,\r\n\t\tsteps:
    30\r\n\t},\r\n\tweek: {\r\n\t\tcommon: false,\r\n\t\tsize: 604800000,\r\n\t\tsteps:
    4\r\n\t},\r\n\tmonth: {\r\n\t\tcommon: true,\r\n\t\tsize: 2.628e9,\r\n\t\tsteps:
    12\r\n\t},\r\n\tquarter: {\r\n\t\tcommon: false,\r\n\t\tsize: 7.884e9,\r\n\t\tsteps:
    4\r\n\t},\r\n\tyear: {\r\n\t\tcommon: true,\r\n\t\tsize: 3.154e10\r\n\t}\r\n};\r\n\r\nvar
    UNITS = Object.keys(INTERVALS);\r\n\r\nfunction sorter(a, b) {\r\n\treturn a -
    b;\r\n}\r\n\r\nfunction arrayUnique(items) {\r\n\tvar hash = {};\r\n\tvar out
    = [];\r\n\tvar i, ilen, item;\r\n\r\n\tfor (i = 0, ilen = items.length; i < ilen;
    ++i) {\r\n\t\titem = items[i];\r\n\t\tif (!hash[item]) {\r\n\t\t\thash[item] =
    true;\r\n\t\t\tout.push(item);\r\n\t\t}\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\nfunction
    getMin(options) {\r\n\treturn helpers$1.valueOrDefault(options.time.min, options.ticks.min);\r\n}\r\n\r\nfunction
    getMax(options) {\r\n\treturn helpers$1.valueOrDefault(options.time.max, options.ticks.max);\r\n}\r\n\r\n/**\r\n
    * Returns an array of {time, pos} objects used to interpolate a specific `time`
    or position\r\n * (`pos`) on the scale, by searching entries before and after
    the requested value. `pos` is\r\n * a decimal between 0 and 1: 0 being the start
    of the scale (left or top) and 1 the other\r\n * extremity (left + width or top
    + height). Note that it would be more optimized to directly\r\n * store pre-computed
    pixels, but the scale dimensions are not guaranteed at the time we need\r\n *
    to create the lookup table. The table ALWAYS contains at least two items: min
    and max.\r\n *\r\n * @param {number[]} timestamps - timestamps sorted from lowest
    to highest.\r\n * @param {string} distribution - If 'linear', timestamps will
    be spread linearly along the min\r\n * and max range, so basically, the table
    will contains only two items: {min, 0} and {max, 1}.\r\n * If 'series', timestamps
    will be positioned at the same distance from each other. In this\r\n * case, only
    timestamps that break the time linearity are registered, meaning that in the\r\n
    * best case, all timestamps are linear, the table contains only min and max.\r\n
    */\r\nfunction buildLookupTable(timestamps, min, max, distribution) {\r\n\tif
    (distribution === 'linear' || !timestamps.length) {\r\n\t\treturn [\r\n\t\t\t{time:
    min, pos: 0},\r\n\t\t\t{time: max, pos: 1}\r\n\t\t];\r\n\t}\r\n\r\n\tvar table
    = [];\r\n\tvar items = [min];\r\n\tvar i, ilen, prev, curr, next;\r\n\r\n\tfor
    (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\tcurr = timestamps[i];\r\n\t\tif
    (curr > min && curr < max) {\r\n\t\t\titems.push(curr);\r\n\t\t}\r\n\t}\r\n\r\n\titems.push(max);\r\n\r\n\tfor
    (i = 0, ilen = items.length; i < ilen; ++i) {\r\n\t\tnext = items[i + 1];\r\n\t\tprev
    = items[i - 1];\r\n\t\tcurr = items[i];\r\n\r\n\t\t// only add points that breaks
    the scale linearity\r\n\t\tif (prev === undefined || next === undefined || Math.round((next
    + prev) / 2) !== curr) {\r\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    table;\r\n}\r\n\r\n// @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\r\nfunction
    lookup(table, key, value) {\r\n\tvar lo = 0;\r\n\tvar hi = table.length - 1;\r\n\tvar
    mid, i0, i1;\r\n\r\n\twhile (lo >= 0 && lo <= hi) {\r\n\t\tmid = (lo + hi) >>
    1;\r\n\t\ti0 = table[mid - 1] || null;\r\n\t\ti1 = table[mid];\r\n\r\n\t\tif (!i0)
    {\r\n\t\t\t// given value is outside table (before first item)\r\n\t\t\treturn
    {lo: null, hi: i1};\r\n\t\t} else if (i1[key] < value) {\r\n\t\t\tlo = mid + 1;\r\n\t\t}
    else if (i0[key] > value) {\r\n\t\t\thi = mid - 1;\r\n\t\t} else {\r\n\t\t\treturn
    {lo: i0, hi: i1};\r\n\t\t}\r\n\t}\r\n\r\n\t// given value is outside table (after
    last item)\r\n\treturn {lo: i1, hi: null};\r\n}\r\n\r\n/**\r\n * Linearly interpolates
    the given source `value` using the table items `skey` values and\r\n * returns
    the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n
    * returns the position for a timestamp equal to 42. If value is out of bounds,
    values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n
    */\r\nfunction interpolate$1(table, skey, sval, tkey) {\r\n\tvar range = lookup(table,
    skey, sval);\r\n\r\n\t// Note: the lookup table ALWAYS contains at least 2 items
    (min and max)\r\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length
    - 2] : range.lo;\r\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length
    - 1] : range.hi;\r\n\r\n\tvar span = next[skey] - prev[skey];\r\n\tvar ratio =
    span ? (sval - prev[skey]) / span : 0;\r\n\tvar offset = (next[tkey] - prev[tkey])
    * ratio;\r\n\r\n\treturn prev[tkey] + offset;\r\n}\r\n\r\nfunction toTimestamp(scale,
    input) {\r\n\tvar adapter = scale._adapter;\r\n\tvar options = scale.options.time;\r\n\tvar
    parser = options.parser;\r\n\tvar format = parser || options.format;\r\n\tvar
    value = input;\r\n\r\n\tif (typeof parser === 'function') {\r\n\t\tvalue = parser(value);\r\n\t}\r\n\r\n\t//
    Only parse if its not a timestamp already\r\n\tif (!helpers$1.isFinite(value))
    {\r\n\t\tvalue = typeof format === 'string'\r\n\t\t\t? adapter.parse(value, format)\r\n\t\t\t:
    adapter.parse(value);\r\n\t}\r\n\r\n\tif (value !== null) {\r\n\t\treturn +value;\r\n\t}\r\n\r\n\t//
    Labels are in an incompatible format and no `parser` has been provided.\r\n\t//
    The user might still use the deprecated `format` option for parsing.\r\n\tif (!parser
    && typeof format === 'function') {\r\n\t\tvalue = format(input);\r\n\r\n\t\t//
    `format` could return something else than a timestamp, if so, parse it\r\n\t\tif
    (!helpers$1.isFinite(value)) {\r\n\t\t\tvalue = adapter.parse(value);\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    value;\r\n}\r\n\r\nfunction parse(scale, input) {\r\n\tif (helpers$1.isNullOrUndef(input))
    {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar options = scale.options.time;\r\n\tvar
    value = toTimestamp(scale, scale.getRightValue(input));\r\n\tif (value === null)
    {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tif (options.round) {\r\n\t\tvalue = +scale._adapter.startOf(value,
    options.round);\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Figures out
    what unit results in an appropriate number of auto-generated ticks\r\n */\r\nfunction
    determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n\tvar ilen = UNITS.length;\r\n\tvar
    i, interval, factor;\r\n\r\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i)
    {\r\n\t\tinterval = INTERVALS[UNITS[i]];\r\n\t\tfactor = interval.steps ? interval.steps
    : MAX_INTEGER;\r\n\r\n\t\tif (interval.common && Math.ceil((max - min) / (factor
    * interval.size)) <= capacity) {\r\n\t\t\treturn UNITS[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    UNITS[ilen - 1];\r\n}\r\n\r\n/**\r\n * Figures out what unit to format a set of
    ticks with\r\n */\r\nfunction determineUnitForFormatting(scale, numTicks, minUnit,
    min, max) {\r\n\tvar i, unit;\r\n\r\n\tfor (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit);
    i--) {\r\n\t\tunit = UNITS[i];\r\n\t\tif (INTERVALS[unit].common && scale._adapter.diff(max,
    min, unit) >= numTicks - 1) {\r\n\t\t\treturn unit;\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\n\r\nfunction determineMajorUnit(unit)
    {\r\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i)
    {\r\n\t\tif (INTERVALS[UNITS[i]].common) {\r\n\t\t\treturn UNITS[i];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n
    * Generates a maximum of `capacity` timestamps between min and max, rounded to
    the\r\n * `minor` unit using the given scale time `options`.\r\n * Important:
    this method can return ticks outside the min and max range, it's the\r\n * responsibility
    of the calling code to clamp values if needed.\r\n */\r\nfunction generate(scale,
    min, max, capacity) {\r\n\tvar adapter = scale._adapter;\r\n\tvar options = scale.options;\r\n\tvar
    timeOpts = options.time;\r\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit,
    min, max, capacity);\r\n\tvar stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize,
    1]);\r\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n\tvar
    first = min;\r\n\tvar ticks = [];\r\n\tvar time;\r\n\r\n\t// For 'week' unit,
    handle the first day of week option\r\n\tif (weekday) {\r\n\t\tfirst = +adapter.startOf(first,
    'isoWeek', weekday);\r\n\t}\r\n\r\n\t// Align first ticks on unit\r\n\tfirst =
    +adapter.startOf(first, weekday ? 'day' : minor);\r\n\r\n\t// Prevent browser
    from freezing in case user options request millions of milliseconds\r\n\tif (adapter.diff(max,
    min, minor) > 100000 * stepSize) {\r\n\t\tthrow min + ' and ' + max + ' are too
    far apart with stepSize of ' + stepSize + ' ' + minor;\r\n\t}\r\n\r\n\tfor (time
    = first; time < max; time = +adapter.add(time, stepSize, minor)) {\r\n\t\tticks.push(time);\r\n\t}\r\n\r\n\tif
    (time === max || options.bounds === 'ticks') {\r\n\t\tticks.push(time);\r\n\t}\r\n\r\n\treturn
    ticks;\r\n}\r\n\r\n/**\r\n * Returns the start and end offsets from edges in the
    form of {start, end}\r\n * where each value is a relative width to the scale and
    ranges between 0 and 1.\r\n * They add extra margins on the both sides by scaling
    down the original scale.\r\n * Offsets are added when the `offset` option is true.\r\n
    */\r\nfunction computeOffsets(table, ticks, min, max, options) {\r\n\tvar start
    = 0;\r\n\tvar end = 0;\r\n\tvar first, last;\r\n\r\n\tif (options.offset && ticks.length)
    {\r\n\t\tfirst = interpolate$1(table, 'time', ticks[0], 'pos');\r\n\t\tif (ticks.length
    === 1) {\r\n\t\t\tstart = 1 - first;\r\n\t\t} else {\r\n\t\t\tstart = (interpolate$1(table,
    'time', ticks[1], 'pos') - first) / 2;\r\n\t\t}\r\n\t\tlast = interpolate$1(table,
    'time', ticks[ticks.length - 1], 'pos');\r\n\t\tif (ticks.length === 1) {\r\n\t\t\tend
    = last;\r\n\t\t} else {\r\n\t\t\tend = (last - interpolate$1(table, 'time', ticks[ticks.length
    - 2], 'pos')) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn {start: start, end: end, factor:
    1 / (start + 1 + end)};\r\n}\r\n\r\nfunction setMajorTicks(scale, ticks, map,
    majorUnit) {\r\n\tvar adapter = scale._adapter;\r\n\tvar first = +adapter.startOf(ticks[0].value,
    majorUnit);\r\n\tvar last = ticks[ticks.length - 1].value;\r\n\tvar major, index;\r\n\r\n\tfor
    (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n\t\tindex
    = map[major];\r\n\t\tif (index >= 0) {\r\n\t\t\tticks[index].major = true;\r\n\t\t}\r\n\t}\r\n\treturn
    ticks;\r\n}\r\n\r\nfunction ticksFromTimestamps(scale, values, majorUnit) {\r\n\tvar
    ticks = [];\r\n\tvar map = {};\r\n\tvar ilen = values.length;\r\n\tvar i, value;\r\n\r\n\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\tvalue = values[i];\r\n\t\tmap[value] = i;\r\n\r\n\t\tticks.push({\r\n\t\t\tvalue:
    value,\r\n\t\t\tmajor: false\r\n\t\t});\r\n\t}\r\n\r\n\t// We set the major ticks
    separately from the above loop because calling startOf for every tick\r\n\t//
    is expensive when there is a large number of ticks\r\n\treturn (ilen === 0 ||
    !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\n\r\nvar
    defaultConfig$4 = {\r\n\tposition: 'bottom',\r\n\r\n\t/**\r\n\t * Data distribution
    along the scale:\r\n\t * - 'linear': data are spread according to their time (distances
    can vary),\r\n\t * - 'series': data are spread at the same distance from each
    other.\r\n\t * @see https://github.com/chartjs/Chart.js/pull/4507\r\n\t * @since
    2.7.0\r\n\t */\r\n\tdistribution: 'linear',\r\n\r\n\t/**\r\n\t * Scale boundary
    strategy (bypassed by min/max time options)\r\n\t * - `data`: make sure data are
    fully visible, ticks outside are removed\r\n\t * - `ticks`: make sure ticks are
    fully visible, data outside are truncated\r\n\t * @see https://github.com/chartjs/Chart.js/pull/4556\r\n\t
    * @since 2.7.0\r\n\t */\r\n\tbounds: 'data',\r\n\r\n\tadapters: {},\r\n\ttime:
    {\r\n\t\tparser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/
    or a custom callback that converts its argument to a moment\r\n\t\tunit: false,
    // false == automatic or override with week, month, year, etc.\r\n\t\tround: false,
    // none, or override with week, month, year, etc.\r\n\t\tdisplayFormat: false,
    // DEPRECATED\r\n\t\tisoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\r\n\t\tminUnit:
    'millisecond',\r\n\t\tdisplayFormats: {}\r\n\t},\r\n\tticks: {\r\n\t\tautoSkip:
    false,\r\n\r\n\t\t/**\r\n\t\t * Ticks generation input values:\r\n\t\t * - 'auto':
    generates \"optimal\" ticks based on scale size and time options.\r\n\t\t * -
    'data': generates ticks from data (including labels from data {t|x|y} objects).\r\n\t\t
    * - 'labels': generates ticks from user given `data.labels` values ONLY.\r\n\t\t
    * @see https://github.com/chartjs/Chart.js/pull/4507\r\n\t\t * @since 2.7.0\r\n\t\t
    */\r\n\t\tsource: 'auto',\r\n\r\n\t\tmajor: {\r\n\t\t\tenabled: false\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar
    scale_time = core_scale.extend({\r\n\tinitialize: function() {\r\n\t\tthis.mergeTicksOptions();\r\n\t\tcore_scale.prototype.initialize.call(this);\r\n\t},\r\n\r\n\tupdate:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    time = options.time || (options.time = {});\r\n\t\tvar adapter = me._adapter =
    new core_adapters._date(options.adapters.date);\r\n\r\n\t\t// DEPRECATIONS: output
    a message only one time per update\r\n\t\tdeprecated$1('time scale', time.format,
    'time.format', 'time.parser');\r\n\t\tdeprecated$1('time scale', time.min, 'time.min',
    'ticks.min');\r\n\t\tdeprecated$1('time scale', time.max, 'time.max', 'ticks.max');\r\n\r\n\t\t//
    Backward compatibility: before introducing adapter, `displayFormats` was\r\n\t\t//
    supposed to contain *all* unit/string pairs but this can't be resolved\r\n\t\t//
    when loading the scale (adapters are loaded afterward), so let's populate\r\n\t\t//
    missing formats on update\r\n\t\thelpers$1.mergeIf(time.displayFormats, adapter.formats());\r\n\r\n\t\treturn
    core_scale.prototype.update.apply(me, arguments);\r\n\t},\r\n\r\n\t/**\r\n\t *
    Allows data to be referenced via 't' attribute\r\n\t */\r\n\tgetRightValue: function(rawValue)
    {\r\n\t\tif (rawValue && rawValue.t !== undefined) {\r\n\t\t\trawValue = rawValue.t;\r\n\t\t}\r\n\t\treturn
    core_scale.prototype.getRightValue.call(this, rawValue);\r\n\t},\r\n\r\n\tdetermineDataLimits:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar adapter
    = me._adapter;\r\n\t\tvar options = me.options;\r\n\t\tvar unit = options.time.unit
    || 'day';\r\n\t\tvar min = MAX_INTEGER;\r\n\t\tvar max = MIN_INTEGER;\r\n\t\tvar
    timestamps = [];\r\n\t\tvar datasets = [];\r\n\t\tvar labels = [];\r\n\t\tvar
    i, j, ilen, jlen, data, timestamp, labelsAdded;\r\n\t\tvar dataLabels = me._getLabels();\r\n\r\n\t\tfor
    (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\tlabels.push(parse(me,
    dataLabels[i]));\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = (chart.data.datasets ||
    []).length; i < ilen; ++i) {\r\n\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\tdata
    = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t// Let's consider that all data
    have the same format.\r\n\t\t\t\tif (helpers$1.isObject(data[0])) {\r\n\t\t\t\t\tdatasets[i]
    = [];\r\n\r\n\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\ttimestamp
    = parse(me, data[j]);\r\n\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\tdatasets[i][j]
    = timestamp;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\tif
    (!labelsAdded) {\r\n\t\t\t\t\t\ttimestamps = timestamps.concat(labels);\r\n\t\t\t\t\t\tlabelsAdded
    = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tdatasets[i] =
    [];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (labels.length) {\r\n\t\t\tmin = Math.min(min,
    labels[0]);\r\n\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t}\r\n\r\n\t\tif
    (timestamps.length) {\r\n\t\t\ttimestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter)
    : timestamps.sort(sorter);\r\n\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\tmax
    = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t}\r\n\r\n\t\tmin =
    parse(me, getMin(options)) || min;\r\n\t\tmax = parse(me, getMax(options)) ||
    max;\r\n\r\n\t\t// In case there is no valid min/max, set limits based on unit
    time option\r\n\t\tmin = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit)
    : min;\r\n\t\tmax = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1
    : max;\r\n\r\n\t\t// Make sure that max is strictly higher than min (required
    by the lookup table)\r\n\t\tme.min = Math.min(min, max);\r\n\t\tme.max = Math.max(min
    + 1, max);\r\n\r\n\t\t// PRIVATE\r\n\t\tme._table = [];\r\n\t\tme._timestamps
    = {\r\n\t\t\tdata: timestamps,\r\n\t\t\tdatasets: datasets,\r\n\t\t\tlabels: labels\r\n\t\t};\r\n\t},\r\n\r\n\tbuildTicks:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\t\tvar
    options = me.options;\r\n\t\tvar tickOpts = options.ticks;\r\n\t\tvar timeOpts
    = options.time;\r\n\t\tvar timestamps = me._timestamps;\r\n\t\tvar ticks = [];\r\n\t\tvar
    capacity = me.getLabelCapacity(min);\r\n\t\tvar source = tickOpts.source;\r\n\t\tvar
    distribution = options.distribution;\r\n\t\tvar i, ilen, timestamp;\r\n\r\n\t\tif
    (source === 'data' || (source === 'auto' && distribution === 'series')) {\r\n\t\t\ttimestamps
    = timestamps.data;\r\n\t\t} else if (source === 'labels') {\r\n\t\t\ttimestamps
    = timestamps.labels;\r\n\t\t} else {\r\n\t\t\ttimestamps = generate(me, min, max,
    capacity);\r\n\t\t}\r\n\r\n\t\tif (options.bounds === 'ticks' && timestamps.length)
    {\r\n\t\t\tmin = timestamps[0];\r\n\t\t\tmax = timestamps[timestamps.length -
    1];\r\n\t\t}\r\n\r\n\t\t// Enforce limits with user min/max options\r\n\t\tmin
    = parse(me, getMin(options)) || min;\r\n\t\tmax = parse(me, getMax(options)) ||
    max;\r\n\r\n\t\t// Remove ticks outside the min/max range\r\n\t\tfor (i = 0, ilen
    = timestamps.length; i < ilen; ++i) {\r\n\t\t\ttimestamp = timestamps[i];\r\n\t\t\tif
    (timestamp >= min && timestamp <= max) {\r\n\t\t\t\tticks.push(timestamp);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.min
    = min;\r\n\t\tme.max = max;\r\n\r\n\t\t// PRIVATE\r\n\t\t// determineUnitForFormatting
    relies on the number of ticks so we don't use it when\r\n\t\t// autoSkip is enabled
    because we don't yet know what the final number of ticks will be\r\n\t\tme._unit
    = timeOpts.unit || (tickOpts.autoSkip\r\n\t\t\t? determineUnitForAutoTicks(timeOpts.minUnit,
    me.min, me.max, capacity)\r\n\t\t\t: determineUnitForFormatting(me, ticks.length,
    timeOpts.minUnit, me.min, me.max));\r\n\t\tme._majorUnit = !tickOpts.major.enabled
    || me._unit === 'year' ? undefined\r\n\t\t\t: determineMajorUnit(me._unit);\r\n\t\tme._table
    = buildLookupTable(me._timestamps.data, min, max, distribution);\r\n\t\tme._offsets
    = computeOffsets(me._table, ticks, min, max, options);\r\n\r\n\t\tif (tickOpts.reverse)
    {\r\n\t\t\tticks.reverse();\r\n\t\t}\r\n\r\n\t\treturn ticksFromTimestamps(me,
    ticks, me._majorUnit);\r\n\t},\r\n\r\n\tgetLabelForIndex: function(index, datasetIndex)
    {\r\n\t\tvar me = this;\r\n\t\tvar adapter = me._adapter;\r\n\t\tvar data = me.chart.data;\r\n\t\tvar
    timeOpts = me.options.time;\r\n\t\tvar label = data.labels && index < data.labels.length
    ? data.labels[index] : '';\r\n\t\tvar value = data.datasets[datasetIndex].data[index];\r\n\r\n\t\tif
    (helpers$1.isObject(value)) {\r\n\t\t\tlabel = me.getRightValue(value);\r\n\t\t}\r\n\t\tif
    (timeOpts.tooltipFormat) {\r\n\t\t\treturn adapter.format(toTimestamp(me, label),
    timeOpts.tooltipFormat);\r\n\t\t}\r\n\t\tif (typeof label === 'string') {\r\n\t\t\treturn
    label;\r\n\t\t}\r\n\t\treturn adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Function to format an individual tick mark\r\n\t * @private\r\n\t */\r\n\ttickFormatFunction:
    function(time, index, ticks, format) {\r\n\t\tvar me = this;\r\n\t\tvar adapter
    = me._adapter;\r\n\t\tvar options = me.options;\r\n\t\tvar formats = options.time.displayFormats;\r\n\t\tvar
    minorFormat = formats[me._unit];\r\n\t\tvar majorUnit = me._majorUnit;\r\n\t\tvar
    majorFormat = formats[majorUnit];\r\n\t\tvar tick = ticks[index];\r\n\t\tvar tickOpts
    = options.ticks;\r\n\t\tvar major = majorUnit && majorFormat && tick && tick.major;\r\n\t\tvar
    label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\r\n\t\tvar
    nestedTickOpts = major ? tickOpts.major : tickOpts.minor;\r\n\t\tvar formatter
    = resolve$5([\r\n\t\t\tnestedTickOpts.callback,\r\n\t\t\tnestedTickOpts.userCallback,\r\n\t\t\ttickOpts.callback,\r\n\t\t\ttickOpts.userCallback\r\n\t\t]);\r\n\r\n\t\treturn
    formatter ? formatter(label, index, ticks) : label;\r\n\t},\r\n\r\n\tconvertTicksToLabels:
    function(ticks) {\r\n\t\tvar labels = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i
    = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\tlabels.push(this.tickFormatFunction(ticks[i].value,
    i, ticks));\r\n\t\t}\r\n\r\n\t\treturn labels;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tgetPixelForOffset: function(time) {\r\n\t\tvar me = this;\r\n\t\tvar offsets
    = me._offsets;\r\n\t\tvar pos = interpolate$1(me._table, 'time', time, 'pos');\r\n\t\treturn
    me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n\t},\r\n\r\n\tgetPixelForValue:
    function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar time =
    null;\r\n\r\n\t\tif (index !== undefined && datasetIndex !== undefined) {\r\n\t\t\ttime
    = me._timestamps.datasets[datasetIndex][index];\r\n\t\t}\r\n\r\n\t\tif (time ===
    null) {\r\n\t\t\ttime = parse(me, value);\r\n\t\t}\r\n\r\n\t\tif (time !== null)
    {\r\n\t\t\treturn me.getPixelForOffset(time);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPixelForTick:
    function(index) {\r\n\t\tvar ticks = this.getTicks();\r\n\t\treturn index >= 0
    && index < ticks.length ?\r\n\t\t\tthis.getPixelForOffset(ticks[index].value)
    :\r\n\t\t\tnull;\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel) {\r\n\t\tvar
    me = this;\r\n\t\tvar offsets = me._offsets;\r\n\t\tvar pos = me.getDecimalForPixel(pixel)
    / offsets.factor - offsets.end;\r\n\t\tvar time = interpolate$1(me._table, 'pos',
    pos, 'time');\r\n\r\n\t\t// DEPRECATION, we should return time directly\r\n\t\treturn
    me._adapter._create(time);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLabelSize:
    function(label) {\r\n\t\tvar me = this;\r\n\t\tvar ticksOpts = me.options.ticks;\r\n\t\tvar
    tickLabelWidth = me.ctx.measureText(label).width;\r\n\t\tvar angle = helpers$1.toRadians(me.isHorizontal()
    ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n\t\tvar cosRotation = Math.cos(angle);\r\n\t\tvar
    sinRotation = Math.sin(angle);\r\n\t\tvar tickFontSize = valueOrDefault$d(ticksOpts.fontSize,
    core_defaults.global.defaultFontSize);\r\n\r\n\t\treturn {\r\n\t\t\tw: (tickLabelWidth
    * cosRotation) + (tickFontSize * sinRotation),\r\n\t\t\th: (tickLabelWidth * sinRotation)
    + (tickFontSize * cosRotation)\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Crude approximation
    of what the label width might be\r\n\t * @private\r\n\t */\r\n\tgetLabelWidth:
    function(label) {\r\n\t\treturn this._getLabelSize(label).w;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tgetLabelCapacity: function(exampleTime) {\r\n\t\tvar
    me = this;\r\n\t\tvar timeOpts = me.options.time;\r\n\t\tvar displayFormats =
    timeOpts.displayFormats;\r\n\r\n\t\t// pick the longest format (milliseconds)
    for guestimation\r\n\t\tvar format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n\t\tvar
    exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime],
    me._majorUnit), format);\r\n\t\tvar size = me._getLabelSize(exampleLabel);\r\n\t\tvar
    capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);\r\n\r\n\t\tif
    (me.options.offset) {\r\n\t\t\tcapacity--;\r\n\t\t}\r\n\r\n\t\treturn capacity
    > 0 ? capacity : 1;\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options,
    registered in src/index.js\r\nvar _defaults$4 = defaultConfig$4;\nscale_time._defaults
    = _defaults$4;\n\nvar scales = {\r\n\tcategory: scale_category,\r\n\tlinear: scale_linear,\r\n\tlogarithmic:
    scale_logarithmic,\r\n\tradialLinear: scale_radialLinear,\r\n\ttime: scale_time\r\n};\n\nvar
    moment = createCommonjsModule(function (module, exports) {\n(function (global,
    factory) {\n     module.exports = factory() ;\n}(commonjsGlobal, (function ()
    {\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null,
    arguments);\n    }\n\n    // This is done to register the method called with moment()\n
    \   // without creating circular dependencies.\n    function setHookCallback (callback)
    {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n
    \       return input instanceof Array || Object.prototype.toString.call(input)
    === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8
    will treat undefined and null as object if it wasn't for\n        // input !=
    null\n        return input != null && Object.prototype.toString.call(input) ===
    '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames)
    {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        }
    else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k))
    {\n                    return false;\n                }\n            }\n            return
    true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input
    === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input
    === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n
    \   }\n\n    function isDate(input) {\n        return input instanceof Date ||
    Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function
    map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length;
    ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n
    \   }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a,
    b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if
    (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n
    \       if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n
    \       }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf =
    b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input,
    format, locale, strict) {\n        return createLocalOrUTC(input, format, locale,
    strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        //
    We need to deep clone this object.\n        return {\n            empty           :
    false,\n            unusedTokens    : [],\n            unusedInput     : [],\n
    \           overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput
    \      : false,\n            invalidMonth    : null,\n            invalidFormat
    \  : false,\n            userInvalidated : false,\n            iso             :
    false,\n            parsedDateParts : [],\n            meridiem        : null,\n
    \           rfc2822         : false,\n            weekdayMismatch : false\n        };\n
    \   }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf
    = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n
    \   if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else
    {\n        some = function (fun) {\n            var t = Object(this);\n            var
    len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if
    (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n
    \           }\n\n            return false;\n        };\n    }\n\n    function
    isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n
    \           var parsedParts = some.call(flags.parsedDateParts, function (i) {\n
    \               return i != null;\n            });\n            var isNowValid
    = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty
    &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday
    &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput
    &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated
    &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n
    \           if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver
    === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour
    === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m))
    {\n                m._isValid = isNowValid;\n            }\n            else {\n
    \               return isNowValid;\n            }\n        }\n        return m._isValid;\n
    \   }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n
    \       if (flags != null) {\n            extend(getParsingFlags(m), flags);\n
    \       }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n
    \       }\n\n        return m;\n    }\n\n    // Plugins that add properties should
    also add the key here (null value),\n    // so we can properly clone ourselves.\n
    \   var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to,
    from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject))
    {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if
    (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if
    (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if
    (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if
    (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n
    \       if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n
    \       if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n
    \       }\n        if (!isUndefined(from._offset)) {\n            to._offset =
    from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf
    = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n
    \           to._locale = from._locale;\n        }\n\n        if (momentProperties.length
    > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop
    = momentProperties[i];\n                val = from[prop];\n                if
    (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n
    \           }\n        }\n\n        return to;\n    }\n\n    var updateInProgress
    = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this,
    config);\n        this._d = new Date(config._d != null ? config._d.getTime() :
    NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n
    \       }\n        // Prevent infinite loop in case updateOffset creates new moment\n
    \       // objects.\n        if (updateInProgress === false) {\n            updateInProgress
    = true;\n            hooks.updateOffset(this);\n            updateInProgress =
    false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj
    instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n
    \   function absFloor (number) {\n        if (number < 0) {\n            // -0
    -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return
    Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion)
    {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n
    \       if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value
    = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    //
    compare two arrays, return the number of differences\n    function compareArrays(array1,
    array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n
    \           lengthDiff = Math.abs(array1.length - array2.length),\n            diffs
    = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert
    && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i])
    !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n
    \       return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if
    (hooks.suppressDeprecationWarnings === false &&\n                (typeof console
    !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning:
    ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var
    firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler
    != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n
    \           if (firstTime) {\n                var args = [];\n                var
    arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg
    = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg
    += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n
    \                           arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n
    \                       arg = arg.slice(0, -2); // Remove trailing comma and space\n
    \                   } else {\n                        arg = arguments[i];\n                    }\n
    \                   args.push(arg);\n                }\n                warn(msg
    + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new
    Error()).stack);\n                firstTime = false;\n            }\n            return
    fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n
    \   function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler
    != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if
    (!deprecations[name]) {\n            warn(msg);\n            deprecations[name]
    = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n
    \   hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return
    input instanceof Function || Object.prototype.toString.call(input) === '[object
    Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for
    (i in config) {\n            prop = config[i];\n            if (isFunction(prop))
    {\n                this[i] = prop;\n            } else {\n                this['_'
    + i] = prop;\n            }\n        }\n        this._config = config;\n        //
    Lenient ordinal parsing accepts just a number in addition to\n        // number
    + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove
    \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient
    = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source)
    +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig,
    childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for
    (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if
    (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop]
    = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop],
    childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n
    \                   res[prop] = childConfig[prop];\n                } else {\n
    \                   delete res[prop];\n                }\n            }\n        }\n
    \       for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig,
    prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop]))
    {\n                // make sure changes to properties don't modify parent config\n
    \               res[prop] = extend({}, res[prop]);\n            }\n        }\n
    \       return res;\n    }\n\n    function Locale(config) {\n        if (config
    != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n
    \   if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys
    = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n
    \               if (hasOwnProp(obj, i)) {\n                    res.push(i);\n
    \               }\n            }\n            return res;\n        };\n    }\n\n
    \   var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay
    : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday
    at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n
    \   };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key]
    || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom,
    now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss
    A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM
    D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D,
    YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format
    = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n
    \       if (format || !formatUpper) {\n            return format;\n        }\n\n
    \       this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function
    (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n
    \   }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate
    () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n
    \   var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number)
    {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime
    = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few
    seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm :
    '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  :
    'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n
    \       y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime
    (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n
    \       return (isFunction(output)) ?\n            output(number, withoutSuffix,
    string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function
    pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0
    ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i,
    output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand)
    {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase
    + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units)
    {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()]
    : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var
    normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for
    (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp
    = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp]
    = inputObject[prop];\n                }\n            }\n        }\n\n        return
    normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit,
    priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj)
    {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit:
    u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n
    \           return a.priority - b.priority;\n        });\n        return units;\n
    \   }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var
    absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n
    \           sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '')
    : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1)
    + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n
    \   var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n
    \   var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    //
    token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback:
    function () { this.month() + 1 }\n    function addFormatToken (token, padded,
    ordinal, callback) {\n        var func = callback;\n        if (typeof callback
    === 'string') {\n            func = function () {\n                return this[callback]();\n
    \           };\n        }\n        if (token) {\n            formatTokenFunctions[token]
    = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]]
    = function () {\n                return zeroFill(func.apply(this, arguments),
    padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal]
    = function () {\n                return this.localeData().ordinal(func.apply(this,
    arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input)
    {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g,
    '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function
    makeFormatFunction(format) {\n        var array = format.match(formattingTokens),
    i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n
    \           if (formatTokenFunctions[array[i]]) {\n                array[i] =
    formatTokenFunctions[array[i]];\n            } else {\n                array[i]
    = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return
    function (mom) {\n            var output = '', i;\n            for (i = 0; i <
    length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom,
    format) : array[i];\n            }\n            return output;\n        };\n    }\n\n
    \   // format date using native date object\n    function formatMoment(m, format)
    {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n
    \       }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format]
    = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n
    \   }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function
    replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input)
    || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while
    (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens,
    replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n
    \           i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1
    \        = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;
    \         //      00 - 99\n    var match3         = /\\d{3}/;         //     000
    - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6
    \        = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;
    \        //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999
    - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n
    \   var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4
    \     = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;
    \ // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0
    - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var
    matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n
    \   var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00
    +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789
    123456789.123\n\n    // any word (or two) characters or numbers including two/three
    word month in arabic.\n    // includes scottish gaelic two word and hyphenated
    months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n
    \   var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex)
    {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData)
    {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n
    \   }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes,
    token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n
    \       return regexes[token](config._strict, config._locale);\n    }\n\n    //
    Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n
    \   function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\',
    '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched,
    p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n
    \   function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g,
    '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token,
    callback) {\n        var i, func = callback;\n        if (typeof token === 'string')
    {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n
    \           func = function (input, array) {\n                array[callback]
    = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length;
    i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function
    addWeekParseToken (token, callback) {\n        addParseToken(token, function (input,
    array, config, token) {\n            config._w = config._w || {};\n            callback(input,
    config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token,
    input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n
    \           tokens[token](input, config._a, config, token);\n        }\n    }\n\n
    \   var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n
    \   var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK
    = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0,
    0, function () {\n        var y = this.year();\n        return y <= 9999 ? ''
    + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n
    \       return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],
    \      0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0,
    ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year',
    'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n
    \   addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2,
    match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',
    \ match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY',
    'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR]
    = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n
    \   addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n
    \   });\n    addParseToken('Y', function (input, array) {\n        array[YEAR]
    = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year)
    {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year)
    {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n
    \   }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return
    toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n
    \   var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear
    () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet
    (unit, keepTime) {\n        return function (value) {\n            if (value !=
    null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this,
    keepTime);\n                return this;\n            } else {\n                return
    get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit)
    {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC'
    : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if
    (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year())
    && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC
    ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n
    \           }\n            else {\n                mom._d['set' + (mom._isUTC
    ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n
    \   function stringGet (units) {\n        units = normalizeUnits(units);\n        if
    (isFunction(this[units])) {\n            return this[units]();\n        }\n        return
    this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof
    units === 'object') {\n            units = normalizeObjectUnits(units);\n            var
    prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length;
    i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n
    \           }\n        } else {\n            units = normalizeUnits(units);\n
    \           if (isFunction(this[units])) {\n                return this[units](value);\n
    \           }\n        }\n        return this;\n    }\n\n    function mod(n, x)
    {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf)
    {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf =
    function (o) {\n            // I know\n            var i;\n            for (i
    = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return
    i;\n                }\n            }\n            return -1;\n        };\n    }\n\n
    \   function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month))
    {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n
    \       year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year)
    ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M',
    ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n
    \   addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this,
    format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return
    this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month',
    'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n
    \   addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n
    \   addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n
    \   });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return
    locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function
    (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM',
    'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input,
    token, config._strict);\n        // if we didn't find a month name, mark the date
    as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n
    \       } else {\n            getParsingFlags(config).invalidMonth = input;\n
    \       }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n
    \   var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n
    \   function localeMonths (m, format) {\n        if (!m) {\n            return
    isArray(this._months) ? this._months :\n                this._months['standalone'];\n
    \       }\n        return isArray(this._months) ? this._months[m.month()] :\n
    \           this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format)
    ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort
    = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function
    localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort)
    ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n
    \       return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format)
    ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName,
    format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n
    \       if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse
    = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse
    = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000,
    i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n
    \               this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n
    \           }\n        }\n\n        if (strict) {\n            if (format ===
    'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return
    ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse,
    llc);\n                return ii !== -1 ? ii : null;\n            }\n        }
    else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse,
    llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n
    \               ii = indexOf.call(this._longMonthsParse, llc);\n                return
    ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse,
    llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n
    \               ii = indexOf.call(this._shortMonthsParse, llc);\n                return
    ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse
    (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact)
    {\n            return handleStrictParse.call(this, monthName, format, strict);\n
    \       }\n\n        if (!this._monthsParse) {\n            this._monthsParse
    = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse
    = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure
    if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n
    \       for (i = 0; i < 12; i++) {\n            // make the regex if we don't
    have it already\n            mom = createUTC([2000, i]);\n            if (strict
    && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new
    RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i]
    = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n
    \           if (!strict && !this._monthsParse[i]) {\n                regex = '^'
    + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i]
    = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test
    the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName))
    {\n                return i;\n            } else if (strict && format === 'MMM'
    && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            }
    else if (!strict && this._monthsParse[i].test(monthName)) {\n                return
    i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth
    (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            //
    No op\n            return mom;\n        }\n\n        if (typeof value === 'string')
    {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n
    \           } else {\n                value = mom.localeData().monthsParse(value);\n
    \               // TODO: Another silent failure?\n                if (!isNumber(value))
    {\n                    return mom;\n                }\n            }\n        }\n\n
    \       dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set'
    + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n
    \   }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this,
    value);\n            hooks.updateOffset(this, true);\n            return this;\n
    \       } else {\n            return get(this, 'Month');\n        }\n    }\n\n
    \   function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n
    \   }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex
    (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this,
    '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n
    \           if (isStrict) {\n                return this._monthsShortStrictRegex;\n
    \           } else {\n                return this._monthsShortRegex;\n            }\n
    \       } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n
    \               this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n
    \           return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex
    : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n
    \   function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n
    \           if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n
    \           }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n
    \           } else {\n                return this._monthsRegex;\n            }\n
    \       } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex
    = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex
    && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n
    \       }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a,
    b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces
    = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i
    = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n
    \           mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom,
    ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom,
    ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        //
    Sorting makes sure if one month (or abbr) is a prefix of another it\n        //
    will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n
    \       mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i]
    = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n
    \       }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n
    \       }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|')
    + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex
    = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex
    = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function
    createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a
    date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        //
    the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y
    >= 0) {\n            // preserve leap years using a full 400 year cycle, then
    reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if
    (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n
    \       } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n\n
    \       return date;\n    }\n\n    function createUTCDate (y) {\n        var date;\n
    \       // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y
    < 100 && y >= 0) {\n            var args = Array.prototype.slice.call(arguments);\n
    \           // preserve leap years using a full 400 year cycle, then reset\n            args[0]
    = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if
    (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n
    \           }\n        } else {\n            date = new Date(Date.UTC.apply(null,
    arguments));\n        }\n\n        return date;\n    }\n\n    // start-of-first-week
    - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var //
    first-week day -- which january is always in the first week (4 for iso, 1 for
    other)\n            fwd = 7 + dow - doy,\n            // first-week day local
    weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year,
    0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n
    \   // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n
    \   function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var
    localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year,
    dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n
    \           resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear
    = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        }
    else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear
    = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n
    \           resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year:
    resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function
    weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(),
    dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) /
    7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear
    = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n
    \       } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek
    = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year()
    + 1;\n        } else {\n            resYear = mom.year();\n            resWeek
    = week;\n        }\n\n        return {\n            week: resWeek,\n            year:
    resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var
    weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year
    + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext)
    / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n
    \   addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week',
    'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week',
    5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',
    \ match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',
    \ match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w',
    'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0,
    1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function
    localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n
    \   }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first
    day of the week.\n        doy : 6  // The week that contains Jan 6th is the first
    week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return
    this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return
    this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n
    \       var week = this.localeData().week(this);\n        return input == null
    ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek
    (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input
    == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n
    \   addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function
    (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n
    \   addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this,
    format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return
    this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e',
    0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n
    \   addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday',
    'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday',
    11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',
    \   match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',
    \   match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return
    locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function
    (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n
    \   addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n
    \   });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week,
    config, token) {\n        var weekday = config._locale.weekdaysParse(input, token,
    config._strict);\n        // if we didn't get a weekday name, mark the date as
    invalid\n        if (weekday != null) {\n            week.d = weekday;\n        }
    else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n
    \   });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config,
    token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function
    parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return
    input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input,
    10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof
    input === 'number') {\n            return input;\n        }\n\n        return
    null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof
    input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n
    \       }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n
    \   function shiftWeekdays (ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0,
    n));\n    }\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n
    \   function localeWeekdays (m, format) {\n        var weekdays = isArray(this._weekdays)
    ? this._weekdays :\n            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format))
    ? 'format' : 'standalone'];\n        return (m === true) ? shiftWeekdays(weekdays,
    this._week.dow)\n            : (m) ? weekdays[m.day()] : weekdays;\n    }\n\n
    \   var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n
    \   function localeWeekdaysShort (m) {\n        return (m === true) ? shiftWeekdays(this._weekdaysShort,
    this._week.dow)\n            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n
    \   }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n
    \   function localeWeekdaysMin (m) {\n        return (m === true) ? shiftWeekdays(this._weekdaysMin,
    this._week.dow)\n            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n
    \   }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var
    i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse)
    {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse
    = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i <
    7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i]
    = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i]
    = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i]
    = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if
    (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse,
    llc);\n                return ii !== -1 ? ii : null;\n            } else if (format
    === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n
    \               return ii !== -1 ? ii : null;\n            } else {\n                ii
    = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1
    ? ii : null;\n            }\n        } else {\n            if (format === 'dddd')
    {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if
    (ii !== -1) {\n                    return ii;\n                }\n                ii
    = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1)
    {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse,
    llc);\n                return ii !== -1 ? ii : null;\n            } else if (format
    === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n
    \               if (ii !== -1) {\n                    return ii;\n                }\n
    \               ii = indexOf.call(this._weekdaysParse, llc);\n                if
    (ii !== -1) {\n                    return ii;\n                }\n                ii
    = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1
    ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse,
    llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n
    \               ii = indexOf.call(this._weekdaysParse, llc);\n                if
    (ii !== -1) {\n                    return ii;\n                }\n                ii
    = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !==
    -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse
    (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact)
    {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n
    \       }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse
    = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse
    = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i
    = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n
    \           mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i])
    {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom,
    '').replace('.', '\\\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i]
    = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n
    \               this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom,
    '').replace('.', '\\\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i])
    {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom,
    '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i]
    = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test
    the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName))
    {\n                return i;\n            } else if (strict && format === 'ddd'
    && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n
    \           } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName))
    {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName))
    {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n
    \   function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return
    input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay()
    : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input,
    this.localeData());\n            return this.add(input - day, 'd');\n        }
    else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek
    (input) {\n        if (!this.isValid()) {\n            return input != null ?
    this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow)
    % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n
    \   }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid())
    {\n            return input != null ? this : NaN;\n        }\n\n        // behaves
    the same as moment#day except\n        // as a getter, returns 7 instead of 0
    (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the
    previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input,
    this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday
    - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n
    \   var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict)
    {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this,
    '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n
    \           if (isStrict) {\n                return this._weekdaysStrictRegex;\n
    \           } else {\n                return this._weekdaysRegex;\n            }\n
    \       } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex
    = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex
    && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n
    \       }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function
    weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if
    (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n
    \           }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n
    \           } else {\n                return this._weekdaysShortRegex;\n            }\n
    \       } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n
    \               this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n
    \           return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex
    : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex
    = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact)
    {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n
    \           }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n
    \           } else {\n                return this._weekdaysMinRegex;\n            }\n
    \       } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n
    \               this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n
    \           return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex
    : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse
    () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n
    \       }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces
    = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++)
    {\n            // make the regex if we don't have it already\n            mom
    = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n
    \           shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom,
    '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n
    \           longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n
    \           mixedPieces.push(longp);\n        }\n        // Sorting makes sure
    if one weekday (or abbr) is a prefix of another it\n        // will match the
    longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n
    \       longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for
    (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n
    \           longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i]
    = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new
    RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex
    = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n
    \       this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')',
    'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|')
    + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|')
    + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return
    this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours()
    || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h',
    ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm',
    0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(),
    2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return
    '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(),
    2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return
    '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss',
    0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(),
    2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem
    (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return
    this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n
    \   }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n
    \   addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour',
    13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return
    locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',
    \ matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',
    \ match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2,
    match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk',
    match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss',
    match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss',
    match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k',
    'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n
    \       array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a',
    'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n
    \       config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function
    (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour
    = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n
    \       var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0,
    pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour
    = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n
    \       var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR]
    = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1,
    2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour
    = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n
    \       var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0,
    pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss',
    function (input, array, config) {\n        var pos1 = input.length - 4;\n        var
    pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n
    \       array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] =
    toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM
    (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing
    strings like arrays\n        // Using charAt should be more compatible.\n        return
    ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse
    = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n
    \       if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        }
    else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    //
    MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n
    \   // specified which hour they want. So trying to maintain the same hour (in\n
    \   // a new timezone) makes sense. Adding/subtracting hours does not follow\n
    \   // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var
    baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n
    \       invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse:
    defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n
    \       months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n
    \       week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n
    \       weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n
    \       meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage
    for locale config files\n    var locales = {};\n    var localeFamilies = {};\n
    \   var globalLocale;\n\n    function normalizeLocale(key) {\n        return key
    ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale
    from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in
    move through the list trying each\n    // substring from most specific to least,
    but move to the next array item if it's a more specific variant than the current
    root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale,
    split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n
    \           j = split.length;\n            next = normalizeLocale(names[i + 1]);\n
    \           next = next ? next.split('-') : null;\n            while (j > 0) {\n
    \               locale = loadLocale(split.slice(0, j).join('-'));\n                if
    (locale) {\n                    return locale;\n                }\n                if
    (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the
    next array item is better than a shallower substring of this one\n                    break;\n
    \               }\n                j--;\n            }\n            i++;\n        }\n
    \       return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var
    oldLocale = null;\n        // TODO: Find a better way to register and load all
    the locales in Node\n        if (!locales[name] && ('object' !== 'undefined')
    &&\n                module && module.exports) {\n            try {\n                oldLocale
    = globalLocale._abbr;\n                var aliasedRequire = commonjsRequire;\n
    \               aliasedRequire('./locale/' + name);\n                getSetGlobalLocale(oldLocale);\n
    \           } catch (e) {}\n        }\n        return locales[name];\n    }\n\n
    \   // This function will load locale and then set the global locale.  If\n    //
    no arguments are passed in, it will simply return the current global\n    // locale
    key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if
    (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n
    \           }\n            else {\n                data = defineLocale(key, values);\n
    \           }\n\n            if (data) {\n                // moment.duration._locale
    = moment._locale = data;\n                globalLocale = data;\n            }\n
    \           else {\n                if ((typeof console !==  'undefined') && console.warn)
    {\n                    //warn user if arguments are passed but the locale could
    not be set\n                    console.warn('Locale ' + key +  ' not found. Did
    you forget to load it?');\n                }\n            }\n        }\n\n        return
    globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if
    (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr
    = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n
    \                       'use moment.updateLocale(localeName, config) to change
    ' +\n                        'an existing locale. moment.defineLocale(localeName,
    ' +\n                        'config) should only be used for creating a new locale
    ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/
    for more info.');\n                parentConfig = locales[name]._config;\n            }
    else if (config.parentLocale != null) {\n                if (locales[config.parentLocale]
    != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n
    \               } else {\n                    locale = loadLocale(config.parentLocale);\n
    \                   if (locale != null) {\n                        parentConfig
    = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale])
    {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n
    \                       localeFamilies[config.parentLocale].push({\n                            name:
    name,\n                            config: config\n                        });\n
    \                       return null;\n                    }\n                }\n
    \           }\n            locales[name] = new Locale(mergeConfigs(parentConfig,
    config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function
    (x) {\n                    defineLocale(x.name, x.config);\n                });\n
    \           }\n\n            // backwards compat for now: also set the locale\n
    \           // make sure we set the locale AFTER all child locales have been\n
    \           // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n
    \           return locales[name];\n        } else {\n            // useful for
    testing\n            delete locales[name];\n            return null;\n        }\n
    \   }\n\n    function updateLocale(name, config) {\n        if (config != null)
    {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            //
    MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale !=
    null) {\n                parentConfig = tmpLocale._config;\n            }\n            config
    = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n
    \           locale.parentLocale = locales[name];\n            locales[name] =
    locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n
    \       } else {\n            // pass null for config to unupdate, useful for
    tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale
    != null) {\n                    locales[name] = locales[name].parentLocale;\n
    \               } else if (locales[name] != null) {\n                    delete
    locales[name];\n                }\n            }\n        }\n        return locales[name];\n
    \   }\n\n    // returns locale data\n    function getLocale (key) {\n        var
    locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key
    = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n
    \       }\n\n        if (!isArray(key)) {\n            //short-circuit everything
    else\n            locale = loadLocale(key);\n            if (locale) {\n                return
    locale;\n            }\n            key = [key];\n        }\n\n        return
    chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n
    \   }\n\n    function checkOverflow (m) {\n        var overflow;\n        var
    a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow
    =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]
    \       < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]
    \       < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND]
    !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 ||
    a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]
    \     > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] >
    999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear
    && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n
    \           }\n            if (getParsingFlags(m)._overflowWeeks && overflow ===
    -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday
    && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n
    \           getParsingFlags(m).overflow = overflow;\n        }\n\n        return
    m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function
    defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n
    \       if (b != null) {\n            return b;\n        }\n        return c;\n
    \   }\n\n    function currentDateArray(config) {\n        // hooks is actually
    the exported moment object\n        var nowValue = new Date(hooks.now());\n        if
    (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(),
    nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(),
    nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the
    array should mirror the parameters below\n    // note: all values past the year
    are optional and will default to the lowest possible value.\n    // [year, month,
    day , hour, minute, second, millisecond]\n    function configFromArray (config)
    {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n
    \       if (config._d) {\n            return;\n        }\n\n        currentDate
    = currentDateArray(config);\n\n        //compute day of the year from weeks and
    weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH]
    == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if
    the day of the year is set, figure out what it is\n        if (config._dayOfYear
    != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n
    \           if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear
    === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n
    \           }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n
    \           config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE]
    = date.getUTCDate();\n        }\n\n        // Default to current date.\n        //
    * if no year, month, day of month are given, default to today\n        // * if
    day of month is given, default month and year\n        // * if month is given,
    default only year\n        // * if year is given, don't default anything\n        for
    (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i]
    = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted,
    including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i]
    = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        //
    Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE]
    === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND]
    === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n
    \       }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null,
    input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n
    \       // Apply timezone offset from input. The actual utcOffset can be changed\n
    \       // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes()
    - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR]
    = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w
    && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n
    \           getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n
    \   function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday,
    dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG !=
    null || w.W != null || w.E != null) {\n            dow = 1;\n            doy =
    4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends
    on\n            // how we interpret now (local, utc, fixed offset). So create\n
    \           // a now version of current config (take local/utc/offset flags, and\n
    \           // create now).\n            weekYear = defaults(w.GG, config._a[YEAR],
    weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n
    \           weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday
    > 7) {\n                weekdayOverflow = true;\n            }\n        } else
    {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n
    \           var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear
    = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to
    current week.\n            week = defaults(w.w, curWeek.week);\n\n            if
    (w.d != null) {\n                // weekday -- low day numbers are considered
    next week\n                weekday = w.d;\n                if (weekday < 0 ||
    weekday > 6) {\n                    weekdayOverflow = true;\n                }\n
    \           } else if (w.e != null) {\n                // local weekday -- counting
    starts from beginning of week\n                weekday = w.e + dow;\n                if
    (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n
    \           } else {\n                // default to beginning of week\n                weekday
    = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear,
    dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        }
    else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday
    = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week,
    weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear
    = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00
    0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00
    or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T|
    )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n
    \   var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T|
    )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n
    \   var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD',
    /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n
    \       ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/,
    false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/,
    false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n
    \       // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n
    \       ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n
    \   ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS',
    /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n
    \       ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n
    \       ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS',
    /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm',
    /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex
    = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config)
    {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string)
    || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat,
    tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n
    \           for (i = 0, l = isoDates.length; i < l; i++) {\n                if
    (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n
    \                   allowTime = isoDates[i][2] !== false;\n                    break;\n
    \               }\n            }\n            if (dateFormat == null) {\n                config._isValid
    = false;\n                return;\n            }\n            if (match[3]) {\n
    \               for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if
    (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should
    be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n
    \                       break;\n                    }\n                }\n                if
    (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n
    \               }\n            }\n            if (!allowTime && timeFormat !=
    null) {\n                config._isValid = false;\n                return;\n            }\n
    \           if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat
    = 'Z';\n                } else {\n                    config._isValid = false;\n
    \                   return;\n                }\n            }\n            config._f
    = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n
    \       } else {\n            config._isValid = false;\n        }\n    }\n\n    //
    RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n
    \   var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n
    \   function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr,
    secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n
    \           parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr,
    10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr,
    10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr)
    {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return
    2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n
    \       }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n
    \       // Remove comments and folding whitespace and replace multiple-spaces
    with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g,
    ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr,
    parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace
    the vanilla JS Date object with an indepentent day-of-week check.\n            var
    weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual
    = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if
    (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch
    = true;\n                config._isValid = false;\n                return false;\n
    \           }\n        }\n        return true;\n    }\n\n    var obsOffsets =
    {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n
    \       CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST:
    -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function
    calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset)
    {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset)
    {\n            // the only allowed military tz is Z\n            return 0;\n        }
    else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm
    % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n
    \   // date and time from ref 2822 format\n    function configFromRFC2822(config)
    {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if
    (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3],
    match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1],
    parsedArray, config)) {\n                return;\n            }\n\n            config._a
    = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9],
    match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n
    \           config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n
    \           getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid
    = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function
    configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n
    \       if (matched !== null) {\n            config._d = new Date(+matched[1]);\n
    \           return;\n        }\n\n        configFromISO(config);\n        if (config._isValid
    === false) {\n            delete config._isValid;\n        } else {\n            return;\n
    \       }\n\n        configFromRFC2822(config);\n        if (config._isValid ===
    false) {\n            delete config._isValid;\n        } else {\n            return;\n
    \       }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n
    \   }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided
    is not in a recognized RFC2822 or ISO format. moment construction falls back to
    js Date(), ' +\n        'which is not reliable across all browsers and versions.
    Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed
    in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/
    for more info.',\n        function (config) {\n            config._d = new Date(config._i
    + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that
    refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant
    that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    //
    date from string and format string\n    function configFromStringAndFormat(config)
    {\n        // TODO: Move this to another part of the creation flow to prevent
    circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n
    \           return;\n        }\n        if (config._f === hooks.RFC_2822) {\n
    \           configFromRFC2822(config);\n            return;\n        }\n        config._a
    = [];\n        getParsingFlags(config).empty = true;\n\n        // This array
    is used to make a Date, either with `new Date` or `Date.UTC`\n        var string
    = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength
    = string.length,\n            totalParsedInputLength = 0;\n\n        tokens =
    expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for
    (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput
    = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            //
    console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex',
    getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped
    = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length
    > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n
    \               }\n                string = string.slice(string.indexOf(parsedInput)
    + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n
    \           }\n            // don't parse if it's not a known token\n            if
    (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty
    = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n
    \               }\n                addTimeToArrayFromToken(token, parsedInput,
    config);\n            }\n            else if (config._strict && !parsedInput)
    {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n
    \       }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver
    = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n
    \       }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR]
    <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR]
    > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n
    \       getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem
    = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale,
    config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n
    \   }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var
    isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return
    hour;\n        }\n        if (locale.meridiemHour != null) {\n            return
    locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null)
    {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if
    (isPm && hour < 12) {\n                hour += 12;\n            }\n            if
    (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return
    hour;\n        } else {\n            // this is not supposed to happen\n            return
    hour;\n        }\n    }\n\n    // date from string and array of format strings\n
    \   function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n
    \           scoreToBeat,\n            i,\n            currentScore;\n\n        if
    (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat
    = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n
    \       for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n
    \           tempConfig = copyConfig({}, config);\n            if (config._useUTC
    != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n
    \           tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n
    \           if (!isValid(tempConfig)) {\n                continue;\n            }\n\n
    \           // if there is any input that was not parsed add a penalty for that
    format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n
    \           //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length
    * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if
    (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat
    = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n
    \       extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config)
    {\n        if (config._d) {\n            return;\n        }\n\n        var i =
    normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day
    || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return
    obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n
    \   function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n
    \       if (res._nextDay) {\n            // Adding is smart enough around DST\n
    \           res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n
    \       return res;\n    }\n\n    function prepareConfig (config) {\n        var
    input = config._i,\n            format = config._f;\n\n        config._locale
    = config._locale || getLocale(config._l);\n\n        if (input === null || (format
    === undefined && input === '')) {\n            return createInvalid({nullInput:
    true});\n        }\n\n        if (typeof input === 'string') {\n            config._i
    = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input))
    {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input))
    {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n
    \       } else if (format) {\n            configFromStringAndFormat(config);\n
    \       }  else {\n            configFromInput(config);\n        }\n\n        if
    (!isValid(config)) {\n            config._d = null;\n        }\n\n        return
    config;\n    }\n\n    function configFromInput(config) {\n        var input =
    config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n
    \       } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n
    \       } else if (typeof input === 'string') {\n            configFromString(config);\n
    \       } else if (isArray(input)) {\n            config._a = map(input.slice(0),
    function (obj) {\n                return parseInt(obj, 10);\n            });\n
    \           configFromArray(config);\n        } else if (isObject(input)) {\n
    \           configFromObject(config);\n        } else if (isNumber(input)) {\n
    \           // from milliseconds\n            config._d = new Date(input);\n        }
    else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n
    \   function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var
    c = {};\n\n        if (locale === true || locale === false) {\n            strict
    = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input)
    && isObjectEmpty(input)) ||\n                (isArray(input) && input.length ===
    0)) {\n            input = undefined;\n        }\n        // object construction
    must be done this way.\n        // https://github.com/moment/moment/issues/1423\n
    \       c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l
    = locale;\n        c._i = input;\n        c._f = format;\n        c._strict =
    strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal
    (input, format, locale, strict) {\n        return createLocalOrUTC(input, format,
    locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min
    is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n
    \       function () {\n            var other = createLocal.apply(null, arguments);\n
    \           if (this.isValid() && other.isValid()) {\n                return other
    < this ? this : other;\n            } else {\n                return createInvalid();\n
    \           }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max
    is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n
    \       function () {\n            var other = createLocal.apply(null, arguments);\n
    \           if (this.isValid() && other.isValid()) {\n                return other
    > this ? this : other;\n            } else {\n                return createInvalid();\n
    \           }\n        }\n    );\n\n    // Pick a moment m from moments so that
    m[fn](other) is true for all\n    // other. This relies on the function fn to
    be transitive.\n    //\n    // moments should either be an array of moment objects
    or an array, whose\n    // first element is an array of moment objects.\n    function
    pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 &&
    isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if
    (!moments.length) {\n            return createLocal();\n        }\n        res
    = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if
    (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n
    \           }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort
    instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n
    \       return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var
    args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n
    \   }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new
    Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day',
    'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m)
    {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key)
    !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n
    \           }\n        }\n\n        var unitHasDecimal = false;\n        for (var
    i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if
    (unitHasDecimal) {\n                    return false; // only allow non-integers
    for smallest unit\n                }\n                if (parseFloat(m[ordering[i]])
    !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n
    \           }\n        }\n\n        return true;\n    }\n\n    function isValid$1()
    {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n
    \       return createDuration(NaN);\n    }\n\n    function Duration (duration)
    {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years
    = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter ||
    0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week
    || normalizedInput.isoWeek || 0,\n            days = normalizedInput.day || 0,\n
    \           hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute
    || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds
    = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n
    \       // representation for dateAddRemove\n        this._milliseconds = +milliseconds
    +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 *
    60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5
    to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n
    \       // Because of dateAddRemove treats 24 hours as different from a\n        //
    day when working around DST, we need to store them separately\n        this._days
    = +days +\n            weeks * 7;\n        // It is impossible to translate months
    into days without knowing\n        // which months you are are talking about,
    so we have to store\n        // it separately.\n        this._months = +months
    +\n            quarters * 3 +\n            years * 12;\n\n        this._data =
    {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n
    \   function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n
    \   function absRound (number) {\n        if (number < 0) {\n            return
    Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n
    \       }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator)
    {\n        addFormatToken(token, 0, 0, function () {\n            var offset =
    this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n
    \               offset = -offset;\n                sign = '-';\n            }\n
    \           return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset)
    % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n
    \   // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ',
    matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config)
    {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset,
    input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00'
    > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n
    \   function offsetFromString(matcher, string) {\n        var matches = (string
    || '').match(matcher);\n\n        if (matches === null) {\n            return
    null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n
    \       var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var
    minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0
    ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n
    \   // Return a moment from input, that is local/utc/zone equivalent to model.\n
    \   function cloneWithOffset(input, model) {\n        var res, diff;\n        if
    (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input)
    || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n
    \           // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf()
    + diff);\n            hooks.updateOffset(res, false);\n            return res;\n
    \       } else {\n            return createLocal(input).local();\n        }\n
    \   }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset
    returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n
    \       return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    //
    HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    //
    It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset
    = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only
    change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300
    --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't
    exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n
    \   //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from
    the actual represented time. That is why we call updateOffset\n    // a second
    time. In case it wants us to change the offset again\n    // _changeInProgress
    == true case, then we have to adjust, because\n    // there is no such time in
    the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes)
    {\n        var offset = this._offset || 0,\n            localAdjust;\n        if
    (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n
    \       if (input != null) {\n            if (typeof input === 'string') {\n                input
    = offsetFromString(matchShortOffset, input);\n                if (input === null)
    {\n                    return this;\n                }\n            } else if
    (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n
    \           }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust
    = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC
    = true;\n            if (localAdjust != null) {\n                this.add(localAdjust,
    'm');\n            }\n            if (offset !== input) {\n                if
    (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this,
    createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress)
    {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this,
    true);\n                    this._changeInProgress = null;\n                }\n
    \           }\n            return this;\n        } else {\n            return
    this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function
    getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if
    (typeof input !== 'string') {\n                input = -input;\n            }\n\n
    \           this.utcOffset(input, keepLocalTime);\n\n            return this;\n
    \       } else {\n            return -this.utcOffset();\n        }\n    }\n\n
    \   function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0,
    keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if
    (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC
    = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this),
    'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset
    () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm,
    false, true);\n        } else if (typeof this._i === 'string') {\n            var
    tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null)
    {\n                this.utcOffset(tZone);\n            }\n            else {\n
    \               this.utcOffset(0, true);\n            }\n        }\n        return
    this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid())
    {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset()
    : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function
    isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset()
    ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n
    \   }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted))
    {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n
    \       copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a)
    {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted
    = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n
    \       } else {\n            this._isDSTShifted = false;\n        }\n\n        return
    this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid()
    ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return
    this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return
    this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET
    json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n
    \   // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n
    \   // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n
    \   // and further modified to allow for strings containing both week and day\n
    \   var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n
    \   function createDuration (input, key) {\n        var duration = input,\n            //
    matching against regexp is expensive, do it on demand\n            match = null,\n
    \           sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input))
    {\n            duration = {\n                ms : input._milliseconds,\n                d
    \ : input._days,\n                M  : input._months\n            };\n        }
    else if (isNumber(input)) {\n            duration = {};\n            if (key)
    {\n                duration[key] = input;\n            } else {\n                duration.milliseconds
    = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input)))
    {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n
    \               y  : 0,\n                d  : toInt(match[DATE])                         *
    sign,\n                h  : toInt(match[HOUR])                         * sign,\n
    \               m  : toInt(match[MINUTE])                       * sign,\n                s
    \ : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND]
    * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n
    \       } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1]
    === '-') ? -1 : 1;\n            duration = {\n                y : parseIso(match[2],
    sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4],
    sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6],
    sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8],
    sign)\n            };\n        } else if (duration == null) {// checks for null
    or undefined\n            duration = {};\n        } else if (typeof duration ===
    'object' && ('from' in duration || 'to' in duration)) {\n            diffRes =
    momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration
    = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M
    = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if
    (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale
    = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn
    = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function
    parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately
    it also\n        // converts floats to ints.\n        // inp may be undefined,
    so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',',
    '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ?
    0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other)
    {\n        var res = {};\n\n        res.months = other.month() - base.month()
    +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months,
    'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds
    = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n
    \   function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid()
    && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n
    \       other = cloneWithOffset(other, base);\n        if (base.isBefore(other))
    {\n            res = positiveMomentsDifference(base, other);\n        } else {\n
    \           res = positiveMomentsDifference(other, base);\n            res.milliseconds
    = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return
    res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function
    createAdder(direction, name) {\n        return function (val, period) {\n            var
    dur, tmp;\n            //invert the arguments, but complain about it\n            if
    (period !== null && !isNaN(+period)) {\n                deprecateSimple(name,
    'moment().' + name  + '(period, number) is deprecated. Please use moment().' +
    name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/
    for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n
    \           val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val,
    period);\n            addSubtract(this, dur, direction);\n            return this;\n
    \       };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset)
    {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n
    \           months = absRound(duration._months);\n\n        if (!mom.isValid())
    {\n            // No op\n            return;\n        }\n\n        updateOffset
    = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom,
    get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom,
    'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds)
    {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n
    \       if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n
    \       }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract
    = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now)
    {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff <
    -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff
    < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff
    < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n
    \   function calendar$1 (time, formats) {\n        // We want to compare the start
    of today, vs this.\n        // Getting start-of-today depends on whether we're
    local/utc/offset or not.\n        var now = time || createLocal(),\n            sod
    = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this,
    sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format])
    ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output
    || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function
    clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input,
    units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n
    \       if (!(this.isValid() && localInput.isValid())) {\n            return false;\n
    \       }\n        units = normalizeUnits(units) || 'millisecond';\n        if
    (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n
    \       } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n
    \       }\n    }\n\n    function isBefore (input, units) {\n        var localInput
    = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid()
    && localInput.isValid())) {\n            return false;\n        }\n        units
    = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond')
    {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n
    \           return this.clone().endOf(units).valueOf() < localInput.valueOf();\n
    \       }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n
    \       var localFrom = isMoment(from) ? from : createLocal(from),\n            localTo
    = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid()
    && localTo.isValid())) {\n            return false;\n        }\n        inclusivity
    = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(localFrom,
    units) : !this.isBefore(localFrom, units)) &&\n            (inclusivity[1] ===
    ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n    }\n\n
    \   function isSame (input, units) {\n        var localInput = isMoment(input)
    ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid()
    && localInput.isValid())) {\n            return false;\n        }\n        units
    = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond')
    {\n            return this.valueOf() === localInput.valueOf();\n        } else
    {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf()
    <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n
    \   function isSameOrAfter (input, units) {\n        return this.isSame(input,
    units) || this.isAfter(input, units);\n    }\n\n    function isSameOrBefore (input,
    units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n
    \   }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n
    \           output;\n\n        if (!this.isValid()) {\n            return NaN;\n
    \       }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid())
    {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset()
    - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch
    (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n
    \           case 'month': output = monthDiff(this, that); break;\n            case
    'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second':
    output = (this - that) / 1e3; break; // 1000\n            case 'minute': output
    = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output =
    (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output
    = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n
    \           case 'week': output = (this - that - zoneDelta) / 6048e5; break; //
    1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n
    \       }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function
    monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff
    = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is
    in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff,
    'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2
    = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the
    month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else
    {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            //
    linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n
    \       }\n\n        //check for negative zero, return zero if negative zero\n
    \       return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat
    = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n
    \   function toString () {\n        return this.clone().locale('en').format('ddd
    MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset)
    {\n        if (!this.isValid()) {\n            return null;\n        }\n        var
    utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n
    \       if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m,
    utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n
    \       if (isFunction(Date.prototype.toISOString)) {\n            // native implementation
    is ~50x faster, use it when we can\n            if (utc) {\n                return
    this.toDate().toISOString();\n            } else {\n                return new
    Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z',
    formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m,
    utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n
    \   /**\n     * Return a human readable representation of a moment that can\n
    \    * also be evaluated to get a new moment which is the same\n     *\n     *
    @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n
    \    */\n    function inspect () {\n        if (!this.isValid()) {\n            return
    'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n
    \       var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset()
    === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n
    \       var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year()
    && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n
    \       var suffix = zone + '[\")]';\n\n        return this.format(prefix + year
    + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if
    (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc
    : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n
    \       return this.localeData().postformat(output);\n    }\n\n    function from
    (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time)
    && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return
    createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n
    \       } else {\n            return this.localeData().invalidDate();\n        }\n
    \   }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(),
    withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if
    (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid()))
    {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n
    \       } else {\n            return this.localeData().invalidDate();\n        }\n
    \   }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(),
    withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale
    for this\n    // instance.  Otherwise, it will return the locale configuration\n
    \   // variables for this instance.\n    function locale (key) {\n        var
    newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n
    \       } else {\n            newLocaleData = getLocale(key);\n            if
    (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n
    \           return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang()
    is deprecated. Instead, use moment().localeData() to get the language configuration.
    Use moment().locale() to change languages.',\n        function (key) {\n            if
    (key === undefined) {\n                return this.localeData();\n            }
    else {\n                return this.locale(key);\n            }\n        }\n    );\n\n
    \   function localeData () {\n        return this._locale;\n    }\n\n    var MS_PER_SECOND
    = 1000;\n    var MS_PER_MINUTE = 60 * MS_PER_SECOND;\n    var MS_PER_HOUR = 60
    * MS_PER_MINUTE;\n    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\n
    \   // actual modulo - handles negative numbers (for dates before 1970):\n    function
    mod$1(dividend, divisor) {\n        return (dividend % divisor + divisor) % divisor;\n
    \   }\n\n    function localStartOfDate(y, m, d) {\n        // the date constructor
    remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            //
    preserve leap years using a full 400 year cycle, then reset\n            return
    new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return
    new Date(y, m, d).valueOf();\n        }\n    }\n\n    function utcStartOfDate(y,
    m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100
    && y >= 0) {\n            // preserve leap years using a full 400 year cycle,
    then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        }
    else {\n            return Date.UTC(y, m, d);\n        }\n    }\n\n    function
    startOf (units) {\n        var time;\n        units = normalizeUnits(units);\n
    \       if (units === undefined || units === 'millisecond' || !this.isValid())
    {\n            return this;\n        }\n\n        var startOfDate = this._isUTC
    ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case
    'year':\n                time = startOfDate(this.year(), 0, 1);\n                break;\n
    \           case 'quarter':\n                time = startOfDate(this.year(), this.month()
    - this.month() % 3, 1);\n                break;\n            case 'month':\n                time
    = startOfDate(this.year(), this.month(), 1);\n                break;\n            case
    'week':\n                time = startOfDate(this.year(), this.month(), this.date()
    - this.weekday());\n                break;\n            case 'isoWeek':\n                time
    = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n
    \               break;\n            case 'day':\n            case 'date':\n                time
    = startOfDate(this.year(), this.month(), this.date());\n                break;\n
    \           case 'hour':\n                time = this._d.valueOf();\n                time
    -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n
    \               break;\n            case 'minute':\n                time = this._d.valueOf();\n
    \               time -= mod$1(time, MS_PER_MINUTE);\n                break;\n
    \           case 'second':\n                time = this._d.valueOf();\n                time
    -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n\n        this._d.setTime(time);\n
    \       hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function
    endOf (units) {\n        var time;\n        units = normalizeUnits(units);\n        if
    (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return
    this;\n        }\n\n        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n
    \       switch (units) {\n            case 'year':\n                time = startOfDate(this.year()
    + 1, 0, 1) - 1;\n                break;\n            case 'quarter':\n                time
    = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n                break;\n
    \           case 'month':\n                time = startOfDate(this.year(), this.month()
    + 1, 1) - 1;\n                break;\n            case 'week':\n                time
    = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n
    \               break;\n            case 'isoWeek':\n                time = startOfDate(this.year(),
    this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n                break;\n
    \           case 'day':\n            case 'date':\n                time = startOfDate(this.year(),
    this.month(), this.date() + 1) - 1;\n                break;\n            case
    'hour':\n                time = this._d.valueOf();\n                time += MS_PER_HOUR
    - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR)
    - 1;\n                break;\n            case 'minute':\n                time
    = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE)
    - 1;\n                break;\n            case 'second':\n                time
    = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND)
    - 1;\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this,
    true);\n        return this;\n    }\n\n    function valueOf () {\n        return
    this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix
    () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function
    toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray
    () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(),
    m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n
    \       var m = this;\n        return {\n            years: m.year(),\n            months:
    m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes:
    m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n
    \       };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON()
    === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n
    \   function isValid$2 () {\n        return isValid(this);\n    }\n\n    function
    parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n
    \   function invalidAt () {\n        return getParsingFlags(this).overflow;\n
    \   }\n\n    function creationData() {\n        return {\n            input: this._i,\n
    \           format: this._f,\n            locale: this._locale,\n            isUTC:
    this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n
    \   addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear()
    % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return
    this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token,
    getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n
    \   addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',
    \   'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG',
    'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear',
    'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear',
    1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',
    \     matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',
    \    match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',
    \  match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',
    \ match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'],
    function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n
    \   });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config,
    token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    //
    MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n
    \               input,\n                this.week(),\n                this.weekday(),\n
    \               this.localeData()._week.dow,\n                this.localeData()._week.doy);\n
    \   }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n
    \               input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function
    getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n
    \   function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n
    \       return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n
    \   function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var
    weeksTarget;\n        if (input == null) {\n            return weekOfYear(this,
    dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input,
    dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n
    \           }\n            return setWeekAll.call(this, input, week, weekday,
    dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday,
    dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday,
    dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n
    \       this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n
    \       this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n
    \   addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter',
    'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n
    \   addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array)
    {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n
    \   function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month()
    + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n
    \   addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date',
    'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n
    \   addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n
    \   addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove
    \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n
    \         (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n
    \   });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function
    (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n
    \   // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    //
    FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n
    \   // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear',
    4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD',
    match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n
    \       config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    //
    MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day')
    - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ?
    dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n
    \   addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute',
    'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n
    \   addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n
    \   addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute
    = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s',
    ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n
    \   // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',
    \ match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s',
    'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds',
    false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n
    \       return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0,
    ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n
    \   addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS',
    4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0,
    ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n
    \   addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond()
    * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return
    this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0,
    function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0,
    ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n
    \   });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    //
    PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',
    \   match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',
    \ match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length
    <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n
    \   function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.'
    + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token +=
    'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var
    getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n
    \   addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n
    \   // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ?
    'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC
    ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n
    \   proto.add               = add;\n    proto.calendar          = calendar$1;\n
    \   proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf
    \            = endOf;\n    proto.format            = format;\n    proto.from              =
    from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n
    \   proto.toNow             = toNow;\n    proto.get               = stringGet;\n
    \   proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n
    \   proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n
    \   proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n
    \   proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n
    \   proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData
    \       = localeData;\n    proto.max               = prototypeMax;\n    proto.min
    \              = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n
    \   proto.set               = stringSet;\n    proto.startOf           = startOf;\n
    \   proto.subtract          = subtract;\n    proto.toArray           = toArray;\n
    \   proto.toObject          = toObject;\n    proto.toDate            = toDate;\n
    \   proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n
    \   proto.toJSON            = toJSON;\n    proto.toString          = toString;\n
    \   proto.unix              = unix;\n    proto.valueOf           = valueOf;\n
    \   proto.creationData      = creationData;\n    proto.year       = getSetYear;\n
    \   proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n
    \   proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters
    = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth
    = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n
    \   proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear
    \   = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date
    \      = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n
    \   proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n
    \   proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n
    \   proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds
    = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n
    \   proto.utcOffset            = getSetOffset;\n    proto.utc                  =
    setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone
    \           = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n
    \   proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              =
    isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                =
    isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n
    \   proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor
    is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months
    accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  =
    deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone
    \  = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
    getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated.
    See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
    isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return
    createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return
    createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat
    (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n
    \   proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n
    \   proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n
    \   proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      =
    preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture
    \     = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months
    \           =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n
    \   proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex
    \      = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week
    = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek
    = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n
    \   proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort
    \ =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n
    \   proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex
    \ =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n
    \   proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function
    get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var
    utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n
    \   }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format))
    {\n            index = format;\n            format = undefined;\n        }\n\n
    \       format = format || '';\n\n        if (index != null) {\n            return
    get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var
    out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format,
    i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    //
    (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true,
    fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format,
    index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if
    (isNumber(format)) {\n                index = format;\n                format
    = undefined;\n            }\n\n            format = format || '';\n        } else
    {\n            format = localeSorted;\n            index = format;\n            localeSorted
    = false;\n\n            if (isNumber(format)) {\n                index = format;\n
    \               format = undefined;\n            }\n\n            format = format
    || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted
    ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format,
    (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var
    out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format,
    (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function
    listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n
    \   }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format,
    index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format,
    index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n
    \   }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return
    listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function
    listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted,
    format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse:
    /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var
    b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ?
    'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n
    \               (b === 3) ? 'rd' : 'th';\n            return number + output;\n
    \       }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang
    is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData
    = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n
    \   var mathAbs = Math.abs;\n\n    function abs () {\n        var data           =
    this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days
    \        = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n
    \       data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds
    \      = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n
    \       data.hours         = mathAbs(data.hours);\n        data.months        =
    mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return
    this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction)
    {\n        var other = createDuration(input, value);\n\n        duration._milliseconds
    += direction * other._milliseconds;\n        duration._days         += direction
    * other._days;\n        duration._months       += direction * other._months;\n\n
    \       return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1,
    's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this,
    input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or
    subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this,
    input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number
    < 0) {\n            return Math.floor(number);\n        } else {\n            return
    Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var
    milliseconds = this._milliseconds;\n        var days         = this._days;\n        var
    months       = this._months;\n        var data         = this._data;\n        var
    seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix
    of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n
    \       if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds
    <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months)
    + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n
    \       // The following code bubbles up values, see the tests for\n        //
    examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n
    \       seconds           = absFloor(milliseconds / 1000);\n        data.seconds
    \     = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n
    \       data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes
    / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours
    / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n
    \       months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n
    \       // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months
    %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years
    \ = years;\n\n        return this;\n    }\n\n    function daysToMonths (days)
    {\n        // 400 years have 146097 days (taking into account leap year rules)\n
    \       // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n
    \   }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n
    \       return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if
    (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var
    months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n
    \       if (units === 'month' || units === 'quarter' || units === 'year') {\n
    \           days = this._days + milliseconds / 864e5;\n            months = this._months
    + daysToMonths(days);\n            switch (units) {\n                case 'month':
    \  return months;\n                case 'quarter': return months / 3;\n                case
    'year':    return months / 12;\n            }\n        } else {\n            //
    handle milliseconds separately because of floating point math errors (issue #1867)\n
    \           days = this._days + Math.round(monthsToDays(this._months));\n            switch
    (units) {\n                case 'week'   : return days / 7     + milliseconds
    / 6048e5;\n                case 'day'    : return days         + milliseconds
    / 864e5;\n                case 'hour'   : return days * 24    + milliseconds /
    36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n
    \               case 'second' : return days * 86400 + milliseconds / 1000;\n                //
    Math.floor prevents floating point math errors here\n                case 'millisecond':
    return Math.floor(days * 864e5) + milliseconds;\n                default: throw
    new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    //
    TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid())
    {\n            return NaN;\n        }\n        return (\n            this._milliseconds
    +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6
    +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function
    makeAs (alias) {\n        return function () {\n            return this.as(alias);\n
    \       };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds
    \     = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        =
    makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        =
    makeAs('w');\n    var asMonths       = makeAs('M');\n    var asQuarters     =
    makeAs('Q');\n    var asYears        = makeAs('y');\n\n    function clone$1 ()
    {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n
    \       units = normalizeUnits(units);\n        return this.isValid() ? this[units
    + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function
    () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n
    \   }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      =
    makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var
    hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n
    \   var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n
    \   function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n
    \   var round = Math.round;\n    var thresholds = {\n        ss: 44,         //
    a few seconds to seconds\n        s : 45,         // seconds to minute\n        m
    : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d
    : 26,         // days to month\n        M : 11          // months to year\n    };\n\n
    \   // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n
    \   function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale)
    {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n
    \   }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n
    \       var duration = createDuration(posNegDuration).abs();\n        var seconds
    \ = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n
    \       var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n
    \       var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n
    \       var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds
    < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             &&
    ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes]
    ||\n                hours   <= 1             && ['h']           ||\n                hours
    \  < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             &&
    ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n
    \               months  <= 1             && ['M']           ||\n                months
    \ < thresholds.M   && ['MM', months]  ||\n                years   <= 1             &&
    ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3]
    = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null,
    a);\n    }\n\n    // This function allows you to set the rounding function for
    relative time strings\n    function getSetRelativeTimeRounding (roundingFunction)
    {\n        if (roundingFunction === undefined) {\n            return round;\n
    \       }\n        if (typeof(roundingFunction) === 'function') {\n            round
    = roundingFunction;\n            return true;\n        }\n        return false;\n
    \   }\n\n    // This function allows you to set a threshold for relative time
    strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if
    (thresholds[threshold] === undefined) {\n            return false;\n        }\n
    \       if (limit === undefined) {\n            return thresholds[threshold];\n
    \       }\n        thresholds[threshold] = limit;\n        if (threshold === 's')
    {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n
    \   function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return
    this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n
    \       var output = relativeTime$1(this, !withSuffix, locale);\n\n        if
    (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n
    \       return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n
    \   function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function
    toISOString$1() {\n        // for ISO strings we do not use the normal bubbling
    rules:\n        //  * milliseconds bubble up until they become hours\n        //
    \ * days do not bubble at all\n        //  * months bubble up until they become
    years\n        // This is because there is no context-free conversion between
    hours and days\n        // (think of clock changes)\n        // and also not between
    days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return
    this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds)
    / 1000;\n        var days         = abs$1(this._days);\n        var months       =
    abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds
    -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n
    \       hours             = absFloor(minutes / 60);\n        seconds %= 60;\n
    \       minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months
    / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n
    \       var Y = years;\n        var M = months;\n        var D = days;\n        var
    h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/,
    '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            //
    this is the same as C#'s (Noda) and python (isodate)...\n            // but not
    other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign
    = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total)
    ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n
    \       var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n
    \       return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n
    \           (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D'
    : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign +
    h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ?
    hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid
    \       = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            =
    add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             =
    as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      =
    asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        =
    asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n
    \   proto$2.asMonths       = asMonths;\n    proto$2.asQuarters     = asQuarters;\n
    \   proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n
    \   proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n
    \   proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n
    \   proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n
    \   proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks
    \         = weeks;\n    proto$2.months         = months;\n    proto$2.years          =
    years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n
    \   proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n
    \   proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n
    \   proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString()
    instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n
    \   // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0,
    0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x',
    matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X',
    function (input, array, config) {\n        config._d = new Date(parseFloat(input,
    10) * 1000);\n    });\n    addParseToken('x', function (input, array, config)
    {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect
    imports\n\n\n    hooks.version = '2.24.0';\n\n    setHookCallback(createLocal);\n\n
    \   hooks.fn                    = proto;\n    hooks.min                   = min;\n
    \   hooks.max                   = max;\n    hooks.now                   = now;\n
    \   hooks.utc                   = createUTC;\n    hooks.unix                  =
    createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                =
    isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid
    \              = createInvalid;\n    hooks.duration              = createDuration;\n
    \   hooks.isMoment              = isMoment;\n    hooks.weekdays              =
    listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData
    \           = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort
    \          = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n
    \   hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          =
    updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort
    \        = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n
    \   hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold
    = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n
    \   hooks.prototype             = proto;\n\n    // currently HTML5 input type
    only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL:
    'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS:
    'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS:
    'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\"
    />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\"
    />\n        TIME: 'HH:mm',                                  // <input type=\"time\"
    />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\"
    step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input
    type=\"time\" step=\"0.001\" />\n        WEEK: 'GGGG-[W]WW',                             //
    <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                //
    <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n});\n\nvar FORMATS
    = {\r\n\tdatetime: 'MMM D, YYYY, h:mm:ss a',\r\n\tmillisecond: 'h:mm:ss.SSS a',\r\n\tsecond:
    'h:mm:ss a',\r\n\tminute: 'h:mm a',\r\n\thour: 'hA',\r\n\tday: 'MMM D',\r\n\tweek:
    'll',\r\n\tmonth: 'MMM YYYY',\r\n\tquarter: '[Q]Q - YYYY',\r\n\tyear: 'YYYY'\r\n};\r\n\r\ncore_adapters._date.override(typeof
    moment === 'function' ? {\r\n\t_id: 'moment', // DEBUG ONLY\r\n\r\n\tformats:
    function() {\r\n\t\treturn FORMATS;\r\n\t},\r\n\r\n\tparse: function(value, format)
    {\r\n\t\tif (typeof value === 'string' && typeof format === 'string') {\r\n\t\t\tvalue
    = moment(value, format);\r\n\t\t} else if (!(value instanceof moment)) {\r\n\t\t\tvalue
    = moment(value);\r\n\t\t}\r\n\t\treturn value.isValid() ? value.valueOf() : null;\r\n\t},\r\n\r\n\tformat:
    function(time, format) {\r\n\t\treturn moment(time).format(format);\r\n\t},\r\n\r\n\tadd:
    function(time, amount, unit) {\r\n\t\treturn moment(time).add(amount, unit).valueOf();\r\n\t},\r\n\r\n\tdiff:
    function(max, min, unit) {\r\n\t\treturn moment(max).diff(moment(min), unit);\r\n\t},\r\n\r\n\tstartOf:
    function(time, unit, weekday) {\r\n\t\ttime = moment(time);\r\n\t\tif (unit ===
    'isoWeek') {\r\n\t\t\treturn time.isoWeekday(weekday).valueOf();\r\n\t\t}\r\n\t\treturn
    time.startOf(unit).valueOf();\r\n\t},\r\n\r\n\tendOf: function(time, unit) {\r\n\t\treturn
    moment(time).endOf(unit).valueOf();\r\n\t},\r\n\r\n\t// DEPRECATIONS\r\n\r\n\t/**\r\n\t
    * Provided for backward compatibility with scale.getValueForPixel().\r\n\t * @deprecated
    since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t * @private\r\n\t */\r\n\t_create:
    function(time) {\r\n\t\treturn moment(time);\r\n\t},\r\n} : {});\n\ncore_defaults._set('global',
    {\r\n\tplugins: {\r\n\t\tfiller: {\r\n\t\t\tpropagate: true\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    mappers = {\r\n\tdataset: function(source) {\r\n\t\tvar index = source.fill;\r\n\t\tvar
    chart = source.chart;\r\n\t\tvar meta = chart.getDatasetMeta(index);\r\n\t\tvar
    visible = meta && chart.isDatasetVisible(index);\r\n\t\tvar points = (visible
    && meta.dataset._children) || [];\r\n\t\tvar length = points.length || 0;\r\n\r\n\t\treturn
    !length ? null : function(point, i) {\r\n\t\t\treturn (i < length && points[i]._view)
    || null;\r\n\t\t};\r\n\t},\r\n\r\n\tboundary: function(source) {\r\n\t\tvar boundary
    = source.boundary;\r\n\t\tvar x = boundary ? boundary.x : null;\r\n\t\tvar y =
    boundary ? boundary.y : null;\r\n\r\n\t\tif (helpers$1.isArray(boundary)) {\r\n\t\t\treturn
    function(point, i) {\r\n\t\t\t\treturn boundary[i];\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn
    function(point) {\r\n\t\t\treturn {\r\n\t\t\t\tx: x === null ? point.x : x,\r\n\t\t\t\ty:
    y === null ? point.y : y,\r\n\t\t\t};\r\n\t\t};\r\n\t}\r\n};\r\n\r\n// @todo if
    (fill[0] === '#')\r\nfunction decodeFill(el, index, count) {\r\n\tvar model =
    el._model || {};\r\n\tvar fill = model.fill;\r\n\tvar target;\r\n\r\n\tif (fill
    === undefined) {\r\n\t\tfill = !!model.backgroundColor;\r\n\t}\r\n\r\n\tif (fill
    === false || fill === null) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (fill ===
    true) {\r\n\t\treturn 'origin';\r\n\t}\r\n\r\n\ttarget = parseFloat(fill, 10);\r\n\tif
    (isFinite(target) && Math.floor(target) === target) {\r\n\t\tif (fill[0] === '-'
    || fill[0] === '+') {\r\n\t\t\ttarget = index + target;\r\n\t\t}\r\n\r\n\t\tif
    (target === index || target < 0 || target >= count) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn
    target;\r\n\t}\r\n\r\n\tswitch (fill) {\r\n\t// compatibility\r\n\tcase 'bottom':\r\n\t\treturn
    'start';\r\n\tcase 'top':\r\n\t\treturn 'end';\r\n\tcase 'zero':\r\n\t\treturn
    'origin';\r\n\t// supported boundaries\r\n\tcase 'origin':\r\n\tcase 'start':\r\n\tcase
    'end':\r\n\t\treturn fill;\r\n\t// invalid fill values\r\n\tdefault:\r\n\t\treturn
    false;\r\n\t}\r\n}\r\n\r\nfunction computeLinearBoundary(source) {\r\n\tvar model
    = source.el._model || {};\r\n\tvar scale = source.el._scale || {};\r\n\tvar fill
    = source.fill;\r\n\tvar target = null;\r\n\tvar horizontal;\r\n\r\n\tif (isFinite(fill))
    {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Backward compatibility: until v3, we
    still need to support boundary values set on\r\n\t// the model (scaleTop, scaleBottom
    and scaleZero) because some external plugins and\r\n\t// controllers might still
    use it (e.g. the Smith chart).\r\n\r\n\tif (fill === 'start') {\r\n\t\ttarget
    = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\r\n\t} else
    if (fill === 'end') {\r\n\t\ttarget = model.scaleTop === undefined ? scale.top
    : model.scaleTop;\r\n\t} else if (model.scaleZero !== undefined) {\r\n\t\ttarget
    = model.scaleZero;\r\n\t} else if (scale.getBasePixel) {\r\n\t\ttarget = scale.getBasePixel();\r\n\t}\r\n\r\n\tif
    (target !== undefined && target !== null) {\r\n\t\tif (target.x !== undefined
    && target.y !== undefined) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\tif (helpers$1.isFinite(target))
    {\r\n\t\t\thorizontal = scale.isHorizontal();\r\n\t\t\treturn {\r\n\t\t\t\tx:
    horizontal ? target : null,\r\n\t\t\t\ty: horizontal ? null : target\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    null;\r\n}\r\n\r\nfunction computeCircularBoundary(source) {\r\n\tvar scale =
    source.el._scale;\r\n\tvar options = scale.options;\r\n\tvar length = scale.chart.data.labels.length;\r\n\tvar
    fill = source.fill;\r\n\tvar target = [];\r\n\tvar start, end, center, i, point;\r\n\r\n\tif
    (!length) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstart = options.ticks.reverse
    ? scale.max : scale.min;\r\n\tend = options.ticks.reverse ? scale.min : scale.max;\r\n\tcenter
    = scale.getPointPositionForValue(0, start);\r\n\tfor (i = 0; i < length; ++i)
    {\r\n\t\tpoint = fill === 'start' || fill === 'end'\r\n\t\t\t? scale.getPointPositionForValue(i,
    fill === 'start' ? start : end)\r\n\t\t\t: scale.getBasePosition(i);\r\n\t\tif
    (options.gridLines.circular) {\r\n\t\t\tpoint.cx = center.x;\r\n\t\t\tpoint.cy
    = center.y;\r\n\t\t\tpoint.angle = scale.getIndexAngle(i) - Math.PI / 2;\r\n\t\t}\r\n\t\ttarget.push(point);\r\n\t}\r\n\treturn
    target;\r\n}\r\n\r\nfunction computeBoundary(source) {\r\n\tvar scale = source.el._scale
    || {};\r\n\r\n\tif (scale.getPointPositionForValue) {\r\n\t\treturn computeCircularBoundary(source);\r\n\t}\r\n\treturn
    computeLinearBoundary(source);\r\n}\r\n\r\nfunction resolveTarget(sources, index,
    propagate) {\r\n\tvar source = sources[index];\r\n\tvar fill = source.fill;\r\n\tvar
    visited = [index];\r\n\tvar target;\r\n\r\n\tif (!propagate) {\r\n\t\treturn fill;\r\n\t}\r\n\r\n\twhile
    (fill !== false && visited.indexOf(fill) === -1) {\r\n\t\tif (!isFinite(fill))
    {\r\n\t\t\treturn fill;\r\n\t\t}\r\n\r\n\t\ttarget = sources[fill];\r\n\t\tif
    (!target) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (target.visible) {\r\n\t\t\treturn
    fill;\r\n\t\t}\r\n\r\n\t\tvisited.push(fill);\r\n\t\tfill = target.fill;\r\n\t}\r\n\r\n\treturn
    false;\r\n}\r\n\r\nfunction createMapper(source) {\r\n\tvar fill = source.fill;\r\n\tvar
    type = 'dataset';\r\n\r\n\tif (fill === false) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tif
    (!isFinite(fill)) {\r\n\t\ttype = 'boundary';\r\n\t}\r\n\r\n\treturn mappers[type](source);\r\n}\r\n\r\nfunction
    isDrawable(point) {\r\n\treturn point && !point.skip;\r\n}\r\n\r\nfunction drawArea(ctx,
    curve0, curve1, len0, len1) {\r\n\tvar i, cx, cy, r;\r\n\r\n\tif (!len0 || !len1)
    {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// building first area curve (normal)\r\n\tctx.moveTo(curve0[0].x,
    curve0[0].y);\r\n\tfor (i = 1; i < len0; ++i) {\r\n\t\thelpers$1.canvas.lineTo(ctx,
    curve0[i - 1], curve0[i]);\r\n\t}\r\n\r\n\tif (curve1[0].angle !== undefined)
    {\r\n\t\tcx = curve1[0].cx;\r\n\t\tcy = curve1[0].cy;\r\n\t\tr = Math.sqrt(Math.pow(curve1[0].x
    - cx, 2) + Math.pow(curve1[0].y - cy, 2));\r\n\t\tfor (i = len1 - 1; i > 0; --i)
    {\r\n\t\t\tctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\t//
    joining the two area curves\r\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 -
    1].y);\r\n\r\n\t// building opposite area curve (reverse)\r\n\tfor (i = len1 -
    1; i > 0; --i) {\r\n\t\thelpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1],
    true);\r\n\t}\r\n}\r\n\r\nfunction doFill(ctx, points, mapper, view, color, loop)
    {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0
    = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i,
    ilen, index, p0, p1, d0, d1, loopOffset;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor
    (i = 0, ilen = count; i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1
    = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif
    (loop && loopOffset === undefined && d0) {\r\n\t\t\tloopOffset = i + 1;\r\n\t\t\tilen
    = count + loopOffset;\r\n\t\t}\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1
    = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx,
    curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1
    = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif
    (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx,
    curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r\n\r\nvar
    plugin_filler = {\r\n\tid: 'filler',\r\n\r\n\tafterDatasetsUpdate: function(chart,
    options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate
    = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor
    (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel
    = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el
    instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill:
    decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler
    = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count;
    ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill
    = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper
    = createMapper(source);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeDatasetsDraw: function(chart)
    {\r\n\t\tvar metasets = chart._getSortedVisibleDatasetMetas();\r\n\t\tvar ctx
    = chart.ctx;\r\n\t\tvar meta, i, el, view, points, mapper, color;\r\n\r\n\t\tfor
    (i = metasets.length - 1; i >= 0; --i) {\r\n\t\t\tmeta = metasets[i].$filler;\r\n\r\n\t\t\tif
    (!meta || !meta.visible) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tel = meta.el;\r\n\t\t\tview
    = el._view;\r\n\t\t\tpoints = el._children || [];\r\n\t\t\tmapper = meta.mapper;\r\n\t\t\tcolor
    = view.backgroundColor || core_defaults.global.defaultColor;\r\n\r\n\t\t\tif (mapper
    && color && points.length) {\r\n\t\t\t\thelpers$1.canvas.clipArea(ctx, chart.chartArea);\r\n\t\t\t\tdoFill(ctx,
    points, mapper, view, color, el._loop);\r\n\t\t\t\thelpers$1.canvas.unclipArea(ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\nvar
    getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;\r\nvar noop$1 = helpers$1.noop;\r\nvar
    valueOrDefault$e = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('global',
    {\r\n\tlegend: {\r\n\t\tdisplay: true,\r\n\t\tposition: 'top',\r\n\t\talign: 'center',\r\n\t\tfullWidth:
    true,\r\n\t\treverse: false,\r\n\t\tweight: 1000,\r\n\r\n\t\t// a callback that
    will handle\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar index = legendItem.datasetIndex;\r\n\t\t\tvar
    ci = this.chart;\r\n\t\t\tvar meta = ci.getDatasetMeta(index);\r\n\r\n\t\t\t//
    See controller.isDatasetVisible comment\r\n\t\t\tmeta.hidden = meta.hidden ===
    null ? !ci.data.datasets[index].hidden : null;\r\n\r\n\t\t\t// We hid a dataset
    ... rerender the chart\r\n\t\t\tci.update();\r\n\t\t},\r\n\r\n\t\tonHover: null,\r\n\t\tonLeave:
    null,\r\n\r\n\t\tlabels: {\r\n\t\t\tboxWidth: 40,\r\n\t\t\tpadding: 10,\r\n\t\t\t//
    Generates labels shown in the legend\r\n\t\t\t// Valid properties to return:\r\n\t\t\t//
    text : text to display\r\n\t\t\t// fillStyle : fill of coloured box\r\n\t\t\t//
    strokeStyle: stroke of coloured box\r\n\t\t\t// hidden : if this legend item refers
    to a hidden item\r\n\t\t\t// lineCap : cap style for line\r\n\t\t\t// lineDash\r\n\t\t\t//
    lineDashOffset :\r\n\t\t\t// lineJoin :\r\n\t\t\t// lineWidth :\r\n\t\t\tgenerateLabels:
    function(chart) {\r\n\t\t\t\tvar datasets = chart.data.datasets;\r\n\t\t\t\tvar
    options = chart.options.legend || {};\r\n\t\t\t\tvar usePointStyle = options.labels
    && options.labels.usePointStyle;\r\n\r\n\t\t\t\treturn chart._getSortedDatasetMetas().map(function(meta)
    {\r\n\t\t\t\t\tvar style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n\r\n\t\t\t\t\treturn
    {\r\n\t\t\t\t\t\ttext: datasets[meta.index].label,\r\n\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\thidden:
    !chart.isDatasetVisible(meta.index),\r\n\t\t\t\t\t\tlineCap: style.borderCapStyle,\r\n\t\t\t\t\t\tlineDash:
    style.borderDash,\r\n\t\t\t\t\t\tlineDashOffset: style.borderDashOffset,\r\n\t\t\t\t\t\tlineJoin:
    style.borderJoinStyle,\r\n\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\tstrokeStyle:
    style.borderColor,\r\n\t\t\t\t\t\tpointStyle: style.pointStyle,\r\n\t\t\t\t\t\trotation:
    style.rotation,\r\n\r\n\t\t\t\t\t\t// Below is extra data used for toggling the
    datasets\r\n\t\t\t\t\t\tdatasetIndex: meta.index\r\n\t\t\t\t\t};\r\n\t\t\t\t},
    this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tlegendCallback: function(chart) {\r\n\t\tvar
    list = document.createElement('ul');\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar
    i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id
    + '-legend');\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n\t\t\tlistItem
    = list.appendChild(document.createElement('li'));\r\n\t\t\tlistItemSpan = listItem.appendChild(document.createElement('span'));\r\n\t\t\tlistItemSpan.style.backgroundColor
    = datasets[i].backgroundColor;\r\n\t\t\tif (datasets[i].label) {\r\n\t\t\t\tlistItem.appendChild(document.createTextNode(datasets[i].label));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    list.outerHTML;\r\n\t}\r\n});\r\n\r\n/**\r\n * Helper function to get the box
    width based on the usePointStyle option\r\n * @param {object} labelopts - the
    label options on the legend\r\n * @param {number} fontSize - the label font size\r\n
    * @return {number} width of the color box area\r\n */\r\nfunction getBoxWidth(labelOpts,
    fontSize) {\r\n\treturn labelOpts.usePointStyle && labelOpts.boxWidth > fontSize
    ?\r\n\t\tfontSize :\r\n\t\tlabelOpts.boxWidth;\r\n}\r\n\r\n/**\r\n * IMPORTANT:
    this class is exposed publicly as Chart.Legend, backward compatibility required!\r\n
    */\r\nvar Legend = core_element.extend({\r\n\r\n\tinitialize: function(config)
    {\r\n\t\tvar me = this;\r\n\t\thelpers$1.extend(me, config);\r\n\r\n\t\t// Contains
    hit boxes for each dataset (in dataset order)\r\n\t\tme.legendHitBoxes = [];\r\n\r\n\t\t/**\r\n
    \t\t * @private\r\n \t\t */\r\n\t\tme._hoveredItem = null;\r\n\r\n\t\t// Are we
    in doughnut mode which has a different data type\r\n\t\tme.doughnutMode = false;\r\n\t},\r\n\r\n\t//
    These methods are ordered by lifecycle. Utilities then follow.\r\n\t// Any function
    defined here is inherited by all legend types.\r\n\t// Any function can be extended
    by the legend type\r\n\r\n\tbeforeUpdate: noop$1,\r\n\tupdate: function(maxWidth,
    maxHeight, margins) {\r\n\t\tvar me = this;\r\n\r\n\t\t// Update Lifecycle - Probably
    don't want to ever extend or overwrite this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t//
    Absorb the master measurements\r\n\t\tme.maxWidth = maxWidth;\r\n\t\tme.maxHeight
    = maxHeight;\r\n\t\tme.margins = margins;\r\n\r\n\t\t// Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\t\t//
    Labels\r\n\t\tme.beforeBuildLabels();\r\n\t\tme.buildLabels();\r\n\t\tme.afterBuildLabels();\r\n\r\n\t\t//
    Fit\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\t\t//\r\n\t\tme.afterUpdate();\r\n\r\n\t\treturn
    me.minSize;\r\n\t},\r\n\tafterUpdate: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions:
    noop$1,\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the
    unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left
    = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom
    = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop
    = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\r\n\t\t// Reset
    minSize\r\n\t\tme.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\t},\r\n\tafterSetDimensions:
    noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeBuildLabels: noop$1,\r\n\tbuildLabels: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar labelOpts = me.options.labels || {};\r\n\t\tvar
    legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) ||
    [];\r\n\r\n\t\tif (labelOpts.filter) {\r\n\t\t\tlegendItems = legendItems.filter(function(item)
    {\r\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif
    (me.options.reverse) {\r\n\t\t\tlegendItems.reverse();\r\n\t\t}\r\n\r\n\t\tme.legendItems
    = legendItems;\r\n\t},\r\n\tafterBuildLabels: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeFit:
    noop$1,\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar
    labelOpts = opts.labels;\r\n\t\tvar display = opts.display;\r\n\r\n\t\tvar ctx
    = me.ctx;\r\n\r\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\r\n\t\tvar
    fontSize = labelFont.size;\r\n\r\n\t\t// Reset hit boxes\r\n\t\tvar hitboxes =
    me.legendHitBoxes = [];\r\n\r\n\t\tvar minSize = me.minSize;\r\n\t\tvar isHorizontal
    = me.isHorizontal();\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.width = me.maxWidth;
    // fill all the width\r\n\t\t\tminSize.height = display ? 10 : 0;\r\n\t\t} else
    {\r\n\t\t\tminSize.width = display ? 10 : 0;\r\n\t\t\tminSize.height = me.maxHeight;
    // fill all the height\r\n\t\t}\r\n\r\n\t\t// Increase sizes here\r\n\t\tif (!display)
    {\r\n\t\t\tme.width = minSize.width = me.height = minSize.height = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tctx.font
    = labelFont.string;\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\t// Labels\r\n\r\n\t\t\t//
    Width of each line of legend boxes. Labels wrap onto multiple lines when there
    are too many to fit on one\r\n\t\t\tvar lineWidths = me.lineWidths = [0];\r\n\t\t\tvar
    totalHeight = 0;\r\n\r\n\t\t\tctx.textAlign = 'left';\r\n\t\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\t\thelpers$1.each(me.legendItems, function(legendItem, i)
    {\r\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\tvar width
    = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\tif
    (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding
    > minSize.width) {\r\n\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\r\n\t\t\t\t\tlineWidths[lineWidths.length
    - (i > 0 ? 0 : 1)] = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store the hitbox width
    and height here. Final position will be updated in `draw`\r\n\t\t\t\thitboxes[i]
    = {\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\twidth: width,\r\n\t\t\t\t\theight:
    fontSize\r\n\t\t\t\t};\r\n\r\n\t\t\t\tlineWidths[lineWidths.length - 1] += width
    + labelOpts.padding;\r\n\t\t\t});\r\n\r\n\t\t\tminSize.height += totalHeight;\r\n\r\n\t\t}
    else {\r\n\t\t\tvar vPadding = labelOpts.padding;\r\n\t\t\tvar columnWidths =
    me.columnWidths = [];\r\n\t\t\tvar columnHeights = me.columnHeights = [];\r\n\t\t\tvar
    totalWidth = labelOpts.padding;\r\n\t\t\tvar currentColWidth = 0;\r\n\t\t\tvar
    currentColHeight = 0;\r\n\r\n\t\t\thelpers$1.each(me.legendItems, function(legendItem,
    i) {\r\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\tvar
    itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\t//
    If too tall, go to new column\r\n\t\t\t\tif (i > 0 && currentColHeight + fontSize
    + 2 * vPadding > minSize.height) {\r\n\t\t\t\t\ttotalWidth += currentColWidth
    + labelOpts.padding;\r\n\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous
    column width\r\n\t\t\t\t\tcolumnHeights.push(currentColHeight);\r\n\t\t\t\t\tcurrentColWidth
    = 0;\r\n\t\t\t\t\tcurrentColHeight = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get max
    width\r\n\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\r\n\t\t\t\tcurrentColHeight
    += fontSize + vPadding;\r\n\r\n\t\t\t\t// Store the hitbox width and height here.
    Final position will be updated in `draw`\r\n\t\t\t\thitboxes[i] = {\r\n\t\t\t\t\tleft:
    0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\twidth: itemWidth,\r\n\t\t\t\t\theight: fontSize\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\ttotalWidth
    += currentColWidth;\r\n\t\t\tcolumnWidths.push(currentColWidth);\r\n\t\t\tcolumnHeights.push(currentColHeight);\r\n\t\t\tminSize.width
    += totalWidth;\r\n\t\t}\r\n\r\n\t\tme.width = minSize.width;\r\n\t\tme.height
    = minSize.height;\r\n\t},\r\n\tafterFit: noop$1,\r\n\r\n\t// Shared Methods\r\n\tisHorizontal:
    function() {\r\n\t\treturn this.options.position === 'top' || this.options.position
    === 'bottom';\r\n\t},\r\n\r\n\t// Actually draw the legend on the canvas\r\n\tdraw:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar labelOpts
    = opts.labels;\r\n\t\tvar globalDefaults = core_defaults.global;\r\n\t\tvar defaultColor
    = globalDefaults.defaultColor;\r\n\t\tvar lineDefault = globalDefaults.elements.line;\r\n\t\tvar
    legendHeight = me.height;\r\n\t\tvar columnHeights = me.columnHeights;\r\n\t\tvar
    legendWidth = me.width;\r\n\t\tvar lineWidths = me.lineWidths;\r\n\r\n\t\tif (!opts.display)
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar rtlHelper = getRtlHelper$1(opts.rtl,
    me.left, me.minSize.width);\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar fontColor = valueOrDefault$e(labelOpts.fontColor,
    globalDefaults.defaultFontColor);\r\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\r\n\t\tvar
    fontSize = labelFont.size;\r\n\t\tvar cursor;\r\n\r\n\t\t// Canvas setup\r\n\t\tctx.textAlign
    = rtlHelper.textAlign('left');\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.lineWidth
    = 0.5;\r\n\t\tctx.strokeStyle = fontColor; // for strikethrough effect\r\n\t\tctx.fillStyle
    = fontColor; // render in correct colour\r\n\t\tctx.font = labelFont.string;\r\n\r\n\t\tvar
    boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\tvar hitboxes = me.legendHitBoxes;\r\n\r\n\t\t//
    current position\r\n\t\tvar drawLegendBox = function(x, y, legendItem) {\r\n\t\t\tif
    (isNaN(boxWidth) || boxWidth <= 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t//
    Set the ctx for the box\r\n\t\t\tctx.save();\r\n\r\n\t\t\tvar lineWidth = valueOrDefault$e(legendItem.lineWidth,
    lineDefault.borderWidth);\r\n\t\t\tctx.fillStyle = valueOrDefault$e(legendItem.fillStyle,
    defaultColor);\r\n\t\t\tctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);\r\n\t\t\tctx.lineDashOffset
    = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);\r\n\t\t\tctx.lineJoin
    = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);\r\n\t\t\tctx.lineWidth
    = lineWidth;\r\n\t\t\tctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle,
    defaultColor);\r\n\r\n\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t// IE 9 and 10 do
    not support line dash\r\n\t\t\t\tctx.setLineDash(valueOrDefault$e(legendItem.lineDash,
    lineDefault.borderDash));\r\n\t\t\t}\r\n\r\n\t\t\tif (labelOpts && labelOpts.usePointStyle)
    {\r\n\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\r\n\t\t\t\t//
    x and y to be center of figure (instead of top left)\r\n\t\t\t\tvar radius = boxWidth
    * Math.SQRT2 / 2;\r\n\t\t\t\tvar centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n\t\t\t\tvar
    centerY = y + fontSize / 2;\r\n\r\n\t\t\t\t// Draw pointStyle as legend symbol\r\n\t\t\t\thelpers$1.canvas.drawPoint(ctx,
    legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);\r\n\t\t\t}
    else {\r\n\t\t\t\t// Draw box as legend symbol\r\n\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(x,
    boxWidth), y, boxWidth, fontSize);\r\n\t\t\t\tif (lineWidth !== 0) {\r\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(x,
    boxWidth), y, boxWidth, fontSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t};\r\n\r\n\t\tvar
    fillText = function(x, y, legendItem, textWidth) {\r\n\t\t\tvar halfFontSize =
    fontSize / 2;\r\n\t\t\tvar xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);\r\n\t\t\tvar
    yMiddle = y + halfFontSize;\r\n\r\n\t\t\tctx.fillText(legendItem.text, xLeft,
    yMiddle);\r\n\r\n\t\t\tif (legendItem.hidden) {\r\n\t\t\t\t// Strikethrough the
    text if hidden\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.lineWidth = 2;\r\n\t\t\t\tctx.moveTo(xLeft,
    yMiddle);\r\n\t\t\t\tctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar
    alignmentOffset = function(dimension, blockSize) {\r\n\t\t\tswitch (opts.align)
    {\r\n\t\t\tcase 'start':\r\n\t\t\t\treturn labelOpts.padding;\r\n\t\t\tcase 'end':\r\n\t\t\t\treturn
    dimension - blockSize;\r\n\t\t\tdefault: // center\r\n\t\t\t\treturn (dimension
    - blockSize + labelOpts.padding) / 2;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Horizontal\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\tif (isHorizontal) {\r\n\t\t\tcursor =
    {\r\n\t\t\t\tx: me.left + alignmentOffset(legendWidth, lineWidths[0]),\r\n\t\t\t\ty:
    me.top + labelOpts.padding,\r\n\t\t\t\tline: 0\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tcursor
    = {\r\n\t\t\t\tx: me.left + labelOpts.padding,\r\n\t\t\t\ty: me.top + alignmentOffset(legendHeight,
    columnHeights[0]),\r\n\t\t\t\tline: 0\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\thelpers$1.rtl.overrideTextDirection(me.ctx,
    opts.textDirection);\r\n\r\n\t\tvar itemHeight = fontSize + labelOpts.padding;\r\n\t\thelpers$1.each(me.legendItems,
    function(legendItem, i) {\r\n\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\r\n\t\t\tvar
    width = boxWidth + (fontSize / 2) + textWidth;\r\n\t\t\tvar x = cursor.x;\r\n\t\t\tvar
    y = cursor.y;\r\n\r\n\t\t\trtlHelper.setWidth(me.minSize.width);\r\n\r\n\t\t\t//
    Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\r\n\t\t\t//
    instead of me.right and me.bottom because me.width and me.height\r\n\t\t\t// may
    have been changed since me.minSize was calculated\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tif
    (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\r\n\t\t\t\t\ty
    = cursor.y += itemHeight;\r\n\t\t\t\t\tcursor.line++;\r\n\t\t\t\t\tx = cursor.x
    = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\r\n\t\t\t\t}\r\n\t\t\t}
    else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\r\n\t\t\t\tx
    = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n\t\t\t\tcursor.line++;\r\n\t\t\t\ty
    = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\r\n\t\t\t}\r\n\r\n\t\t\tvar
    realX = rtlHelper.x(x);\r\n\r\n\t\t\tdrawLegendBox(realX, y, legendItem);\r\n\r\n\t\t\thitboxes[i].left
    = rtlHelper.leftForLtr(realX, hitboxes[i].width);\r\n\t\t\thitboxes[i].top = y;\r\n\r\n\t\t\t//
    Fill the actual label\r\n\t\t\tfillText(realX, y, legendItem, textWidth);\r\n\r\n\t\t\tif
    (isHorizontal) {\r\n\t\t\t\tcursor.x += width + labelOpts.padding;\r\n\t\t\t}
    else {\r\n\t\t\t\tcursor.y += itemHeight;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.rtl.restoreTextDirection(me.ctx,
    opts.textDirection);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLegendItemAt:
    function(x, y) {\r\n\t\tvar me = this;\r\n\t\tvar i, hitBox, lh;\r\n\r\n\t\tif
    (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\r\n\t\t\t//
    See if we are touching one of the dataset boxes\r\n\t\t\tlh = me.legendHitBoxes;\r\n\t\t\tfor
    (i = 0; i < lh.length; ++i) {\r\n\t\t\t\thitBox = lh[i];\r\n\r\n\t\t\t\tif (x
    >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top
    + hitBox.height) {\r\n\t\t\t\t\t// Touching an element\r\n\t\t\t\t\treturn me.legendItems[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    null;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle an event\r\n\t * @private\r\n\t * @param
    {IEvent} event - The event to handle\r\n\t */\r\n\thandleEvent: function(e) {\r\n\t\tvar
    me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar type = e.type === 'mouseup'
    ? 'click' : e.type;\r\n\t\tvar hoveredItem;\r\n\r\n\t\tif (type === 'mousemove')
    {\r\n\t\t\tif (!opts.onHover && !opts.onLeave) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}
    else if (type === 'click') {\r\n\t\t\tif (!opts.onClick) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}
    else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chart event already has relative
    position in it\r\n\t\thoveredItem = me._getLegendItemAt(e.x, e.y);\r\n\r\n\t\tif
    (type === 'click') {\r\n\t\t\tif (hoveredItem && opts.onClick) {\r\n\t\t\t\t//
    use e.native for backwards compatibility\r\n\t\t\t\topts.onClick.call(me, e.native,
    hoveredItem);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (opts.onLeave && hoveredItem
    !== me._hoveredItem) {\r\n\t\t\t\tif (me._hoveredItem) {\r\n\t\t\t\t\topts.onLeave.call(me,
    e.native, me._hoveredItem);\r\n\t\t\t\t}\r\n\t\t\t\tme._hoveredItem = hoveredItem;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (opts.onHover && hoveredItem) {\r\n\t\t\t\t// use e.native for backwards compatibility\r\n\t\t\t\topts.onHover.call(me,
    e.native, hoveredItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction createNewLegendAndAttach(chart,
    legendOpts) {\r\n\tvar legend = new Legend({\r\n\t\tctx: chart.ctx,\r\n\t\toptions:
    legendOpts,\r\n\t\tchart: chart\r\n\t});\r\n\r\n\tcore_layouts.configure(chart,
    legend, legendOpts);\r\n\tcore_layouts.addBox(chart, legend);\r\n\tchart.legend
    = legend;\r\n}\r\n\r\nvar plugin_legend = {\r\n\tid: 'legend',\r\n\r\n\t/**\r\n\t
    * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\r\n\t
    * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part
    of\r\n\t * the plugin, which one will be re-exposed in the chart.js file.\r\n\t
    * https://github.com/chartjs/Chart.js/pull/2640\r\n\t * @private\r\n\t */\r\n\t_element:
    Legend,\r\n\r\n\tbeforeInit: function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\r\n\t\tif
    (legendOpts) {\r\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeUpdate:
    function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\t\tvar legend
    = chart.legend;\r\n\r\n\t\tif (legendOpts) {\r\n\t\t\thelpers$1.mergeIf(legendOpts,
    core_defaults.global.legend);\r\n\r\n\t\t\tif (legend) {\r\n\t\t\t\tcore_layouts.configure(chart,
    legend, legendOpts);\r\n\t\t\t\tlegend.options = legendOpts;\r\n\t\t\t} else {\r\n\t\t\t\tcreateNewLegendAndAttach(chart,
    legendOpts);\r\n\t\t\t}\r\n\t\t} else if (legend) {\r\n\t\t\tcore_layouts.removeBox(chart,
    legend);\r\n\t\t\tdelete chart.legend;\r\n\t\t}\r\n\t},\r\n\r\n\tafterEvent: function(chart,
    e) {\r\n\t\tvar legend = chart.legend;\r\n\t\tif (legend) {\r\n\t\t\tlegend.handleEvent(e);\r\n\t\t}\r\n\t}\r\n};\n\nvar
    noop$2 = helpers$1.noop;\r\n\r\ncore_defaults._set('global', {\r\n\ttitle: {\r\n\t\tdisplay:
    false,\r\n\t\tfontStyle: 'bold',\r\n\t\tfullWidth: true,\r\n\t\tpadding: 10,\r\n\t\tposition:
    'top',\r\n\t\ttext: '',\r\n\t\tweight: 2000         // by default greater than
    legend (1000) to be above\r\n\t}\r\n});\r\n\r\n/**\r\n * IMPORTANT: this class
    is exposed publicly as Chart.Legend, backward compatibility required!\r\n */\r\nvar
    Title = core_element.extend({\r\n\tinitialize: function(config) {\r\n\t\tvar me
    = this;\r\n\t\thelpers$1.extend(me, config);\r\n\r\n\t\t// Contains hit boxes
    for each dataset (in dataset order)\r\n\t\tme.legendHitBoxes = [];\r\n\t},\r\n\r\n\t//
    These methods are ordered by lifecycle. Utilities then follow.\r\n\r\n\tbeforeUpdate:
    noop$2,\r\n\tupdate: function(maxWidth, maxHeight, margins) {\r\n\t\tvar me =
    this;\r\n\r\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite
    this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth
    = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = margins;\r\n\r\n\t\t//
    Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\t\t//
    Labels\r\n\t\tme.beforeBuildLabels();\r\n\t\tme.buildLabels();\r\n\t\tme.afterBuildLabels();\r\n\r\n\t\t//
    Fit\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\t\t//\r\n\t\tme.afterUpdate();\r\n\r\n\t\treturn
    me.minSize;\r\n\r\n\t},\r\n\tafterUpdate: noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions:
    noop$2,\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the
    unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left
    = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom
    = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop
    = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\r\n\t\t// Reset
    minSize\r\n\t\tme.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\t},\r\n\tafterSetDimensions:
    noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeBuildLabels: noop$2,\r\n\tbuildLabels: noop$2,\r\n\tafterBuildLabels:
    noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeFit: noop$2,\r\n\tfit: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar minSize = me.minSize = {};\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\tvar lineCount, textSize;\r\n\r\n\t\tif
    (!opts.display) {\r\n\t\t\tme.width = minSize.width = me.height = minSize.height
    = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlineCount = helpers$1.isArray(opts.text)
    ? opts.text.length : 1;\r\n\t\ttextSize = lineCount * helpers$1.options._parseFont(opts).lineHeight
    + opts.padding * 2;\r\n\r\n\t\tme.width = minSize.width = isHorizontal ? me.maxWidth
    : textSize;\r\n\t\tme.height = minSize.height = isHorizontal ? textSize : me.maxHeight;\r\n\t},\r\n\tafterFit:
    noop$2,\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\tvar
    pos = this.options.position;\r\n\t\treturn pos === 'top' || pos === 'bottom';\r\n\t},\r\n\r\n\t//
    Actually draw the title block on the canvas\r\n\tdraw: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\r\n\t\tif
    (!opts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar fontOpts = helpers$1.options._parseFont(opts);\r\n\t\tvar
    lineHeight = fontOpts.lineHeight;\r\n\t\tvar offset = lineHeight / 2 + opts.padding;\r\n\t\tvar
    rotation = 0;\r\n\t\tvar top = me.top;\r\n\t\tvar left = me.left;\r\n\t\tvar bottom
    = me.bottom;\r\n\t\tvar right = me.right;\r\n\t\tvar maxWidth, titleX, titleY;\r\n\r\n\t\tctx.fillStyle
    = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
    // render in correct colour\r\n\t\tctx.font = fontOpts.string;\r\n\r\n\t\t// Horizontal\r\n\t\tif
    (me.isHorizontal()) {\r\n\t\t\ttitleX = left + ((right - left) / 2); // midpoint
    of the width\r\n\t\t\ttitleY = top + offset;\r\n\t\t\tmaxWidth = right - left;\r\n\t\t}
    else {\r\n\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\r\n\t\t\ttitleY
    = top + ((bottom - top) / 2);\r\n\t\t\tmaxWidth = bottom - top;\r\n\t\t\trotation
    = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(titleX,
    titleY);\r\n\t\tctx.rotate(rotation);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\tvar text = opts.text;\r\n\t\tif (helpers$1.isArray(text))
    {\r\n\t\t\tvar y = 0;\r\n\t\t\tfor (var i = 0; i < text.length; ++i) {\r\n\t\t\t\tctx.fillText(text[i],
    0, y, maxWidth);\r\n\t\t\t\ty += lineHeight;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tctx.fillText(text,
    0, 0, maxWidth);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n});\r\n\r\nfunction
    createNewTitleBlockAndAttach(chart, titleOpts) {\r\n\tvar title = new Title({\r\n\t\tctx:
    chart.ctx,\r\n\t\toptions: titleOpts,\r\n\t\tchart: chart\r\n\t});\r\n\r\n\tcore_layouts.configure(chart,
    title, titleOpts);\r\n\tcore_layouts.addBox(chart, title);\r\n\tchart.titleBlock
    = title;\r\n}\r\n\r\nvar plugin_title = {\r\n\tid: 'title',\r\n\r\n\t/**\r\n\t
    * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\r\n\t
    * Chart.Title obsolete. To avoid a breaking change, we export the Title as part
    of\r\n\t * the plugin, which one will be re-exposed in the chart.js file.\r\n\t
    * https://github.com/chartjs/Chart.js/pull/2640\r\n\t * @private\r\n\t */\r\n\t_element:
    Title,\r\n\r\n\tbeforeInit: function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\r\n\t\tif
    (titleOpts) {\r\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeUpdate:
    function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\t\tvar titleBlock
    = chart.titleBlock;\r\n\r\n\t\tif (titleOpts) {\r\n\t\t\thelpers$1.mergeIf(titleOpts,
    core_defaults.global.title);\r\n\r\n\t\t\tif (titleBlock) {\r\n\t\t\t\tcore_layouts.configure(chart,
    titleBlock, titleOpts);\r\n\t\t\t\ttitleBlock.options = titleOpts;\r\n\t\t\t}
    else {\r\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t\t}\r\n\t\t}
    else if (titleBlock) {\r\n\t\t\tcore_layouts.removeBox(chart, titleBlock);\r\n\t\t\tdelete
    chart.titleBlock;\r\n\t\t}\r\n\t}\r\n};\n\nvar plugins = {};\r\nvar filler = plugin_filler;\r\nvar
    legend = plugin_legend;\r\nvar title = plugin_title;\nplugins.filler = filler;\nplugins.legend
    = legend;\nplugins.title = title;\n\n/**\r\n * @namespace Chart\r\n */\r\n\r\n\r\ncore_controller.helpers
    = helpers$1;\r\n\r\n// @todo dispatch these helpers into appropriated helpers/helpers.*
    file and write unit tests!\r\ncore_helpers();\r\n\r\ncore_controller._adapters
    = core_adapters;\r\ncore_controller.Animation = core_animation;\r\ncore_controller.animationService
    = core_animations;\r\ncore_controller.controllers = controllers;\r\ncore_controller.DatasetController
    = core_datasetController;\r\ncore_controller.defaults = core_defaults;\r\ncore_controller.Element
    = core_element;\r\ncore_controller.elements = elements;\r\ncore_controller.Interaction
    = core_interaction;\r\ncore_controller.layouts = core_layouts;\r\ncore_controller.platform
    = platform;\r\ncore_controller.plugins = core_plugins;\r\ncore_controller.Scale
    = core_scale;\r\ncore_controller.scaleService = core_scaleService;\r\ncore_controller.Ticks
    = core_ticks;\r\ncore_controller.Tooltip = core_tooltip;\r\n\r\n// Register built-in
    scales\r\n\r\ncore_controller.helpers.each(scales, function(scale, type) {\r\n\tcore_controller.scaleService.registerScaleType(type,
    scale, scale._defaults);\r\n});\r\n\r\n// Load to register built-in adapters (as
    side effects)\r\n\r\n\r\n// Loading built-in plugins\r\n\r\nfor (var k in plugins)
    {\r\n\tif (plugins.hasOwnProperty(k)) {\r\n\t\tcore_controller.plugins.register(plugins[k]);\r\n\t}\r\n}\r\n\r\ncore_controller.platform.initialize();\r\n\r\nvar
    src = core_controller;\r\nif (typeof window !== 'undefined') {\r\n\twindow.Chart
    = core_controller;\r\n}\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward
    compatibility, not available anymore\r\n * @namespace Chart.Chart\r\n * @deprecated
    since version 2.8.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Chart
    = core_controller;\r\n\r\n/**\r\n * Provided for backward compatibility, not available
    anymore\r\n * @namespace Chart.Legend\r\n * @deprecated since version 2.1.5\r\n
    * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Legend =
    plugins.legend._element;\r\n\r\n/**\r\n * Provided for backward compatibility,
    not available anymore\r\n * @namespace Chart.Title\r\n * @deprecated since version
    2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Title
    = plugins.title._element;\r\n\r\n/**\r\n * Provided for backward compatibility,
    use Chart.plugins instead\r\n * @namespace Chart.pluginService\r\n * @deprecated
    since version 2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.pluginService
    = core_controller.plugins;\r\n\r\n/**\r\n * Provided for backward compatibility,
    inheriting from Chart.PlugingBase has no\r\n * effect, instead simply create/register
    plugins via plain JavaScript objects.\r\n * @interface Chart.PluginBase\r\n *
    @deprecated since version 2.5.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\ncore_controller.PluginBase = core_controller.Element.extend({});\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.helpers.canvas instead.\r\n *
    @namespace Chart.canvasHelpers\r\n * @deprecated since version 2.6.0\r\n * @todo
    remove at version 3\r\n * @private\r\n */\r\ncore_controller.canvasHelpers = core_controller.helpers.canvas;\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.layouts instead.\r\n * @namespace
    Chart.layoutService\r\n * @deprecated since version 2.7.3\r\n * @todo remove at
    version 3\r\n * @private\r\n */\r\ncore_controller.layoutService = core_controller.layouts;\r\n\r\n/**\r\n
    * Provided for backward compatibility, not available anymore.\r\n * @namespace
    Chart.LinearScaleBase\r\n * @deprecated since version 2.8\r\n * @todo remove at
    version 3\r\n * @private\r\n */\r\ncore_controller.LinearScaleBase = scale_linearbase;\r\n\r\n/**\r\n
    * Provided for backward compatibility, instead we should create a new Chart\r\n
    * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\r\n
    * @deprecated since version 2.8.0\r\n * @todo remove at version 3\r\n */\r\ncore_controller.helpers.each(\r\n\t[\r\n\t\t'Bar',\r\n\t\t'Bubble',\r\n\t\t'Doughnut',\r\n\t\t'Line',\r\n\t\t'PolarArea',\r\n\t\t'Radar',\r\n\t\t'Scatter'\r\n\t],\r\n\tfunction(klass)
    {\r\n\t\tcore_controller[klass] = function(ctx, cfg) {\r\n\t\t\treturn new core_controller(ctx,
    core_controller.helpers.merge(cfg || {}, {\r\n\t\t\t\ttype: klass.charAt(0).toLowerCase()
    + klass.slice(1)\r\n\t\t\t}));\r\n\t\t};\r\n\t}\r\n);\n\nreturn src;\n\n})));\n"
  admin-Public-Admin-plugins-chart.js-Chart.bundle.min.js: |
    /*!
     * Chart.js v2.9.4
     * https://www.chartjs.org
     * (c) 2020 Chart.js Contributors
     * Released under the MIT License
     */
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).Chart=e()}(this,(function(){"use strict";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function t(){throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs")}function e(t,e){return t(e={exports:{}},e.exports),e.exports}var n={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},i=e((function(t){var e={};for(var i in n)n.hasOwnProperty(i)&&(e[n[i]]=i);var a=t.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var r in a)if(a.hasOwnProperty(r)){if(!("channels"in a[r]))throw new Error("missing channels property: "+r);if(!("labels"in a[r]))throw new Error("missing channel labels property: "+r);if(a[r].labels.length!==a[r].channels)throw new Error("channel and label counts mismatch: "+r);var o=a[r].channels,s=a[r].labels;delete a[r].channels,delete a[r].labels,Object.defineProperty(a[r],"channels",{value:o}),Object.defineProperty(a[r],"labels",{value:s})}a.rgb.hsl=function(t){var e,n,i=t[0]/255,a=t[1]/255,r=t[2]/255,o=Math.min(i,a,r),s=Math.max(i,a,r),l=s-o;return s===o?e=0:i===s?e=(a-r)/l:a===s?e=2+(r-i)/l:r===s&&(e=4+(i-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),n=(o+s)/2,[e,100*(s===o?0:n<=.5?l/(s+o):l/(2-s-o)),100*n]},a.rgb.hsv=function(t){var e,n,i,a,r,o=t[0]/255,s=t[1]/255,l=t[2]/255,u=Math.max(o,s,l),d=u-Math.min(o,s,l),h=function(t){return(u-t)/6/d+.5};return 0===d?a=r=0:(r=d/u,e=h(o),n=h(s),i=h(l),o===u?a=i-n:s===u?a=1/3+e-i:l===u&&(a=2/3+n-e),a<0?a+=1:a>1&&(a-=1)),[360*a,100*r,100*u]},a.rgb.hwb=function(t){var e=t[0],n=t[1],i=t[2];return[a.rgb.hsl(t)[0],100*(1/255*Math.min(e,Math.min(n,i))),100*(i=1-1/255*Math.max(e,Math.max(n,i)))]},a.rgb.cmyk=function(t){var e,n=t[0]/255,i=t[1]/255,a=t[2]/255;return[100*((1-n-(e=Math.min(1-n,1-i,1-a)))/(1-e)||0),100*((1-i-e)/(1-e)||0),100*((1-a-e)/(1-e)||0),100*e]},a.rgb.keyword=function(t){var i=e[t];if(i)return i;var a,r,o,s=1/0;for(var l in n)if(n.hasOwnProperty(l)){var u=n[l],d=(r=t,o=u,Math.pow(r[0]-o[0],2)+Math.pow(r[1]-o[1],2)+Math.pow(r[2]-o[2],2));d<s&&(s=d,a=l)}return a},a.keyword.rgb=function(t){return n[t]},a.rgb.xyz=function(t){var e=t[0]/255,n=t[1]/255,i=t[2]/255;return[100*(.4124*(e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)+.1805*(i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92)),100*(.2126*e+.7152*n+.0722*i),100*(.0193*e+.1192*n+.9505*i)]},a.rgb.lab=function(t){var e=a.rgb.xyz(t),n=e[0],i=e[1],r=e[2];return i/=100,r/=108.883,n=(n/=95.047)>.008856?Math.pow(n,1/3):7.787*n+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(n-i),200*(i-(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116))]},a.hsl.rgb=function(t){var e,n,i,a,r,o=t[0]/360,s=t[1]/100,l=t[2]/100;if(0===s)return[r=255*l,r,r];e=2*l-(n=l<.5?l*(1+s):l+s-l*s),a=[0,0,0];for(var u=0;u<3;u++)(i=o+1/3*-(u-1))<0&&i++,i>1&&i--,r=6*i<1?e+6*(n-e)*i:2*i<1?n:3*i<2?e+(n-e)*(2/3-i)*6:e,a[u]=255*r;return a},a.hsl.hsv=function(t){var e=t[0],n=t[1]/100,i=t[2]/100,a=n,r=Math.max(i,.01);return n*=(i*=2)<=1?i:2-i,a*=r<=1?r:2-r,[e,100*(0===i?2*a/(r+a):2*n/(i+n)),100*((i+n)/2)]},a.hsv.rgb=function(t){var e=t[0]/60,n=t[1]/100,i=t[2]/100,a=Math.floor(e)%6,r=e-Math.floor(e),o=255*i*(1-n),s=255*i*(1-n*r),l=255*i*(1-n*(1-r));switch(i*=255,a){case 0:return[i,l,o];case 1:return[s,i,o];case 2:return[o,i,l];case 3:return[o,s,i];case 4:return[l,o,i];case 5:return[i,o,s]}},a.hsv.hsl=function(t){var e,n,i,a=t[0],r=t[1]/100,o=t[2]/100,s=Math.max(o,.01);return i=(2-r)*o,n=r*s,[a,100*(n=(n/=(e=(2-r)*s)<=1?e:2-e)||0),100*(i/=2)]},a.hwb.rgb=function(t){var e,n,i,a,r,o,s,l=t[0]/360,u=t[1]/100,d=t[2]/100,h=u+d;switch(h>1&&(u/=h,d/=h),i=6*l-(e=Math.floor(6*l)),0!=(1&e)&&(i=1-i),a=u+i*((n=1-d)-u),e){default:case 6:case 0:r=n,o=a,s=u;break;case 1:r=a,o=n,s=u;break;case 2:r=u,o=n,s=a;break;case 3:r=u,o=a,s=n;break;case 4:r=a,o=u,s=n;break;case 5:r=n,o=u,s=a}return[255*r,255*o,255*s]},a.cmyk.rgb=function(t){var e=t[0]/100,n=t[1]/100,i=t[2]/100,a=t[3]/100;return[255*(1-Math.min(1,e*(1-a)+a)),255*(1-Math.min(1,n*(1-a)+a)),255*(1-Math.min(1,i*(1-a)+a))]},a.xyz.rgb=function(t){var e,n,i,a=t[0]/100,r=t[1]/100,o=t[2]/100;return n=-.9689*a+1.8758*r+.0415*o,i=.0557*a+-.204*r+1.057*o,e=(e=3.2406*a+-1.5372*r+-.4986*o)>.0031308?1.055*Math.pow(e,1/2.4)-.055:12.92*e,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:12.92*i,[255*(e=Math.min(Math.max(0,e),1)),255*(n=Math.min(Math.max(0,n),1)),255*(i=Math.min(Math.max(0,i),1))]},a.xyz.lab=function(t){var e=t[0],n=t[1],i=t[2];return n/=100,i/=108.883,e=(e/=95.047)>.008856?Math.pow(e,1/3):7.787*e+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(e-n),200*(n-(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116))]},a.lab.xyz=function(t){var e,n,i,a=t[0];e=t[1]/500+(n=(a+16)/116),i=n-t[2]/200;var r=Math.pow(n,3),o=Math.pow(e,3),s=Math.pow(i,3);return n=r>.008856?r:(n-16/116)/7.787,e=o>.008856?o:(e-16/116)/7.787,i=s>.008856?s:(i-16/116)/7.787,[e*=95.047,n*=100,i*=108.883]},a.lab.lch=function(t){var e,n=t[0],i=t[1],a=t[2];return(e=360*Math.atan2(a,i)/2/Math.PI)<0&&(e+=360),[n,Math.sqrt(i*i+a*a),e]},a.lch.lab=function(t){var e,n=t[0],i=t[1];return e=t[2]/360*2*Math.PI,[n,i*Math.cos(e),i*Math.sin(e)]},a.rgb.ansi16=function(t){var e=t[0],n=t[1],i=t[2],r=1 in arguments?arguments[1]:a.rgb.hsv(t)[2];if(0===(r=Math.round(r/50)))return 30;var o=30+(Math.round(i/255)<<2|Math.round(n/255)<<1|Math.round(e/255));return 2===r&&(o+=60),o},a.hsv.ansi16=function(t){return a.rgb.ansi16(a.hsv.rgb(t),t[2])},a.rgb.ansi256=function(t){var e=t[0],n=t[1],i=t[2];return e===n&&n===i?e<8?16:e>248?231:Math.round((e-8)/247*24)+232:16+36*Math.round(e/255*5)+6*Math.round(n/255*5)+Math.round(i/255*5)},a.ansi16.rgb=function(t){var e=t%10;if(0===e||7===e)return t>50&&(e+=3.5),[e=e/10.5*255,e,e];var n=.5*(1+~~(t>50));return[(1&e)*n*255,(e>>1&1)*n*255,(e>>2&1)*n*255]},a.ansi256.rgb=function(t){if(t>=232){var e=10*(t-232)+8;return[e,e,e]}var n;return t-=16,[Math.floor(t/36)/5*255,Math.floor((n=t%36)/6)/5*255,n%6/5*255]},a.rgb.hex=function(t){var e=(((255&Math.round(t[0]))<<16)+((255&Math.round(t[1]))<<8)+(255&Math.round(t[2]))).toString(16).toUpperCase();return"000000".substring(e.length)+e},a.hex.rgb=function(t){var e=t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!e)return[0,0,0];var n=e[0];3===e[0].length&&(n=n.split("").map((function(t){return t+t})).join(""));var i=parseInt(n,16);return[i>>16&255,i>>8&255,255&i]},a.rgb.hcg=function(t){var e,n=t[0]/255,i=t[1]/255,a=t[2]/255,r=Math.max(Math.max(n,i),a),o=Math.min(Math.min(n,i),a),s=r-o;return e=s<=0?0:r===n?(i-a)/s%6:r===i?2+(a-n)/s:4+(n-i)/s+4,e/=6,[360*(e%=1),100*s,100*(s<1?o/(1-s):0)]},a.hsl.hcg=function(t){var e=t[1]/100,n=t[2]/100,i=1,a=0;return(i=n<.5?2*e*n:2*e*(1-n))<1&&(a=(n-.5*i)/(1-i)),[t[0],100*i,100*a]},a.hsv.hcg=function(t){var e=t[1]/100,n=t[2]/100,i=e*n,a=0;return i<1&&(a=(n-i)/(1-i)),[t[0],100*i,100*a]},a.hcg.rgb=function(t){var e=t[0]/360,n=t[1]/100,i=t[2]/100;if(0===n)return[255*i,255*i,255*i];var a,r=[0,0,0],o=e%1*6,s=o%1,l=1-s;switch(Math.floor(o)){case 0:r[0]=1,r[1]=s,r[2]=0;break;case 1:r[0]=l,r[1]=1,r[2]=0;break;case 2:r[0]=0,r[1]=1,r[2]=s;break;case 3:r[0]=0,r[1]=l,r[2]=1;break;case 4:r[0]=s,r[1]=0,r[2]=1;break;default:r[0]=1,r[1]=0,r[2]=l}return a=(1-n)*i,[255*(n*r[0]+a),255*(n*r[1]+a),255*(n*r[2]+a)]},a.hcg.hsv=function(t){var e=t[1]/100,n=e+t[2]/100*(1-e),i=0;return n>0&&(i=e/n),[t[0],100*i,100*n]},a.hcg.hsl=function(t){var e=t[1]/100,n=t[2]/100*(1-e)+.5*e,i=0;return n>0&&n<.5?i=e/(2*n):n>=.5&&n<1&&(i=e/(2*(1-n))),[t[0],100*i,100*n]},a.hcg.hwb=function(t){var e=t[1]/100,n=e+t[2]/100*(1-e);return[t[0],100*(n-e),100*(1-n)]},a.hwb.hcg=function(t){var e=t[1]/100,n=1-t[2]/100,i=n-e,a=0;return i<1&&(a=(n-i)/(1-i)),[t[0],100*i,100*a]},a.apple.rgb=function(t){return[t[0]/65535*255,t[1]/65535*255,t[2]/65535*255]},a.rgb.apple=function(t){return[t[0]/255*65535,t[1]/255*65535,t[2]/255*65535]},a.gray.rgb=function(t){return[t[0]/100*255,t[0]/100*255,t[0]/100*255]},a.gray.hsl=a.gray.hsv=function(t){return[0,0,t[0]]},a.gray.hwb=function(t){return[0,100,t[0]]},a.gray.cmyk=function(t){return[0,0,0,t[0]]},a.gray.lab=function(t){return[t[0],0,0]},a.gray.hex=function(t){var e=255&Math.round(t[0]/100*255),n=((e<<16)+(e<<8)+e).toString(16).toUpperCase();return"000000".substring(n.length)+n},a.rgb.gray=function(t){return[(t[0]+t[1]+t[2])/3/255*100]}}));i.rgb,i.hsl,i.hsv,i.hwb,i.cmyk,i.xyz,i.lab,i.lch,i.hex,i.keyword,i.ansi16,i.ansi256,i.hcg,i.apple,i.gray;function a(t){var e=function(){for(var t={},e=Object.keys(i),n=e.length,a=0;a<n;a++)t[e[a]]={distance:-1,parent:null};return t}(),n=[t];for(e[t].distance=0;n.length;)for(var a=n.pop(),r=Object.keys(i[a]),o=r.length,s=0;s<o;s++){var l=r[s],u=e[l];-1===u.distance&&(u.distance=e[a].distance+1,u.parent=a,n.unshift(l))}return e}function r(t,e){return function(n){return e(t(n))}}function o(t,e){for(var n=[e[t].parent,t],a=i[e[t].parent][t],o=e[t].parent;e[o].parent;)n.unshift(e[o].parent),a=r(i[e[o].parent][o],a),o=e[o].parent;return a.conversion=n,a}var s={};Object.keys(i).forEach((function(t){s[t]={},Object.defineProperty(s[t],"channels",{value:i[t].channels}),Object.defineProperty(s[t],"labels",{value:i[t].labels});var e=function(t){for(var e=a(t),n={},i=Object.keys(e),r=i.length,s=0;s<r;s++){var l=i[s];null!==e[l].parent&&(n[l]=o(l,e))}return n}(t);Object.keys(e).forEach((function(n){var i=e[n];s[t][n]=function(t){var e=function(e){if(null==e)return e;arguments.length>1&&(e=Array.prototype.slice.call(arguments));var n=t(e);if("object"==typeof n)for(var i=n.length,a=0;a<i;a++)n[a]=Math.round(n[a]);return n};return"conversion"in t&&(e.conversion=t.conversion),e}(i),s[t][n].raw=function(t){var e=function(e){return null==e?e:(arguments.length>1&&(e=Array.prototype.slice.call(arguments)),t(e))};return"conversion"in t&&(e.conversion=t.conversion),e}(i)}))}));var l=s,u={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},d={getRgba:h,getHsla:c,getRgb:function(t){var e=h(t);return e&&e.slice(0,3)},getHsl:function(t){var e=c(t);return e&&e.slice(0,3)},getHwb:f,getAlpha:function(t){var e=h(t);if(e)return e[3];if(e=c(t))return e[3];if(e=f(t))return e[3]},hexString:function(t,e){e=void 0!==e&&3===t.length?e:t[3];return"#"+b(t[0])+b(t[1])+b(t[2])+(e>=0&&e<1?b(Math.round(255*e)):"")},rgbString:function(t,e){if(e<1||t[3]&&t[3]<1)return g(t,e);return"rgb("+t[0]+", "+t[1]+", "+t[2]+")"},rgbaString:g,percentString:function(t,e){if(e<1||t[3]&&t[3]<1)return m(t,e);var n=Math.round(t[0]/255*100),i=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgb("+n+"%, "+i+"%, "+a+"%)"},percentaString:m,hslString:function(t,e){if(e<1||t[3]&&t[3]<1)return p(t,e);return"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"},hslaString:p,hwbString:function(t,e){void 0===e&&(e=void 0!==t[3]?t[3]:1);return"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"},keyword:function(t){return y[t.slice(0,3)]}};function h(t){if(t){var e=[0,0,0],n=1,i=t.match(/^#([a-fA-F0-9]{3,4})$/i),a="";if(i){a=(i=i[1])[3];for(var r=0;r<e.length;r++)e[r]=parseInt(i[r]+i[r],16);a&&(n=Math.round(parseInt(a+a,16)/255*100)/100)}else if(i=t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)){a=i[2],i=i[1];for(r=0;r<e.length;r++)e[r]=parseInt(i.slice(2*r,2*r+2),16);a&&(n=Math.round(parseInt(a,16)/255*100)/100)}else if(i=t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(r=0;r<e.length;r++)e[r]=parseInt(i[r+1]);n=parseFloat(i[4])}else if(i=t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(r=0;r<e.length;r++)e[r]=Math.round(2.55*parseFloat(i[r+1]));n=parseFloat(i[4])}else if(i=t.match(/(\w+)/)){if("transparent"==i[1])return[0,0,0,0];if(!(e=u[i[1]]))return}for(r=0;r<e.length;r++)e[r]=v(e[r],0,255);return n=n||0==n?v(n,0,1):1,e[3]=n,e}}function c(t){if(t){var e=t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var n=parseFloat(e[4]);return[v(parseInt(e[1]),0,360),v(parseFloat(e[2]),0,100),v(parseFloat(e[3]),0,100),v(isNaN(n)?1:n,0,1)]}}}function f(t){if(t){var e=t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var n=parseFloat(e[4]);return[v(parseInt(e[1]),0,360),v(parseFloat(e[2]),0,100),v(parseFloat(e[3]),0,100),v(isNaN(n)?1:n,0,1)]}}}function g(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function m(t,e){return"rgba("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%, "+(e||t[3]||1)+")"}function p(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}function v(t,e,n){return Math.min(Math.max(e,t),n)}function b(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}var y={};for(var x in u)y[u[x]]=x;var _=function(t){return t instanceof _?t:this instanceof _?(this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1},void("string"==typeof t?(e=d.getRgba(t))?this.setValues("rgb",e):(e=d.getHsla(t))?this.setValues("hsl",e):(e=d.getHwb(t))&&this.setValues("hwb",e):"object"==typeof t&&(void 0!==(e=t).r||void 0!==e.red?this.setValues("rgb",e):void 0!==e.l||void 0!==e.lightness?this.setValues("hsl",e):void 0!==e.v||void 0!==e.value?this.setValues("hsv",e):void 0!==e.w||void 0!==e.whiteness?this.setValues("hwb",e):void 0===e.c&&void 0===e.cyan||this.setValues("cmyk",e)))):new _(t);var e};_.prototype={isValid:function(){return this.valid},rgb:function(){return this.setSpace("rgb",arguments)},hsl:function(){return this.setSpace("hsl",arguments)},hsv:function(){return this.setSpace("hsv",arguments)},hwb:function(){return this.setSpace("hwb",arguments)},cmyk:function(){return this.setSpace("cmyk",arguments)},rgbArray:function(){return this.values.rgb},hslArray:function(){return this.values.hsl},hsvArray:function(){return this.values.hsv},hwbArray:function(){var t=this.values;return 1!==t.alpha?t.hwb.concat([t.alpha]):t.hwb},cmykArray:function(){return this.values.cmyk},rgbaArray:function(){var t=this.values;return t.rgb.concat([t.alpha])},hslaArray:function(){var t=this.values;return t.hsl.concat([t.alpha])},alpha:function(t){return void 0===t?this.values.alpha:(this.setValues("alpha",t),this)},red:function(t){return this.setChannel("rgb",0,t)},green:function(t){return this.setChannel("rgb",1,t)},blue:function(t){return this.setChannel("rgb",2,t)},hue:function(t){return t&&(t=(t%=360)<0?360+t:t),this.setChannel("hsl",0,t)},saturation:function(t){return this.setChannel("hsl",1,t)},lightness:function(t){return this.setChannel("hsl",2,t)},saturationv:function(t){return this.setChannel("hsv",1,t)},whiteness:function(t){return this.setChannel("hwb",1,t)},blackness:function(t){return this.setChannel("hwb",2,t)},value:function(t){return this.setChannel("hsv",2,t)},cyan:function(t){return this.setChannel("cmyk",0,t)},magenta:function(t){return this.setChannel("cmyk",1,t)},yellow:function(t){return this.setChannel("cmyk",2,t)},black:function(t){return this.setChannel("cmyk",3,t)},hexString:function(){return d.hexString(this.values.rgb)},rgbString:function(){return d.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function(){return d.rgbaString(this.values.rgb,this.values.alpha)},percentString:function(){return d.percentString(this.values.rgb,this.values.alpha)},hslString:function(){return d.hslString(this.values.hsl,this.values.alpha)},hslaString:function(){return d.hslaString(this.values.hsl,this.values.alpha)},hwbString:function(){return d.hwbString(this.values.hwb,this.values.alpha)},keyword:function(){return d.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function(){var t=this.values.rgb;return t[0]<<16|t[1]<<8|t[2]},luminosity:function(){for(var t=this.values.rgb,e=[],n=0;n<t.length;n++){var i=t[n]/255;e[n]=i<=.03928?i/12.92:Math.pow((i+.055)/1.055,2.4)}return.2126*e[0]+.7152*e[1]+.0722*e[2]},contrast:function(t){var e=this.luminosity(),n=t.luminosity();return e>n?(e+.05)/(n+.05):(n+.05)/(e+.05)},level:function(t){var e=this.contrast(t);return e>=7.1?"AAA":e>=4.5?"AA":""},dark:function(){var t=this.values.rgb;return(299*t[0]+587*t[1]+114*t[2])/1e3<128},light:function(){return!this.dark()},negate:function(){for(var t=[],e=0;e<3;e++)t[e]=255-this.values.rgb[e];return this.setValues("rgb",t),this},lighten:function(t){var e=this.values.hsl;return e[2]+=e[2]*t,this.setValues("hsl",e),this},darken:function(t){var e=this.values.hsl;return e[2]-=e[2]*t,this.setValues("hsl",e),this},saturate:function(t){var e=this.values.hsl;return e[1]+=e[1]*t,this.setValues("hsl",e),this},desaturate:function(t){var e=this.values.hsl;return e[1]-=e[1]*t,this.setValues("hsl",e),this},whiten:function(t){var e=this.values.hwb;return e[1]+=e[1]*t,this.setValues("hwb",e),this},blacken:function(t){var e=this.values.hwb;return e[2]+=e[2]*t,this.setValues("hwb",e),this},greyscale:function(){var t=this.values.rgb,e=.3*t[0]+.59*t[1]+.11*t[2];return this.setValues("rgb",[e,e,e]),this},clearer:function(t){var e=this.values.alpha;return this.setValues("alpha",e-e*t),this},opaquer:function(t){var e=this.values.alpha;return this.setValues("alpha",e+e*t),this},rotate:function(t){var e=this.values.hsl,n=(e[0]+t)%360;return e[0]=n<0?360+n:n,this.setValues("hsl",e),this},mix:function(t,e){var n=t,i=void 0===e?.5:e,a=2*i-1,r=this.alpha()-n.alpha(),o=((a*r==-1?a:(a+r)/(1+a*r))+1)/2,s=1-o;return this.rgb(o*this.red()+s*n.red(),o*this.green()+s*n.green(),o*this.blue()+s*n.blue()).alpha(this.alpha()*i+n.alpha()*(1-i))},toJSON:function(){return this.rgb()},clone:function(){var t,e,n=new _,i=this.values,a=n.values;for(var r in i)i.hasOwnProperty(r)&&(t=i[r],"[object Array]"===(e={}.toString.call(t))?a[r]=t.slice(0):"[object Number]"===e?a[r]=t:console.error("unexpected color value:",t));return n}},_.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},_.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},_.prototype.getValues=function(t){for(var e=this.values,n={},i=0;i<t.length;i++)n[t.charAt(i)]=e[t][i];return 1!==e.alpha&&(n.a=e.alpha),n},_.prototype.setValues=function(t,e){var n,i,a=this.values,r=this.spaces,o=this.maxes,s=1;if(this.valid=!0,"alpha"===t)s=e;else if(e.length)a[t]=e.slice(0,t.length),s=e[t.length];else if(void 0!==e[t.charAt(0)]){for(n=0;n<t.length;n++)a[t][n]=e[t.charAt(n)];s=e.a}else if(void 0!==e[r[t][0]]){var u=r[t];for(n=0;n<t.length;n++)a[t][n]=e[u[n]];s=e.alpha}if(a.alpha=Math.max(0,Math.min(1,void 0===s?a.alpha:s)),"alpha"===t)return!1;for(n=0;n<t.length;n++)i=Math.max(0,Math.min(o[t][n],a[t][n])),a[t][n]=Math.round(i);for(var d in r)d!==t&&(a[d]=l[t][d](a[t]));return!0},_.prototype.setSpace=function(t,e){var n=e[0];return void 0===n?this.getValues(t):("number"==typeof n&&(n=Array.prototype.slice.call(e)),this.setValues(t,n),this)},_.prototype.setChannel=function(t,e,n){var i=this.values[t];return void 0===n?i[e]:n===i[e]?this:(i[e]=n,this.setValues(t,i),this)},"undefined"!=typeof window&&(window.Color=_);var w=_;function k(t){return-1===["__proto__","prototype","constructor"].indexOf(t)}var M,S={noop:function(){},uid:(M=0,function(){return M++}),isNullOrUndef:function(t){return null==t},isArray:function(t){if(Array.isArray&&Array.isArray(t))return!0;var e=Object.prototype.toString.call(t);return"[object"===e.substr(0,7)&&"Array]"===e.substr(-6)},isObject:function(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)},isFinite:function(t){return("number"==typeof t||t instanceof Number)&&isFinite(t)},valueOrDefault:function(t,e){return void 0===t?e:t},valueAtIndexOrDefault:function(t,e,n){return S.valueOrDefault(S.isArray(t)?t[e]:t,n)},callback:function(t,e,n){if(t&&"function"==typeof t.call)return t.apply(n,e)},each:function(t,e,n,i){var a,r,o;if(S.isArray(t))if(r=t.length,i)for(a=r-1;a>=0;a--)e.call(n,t[a],a);else for(a=0;a<r;a++)e.call(n,t[a],a);else if(S.isObject(t))for(r=(o=Object.keys(t)).length,a=0;a<r;a++)e.call(n,t[o[a]],o[a])},arrayEquals:function(t,e){var n,i,a,r;if(!t||!e||t.length!==e.length)return!1;for(n=0,i=t.length;n<i;++n)if(a=t[n],r=e[n],a instanceof Array&&r instanceof Array){if(!S.arrayEquals(a,r))return!1}else if(a!==r)return!1;return!0},clone:function(t){if(S.isArray(t))return t.map(S.clone);if(S.isObject(t)){for(var e=Object.create(t),n=Object.keys(t),i=n.length,a=0;a<i;++a)e[n[a]]=S.clone(t[n[a]]);return e}return t},_merger:function(t,e,n,i){if(k(t)){var a=e[t],r=n[t];S.isObject(a)&&S.isObject(r)?S.merge(a,r,i):e[t]=S.clone(r)}},_mergerIf:function(t,e,n){if(k(t)){var i=e[t],a=n[t];S.isObject(i)&&S.isObject(a)?S.mergeIf(i,a):e.hasOwnProperty(t)||(e[t]=S.clone(a))}},merge:function(t,e,n){var i,a,r,o,s,l=S.isArray(e)?e:[e],u=l.length;if(!S.isObject(t))return t;for(i=(n=n||{}).merger||S._merger,a=0;a<u;++a)if(e=l[a],S.isObject(e))for(s=0,o=(r=Object.keys(e)).length;s<o;++s)i(r[s],t,e,n);return t},mergeIf:function(t,e){return S.merge(t,e,{merger:S._mergerIf})},extend:Object.assign||function(t){return S.merge(t,[].slice.call(arguments,1),{merger:function(t,e,n){e[t]=n[t]}})},inherits:function(t){var e=this,n=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return e.apply(this,arguments)},i=function(){this.constructor=n};return i.prototype=e.prototype,n.prototype=new i,n.extend=S.inherits,t&&S.extend(n.prototype,t),n.__super__=e.prototype,n},_deprecated:function(t,e,n,i){void 0!==e&&console.warn(t+': "'+n+'" is deprecated. Please use "'+i+'" instead')}},D=S;S.callCallback=S.callback,S.indexOf=function(t,e,n){return Array.prototype.indexOf.call(t,e,n)},S.getValueOrDefault=S.valueOrDefault,S.getValueAtIndexOrDefault=S.valueAtIndexOrDefault;var C={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return(t-=1)*t*t+1},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-((t-=1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return(t-=1)*t*t*t*t+1},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return 1-Math.cos(t*(Math.PI/2))},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:1-Math.pow(2,-10*t)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},easeInCirc:function(t){return t>=1?t:-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-(t-=1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:1===t?1:(n||(n=.3),i<1?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),-i*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/n))},easeOutElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:1===t?1:(n||(n=.3),i<1?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),i*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/n)+1)},easeInOutElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:2==(t/=.5)?1:(n||(n=.45),i<1?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),t<1?i*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/n)*-.5:i*Math.pow(2,-10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/n)*.5+1)},easeInBack:function(t){var e=1.70158;return t*t*((e+1)*t-e)},easeOutBack:function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:function(t){return 1-C.easeOutBounce(1-t)},easeOutBounce:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInOutBounce:function(t){return t<.5?.5*C.easeInBounce(2*t):.5*C.easeOutBounce(2*t-1)+.5}},P={effects:C};D.easingEffects=C;var T=Math.PI,O=T/180,A=2*T,F=T/2,I=T/4,L=2*T/3,R={clear:function(t){t.ctx.clearRect(0,0,t.width,t.height)},roundedRect:function(t,e,n,i,a,r){if(r){var o=Math.min(r,a/2,i/2),s=e+o,l=n+o,u=e+i-o,d=n+a-o;t.moveTo(e,l),s<u&&l<d?(t.arc(s,l,o,-T,-F),t.arc(u,l,o,-F,0),t.arc(u,d,o,0,F),t.arc(s,d,o,F,T)):s<u?(t.moveTo(s,n),t.arc(u,l,o,-F,F),t.arc(s,l,o,F,T+F)):l<d?(t.arc(s,l,o,-T,0),t.arc(s,d,o,0,T)):t.arc(s,l,o,-T,T),t.closePath(),t.moveTo(e,n)}else t.rect(e,n,i,a)},drawPoint:function(t,e,n,i,a,r){var o,s,l,u,d,h=(r||0)*O;if(e&&"object"==typeof e&&("[object HTMLImageElement]"===(o=e.toString())||"[object HTMLCanvasElement]"===o))return t.save(),t.translate(i,a),t.rotate(h),t.drawImage(e,-e.width/2,-e.height/2,e.width,e.height),void t.restore();if(!(isNaN(n)||n<=0)){switch(t.beginPath(),e){default:t.arc(i,a,n,0,A),t.closePath();break;case"triangle":t.moveTo(i+Math.sin(h)*n,a-Math.cos(h)*n),h+=L,t.lineTo(i+Math.sin(h)*n,a-Math.cos(h)*n),h+=L,t.lineTo(i+Math.sin(h)*n,a-Math.cos(h)*n),t.closePath();break;case"rectRounded":u=n-(d=.516*n),s=Math.cos(h+I)*u,l=Math.sin(h+I)*u,t.arc(i-s,a-l,d,h-T,h-F),t.arc(i+l,a-s,d,h-F,h),t.arc(i+s,a+l,d,h,h+F),t.arc(i-l,a+s,d,h+F,h+T),t.closePath();break;case"rect":if(!r){u=Math.SQRT1_2*n,t.rect(i-u,a-u,2*u,2*u);break}h+=I;case"rectRot":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+l,a-s),t.lineTo(i+s,a+l),t.lineTo(i-l,a+s),t.closePath();break;case"crossRot":h+=I;case"cross":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l),t.moveTo(i+l,a-s),t.lineTo(i-l,a+s);break;case"star":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l),t.moveTo(i+l,a-s),t.lineTo(i-l,a+s),h+=I,s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l),t.moveTo(i+l,a-s),t.lineTo(i-l,a+s);break;case"line":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l);break;case"dash":t.moveTo(i,a),t.lineTo(i+Math.cos(h)*n,a+Math.sin(h)*n)}t.fill(),t.stroke()}},_isPointInArea:function(t,e){return t.x>e.left-1e-6&&t.x<e.right+1e-6&&t.y>e.top-1e-6&&t.y<e.bottom+1e-6},clipArea:function(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()},unclipArea:function(t){t.restore()},lineTo:function(t,e,n,i){var a=n.steppedLine;if(a){if("middle"===a){var r=(e.x+n.x)/2;t.lineTo(r,i?n.y:e.y),t.lineTo(r,i?e.y:n.y)}else"after"===a&&!i||"after"!==a&&i?t.lineTo(e.x,n.y):t.lineTo(n.x,e.y);t.lineTo(n.x,n.y)}else n.tension?t.bezierCurveTo(i?e.controlPointPreviousX:e.controlPointNextX,i?e.controlPointPreviousY:e.controlPointNextY,i?n.controlPointNextX:n.controlPointPreviousX,i?n.controlPointNextY:n.controlPointPreviousY,n.x,n.y):t.lineTo(n.x,n.y)}},N=R;D.clear=R.clear,D.drawRoundedRectangle=function(t){t.beginPath(),R.roundedRect.apply(R,arguments)};var W={_set:function(t,e){return D.merge(this[t]||(this[t]={}),e)}};W._set("global",{defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",defaultLineHeight:1.2,showLines:!0});var Y=W,z=D.valueOrDefault;var E={toLineHeight:function(t,e){var n=(""+t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);if(!n||"normal"===n[1])return 1.2*e;switch(t=+n[2],n[3]){case"px":return t;case"%":t/=100}return e*t},toPadding:function(t){var e,n,i,a;return D.isObject(t)?(e=+t.top||0,n=+t.right||0,i=+t.bottom||0,a=+t.left||0):e=n=i=a=+t||0,{top:e,right:n,bottom:i,left:a,height:e+i,width:a+n}},_parseFont:function(t){var e=Y.global,n=z(t.fontSize,e.defaultFontSize),i={family:z(t.fontFamily,e.defaultFontFamily),lineHeight:D.options.toLineHeight(z(t.lineHeight,e.defaultLineHeight),n),size:n,style:z(t.fontStyle,e.defaultFontStyle),weight:null,string:""};return i.string=function(t){return!t||D.isNullOrUndef(t.size)||D.isNullOrUndef(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}(i),i},resolve:function(t,e,n,i){var a,r,o,s=!0;for(a=0,r=t.length;a<r;++a)if(void 0!==(o=t[a])&&(void 0!==e&&"function"==typeof o&&(o=o(e),s=!1),void 0!==n&&D.isArray(o)&&(o=o[n],s=!1),void 0!==o))return i&&!s&&(i.cacheable=!1),o}},V={_factorize:function(t){var e,n=[],i=Math.sqrt(t);for(e=1;e<i;e++)t%e==0&&(n.push(e),n.push(t/e));return i===(0|i)&&n.push(i),n.sort((function(t,e){return t-e})).pop(),n},log10:Math.log10||function(t){var e=Math.log(t)*Math.LOG10E,n=Math.round(e);return t===Math.pow(10,n)?n:e}},H=V;D.log10=V.log10;var B=D,j=P,U=N,G=E,q=H,Z={getRtlAdapter:function(t,e,n){return t?function(t,e){return{x:function(n){return t+t+e-n},setWidth:function(t){e=t},textAlign:function(t){return"center"===t?t:"right"===t?"left":"right"},xPlus:function(t,e){return t-e},leftForLtr:function(t,e){return t-e}}}(e,n):{x:function(t){return t},setWidth:function(t){},textAlign:function(t){return t},xPlus:function(t,e){return t+e},leftForLtr:function(t,e){return t}}},overrideTextDirection:function(t,e){var n,i;"ltr"!==e&&"rtl"!==e||(i=[(n=t.canvas.style).getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",e,"important"),t.prevTextDirection=i)},restoreTextDirection:function(t){var e=t.prevTextDirection;void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}};B.easing=j,B.canvas=U,B.options=G,B.math=q,B.rtl=Z;var $=function(t){B.extend(this,t),this.initialize.apply(this,arguments)};B.extend($.prototype,{_type:void 0,initialize:function(){this.hidden=!1},pivot:function(){var t=this;return t._view||(t._view=B.extend({},t._model)),t._start={},t},transition:function(t){var e=this,n=e._model,i=e._start,a=e._view;return n&&1!==t?(a||(a=e._view={}),i||(i=e._start={}),function(t,e,n,i){var a,r,o,s,l,u,d,h,c,f=Object.keys(n);for(a=0,r=f.length;a<r;++a)if(u=n[o=f[a]],e.hasOwnProperty(o)||(e[o]=u),(s=e[o])!==u&&"_"!==o[0]){if(t.hasOwnProperty(o)||(t[o]=s),(d=typeof u)===typeof(l=t[o]))if("string"===d){if((h=w(l)).valid&&(c=w(u)).valid){e[o]=c.mix(h,i).rgbString();continue}}else if(B.isFinite(l)&&B.isFinite(u)){e[o]=l+(u-l)*i;continue}e[o]=u}}(i,a,n,t),e):(e._view=B.extend({},n),e._start=null,e)},tooltipPosition:function(){return{x:this._model.x,y:this._model.y}},hasValue:function(){return B.isNumber(this._model.x)&&B.isNumber(this._model.y)}}),$.extend=B.inherits;var X=$,K=X.extend({chart:null,currentStep:0,numSteps:60,easing:"",render:null,onAnimationProgress:null,onAnimationComplete:null}),J=K;Object.defineProperty(K.prototype,"animationObject",{get:function(){return this}}),Object.defineProperty(K.prototype,"chartInstance",{get:function(){return this.chart},set:function(t){this.chart=t}}),Y._set("global",{animation:{duration:1e3,easing:"easeOutQuart",onProgress:B.noop,onComplete:B.noop}});var Q={animations:[],request:null,addAnimation:function(t,e,n,i){var a,r,o=this.animations;for(e.chart=t,e.startTime=Date.now(),e.duration=n,i||(t.animating=!0),a=0,r=o.length;a<r;++a)if(o[a].chart===t)return void(o[a]=e);o.push(e),1===o.length&&this.requestAnimationFrame()},cancelAnimation:function(t){var e=B.findIndex(this.animations,(function(e){return e.chart===t}));-1!==e&&(this.animations.splice(e,1),t.animating=!1)},requestAnimationFrame:function(){var t=this;null===t.request&&(t.request=B.requestAnimFrame.call(window,(function(){t.request=null,t.startDigest()})))},startDigest:function(){this.advance(),this.animations.length>0&&this.requestAnimationFrame()},advance:function(){for(var t,e,n,i,a=this.animations,r=0;r<a.length;)e=(t=a[r]).chart,n=t.numSteps,i=Math.floor((Date.now()-t.startTime)/t.duration*n)+1,t.currentStep=Math.min(i,n),B.callback(t.render,[e,t],e),B.callback(t.onAnimationProgress,[t],e),t.currentStep>=n?(B.callback(t.onAnimationComplete,[t],e),e.animating=!1,a.splice(r,1)):++r}},tt=B.options.resolve,et=["push","pop","shift","splice","unshift"];function nt(t,e){var n=t._chartjs;if(n){var i=n.listeners,a=i.indexOf(e);-1!==a&&i.splice(a,1),i.length>0||(et.forEach((function(e){delete t[e]})),delete t._chartjs)}}var it=function(t,e){this.initialize(t,e)};B.extend(it.prototype,{datasetElementType:null,dataElementType:null,_datasetElementOptions:["backgroundColor","borderCapStyle","borderColor","borderDash","borderDashOffset","borderJoinStyle","borderWidth"],_dataElementOptions:["backgroundColor","borderColor","borderWidth","pointStyle"],initialize:function(t,e){var n=this;n.chart=t,n.index=e,n.linkScales(),n.addElements(),n._type=n.getMeta().type},updateIndex:function(t){this.index=t},linkScales:function(){var t=this.getMeta(),e=this.chart,n=e.scales,i=this.getDataset(),a=e.options.scales;null!==t.xAxisID&&t.xAxisID in n&&!i.xAxisID||(t.xAxisID=i.xAxisID||a.xAxes[0].id),null!==t.yAxisID&&t.yAxisID in n&&!i.yAxisID||(t.yAxisID=i.yAxisID||a.yAxes[0].id)},getDataset:function(){return this.chart.data.datasets[this.index]},getMeta:function(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function(t){return this.chart.scales[t]},_getValueScaleId:function(){return this.getMeta().yAxisID},_getIndexScaleId:function(){return this.getMeta().xAxisID},_getValueScale:function(){return this.getScaleForId(this._getValueScaleId())},_getIndexScale:function(){return this.getScaleForId(this._getIndexScaleId())},reset:function(){this._update(!0)},destroy:function(){this._data&&nt(this._data,this)},createMetaDataset:function(){var t=this.datasetElementType;return t&&new t({_chart:this.chart,_datasetIndex:this.index})},createMetaData:function(t){var e=this.dataElementType;return e&&new e({_chart:this.chart,_datasetIndex:this.index,_index:t})},addElements:function(){var t,e,n=this.getMeta(),i=this.getDataset().data||[],a=n.data;for(t=0,e=i.length;t<e;++t)a[t]=a[t]||this.createMetaData(t);n.dataset=n.dataset||this.createMetaDataset()},addElementAndReset:function(t){var e=this.createMetaData(t);this.getMeta().data.splice(t,0,e),this.updateElement(e,t,!0)},buildOrUpdateElements:function(){var t,e,n=this,i=n.getDataset(),a=i.data||(i.data=[]);n._data!==a&&(n._data&&nt(n._data,n),a&&Object.isExtensible(a)&&(e=n,(t=a)._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),et.forEach((function(e){var n="onData"+e.charAt(0).toUpperCase()+e.slice(1),i=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:function(){var e=Array.prototype.slice.call(arguments),a=i.apply(this,e);return B.each(t._chartjs.listeners,(function(t){"function"==typeof t[n]&&t[n].apply(t,e)})),a}})})))),n._data=a),n.resyncElements()},_configure:function(){this._config=B.merge(Object.create(null),[this.chart.options.datasets[this._type],this.getDataset()],{merger:function(t,e,n){"_meta"!==t&&"data"!==t&&B._merger(t,e,n)}})},_update:function(t){this._configure(),this._cachedDataOpts=null,this.update(t)},update:B.noop,transition:function(t){for(var e=this.getMeta(),n=e.data||[],i=n.length,a=0;a<i;++a)n[a].transition(t);e.dataset&&e.dataset.transition(t)},draw:function(){var t=this.getMeta(),e=t.data||[],n=e.length,i=0;for(t.dataset&&t.dataset.draw();i<n;++i)e[i].draw()},getStyle:function(t){var e,n=this.getMeta(),i=n.dataset;return this._configure(),i&&void 0===t?e=this._resolveDatasetElementOptions(i||{}):(t=t||0,e=this._resolveDataElementOptions(n.data[t]||{},t)),!1!==e.fill&&null!==e.fill||(e.backgroundColor=e.borderColor),e},_resolveDatasetElementOptions:function(t,e){var n,i,a,r,o=this,s=o.chart,l=o._config,u=t.custom||{},d=s.options.elements[o.datasetElementType.prototype._type]||{},h=o._datasetElementOptions,c={},f={chart:s,dataset:o.getDataset(),datasetIndex:o.index,hover:e};for(n=0,i=h.length;n<i;++n)a=h[n],r=e?"hover"+a.charAt(0).toUpperCase()+a.slice(1):a,c[a]=tt([u[r],l[r],d[r]],f);return c},_resolveDataElementOptions:function(t,e){var n=this,i=t&&t.custom,a=n._cachedDataOpts;if(a&&!i)return a;var r,o,s,l,u=n.chart,d=n._config,h=u.options.elements[n.dataElementType.prototype._type]||{},c=n._dataElementOptions,f={},g={chart:u,dataIndex:e,dataset:n.getDataset(),datasetIndex:n.index},m={cacheable:!i};if(i=i||{},B.isArray(c))for(o=0,s=c.length;o<s;++o)f[l=c[o]]=tt([i[l],d[l],h[l]],g,e,m);else for(o=0,s=(r=Object.keys(c)).length;o<s;++o)f[l=r[o]]=tt([i[l],d[c[l]],d[l],h[l]],g,e,m);return m.cacheable&&(n._cachedDataOpts=Object.freeze(f)),f},removeHoverStyle:function(t){B.merge(t._model,t.$previousStyle||{}),delete t.$previousStyle},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],n=t._index,i=t.custom||{},a=t._model,r=B.getHoverColor;t.$previousStyle={backgroundColor:a.backgroundColor,borderColor:a.borderColor,borderWidth:a.borderWidth},a.backgroundColor=tt([i.hoverBackgroundColor,e.hoverBackgroundColor,r(a.backgroundColor)],void 0,n),a.borderColor=tt([i.hoverBorderColor,e.hoverBorderColor,r(a.borderColor)],void 0,n),a.borderWidth=tt([i.hoverBorderWidth,e.hoverBorderWidth,a.borderWidth],void 0,n)},_removeDatasetHoverStyle:function(){var t=this.getMeta().dataset;t&&this.removeHoverStyle(t)},_setDatasetHoverStyle:function(){var t,e,n,i,a,r,o=this.getMeta().dataset,s={};if(o){for(r=o._model,a=this._resolveDatasetElementOptions(o,!0),t=0,e=(i=Object.keys(a)).length;t<e;++t)s[n=i[t]]=r[n],r[n]=a[n];o.$previousStyle=s}},resyncElements:function(){var t=this.getMeta(),e=this.getDataset().data,n=t.data.length,i=e.length;i<n?t.data.splice(i,n-i):i>n&&this.insertElements(n,i-n)},insertElements:function(t,e){for(var n=0;n<e;++n)this.addElementAndReset(t+n)},onDataPush:function(){var t=arguments.length;this.insertElements(this.getDataset().data.length-t,t)},onDataPop:function(){this.getMeta().data.pop()},onDataShift:function(){this.getMeta().data.shift()},onDataSplice:function(t,e){this.getMeta().data.splice(t,e),this.insertElements(t,arguments.length-2)},onDataUnshift:function(){this.insertElements(0,arguments.length)}}),it.extend=B.inherits;var at=it,rt=2*Math.PI;function ot(t,e){var n=e.startAngle,i=e.endAngle,a=e.pixelMargin,r=a/e.outerRadius,o=e.x,s=e.y;t.beginPath(),t.arc(o,s,e.outerRadius,n-r,i+r),e.innerRadius>a?(r=a/e.innerRadius,t.arc(o,s,e.innerRadius-a,i+r,n-r,!0)):t.arc(o,s,a,i+Math.PI/2,n-Math.PI/2),t.closePath(),t.clip()}function st(t,e,n){var i="inner"===e.borderAlign;i?(t.lineWidth=2*e.borderWidth,t.lineJoin="round"):(t.lineWidth=e.borderWidth,t.lineJoin="bevel"),n.fullCircles&&function(t,e,n,i){var a,r=n.endAngle;for(i&&(n.endAngle=n.startAngle+rt,ot(t,n),n.endAngle=r,n.endAngle===n.startAngle&&n.fullCircles&&(n.endAngle+=rt,n.fullCircles--)),t.beginPath(),t.arc(n.x,n.y,n.innerRadius,n.startAngle+rt,n.startAngle,!0),a=0;a<n.fullCircles;++a)t.stroke();for(t.beginPath(),t.arc(n.x,n.y,e.outerRadius,n.startAngle,n.startAngle+rt),a=0;a<n.fullCircles;++a)t.stroke()}(t,e,n,i),i&&ot(t,n),t.beginPath(),t.arc(n.x,n.y,e.outerRadius,n.startAngle,n.endAngle),t.arc(n.x,n.y,n.innerRadius,n.endAngle,n.startAngle,!0),t.closePath(),t.stroke()}Y._set("global",{elements:{arc:{backgroundColor:Y.global.defaultColor,borderColor:"#fff",borderWidth:2,borderAlign:"center"}}});var lt=X.extend({_type:"arc",inLabelRange:function(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hoverRadius,2)},inRange:function(t,e){var n=this._view;if(n){for(var i=B.getAngleFromPoint(n,{x:t,y:e}),a=i.angle,r=i.distance,o=n.startAngle,s=n.endAngle;s<o;)s+=rt;for(;a>s;)a-=rt;for(;a<o;)a+=rt;var l=a>=o&&a<=s,u=r>=n.innerRadius&&r<=n.outerRadius;return l&&u}return!1},getCenterPoint:function(){var t=this._view,e=(t.startAngle+t.endAngle)/2,n=(t.innerRadius+t.outerRadius)/2;return{x:t.x+Math.cos(e)*n,y:t.y+Math.sin(e)*n}},getArea:function(){var t=this._view;return Math.PI*((t.endAngle-t.startAngle)/(2*Math.PI))*(Math.pow(t.outerRadius,2)-Math.pow(t.innerRadius,2))},tooltipPosition:function(){var t=this._view,e=t.startAngle+(t.endAngle-t.startAngle)/2,n=(t.outerRadius-t.innerRadius)/2+t.innerRadius;return{x:t.x+Math.cos(e)*n,y:t.y+Math.sin(e)*n}},draw:function(){var t,e=this._chart.ctx,n=this._view,i="inner"===n.borderAlign?.33:0,a={x:n.x,y:n.y,innerRadius:n.innerRadius,outerRadius:Math.max(n.outerRadius-i,0),pixelMargin:i,startAngle:n.startAngle,endAngle:n.endAngle,fullCircles:Math.floor(n.circumference/rt)};if(e.save(),e.fillStyle=n.backgroundColor,e.strokeStyle=n.borderColor,a.fullCircles){for(a.endAngle=a.startAngle+rt,e.beginPath(),e.arc(a.x,a.y,a.outerRadius,a.startAngle,a.endAngle),e.arc(a.x,a.y,a.innerRadius,a.endAngle,a.startAngle,!0),e.closePath(),t=0;t<a.fullCircles;++t)e.fill();a.endAngle=a.startAngle+n.circumference%rt}e.beginPath(),e.arc(a.x,a.y,a.outerRadius,a.startAngle,a.endAngle),e.arc(a.x,a.y,a.innerRadius,a.endAngle,a.startAngle,!0),e.closePath(),e.fill(),n.borderWidth&&st(e,n,a),e.restore()}}),ut=B.valueOrDefault,dt=Y.global.defaultColor;Y._set("global",{elements:{line:{tension:.4,backgroundColor:dt,borderWidth:3,borderColor:dt,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0}}});var ht=X.extend({_type:"line",draw:function(){var t,e,n,i=this,a=i._view,r=i._chart.ctx,o=a.spanGaps,s=i._children.slice(),l=Y.global,u=l.elements.line,d=-1,h=i._loop;if(s.length){if(i._loop){for(t=0;t<s.length;++t)if(e=B.previousItem(s,t),!s[t]._view.skip&&e._view.skip){s=s.slice(t).concat(s.slice(0,t)),h=o;break}h&&s.push(s[0])}for(r.save(),r.lineCap=a.borderCapStyle||u.borderCapStyle,r.setLineDash&&r.setLineDash(a.borderDash||u.borderDash),r.lineDashOffset=ut(a.borderDashOffset,u.borderDashOffset),r.lineJoin=a.borderJoinStyle||u.borderJoinStyle,r.lineWidth=ut(a.borderWidth,u.borderWidth),r.strokeStyle=a.borderColor||l.defaultColor,r.beginPath(),(n=s[0]._view).skip||(r.moveTo(n.x,n.y),d=0),t=1;t<s.length;++t)n=s[t]._view,e=-1===d?B.previousItem(s,t):s[d],n.skip||(d!==t-1&&!o||-1===d?r.moveTo(n.x,n.y):B.canvas.lineTo(r,e._view,n),d=t);h&&r.closePath(),r.stroke(),r.restore()}}}),ct=B.valueOrDefault,ft=Y.global.defaultColor;function gt(t){var e=this._view;return!!e&&Math.abs(t-e.x)<e.radius+e.hitRadius}Y._set("global",{elements:{point:{radius:3,pointStyle:"circle",backgroundColor:ft,borderColor:ft,borderWidth:1,hitRadius:1,hoverRadius:4,hoverBorderWidth:1}}});var mt=X.extend({_type:"point",inRange:function(t,e){var n=this._view;return!!n&&Math.pow(t-n.x,2)+Math.pow(e-n.y,2)<Math.pow(n.hitRadius+n.radius,2)},inLabelRange:gt,inXRange:gt,inYRange:function(t){var e=this._view;return!!e&&Math.abs(t-e.y)<e.radius+e.hitRadius},getCenterPoint:function(){var t=this._view;return{x:t.x,y:t.y}},getArea:function(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y,padding:t.radius+t.borderWidth}},draw:function(t){var e=this._view,n=this._chart.ctx,i=e.pointStyle,a=e.rotation,r=e.radius,o=e.x,s=e.y,l=Y.global,u=l.defaultColor;e.skip||(void 0===t||B.canvas._isPointInArea(e,t))&&(n.strokeStyle=e.borderColor||u,n.lineWidth=ct(e.borderWidth,l.elements.point.borderWidth),n.fillStyle=e.backgroundColor||u,B.canvas.drawPoint(n,i,r,o,s,a))}}),pt=Y.global.defaultColor;function vt(t){return t&&void 0!==t.width}function bt(t){var e,n,i,a,r;return vt(t)?(r=t.width/2,e=t.x-r,n=t.x+r,i=Math.min(t.y,t.base),a=Math.max(t.y,t.base)):(r=t.height/2,e=Math.min(t.x,t.base),n=Math.max(t.x,t.base),i=t.y-r,a=t.y+r),{left:e,top:i,right:n,bottom:a}}function yt(t,e,n){return t===e?n:t===n?e:t}function xt(t,e,n){var i,a,r,o,s=t.borderWidth,l=function(t){var e=t.borderSkipped,n={};return e?(t.horizontal?t.base>t.x&&(e=yt(e,"left","right")):t.base<t.y&&(e=yt(e,"bottom","top")),n[e]=!0,n):n}(t);return B.isObject(s)?(i=+s.top||0,a=+s.right||0,r=+s.bottom||0,o=+s.left||0):i=a=r=o=+s||0,{t:l.top||i<0?0:i>n?n:i,r:l.right||a<0?0:a>e?e:a,b:l.bottom||r<0?0:r>n?n:r,l:l.left||o<0?0:o>e?e:o}}function _t(t,e,n){var i=null===e,a=null===n,r=!(!t||i&&a)&&bt(t);return r&&(i||e>=r.left&&e<=r.right)&&(a||n>=r.top&&n<=r.bottom)}Y._set("global",{elements:{rectangle:{backgroundColor:pt,borderColor:pt,borderSkipped:"bottom",borderWidth:0}}});var wt=X.extend({_type:"rectangle",draw:function(){var t=this._chart.ctx,e=this._view,n=function(t){var e=bt(t),n=e.right-e.left,i=e.bottom-e.top,a=xt(t,n/2,i/2);return{outer:{x:e.left,y:e.top,w:n,h:i},inner:{x:e.left+a.l,y:e.top+a.t,w:n-a.l-a.r,h:i-a.t-a.b}}}(e),i=n.outer,a=n.inner;t.fillStyle=e.backgroundColor,t.fillRect(i.x,i.y,i.w,i.h),i.w===a.w&&i.h===a.h||(t.save(),t.beginPath(),t.rect(i.x,i.y,i.w,i.h),t.clip(),t.fillStyle=e.borderColor,t.rect(a.x,a.y,a.w,a.h),t.fill("evenodd"),t.restore())},height:function(){var t=this._view;return t.base-t.y},inRange:function(t,e){return _t(this._view,t,e)},inLabelRange:function(t,e){var n=this._view;return vt(n)?_t(n,t,null):_t(n,null,e)},inXRange:function(t){return _t(this._view,t,null)},inYRange:function(t){return _t(this._view,null,t)},getCenterPoint:function(){var t,e,n=this._view;return vt(n)?(t=n.x,e=(n.y+n.base)/2):(t=(n.x+n.base)/2,e=n.y),{x:t,y:e}},getArea:function(){var t=this._view;return vt(t)?t.width*Math.abs(t.y-t.base):t.height*Math.abs(t.x-t.base)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y}}}),kt={},Mt=lt,St=ht,Dt=mt,Ct=wt;kt.Arc=Mt,kt.Line=St,kt.Point=Dt,kt.Rectangle=Ct;var Pt=B._deprecated,Tt=B.valueOrDefault;function Ot(t,e,n){var i,a,r=n.barThickness,o=e.stackCount,s=e.pixels[t],l=B.isNullOrUndef(r)?function(t,e){var n,i,a,r,o=t._length;for(a=1,r=e.length;a<r;++a)o=Math.min(o,Math.abs(e[a]-e[a-1]));for(a=0,r=t.getTicks().length;a<r;++a)i=t.getPixelForTick(a),o=a>0?Math.min(o,Math.abs(i-n)):o,n=i;return o}(e.scale,e.pixels):-1;return B.isNullOrUndef(r)?(i=l*n.categoryPercentage,a=n.barPercentage):(i=r*o,a=1),{chunk:i/o,ratio:a,start:s-i/2}}Y._set("bar",{hover:{mode:"label"},scales:{xAxes:[{type:"category",offset:!0,gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}}),Y._set("global",{datasets:{bar:{categoryPercentage:.8,barPercentage:.9}}});var At=at.extend({dataElementType:kt.Rectangle,_dataElementOptions:["backgroundColor","borderColor","borderSkipped","borderWidth","barPercentage","barThickness","categoryPercentage","maxBarThickness","minBarLength"],initialize:function(){var t,e,n=this;at.prototype.initialize.apply(n,arguments),(t=n.getMeta()).stack=n.getDataset().stack,t.bar=!0,e=n._getIndexScale().options,Pt("bar chart",e.barPercentage,"scales.[x/y]Axes.barPercentage","dataset.barPercentage"),Pt("bar chart",e.barThickness,"scales.[x/y]Axes.barThickness","dataset.barThickness"),Pt("bar chart",e.categoryPercentage,"scales.[x/y]Axes.categoryPercentage","dataset.categoryPercentage"),Pt("bar chart",n._getValueScale().options.minBarLength,"scales.[x/y]Axes.minBarLength","dataset.minBarLength"),Pt("bar chart",e.maxBarThickness,"scales.[x/y]Axes.maxBarThickness","dataset.maxBarThickness")},update:function(t){var e,n,i=this.getMeta().data;for(this._ruler=this.getRuler(),e=0,n=i.length;e<n;++e)this.updateElement(i[e],e,t)},updateElement:function(t,e,n){var i=this,a=i.getMeta(),r=i.getDataset(),o=i._resolveDataElementOptions(t,e);t._xScale=i.getScaleForId(a.xAxisID),t._yScale=i.getScaleForId(a.yAxisID),t._datasetIndex=i.index,t._index=e,t._model={backgroundColor:o.backgroundColor,borderColor:o.borderColor,borderSkipped:o.borderSkipped,borderWidth:o.borderWidth,datasetLabel:r.label,label:i.chart.data.labels[e]},B.isArray(r.data[e])&&(t._model.borderSkipped=null),i._updateElementGeometry(t,e,n,o),t.pivot()},_updateElementGeometry:function(t,e,n,i){var a=this,r=t._model,o=a._getValueScale(),s=o.getBasePixel(),l=o.isHorizontal(),u=a._ruler||a.getRuler(),d=a.calculateBarValuePixels(a.index,e,i),h=a.calculateBarIndexPixels(a.index,e,u,i);r.horizontal=l,r.base=n?s:d.base,r.x=l?n?s:d.head:h.center,r.y=l?h.center:n?s:d.head,r.height=l?h.size:void 0,r.width=l?void 0:h.size},_getStacks:function(t){var e,n,i=this._getIndexScale(),a=i._getMatchingVisibleMetas(this._type),r=i.options.stacked,o=a.length,s=[];for(e=0;e<o&&(n=a[e],(!1===r||-1===s.indexOf(n.stack)||void 0===r&&void 0===n.stack)&&s.push(n.stack),n.index!==t);++e);return s},getStackCount:function(){return this._getStacks().length},getStackIndex:function(t,e){var n=this._getStacks(t),i=void 0!==e?n.indexOf(e):-1;return-1===i?n.length-1:i},getRuler:function(){var t,e,n=this._getIndexScale(),i=[];for(t=0,e=this.getMeta().data.length;t<e;++t)i.push(n.getPixelForValue(null,t,this.index));return{pixels:i,start:n._startPixel,end:n._endPixel,stackCount:this.getStackCount(),scale:n}},calculateBarValuePixels:function(t,e,n){var i,a,r,o,s,l,u,d=this.chart,h=this._getValueScale(),c=h.isHorizontal(),f=d.data.datasets,g=h._getMatchingVisibleMetas(this._type),m=h._parseValue(f[t].data[e]),p=n.minBarLength,v=h.options.stacked,b=this.getMeta().stack,y=void 0===m.start?0:m.max>=0&&m.min>=0?m.min:m.max,x=void 0===m.start?m.end:m.max>=0&&m.min>=0?m.max-m.min:m.min-m.max,_=g.length;if(v||void 0===v&&void 0!==b)for(i=0;i<_&&(a=g[i]).index!==t;++i)a.stack===b&&(r=void 0===(u=h._parseValue(f[a.index].data[e])).start?u.end:u.min>=0&&u.max>=0?u.max:u.min,(m.min<0&&r<0||m.max>=0&&r>0)&&(y+=r));return o=h.getPixelForValue(y),l=(s=h.getPixelForValue(y+x))-o,void 0!==p&&Math.abs(l)<p&&(l=p,s=x>=0&&!c||x<0&&c?o-p:o+p),{size:l,base:o,head:s,center:s+l/2}},calculateBarIndexPixels:function(t,e,n,i){var a="flex"===i.barThickness?function(t,e,n){var i,a=e.pixels,r=a[t],o=t>0?a[t-1]:null,s=t<a.length-1?a[t+1]:null,l=n.categoryPercentage;return null===o&&(o=r-(null===s?e.end-e.start:s-r)),null===s&&(s=r+r-o),i=r-(r-Math.min(o,s))/2*l,{chunk:Math.abs(s-o)/2*l/e.stackCount,ratio:n.barPercentage,start:i}}(e,n,i):Ot(e,n,i),r=this.getStackIndex(t,this.getMeta().stack),o=a.start+a.chunk*r+a.chunk/2,s=Math.min(Tt(i.maxBarThickness,1/0),a.chunk*a.ratio);return{base:o-s/2,head:o+s/2,center:o,size:s}},draw:function(){var t=this.chart,e=this._getValueScale(),n=this.getMeta().data,i=this.getDataset(),a=n.length,r=0;for(B.canvas.clipArea(t.ctx,t.chartArea);r<a;++r){var o=e._parseValue(i.data[r]);isNaN(o.min)||isNaN(o.max)||n[r].draw()}B.canvas.unclipArea(t.ctx)},_resolveDataElementOptions:function(){var t=this,e=B.extend({},at.prototype._resolveDataElementOptions.apply(t,arguments)),n=t._getIndexScale().options,i=t._getValueScale().options;return e.barPercentage=Tt(n.barPercentage,e.barPercentage),e.barThickness=Tt(n.barThickness,e.barThickness),e.categoryPercentage=Tt(n.categoryPercentage,e.categoryPercentage),e.maxBarThickness=Tt(n.maxBarThickness,e.maxBarThickness),e.minBarLength=Tt(i.minBarLength,e.minBarLength),e}}),Ft=B.valueOrDefault,It=B.options.resolve;Y._set("bubble",{hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function(){return""},label:function(t,e){var n=e.datasets[t.datasetIndex].label||"",i=e.datasets[t.datasetIndex].data[t.index];return n+": ("+t.xLabel+", "+t.yLabel+", "+i.r+")"}}}});var Lt=at.extend({dataElementType:kt.Point,_dataElementOptions:["backgroundColor","borderColor","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","pointStyle","rotation"],update:function(t){var e=this,n=e.getMeta().data;B.each(n,(function(n,i){e.updateElement(n,i,t)}))},updateElement:function(t,e,n){var i=this,a=i.getMeta(),r=t.custom||{},o=i.getScaleForId(a.xAxisID),s=i.getScaleForId(a.yAxisID),l=i._resolveDataElementOptions(t,e),u=i.getDataset().data[e],d=i.index,h=n?o.getPixelForDecimal(.5):o.getPixelForValue("object"==typeof u?u:NaN,e,d),c=n?s.getBasePixel():s.getPixelForValue(u,e,d);t._xScale=o,t._yScale=s,t._options=l,t._datasetIndex=d,t._index=e,t._model={backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,hitRadius:l.hitRadius,pointStyle:l.pointStyle,rotation:l.rotation,radius:n?0:l.radius,skip:r.skip||isNaN(h)||isNaN(c),x:h,y:c},t.pivot()},setHoverStyle:function(t){var e=t._model,n=t._options,i=B.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Ft(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Ft(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Ft(n.hoverBorderWidth,n.borderWidth),e.radius=n.radius+n.hoverRadius},_resolveDataElementOptions:function(t,e){var n=this,i=n.chart,a=n.getDataset(),r=t.custom||{},o=a.data[e]||{},s=at.prototype._resolveDataElementOptions.apply(n,arguments),l={chart:i,dataIndex:e,dataset:a,datasetIndex:n.index};return n._cachedDataOpts===s&&(s=B.extend({},s)),s.radius=It([r.radius,o.r,n._config.radius,i.options.elements.point.radius],l,e),s}}),Rt=B.valueOrDefault,Nt=Math.PI,Wt=2*Nt,Yt=Nt/2;Y._set("doughnut",{animation:{animateRotate:!0,animateScale:!1},hover:{mode:"single"},legendCallback:function(t){var e,n,i,a=document.createElement("ul"),r=t.data,o=r.datasets,s=r.labels;if(a.setAttribute("class",t.id+"-legend"),o.length)for(e=0,n=o[0].data.length;e<n;++e)(i=a.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor=o[0].backgroundColor[e],s[e]&&i.appendChild(document.createTextNode(s[e]));return a.outerHTML},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map((function(n,i){var a=t.getDatasetMeta(0),r=a.controller.getStyle(i);return{text:n,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,lineWidth:r.borderWidth,hidden:isNaN(e.datasets[0].data[i])||a.data[i].hidden,index:i}})):[]}},onClick:function(t,e){var n,i,a,r=e.index,o=this.chart;for(n=0,i=(o.data.datasets||[]).length;n<i;++n)(a=o.getDatasetMeta(n)).data[r]&&(a.data[r].hidden=!a.data[r].hidden);o.update()}},cutoutPercentage:50,rotation:-Yt,circumference:Wt,tooltips:{callbacks:{title:function(){return""},label:function(t,e){var n=e.labels[t.index],i=": "+e.datasets[t.datasetIndex].data[t.index];return B.isArray(n)?(n=n.slice())[0]+=i:n+=i,n}}}});var zt=at.extend({dataElementType:kt.Arc,linkScales:B.noop,_dataElementOptions:["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"],getRingIndex:function(t){for(var e=0,n=0;n<t;++n)this.chart.isDatasetVisible(n)&&++e;return e},update:function(t){var e,n,i,a,r=this,o=r.chart,s=o.chartArea,l=o.options,u=1,d=1,h=0,c=0,f=r.getMeta(),g=f.data,m=l.cutoutPercentage/100||0,p=l.circumference,v=r._getRingWeight(r.index);if(p<Wt){var b=l.rotation%Wt,y=(b+=b>=Nt?-Wt:b<-Nt?Wt:0)+p,x=Math.cos(b),_=Math.sin(b),w=Math.cos(y),k=Math.sin(y),M=b<=0&&y>=0||y>=Wt,S=b<=Yt&&y>=Yt||y>=Wt+Yt,D=b<=-Yt&&y>=-Yt||y>=Nt+Yt,C=b===-Nt||y>=Nt?-1:Math.min(x,x*m,w,w*m),P=D?-1:Math.min(_,_*m,k,k*m),T=M?1:Math.max(x,x*m,w,w*m),O=S?1:Math.max(_,_*m,k,k*m);u=(T-C)/2,d=(O-P)/2,h=-(T+C)/2,c=-(O+P)/2}for(i=0,a=g.length;i<a;++i)g[i]._options=r._resolveDataElementOptions(g[i],i);for(o.borderWidth=r.getMaxBorderWidth(),e=(s.right-s.left-o.borderWidth)/u,n=(s.bottom-s.top-o.borderWidth)/d,o.outerRadius=Math.max(Math.min(e,n)/2,0),o.innerRadius=Math.max(o.outerRadius*m,0),o.radiusLength=(o.outerRadius-o.innerRadius)/(r._getVisibleDatasetWeightTotal()||1),o.offsetX=h*o.outerRadius,o.offsetY=c*o.outerRadius,f.total=r.calculateTotal(),r.outerRadius=o.outerRadius-o.radiusLength*r._getRingWeightOffset(r.index),r.innerRadius=Math.max(r.outerRadius-o.radiusLength*v,0),i=0,a=g.length;i<a;++i)r.updateElement(g[i],i,t)},updateElement:function(t,e,n){var i=this,a=i.chart,r=a.chartArea,o=a.options,s=o.animation,l=(r.left+r.right)/2,u=(r.top+r.bottom)/2,d=o.rotation,h=o.rotation,c=i.getDataset(),f=n&&s.animateRotate?0:t.hidden?0:i.calculateCircumference(c.data[e])*(o.circumference/Wt),g=n&&s.animateScale?0:i.innerRadius,m=n&&s.animateScale?0:i.outerRadius,p=t._options||{};B.extend(t,{_datasetIndex:i.index,_index:e,_model:{backgroundColor:p.backgroundColor,borderColor:p.borderColor,borderWidth:p.borderWidth,borderAlign:p.borderAlign,x:l+a.offsetX,y:u+a.offsetY,startAngle:d,endAngle:h,circumference:f,outerRadius:m,innerRadius:g,label:B.valueAtIndexOrDefault(c.label,e,a.data.labels[e])}});var v=t._model;n&&s.animateRotate||(v.startAngle=0===e?o.rotation:i.getMeta().data[e-1]._model.endAngle,v.endAngle=v.startAngle+v.circumference),t.pivot()},calculateTotal:function(){var t,e=this.getDataset(),n=this.getMeta(),i=0;return B.each(n.data,(function(n,a){t=e.data[a],isNaN(t)||n.hidden||(i+=Math.abs(t))})),i},calculateCircumference:function(t){var e=this.getMeta().total;return e>0&&!isNaN(t)?Wt*(Math.abs(t)/e):0},getMaxBorderWidth:function(t){var e,n,i,a,r,o,s,l,u=0,d=this.chart;if(!t)for(e=0,n=d.data.datasets.length;e<n;++e)if(d.isDatasetVisible(e)){t=(i=d.getDatasetMeta(e)).data,e!==this.index&&(r=i.controller);break}if(!t)return 0;for(e=0,n=t.length;e<n;++e)a=t[e],r?(r._configure(),o=r._resolveDataElementOptions(a,e)):o=a._options,"inner"!==o.borderAlign&&(s=o.borderWidth,u=(l=o.hoverBorderWidth)>(u=s>u?s:u)?l:u);return u},setHoverStyle:function(t){var e=t._model,n=t._options,i=B.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=Rt(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Rt(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Rt(n.hoverBorderWidth,n.borderWidth)},_getRingWeightOffset:function(t){for(var e=0,n=0;n<t;++n)this.chart.isDatasetVisible(n)&&(e+=this._getRingWeight(n));return e},_getRingWeight:function(t){return Math.max(Rt(this.chart.data.datasets[t].weight,1),0)},_getVisibleDatasetWeightTotal:function(){return this._getRingWeightOffset(this.chart.data.datasets.length)}});Y._set("horizontalBar",{hover:{mode:"index",axis:"y"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{type:"category",position:"left",offset:!0,gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{mode:"index",axis:"y"}}),Y._set("global",{datasets:{horizontalBar:{categoryPercentage:.8,barPercentage:.9}}});var Et=At.extend({_getValueScaleId:function(){return this.getMeta().xAxisID},_getIndexScaleId:function(){return this.getMeta().yAxisID}}),Vt=B.valueOrDefault,Ht=B.options.resolve,Bt=B.canvas._isPointInArea;function jt(t,e){var n=t&&t.options.ticks||{},i=n.reverse,a=void 0===n.min?e:0,r=void 0===n.max?e:0;return{start:i?r:a,end:i?a:r}}function Ut(t,e,n){var i=n/2,a=jt(t,i),r=jt(e,i);return{top:r.end,right:a.end,bottom:r.start,left:a.start}}function Gt(t){var e,n,i,a;return B.isObject(t)?(e=t.top,n=t.right,i=t.bottom,a=t.left):e=n=i=a=t,{top:e,right:n,bottom:i,left:a}}Y._set("line",{showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}});var qt=at.extend({datasetElementType:kt.Line,dataElementType:kt.Point,_datasetElementOptions:["backgroundColor","borderCapStyle","borderColor","borderDash","borderDashOffset","borderJoinStyle","borderWidth","cubicInterpolationMode","fill"],_dataElementOptions:{backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},update:function(t){var e,n,i=this,a=i.getMeta(),r=a.dataset,o=a.data||[],s=i.chart.options,l=i._config,u=i._showLine=Vt(l.showLine,s.showLines);for(i._xScale=i.getScaleForId(a.xAxisID),i._yScale=i.getScaleForId(a.yAxisID),u&&(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),r._scale=i._yScale,r._datasetIndex=i.index,r._children=o,r._model=i._resolveDatasetElementOptions(r),r.pivot()),e=0,n=o.length;e<n;++e)i.updateElement(o[e],e,t);for(u&&0!==r._model.tension&&i.updateBezierControlPoints(),e=0,n=o.length;e<n;++e)o[e].pivot()},updateElement:function(t,e,n){var i,a,r=this,o=r.getMeta(),s=t.custom||{},l=r.getDataset(),u=r.index,d=l.data[e],h=r._xScale,c=r._yScale,f=o.dataset._model,g=r._resolveDataElementOptions(t,e);i=h.getPixelForValue("object"==typeof d?d:NaN,e,u),a=n?c.getBasePixel():r.calculatePointY(d,e,u),t._xScale=h,t._yScale=c,t._options=g,t._datasetIndex=u,t._index=e,t._model={x:i,y:a,skip:s.skip||isNaN(i)||isNaN(a),radius:g.radius,pointStyle:g.pointStyle,rotation:g.rotation,backgroundColor:g.backgroundColor,borderColor:g.borderColor,borderWidth:g.borderWidth,tension:Vt(s.tension,f?f.tension:0),steppedLine:!!f&&f.steppedLine,hitRadius:g.hitRadius}},_resolveDatasetElementOptions:function(t){var e=this,n=e._config,i=t.custom||{},a=e.chart.options,r=a.elements.line,o=at.prototype._resolveDatasetElementOptions.apply(e,arguments);return o.spanGaps=Vt(n.spanGaps,a.spanGaps),o.tension=Vt(n.lineTension,r.tension),o.steppedLine=Ht([i.steppedLine,n.steppedLine,r.stepped]),o.clip=Gt(Vt(n.clip,Ut(e._xScale,e._yScale,o.borderWidth))),o},calculatePointY:function(t,e,n){var i,a,r,o,s,l,u,d=this.chart,h=this._yScale,c=0,f=0;if(h.options.stacked){for(s=+h.getRightValue(t),u=(l=d._getSortedVisibleDatasetMetas()).length,i=0;i<u&&(r=l[i]).index!==n;++i)a=d.data.datasets[r.index],"line"===r.type&&r.yAxisID===h.id&&((o=+h.getRightValue(a.data[e]))<0?f+=o||0:c+=o||0);return s<0?h.getPixelForValue(f+s):h.getPixelForValue(c+s)}return h.getPixelForValue(t)},updateBezierControlPoints:function(){var t,e,n,i,a=this.chart,r=this.getMeta(),o=r.dataset._model,s=a.chartArea,l=r.data||[];function u(t,e,n){return Math.max(Math.min(t,n),e)}if(o.spanGaps&&(l=l.filter((function(t){return!t._model.skip}))),"monotone"===o.cubicInterpolationMode)B.splineCurveMonotone(l);else for(t=0,e=l.length;t<e;++t)n=l[t]._model,i=B.splineCurve(B.previousItem(l,t)._model,n,B.nextItem(l,t)._model,o.tension),n.controlPointPreviousX=i.previous.x,n.controlPointPreviousY=i.previous.y,n.controlPointNextX=i.next.x,n.controlPointNextY=i.next.y;if(a.options.elements.line.capBezierPoints)for(t=0,e=l.length;t<e;++t)n=l[t]._model,Bt(n,s)&&(t>0&&Bt(l[t-1]._model,s)&&(n.controlPointPreviousX=u(n.controlPointPreviousX,s.left,s.right),n.controlPointPreviousY=u(n.controlPointPreviousY,s.top,s.bottom)),t<l.length-1&&Bt(l[t+1]._model,s)&&(n.controlPointNextX=u(n.controlPointNextX,s.left,s.right),n.controlPointNextY=u(n.controlPointNextY,s.top,s.bottom)))},draw:function(){var t,e=this.chart,n=this.getMeta(),i=n.data||[],a=e.chartArea,r=e.canvas,o=0,s=i.length;for(this._showLine&&(t=n.dataset._model.clip,B.canvas.clipArea(e.ctx,{left:!1===t.left?0:a.left-t.left,right:!1===t.right?r.width:a.right+t.right,top:!1===t.top?0:a.top-t.top,bottom:!1===t.bottom?r.height:a.bottom+t.bottom}),n.dataset.draw(),B.canvas.unclipArea(e.ctx));o<s;++o)i[o].draw(a)},setHoverStyle:function(t){var e=t._model,n=t._options,i=B.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Vt(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Vt(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Vt(n.hoverBorderWidth,n.borderWidth),e.radius=Vt(n.hoverRadius,n.radius)}}),Zt=B.options.resolve;Y._set("polarArea",{scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,legendCallback:function(t){var e,n,i,a=document.createElement("ul"),r=t.data,o=r.datasets,s=r.labels;if(a.setAttribute("class",t.id+"-legend"),o.length)for(e=0,n=o[0].data.length;e<n;++e)(i=a.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor=o[0].backgroundColor[e],s[e]&&i.appendChild(document.createTextNode(s[e]));return a.outerHTML},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map((function(n,i){var a=t.getDatasetMeta(0),r=a.controller.getStyle(i);return{text:n,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,lineWidth:r.borderWidth,hidden:isNaN(e.datasets[0].data[i])||a.data[i].hidden,index:i}})):[]}},onClick:function(t,e){var n,i,a,r=e.index,o=this.chart;for(n=0,i=(o.data.datasets||[]).length;n<i;++n)(a=o.getDatasetMeta(n)).data[r].hidden=!a.data[r].hidden;o.update()}},tooltips:{callbacks:{title:function(){return""},label:function(t,e){return e.labels[t.index]+": "+t.yLabel}}}});var $t=at.extend({dataElementType:kt.Arc,linkScales:B.noop,_dataElementOptions:["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"],_getIndexScaleId:function(){return this.chart.scale.id},_getValueScaleId:function(){return this.chart.scale.id},update:function(t){var e,n,i,a=this,r=a.getDataset(),o=a.getMeta(),s=a.chart.options.startAngle||0,l=a._starts=[],u=a._angles=[],d=o.data;for(a._updateRadius(),o.count=a.countVisibleElements(),e=0,n=r.data.length;e<n;e++)l[e]=s,i=a._computeAngle(e),u[e]=i,s+=i;for(e=0,n=d.length;e<n;++e)d[e]._options=a._resolveDataElementOptions(d[e],e),a.updateElement(d[e],e,t)},_updateRadius:function(){var t=this,e=t.chart,n=e.chartArea,i=e.options,a=Math.min(n.right-n.left,n.bottom-n.top);e.outerRadius=Math.max(a/2,0),e.innerRadius=Math.max(i.cutoutPercentage?e.outerRadius/100*i.cutoutPercentage:1,0),e.radiusLength=(e.outerRadius-e.innerRadius)/e.getVisibleDatasetCount(),t.outerRadius=e.outerRadius-e.radiusLength*t.index,t.innerRadius=t.outerRadius-e.radiusLength},updateElement:function(t,e,n){var i=this,a=i.chart,r=i.getDataset(),o=a.options,s=o.animation,l=a.scale,u=a.data.labels,d=l.xCenter,h=l.yCenter,c=o.startAngle,f=t.hidden?0:l.getDistanceFromCenterForValue(r.data[e]),g=i._starts[e],m=g+(t.hidden?0:i._angles[e]),p=s.animateScale?0:l.getDistanceFromCenterForValue(r.data[e]),v=t._options||{};B.extend(t,{_datasetIndex:i.index,_index:e,_scale:l,_model:{backgroundColor:v.backgroundColor,borderColor:v.borderColor,borderWidth:v.borderWidth,borderAlign:v.borderAlign,x:d,y:h,innerRadius:0,outerRadius:n?p:f,startAngle:n&&s.animateRotate?c:g,endAngle:n&&s.animateRotate?c:m,label:B.valueAtIndexOrDefault(u,e,u[e])}}),t.pivot()},countVisibleElements:function(){var t=this.getDataset(),e=this.getMeta(),n=0;return B.each(e.data,(function(e,i){isNaN(t.data[i])||e.hidden||n++})),n},setHoverStyle:function(t){var e=t._model,n=t._options,i=B.getHoverColor,a=B.valueOrDefault;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=a(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=a(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=a(n.hoverBorderWidth,n.borderWidth)},_computeAngle:function(t){var e=this,n=this.getMeta().count,i=e.getDataset(),a=e.getMeta();if(isNaN(i.data[t])||a.data[t].hidden)return 0;var r={chart:e.chart,dataIndex:t,dataset:i,datasetIndex:e.index};return Zt([e.chart.options.elements.arc.angle,2*Math.PI/n],r,t)}});Y._set("pie",B.clone(Y.doughnut)),Y._set("pie",{cutoutPercentage:0});var Xt=zt,Kt=B.valueOrDefault;Y._set("radar",{spanGaps:!1,scale:{type:"radialLinear"},elements:{line:{fill:"start",tension:0}}});var Jt=at.extend({datasetElementType:kt.Line,dataElementType:kt.Point,linkScales:B.noop,_datasetElementOptions:["backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill"],_dataElementOptions:{backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},_getIndexScaleId:function(){return this.chart.scale.id},_getValueScaleId:function(){return this.chart.scale.id},update:function(t){var e,n,i=this,a=i.getMeta(),r=a.dataset,o=a.data||[],s=i.chart.scale,l=i._config;for(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),r._scale=s,r._datasetIndex=i.index,r._children=o,r._loop=!0,r._model=i._resolveDatasetElementOptions(r),r.pivot(),e=0,n=o.length;e<n;++e)i.updateElement(o[e],e,t);for(i.updateBezierControlPoints(),e=0,n=o.length;e<n;++e)o[e].pivot()},updateElement:function(t,e,n){var i=this,a=t.custom||{},r=i.getDataset(),o=i.chart.scale,s=o.getPointPositionForValue(e,r.data[e]),l=i._resolveDataElementOptions(t,e),u=i.getMeta().dataset._model,d=n?o.xCenter:s.x,h=n?o.yCenter:s.y;t._scale=o,t._options=l,t._datasetIndex=i.index,t._index=e,t._model={x:d,y:h,skip:a.skip||isNaN(d)||isNaN(h),radius:l.radius,pointStyle:l.pointStyle,rotation:l.rotation,backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,tension:Kt(a.tension,u?u.tension:0),hitRadius:l.hitRadius}},_resolveDatasetElementOptions:function(){var t=this,e=t._config,n=t.chart.options,i=at.prototype._resolveDatasetElementOptions.apply(t,arguments);return i.spanGaps=Kt(e.spanGaps,n.spanGaps),i.tension=Kt(e.lineTension,n.elements.line.tension),i},updateBezierControlPoints:function(){var t,e,n,i,a=this.getMeta(),r=this.chart.chartArea,o=a.data||[];function s(t,e,n){return Math.max(Math.min(t,n),e)}for(a.dataset._model.spanGaps&&(o=o.filter((function(t){return!t._model.skip}))),t=0,e=o.length;t<e;++t)n=o[t]._model,i=B.splineCurve(B.previousItem(o,t,!0)._model,n,B.nextItem(o,t,!0)._model,n.tension),n.controlPointPreviousX=s(i.previous.x,r.left,r.right),n.controlPointPreviousY=s(i.previous.y,r.top,r.bottom),n.controlPointNextX=s(i.next.x,r.left,r.right),n.controlPointNextY=s(i.next.y,r.top,r.bottom)},setHoverStyle:function(t){var e=t._model,n=t._options,i=B.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Kt(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Kt(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Kt(n.hoverBorderWidth,n.borderWidth),e.radius=Kt(n.hoverRadius,n.radius)}});Y._set("scatter",{hover:{mode:"single"},scales:{xAxes:[{id:"x-axis-1",type:"linear",position:"bottom"}],yAxes:[{id:"y-axis-1",type:"linear",position:"left"}]},tooltips:{callbacks:{title:function(){return""},label:function(t){return"("+t.xLabel+", "+t.yLabel+")"}}}}),Y._set("global",{datasets:{scatter:{showLine:!1}}});var Qt={bar:At,bubble:Lt,doughnut:zt,horizontalBar:Et,line:qt,polarArea:$t,pie:Xt,radar:Jt,scatter:qt};function te(t,e){return t.native?{x:t.x,y:t.y}:B.getRelativePosition(t,e)}function ee(t,e){var n,i,a,r,o,s,l=t._getSortedVisibleDatasetMetas();for(i=0,r=l.length;i<r;++i)for(a=0,o=(n=l[i].data).length;a<o;++a)(s=n[a])._view.skip||e(s)}function ne(t,e){var n=[];return ee(t,(function(t){t.inRange(e.x,e.y)&&n.push(t)})),n}function ie(t,e,n,i){var a=Number.POSITIVE_INFINITY,r=[];return ee(t,(function(t){if(!n||t.inRange(e.x,e.y)){var o=t.getCenterPoint(),s=i(e,o);s<a?(r=[t],a=s):s===a&&r.push(t)}})),r}function ae(t){var e=-1!==t.indexOf("x"),n=-1!==t.indexOf("y");return function(t,i){var a=e?Math.abs(t.x-i.x):0,r=n?Math.abs(t.y-i.y):0;return Math.sqrt(Math.pow(a,2)+Math.pow(r,2))}}function re(t,e,n){var i=te(e,t);n.axis=n.axis||"x";var a=ae(n.axis),r=n.intersect?ne(t,i):ie(t,i,!1,a),o=[];return r.length?(t._getSortedVisibleDatasetMetas().forEach((function(t){var e=t.data[r[0]._index];e&&!e._view.skip&&o.push(e)})),o):[]}var oe={modes:{single:function(t,e){var n=te(e,t),i=[];return ee(t,(function(t){if(t.inRange(n.x,n.y))return i.push(t),i})),i.slice(0,1)},label:re,index:re,dataset:function(t,e,n){var i=te(e,t);n.axis=n.axis||"xy";var a=ae(n.axis),r=n.intersect?ne(t,i):ie(t,i,!1,a);return r.length>0&&(r=t.getDatasetMeta(r[0]._datasetIndex).data),r},"x-axis":function(t,e){return re(t,e,{intersect:!1})},point:function(t,e){return ne(t,te(e,t))},nearest:function(t,e,n){var i=te(e,t);n.axis=n.axis||"xy";var a=ae(n.axis);return ie(t,i,n.intersect,a)},x:function(t,e,n){var i=te(e,t),a=[],r=!1;return ee(t,(function(t){t.inXRange(i.x)&&a.push(t),t.inRange(i.x,i.y)&&(r=!0)})),n.intersect&&!r&&(a=[]),a},y:function(t,e,n){var i=te(e,t),a=[],r=!1;return ee(t,(function(t){t.inYRange(i.y)&&a.push(t),t.inRange(i.x,i.y)&&(r=!0)})),n.intersect&&!r&&(a=[]),a}}},se=B.extend;function le(t,e){return B.where(t,(function(t){return t.pos===e}))}function ue(t,e){return t.sort((function(t,n){var i=e?n:t,a=e?t:n;return i.weight===a.weight?i.index-a.index:i.weight-a.weight}))}function de(t,e,n,i){return Math.max(t[n],e[n])+Math.max(t[i],e[i])}function he(t,e,n){var i,a,r=n.box,o=t.maxPadding;if(n.size&&(t[n.pos]-=n.size),n.size=n.horizontal?r.height:r.width,t[n.pos]+=n.size,r.getPadding){var s=r.getPadding();o.top=Math.max(o.top,s.top),o.left=Math.max(o.left,s.left),o.bottom=Math.max(o.bottom,s.bottom),o.right=Math.max(o.right,s.right)}if(i=e.outerWidth-de(o,t,"left","right"),a=e.outerHeight-de(o,t,"top","bottom"),i!==t.w||a!==t.h){t.w=i,t.h=a;var l=n.horizontal?[i,t.w]:[a,t.h];return!(l[0]===l[1]||isNaN(l[0])&&isNaN(l[1]))}}function ce(t,e){var n=e.maxPadding;function i(t){var i={left:0,top:0,right:0,bottom:0};return t.forEach((function(t){i[t]=Math.max(e[t],n[t])})),i}return i(t?["left","right"]:["top","bottom"])}function fe(t,e,n){var i,a,r,o,s,l,u=[];for(i=0,a=t.length;i<a;++i)(o=(r=t[i]).box).update(r.width||e.w,r.height||e.h,ce(r.horizontal,e)),he(e,n,r)&&(l=!0,u.length&&(s=!0)),o.fullWidth||u.push(r);return s&&fe(u,e,n)||l}function ge(t,e,n){var i,a,r,o,s=n.padding,l=e.x,u=e.y;for(i=0,a=t.length;i<a;++i)o=(r=t[i]).box,r.horizontal?(o.left=o.fullWidth?s.left:e.left,o.right=o.fullWidth?n.outerWidth-s.right:e.left+e.w,o.top=u,o.bottom=u+o.height,o.width=o.right-o.left,u=o.bottom):(o.left=l,o.right=l+o.width,o.top=e.top,o.bottom=e.top+e.h,o.height=o.bottom-o.top,l=o.right);e.x=l,e.y=u}Y._set("global",{layout:{padding:{top:0,right:0,bottom:0,left:0}}});var me,pe={defaults:{},addBox:function(t,e){t.boxes||(t.boxes=[]),e.fullWidth=e.fullWidth||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw:function(){e.draw.apply(e,arguments)}}]},t.boxes.push(e)},removeBox:function(t,e){var n=t.boxes?t.boxes.indexOf(e):-1;-1!==n&&t.boxes.splice(n,1)},configure:function(t,e,n){for(var i,a=["fullWidth","position","weight"],r=a.length,o=0;o<r;++o)i=a[o],n.hasOwnProperty(i)&&(e[i]=n[i])},update:function(t,e,n){if(t){var i=t.options.layout||{},a=B.options.toPadding(i.padding),r=e-a.width,o=n-a.height,s=function(t){var e=function(t){var e,n,i,a=[];for(e=0,n=(t||[]).length;e<n;++e)i=t[e],a.push({index:e,box:i,pos:i.position,horizontal:i.isHorizontal(),weight:i.weight});return a}(t),n=ue(le(e,"left"),!0),i=ue(le(e,"right")),a=ue(le(e,"top"),!0),r=ue(le(e,"bottom"));return{leftAndTop:n.concat(a),rightAndBottom:i.concat(r),chartArea:le(e,"chartArea"),vertical:n.concat(i),horizontal:a.concat(r)}}(t.boxes),l=s.vertical,u=s.horizontal,d=Object.freeze({outerWidth:e,outerHeight:n,padding:a,availableWidth:r,vBoxMaxWidth:r/2/l.length,hBoxMaxHeight:o/2}),h=se({maxPadding:se({},a),w:r,h:o,x:a.left,y:a.top},a);!function(t,e){var n,i,a;for(n=0,i=t.length;n<i;++n)(a=t[n]).width=a.horizontal?a.box.fullWidth&&e.availableWidth:e.vBoxMaxWidth,a.height=a.horizontal&&e.hBoxMaxHeight}(l.concat(u),d),fe(l,h,d),fe(u,h,d)&&fe(l,h,d),function(t){var e=t.maxPadding;function n(n){var i=Math.max(e[n]-t[n],0);return t[n]+=i,i}t.y+=n("top"),t.x+=n("left"),n("right"),n("bottom")}(h),ge(s.leftAndTop,h,d),h.x+=h.w,h.y+=h.h,ge(s.rightAndBottom,h,d),t.chartArea={left:h.left,top:h.top,right:h.left+h.w,bottom:h.top+h.h},B.each(s.chartArea,(function(e){var n=e.box;se(n,t.chartArea),n.update(h.w,h.h)}))}}},ve=(me=Object.freeze({__proto__:null,default:"@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}"}))&&me.default||me,be="$chartjs",ye="chartjs-size-monitor",xe="chartjs-render-monitor",_e="chartjs-render-animation",we=["animationstart","webkitAnimationStart"],ke={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};function Me(t,e){var n=B.getStyle(t,e),i=n&&n.match(/^(\d+)(\.\d+)?px$/);return i?Number(i[1]):void 0}var Se=!!function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("e",null,e)}catch(t){}return t}()&&{passive:!0};function De(t,e,n){t.addEventListener(e,n,Se)}function Ce(t,e,n){t.removeEventListener(e,n,Se)}function Pe(t,e,n,i,a){return{type:t,chart:e,native:a||null,x:void 0!==n?n:null,y:void 0!==i?i:null}}function Te(t){var e=document.createElement("div");return e.className=t||"",e}function Oe(t,e,n){var i,a,r,o,s=t[be]||(t[be]={}),l=s.resizer=function(t){var e=Te(ye),n=Te(ye+"-expand"),i=Te(ye+"-shrink");n.appendChild(Te()),i.appendChild(Te()),e.appendChild(n),e.appendChild(i),e._reset=function(){n.scrollLeft=1e6,n.scrollTop=1e6,i.scrollLeft=1e6,i.scrollTop=1e6};var a=function(){e._reset(),t()};return De(n,"scroll",a.bind(n,"expand")),De(i,"scroll",a.bind(i,"shrink")),e}((i=function(){if(s.resizer){var i=n.options.maintainAspectRatio&&t.parentNode,a=i?i.clientWidth:0;e(Pe("resize",n)),i&&i.clientWidth<a&&n.canvas&&e(Pe("resize",n))}},r=!1,o=[],function(){o=Array.prototype.slice.call(arguments),a=a||this,r||(r=!0,B.requestAnimFrame.call(window,(function(){r=!1,i.apply(a,o)})))}));!function(t,e){var n=t[be]||(t[be]={}),i=n.renderProxy=function(t){t.animationName===_e&&e()};B.each(we,(function(e){De(t,e,i)})),n.reflow=!!t.offsetParent,t.classList.add(xe)}(t,(function(){if(s.resizer){var e=t.parentNode;e&&e!==l.parentNode&&e.insertBefore(l,e.firstChild),l._reset()}}))}function Ae(t){var e=t[be]||{},n=e.resizer;delete e.resizer,function(t){var e=t[be]||{},n=e.renderProxy;n&&(B.each(we,(function(e){Ce(t,e,n)})),delete e.renderProxy),t.classList.remove(xe)}(t),n&&n.parentNode&&n.parentNode.removeChild(n)}var Fe={disableCSSInjection:!1,_enabled:"undefined"!=typeof window&&"undefined"!=typeof document,_ensureLoaded:function(t){if(!this.disableCSSInjection){var e=t.getRootNode?t.getRootNode():document;!function(t,e){var n=t[be]||(t[be]={});if(!n.containsStyles){n.containsStyles=!0,e="/* Chart.js */\n"+e;var i=document.createElement("style");i.setAttribute("type","text/css"),i.appendChild(document.createTextNode(e)),t.appendChild(i)}}(e.host?e:document.head,ve)}},acquireContext:function(t,e){"string"==typeof t?t=document.getElementById(t):t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas);var n=t&&t.getContext&&t.getContext("2d");return n&&n.canvas===t?(this._ensureLoaded(t),function(t,e){var n=t.style,i=t.getAttribute("height"),a=t.getAttribute("width");if(t[be]={initial:{height:i,width:a,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",null===a||""===a){var r=Me(t,"width");void 0!==r&&(t.width=r)}if(null===i||""===i)if(""===t.style.height)t.height=t.width/(e.options.aspectRatio||2);else{var o=Me(t,"height");void 0!==r&&(t.height=o)}}(t,e),n):null},releaseContext:function(t){var e=t.canvas;if(e[be]){var n=e[be].initial;["height","width"].forEach((function(t){var i=n[t];B.isNullOrUndef(i)?e.removeAttribute(t):e.setAttribute(t,i)})),B.each(n.style||{},(function(t,n){e.style[n]=t})),e.width=e.width,delete e[be]}},addEventListener:function(t,e,n){var i=t.canvas;if("resize"!==e){var a=n[be]||(n[be]={});De(i,e,(a.proxies||(a.proxies={}))[t.id+"_"+e]=function(e){n(function(t,e){var n=ke[t.type]||t.type,i=B.getRelativePosition(t,e);return Pe(n,e,i.x,i.y,t)}(e,t))})}else Oe(i,n,t)},removeEventListener:function(t,e,n){var i=t.canvas;if("resize"!==e){var a=((n[be]||{}).proxies||{})[t.id+"_"+e];a&&Ce(i,e,a)}else Ae(i)}};B.addEvent=De,B.removeEvent=Ce;var Ie=Fe._enabled?Fe:{acquireContext:function(t){return t&&t.canvas&&(t=t.canvas),t&&t.getContext("2d")||null}},Le=B.extend({initialize:function(){},acquireContext:function(){},releaseContext:function(){},addEventListener:function(){},removeEventListener:function(){}},Ie);Y._set("global",{plugins:{}});var Re={_plugins:[],_cacheId:0,register:function(t){var e=this._plugins;[].concat(t).forEach((function(t){-1===e.indexOf(t)&&e.push(t)})),this._cacheId++},unregister:function(t){var e=this._plugins;[].concat(t).forEach((function(t){var n=e.indexOf(t);-1!==n&&e.splice(n,1)})),this._cacheId++},clear:function(){this._plugins=[],this._cacheId++},count:function(){return this._plugins.length},getAll:function(){return this._plugins},notify:function(t,e,n){var i,a,r,o,s,l=this.descriptors(t),u=l.length;for(i=0;i<u;++i)if("function"==typeof(s=(r=(a=l[i]).plugin)[e])&&((o=[t].concat(n||[])).push(a.options),!1===s.apply(r,o)))return!1;return!0},descriptors:function(t){var e=t.$plugins||(t.$plugins={});if(e.id===this._cacheId)return e.descriptors;var n=[],i=[],a=t&&t.config||{},r=a.options&&a.options.plugins||{};return this._plugins.concat(a.plugins||[]).forEach((function(t){if(-1===n.indexOf(t)){var e=t.id,a=r[e];!1!==a&&(!0===a&&(a=B.clone(Y.global.plugins[e])),n.push(t),i.push({plugin:t,options:a||{}}))}})),e.descriptors=i,e.id=this._cacheId,i},_invalidate:function(t){delete t.$plugins}},Ne={constructors:{},defaults:{},registerScaleType:function(t,e,n){this.constructors[t]=e,this.defaults[t]=B.clone(n)},getScaleConstructor:function(t){return this.constructors.hasOwnProperty(t)?this.constructors[t]:void 0},getScaleDefaults:function(t){return this.defaults.hasOwnProperty(t)?B.merge(Object.create(null),[Y.scale,this.defaults[t]]):{}},updateScaleDefaults:function(t,e){this.defaults.hasOwnProperty(t)&&(this.defaults[t]=B.extend(this.defaults[t],e))},addScalesToLayout:function(t){B.each(t.scales,(function(e){e.fullWidth=e.options.fullWidth,e.position=e.options.position,e.weight=e.options.weight,pe.addBox(t,e)}))}},We=B.valueOrDefault,Ye=B.rtl.getRtlAdapter;Y._set("global",{tooltips:{enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{beforeTitle:B.noop,title:function(t,e){var n="",i=e.labels,a=i?i.length:0;if(t.length>0){var r=t[0];r.label?n=r.label:r.xLabel?n=r.xLabel:a>0&&r.index<a&&(n=i[r.index])}return n},afterTitle:B.noop,beforeBody:B.noop,beforeLabel:B.noop,label:function(t,e){var n=e.datasets[t.datasetIndex].label||"";return n&&(n+=": "),B.isNullOrUndef(t.value)?n+=t.yLabel:n+=t.value,n},labelColor:function(t,e){var n=e.getDatasetMeta(t.datasetIndex).data[t.index]._view;return{borderColor:n.borderColor,backgroundColor:n.backgroundColor}},labelTextColor:function(){return this._options.bodyFontColor},afterLabel:B.noop,afterBody:B.noop,beforeFooter:B.noop,footer:B.noop,afterFooter:B.noop}}});var ze={average:function(t){if(!t.length)return!1;var e,n,i=0,a=0,r=0;for(e=0,n=t.length;e<n;++e){var o=t[e];if(o&&o.hasValue()){var s=o.tooltipPosition();i+=s.x,a+=s.y,++r}}return{x:i/r,y:a/r}},nearest:function(t,e){var n,i,a,r=e.x,o=e.y,s=Number.POSITIVE_INFINITY;for(n=0,i=t.length;n<i;++n){var l=t[n];if(l&&l.hasValue()){var u=l.getCenterPoint(),d=B.distanceBetweenPoints(e,u);d<s&&(s=d,a=l)}}if(a){var h=a.tooltipPosition();r=h.x,o=h.y}return{x:r,y:o}}};function Ee(t,e){return e&&(B.isArray(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Ve(t){return("string"==typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function He(t){var e=Y.global;return{xPadding:t.xPadding,yPadding:t.yPadding,xAlign:t.xAlign,yAlign:t.yAlign,rtl:t.rtl,textDirection:t.textDirection,bodyFontColor:t.bodyFontColor,_bodyFontFamily:We(t.bodyFontFamily,e.defaultFontFamily),_bodyFontStyle:We(t.bodyFontStyle,e.defaultFontStyle),_bodyAlign:t.bodyAlign,bodyFontSize:We(t.bodyFontSize,e.defaultFontSize),bodySpacing:t.bodySpacing,titleFontColor:t.titleFontColor,_titleFontFamily:We(t.titleFontFamily,e.defaultFontFamily),_titleFontStyle:We(t.titleFontStyle,e.defaultFontStyle),titleFontSize:We(t.titleFontSize,e.defaultFontSize),_titleAlign:t.titleAlign,titleSpacing:t.titleSpacing,titleMarginBottom:t.titleMarginBottom,footerFontColor:t.footerFontColor,_footerFontFamily:We(t.footerFontFamily,e.defaultFontFamily),_footerFontStyle:We(t.footerFontStyle,e.defaultFontStyle),footerFontSize:We(t.footerFontSize,e.defaultFontSize),_footerAlign:t.footerAlign,footerSpacing:t.footerSpacing,footerMarginTop:t.footerMarginTop,caretSize:t.caretSize,cornerRadius:t.cornerRadius,backgroundColor:t.backgroundColor,opacity:0,legendColorBackground:t.multiKeyBackground,displayColors:t.displayColors,borderColor:t.borderColor,borderWidth:t.borderWidth}}function Be(t,e){return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-t.xPadding:t.x+t.xPadding}function je(t){return Ee([],Ve(t))}var Ue=X.extend({initialize:function(){this._model=He(this._options),this._lastActive=[]},getTitle:function(){var t=this,e=t._options,n=e.callbacks,i=n.beforeTitle.apply(t,arguments),a=n.title.apply(t,arguments),r=n.afterTitle.apply(t,arguments),o=[];return o=Ee(o,Ve(i)),o=Ee(o,Ve(a)),o=Ee(o,Ve(r))},getBeforeBody:function(){return je(this._options.callbacks.beforeBody.apply(this,arguments))},getBody:function(t,e){var n=this,i=n._options.callbacks,a=[];return B.each(t,(function(t){var r={before:[],lines:[],after:[]};Ee(r.before,Ve(i.beforeLabel.call(n,t,e))),Ee(r.lines,i.label.call(n,t,e)),Ee(r.after,Ve(i.afterLabel.call(n,t,e))),a.push(r)})),a},getAfterBody:function(){return je(this._options.callbacks.afterBody.apply(this,arguments))},getFooter:function(){var t=this,e=t._options.callbacks,n=e.beforeFooter.apply(t,arguments),i=e.footer.apply(t,arguments),a=e.afterFooter.apply(t,arguments),r=[];return r=Ee(r,Ve(n)),r=Ee(r,Ve(i)),r=Ee(r,Ve(a))},update:function(t){var e,n,i,a,r,o,s,l,u,d,h=this,c=h._options,f=h._model,g=h._model=He(c),m=h._active,p=h._data,v={xAlign:f.xAlign,yAlign:f.yAlign},b={x:f.x,y:f.y},y={width:f.width,height:f.height},x={x:f.caretX,y:f.caretY};if(m.length){g.opacity=1;var _=[],w=[];x=ze[c.position].call(h,m,h._eventPosition);var k=[];for(e=0,n=m.length;e<n;++e)k.push((i=m[e],a=void 0,r=void 0,o=void 0,s=void 0,l=void 0,u=void 0,d=void 0,a=i._xScale,r=i._yScale||i._scale,o=i._index,s=i._datasetIndex,l=i._chart.getDatasetMeta(s).controller,u=l._getIndexScale(),d=l._getValueScale(),{xLabel:a?a.getLabelForIndex(o,s):"",yLabel:r?r.getLabelForIndex(o,s):"",label:u?""+u.getLabelForIndex(o,s):"",value:d?""+d.getLabelForIndex(o,s):"",index:o,datasetIndex:s,x:i._model.x,y:i._model.y}));c.filter&&(k=k.filter((function(t){return c.filter(t,p)}))),c.itemSort&&(k=k.sort((function(t,e){return c.itemSort(t,e,p)}))),B.each(k,(function(t){_.push(c.callbacks.labelColor.call(h,t,h._chart)),w.push(c.callbacks.labelTextColor.call(h,t,h._chart))})),g.title=h.getTitle(k,p),g.beforeBody=h.getBeforeBody(k,p),g.body=h.getBody(k,p),g.afterBody=h.getAfterBody(k,p),g.footer=h.getFooter(k,p),g.x=x.x,g.y=x.y,g.caretPadding=c.caretPadding,g.labelColors=_,g.labelTextColors=w,g.dataPoints=k,y=function(t,e){var n=t._chart.ctx,i=2*e.yPadding,a=0,r=e.body,o=r.reduce((function(t,e){return t+e.before.length+e.lines.length+e.after.length}),0);o+=e.beforeBody.length+e.afterBody.length;var s=e.title.length,l=e.footer.length,u=e.titleFontSize,d=e.bodyFontSize,h=e.footerFontSize;i+=s*u,i+=s?(s-1)*e.titleSpacing:0,i+=s?e.titleMarginBottom:0,i+=o*d,i+=o?(o-1)*e.bodySpacing:0,i+=l?e.footerMarginTop:0,i+=l*h,i+=l?(l-1)*e.footerSpacing:0;var c=0,f=function(t){a=Math.max(a,n.measureText(t).width+c)};return n.font=B.fontString(u,e._titleFontStyle,e._titleFontFamily),B.each(e.title,f),n.font=B.fontString(d,e._bodyFontStyle,e._bodyFontFamily),B.each(e.beforeBody.concat(e.afterBody),f),c=e.displayColors?d+2:0,B.each(r,(function(t){B.each(t.before,f),B.each(t.lines,f),B.each(t.after,f)})),c=0,n.font=B.fontString(h,e._footerFontStyle,e._footerFontFamily),B.each(e.footer,f),{width:a+=2*e.xPadding,height:i}}(this,g),b=function(t,e,n,i){var a=t.x,r=t.y,o=t.caretSize,s=t.caretPadding,l=t.cornerRadius,u=n.xAlign,d=n.yAlign,h=o+s,c=l+s;return"right"===u?a-=e.width:"center"===u&&((a-=e.width/2)+e.width>i.width&&(a=i.width-e.width),a<0&&(a=0)),"top"===d?r+=h:r-="bottom"===d?e.height+h:e.height/2,"center"===d?"left"===u?a+=h:"right"===u&&(a-=h):"left"===u?a-=c:"right"===u&&(a+=c),{x:a,y:r}}(g,y,v=function(t,e){var n,i,a,r,o,s=t._model,l=t._chart,u=t._chart.chartArea,d="center",h="center";s.y<e.height?h="top":s.y>l.height-e.height&&(h="bottom");var c=(u.left+u.right)/2,f=(u.top+u.bottom)/2;"center"===h?(n=function(t){return t<=c},i=function(t){return t>c}):(n=function(t){return t<=e.width/2},i=function(t){return t>=l.width-e.width/2}),a=function(t){return t+e.width+s.caretSize+s.caretPadding>l.width},r=function(t){return t-e.width-s.caretSize-s.caretPadding<0},o=function(t){return t<=f?"top":"bottom"},n(s.x)?(d="left",a(s.x)&&(d="center",h=o(s.y))):i(s.x)&&(d="right",r(s.x)&&(d="center",h=o(s.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:d,yAlign:g.yAlign?g.yAlign:h}}(this,y),h._chart)}else g.opacity=0;return g.xAlign=v.xAlign,g.yAlign=v.yAlign,g.x=b.x,g.y=b.y,g.width=y.width,g.height=y.height,g.caretX=x.x,g.caretY=x.y,h._model=g,t&&c.custom&&c.custom.call(h,g),h},drawCaret:function(t,e){var n=this._chart.ctx,i=this._view,a=this.getCaretPosition(t,e,i);n.lineTo(a.x1,a.y1),n.lineTo(a.x2,a.y2),n.lineTo(a.x3,a.y3)},getCaretPosition:function(t,e,n){var i,a,r,o,s,l,u=n.caretSize,d=n.cornerRadius,h=n.xAlign,c=n.yAlign,f=t.x,g=t.y,m=e.width,p=e.height;if("center"===c)s=g+p/2,"left"===h?(a=(i=f)-u,r=i,o=s+u,l=s-u):(a=(i=f+m)+u,r=i,o=s-u,l=s+u);else if("left"===h?(i=(a=f+d+u)-u,r=a+u):"right"===h?(i=(a=f+m-d-u)-u,r=a+u):(i=(a=n.caretX)-u,r=a+u),"top"===c)s=(o=g)-u,l=o;else{s=(o=g+p)+u,l=o;var v=r;r=i,i=v}return{x1:i,x2:a,x3:r,y1:o,y2:s,y3:l}},drawTitle:function(t,e,n){var i,a,r,o=e.title,s=o.length;if(s){var l=Ye(e.rtl,e.x,e.width);for(t.x=Be(e,e._titleAlign),n.textAlign=l.textAlign(e._titleAlign),n.textBaseline="middle",i=e.titleFontSize,a=e.titleSpacing,n.fillStyle=e.titleFontColor,n.font=B.fontString(i,e._titleFontStyle,e._titleFontFamily),r=0;r<s;++r)n.fillText(o[r],l.x(t.x),t.y+i/2),t.y+=i+a,r+1===s&&(t.y+=e.titleMarginBottom-a)}},drawBody:function(t,e,n){var i,a,r,o,s,l,u,d,h=e.bodyFontSize,c=e.bodySpacing,f=e._bodyAlign,g=e.body,m=e.displayColors,p=0,v=m?Be(e,"left"):0,b=Ye(e.rtl,e.x,e.width),y=function(e){n.fillText(e,b.x(t.x+p),t.y+h/2),t.y+=h+c},x=b.textAlign(f);for(n.textAlign=f,n.textBaseline="middle",n.font=B.fontString(h,e._bodyFontStyle,e._bodyFontFamily),t.x=Be(e,x),n.fillStyle=e.bodyFontColor,B.each(e.beforeBody,y),p=m&&"right"!==x?"center"===f?h/2+1:h+2:0,s=0,u=g.length;s<u;++s){for(i=g[s],a=e.labelTextColors[s],r=e.labelColors[s],n.fillStyle=a,B.each(i.before,y),l=0,d=(o=i.lines).length;l<d;++l){if(m){var _=b.x(v);n.fillStyle=e.legendColorBackground,n.fillRect(b.leftForLtr(_,h),t.y,h,h),n.lineWidth=1,n.strokeStyle=r.borderColor,n.strokeRect(b.leftForLtr(_,h),t.y,h,h),n.fillStyle=r.backgroundColor,n.fillRect(b.leftForLtr(b.xPlus(_,1),h-2),t.y+1,h-2,h-2),n.fillStyle=a}y(o[l])}B.each(i.after,y)}p=0,B.each(e.afterBody,y),t.y-=c},drawFooter:function(t,e,n){var i,a,r=e.footer,o=r.length;if(o){var s=Ye(e.rtl,e.x,e.width);for(t.x=Be(e,e._footerAlign),t.y+=e.footerMarginTop,n.textAlign=s.textAlign(e._footerAlign),n.textBaseline="middle",i=e.footerFontSize,n.fillStyle=e.footerFontColor,n.font=B.fontString(i,e._footerFontStyle,e._footerFontFamily),a=0;a<o;++a)n.fillText(r[a],s.x(t.x),t.y+i/2),t.y+=i+e.footerSpacing}},drawBackground:function(t,e,n,i){n.fillStyle=e.backgroundColor,n.strokeStyle=e.borderColor,n.lineWidth=e.borderWidth;var a=e.xAlign,r=e.yAlign,o=t.x,s=t.y,l=i.width,u=i.height,d=e.cornerRadius;n.beginPath(),n.moveTo(o+d,s),"top"===r&&this.drawCaret(t,i),n.lineTo(o+l-d,s),n.quadraticCurveTo(o+l,s,o+l,s+d),"center"===r&&"right"===a&&this.drawCaret(t,i),n.lineTo(o+l,s+u-d),n.quadraticCurveTo(o+l,s+u,o+l-d,s+u),"bottom"===r&&this.drawCaret(t,i),n.lineTo(o+d,s+u),n.quadraticCurveTo(o,s+u,o,s+u-d),"center"===r&&"left"===a&&this.drawCaret(t,i),n.lineTo(o,s+d),n.quadraticCurveTo(o,s,o+d,s),n.closePath(),n.fill(),e.borderWidth>0&&n.stroke()},draw:function(){var t=this._chart.ctx,e=this._view;if(0!==e.opacity){var n={width:e.width,height:e.height},i={x:e.x,y:e.y},a=Math.abs(e.opacity<.001)?0:e.opacity,r=e.title.length||e.beforeBody.length||e.body.length||e.afterBody.length||e.footer.length;this._options.enabled&&r&&(t.save(),t.globalAlpha=a,this.drawBackground(i,e,t,n),i.y+=e.yPadding,B.rtl.overrideTextDirection(t,e.textDirection),this.drawTitle(i,e,t),this.drawBody(i,e,t),this.drawFooter(i,e,t),B.rtl.restoreTextDirection(t,e.textDirection),t.restore())}},handleEvent:function(t){var e,n=this,i=n._options;return n._lastActive=n._lastActive||[],"mouseout"===t.type?n._active=[]:(n._active=n._chart.getElementsAtEventForMode(t,i.mode,i),i.reverse&&n._active.reverse()),(e=!B.arrayEquals(n._active,n._lastActive))&&(n._lastActive=n._active,(i.enabled||i.custom)&&(n._eventPosition={x:t.x,y:t.y},n.update(!0),n.pivot())),e}}),Ge=ze,qe=Ue;qe.positioners=Ge;var Ze=B.valueOrDefault;function $e(){return B.merge(Object.create(null),[].slice.call(arguments),{merger:function(t,e,n,i){if("xAxes"===t||"yAxes"===t){var a,r,o,s=n[t].length;for(e[t]||(e[t]=[]),a=0;a<s;++a)o=n[t][a],r=Ze(o.type,"xAxes"===t?"category":"linear"),a>=e[t].length&&e[t].push({}),!e[t][a].type||o.type&&o.type!==e[t][a].type?B.merge(e[t][a],[Ne.getScaleDefaults(r),o]):B.merge(e[t][a],o)}else B._merger(t,e,n,i)}})}function Xe(){return B.merge(Object.create(null),[].slice.call(arguments),{merger:function(t,e,n,i){var a=e[t]||Object.create(null),r=n[t];"scales"===t?e[t]=$e(a,r):"scale"===t?e[t]=B.merge(a,[Ne.getScaleDefaults(r.type),r]):B._merger(t,e,n,i)}})}function Ke(t){var e=t.options;B.each(t.scales,(function(e){pe.removeBox(t,e)})),e=Xe(Y.global,Y[t.config.type],e),t.options=t.config.options=e,t.ensureScalesHaveIDs(),t.buildOrUpdateScales(),t.tooltip._options=e.tooltips,t.tooltip.initialize()}function Je(t,e,n){var i,a=function(t){return t.id===i};do{i=e+n++}while(B.findIndex(t,a)>=0);return i}function Qe(t){return"top"===t||"bottom"===t}function tn(t,e){return function(n,i){return n[t]===i[t]?n[e]-i[e]:n[t]-i[t]}}Y._set("global",{elements:{},events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,maintainAspectRatio:!0,responsive:!0,responsiveAnimationDuration:0});var en=function(t,e){return this.construct(t,e),this};B.extend(en.prototype,{construct:function(t,e){var n=this;e=function(t){var e=(t=t||Object.create(null)).data=t.data||{};return e.datasets=e.datasets||[],e.labels=e.labels||[],t.options=Xe(Y.global,Y[t.type],t.options||{}),t}(e);var i=Le.acquireContext(t,e),a=i&&i.canvas,r=a&&a.height,o=a&&a.width;n.id=B.uid(),n.ctx=i,n.canvas=a,n.config=e,n.width=o,n.height=r,n.aspectRatio=r?o/r:null,n.options=e.options,n._bufferedRender=!1,n._layers=[],n.chart=n,n.controller=n,en.instances[n.id]=n,Object.defineProperty(n,"data",{get:function(){return n.config.data},set:function(t){n.config.data=t}}),i&&a?(n.initialize(),n.update()):console.error("Failed to create chart: can't acquire context from the given item")},initialize:function(){var t=this;return Re.notify(t,"beforeInit"),B.retinaScale(t,t.options.devicePixelRatio),t.bindEvents(),t.options.responsive&&t.resize(!0),t.initToolTip(),Re.notify(t,"afterInit"),t},clear:function(){return B.canvas.clear(this),this},stop:function(){return Q.cancelAnimation(this),this},resize:function(t){var e=this,n=e.options,i=e.canvas,a=n.maintainAspectRatio&&e.aspectRatio||null,r=Math.max(0,Math.floor(B.getMaximumWidth(i))),o=Math.max(0,Math.floor(a?r/a:B.getMaximumHeight(i)));if((e.width!==r||e.height!==o)&&(i.width=e.width=r,i.height=e.height=o,i.style.width=r+"px",i.style.height=o+"px",B.retinaScale(e,n.devicePixelRatio),!t)){var s={width:r,height:o};Re.notify(e,"resize",[s]),n.onResize&&n.onResize(e,s),e.stop(),e.update({duration:n.responsiveAnimationDuration})}},ensureScalesHaveIDs:function(){var t=this.options,e=t.scales||{},n=t.scale;B.each(e.xAxes,(function(t,n){t.id||(t.id=Je(e.xAxes,"x-axis-",n))})),B.each(e.yAxes,(function(t,n){t.id||(t.id=Je(e.yAxes,"y-axis-",n))})),n&&(n.id=n.id||"scale")},buildOrUpdateScales:function(){var t=this,e=t.options,n=t.scales||{},i=[],a=Object.keys(n).reduce((function(t,e){return t[e]=!1,t}),{});e.scales&&(i=i.concat((e.scales.xAxes||[]).map((function(t){return{options:t,dtype:"category",dposition:"bottom"}})),(e.scales.yAxes||[]).map((function(t){return{options:t,dtype:"linear",dposition:"left"}})))),e.scale&&i.push({options:e.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),B.each(i,(function(e){var i=e.options,r=i.id,o=Ze(i.type,e.dtype);Qe(i.position)!==Qe(e.dposition)&&(i.position=e.dposition),a[r]=!0;var s=null;if(r in n&&n[r].type===o)(s=n[r]).options=i,s.ctx=t.ctx,s.chart=t;else{var l=Ne.getScaleConstructor(o);if(!l)return;s=new l({id:r,type:o,options:i,ctx:t.ctx,chart:t}),n[s.id]=s}s.mergeTicksOptions(),e.isDefault&&(t.scale=s)})),B.each(a,(function(t,e){t||delete n[e]})),t.scales=n,Ne.addScalesToLayout(this)},buildOrUpdateControllers:function(){var t,e,n=this,i=[],a=n.data.datasets;for(t=0,e=a.length;t<e;t++){var r=a[t],o=n.getDatasetMeta(t),s=r.type||n.config.type;if(o.type&&o.type!==s&&(n.destroyDatasetMeta(t),o=n.getDatasetMeta(t)),o.type=s,o.order=r.order||0,o.index=t,o.controller)o.controller.updateIndex(t),o.controller.linkScales();else{var l=Qt[o.type];if(void 0===l)throw new Error('"'+o.type+'" is not a chart type.');o.controller=new l(n,t),i.push(o.controller)}}return i},resetElements:function(){var t=this;B.each(t.data.datasets,(function(e,n){t.getDatasetMeta(n).controller.reset()}),t)},reset:function(){this.resetElements(),this.tooltip.initialize()},update:function(t){var e,n,i=this;if(t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]}),Ke(i),Re._invalidate(i),!1!==Re.notify(i,"beforeUpdate")){i.tooltip._data=i.data;var a=i.buildOrUpdateControllers();for(e=0,n=i.data.datasets.length;e<n;e++)i.getDatasetMeta(e).controller.buildOrUpdateElements();i.updateLayout(),i.options.animation&&i.options.animation.duration&&B.each(a,(function(t){t.reset()})),i.updateDatasets(),i.tooltip.initialize(),i.lastActive=[],Re.notify(i,"afterUpdate"),i._layers.sort(tn("z","_idx")),i._bufferedRender?i._bufferedRequest={duration:t.duration,easing:t.easing,lazy:t.lazy}:i.render(t)}},updateLayout:function(){var t=this;!1!==Re.notify(t,"beforeLayout")&&(pe.update(this,this.width,this.height),t._layers=[],B.each(t.boxes,(function(e){e._configure&&e._configure(),t._layers.push.apply(t._layers,e._layers())}),t),t._layers.forEach((function(t,e){t._idx=e})),Re.notify(t,"afterScaleUpdate"),Re.notify(t,"afterLayout"))},updateDatasets:function(){if(!1!==Re.notify(this,"beforeDatasetsUpdate")){for(var t=0,e=this.data.datasets.length;t<e;++t)this.updateDataset(t);Re.notify(this,"afterDatasetsUpdate")}},updateDataset:function(t){var e=this.getDatasetMeta(t),n={meta:e,index:t};!1!==Re.notify(this,"beforeDatasetUpdate",[n])&&(e.controller._update(),Re.notify(this,"afterDatasetUpdate",[n]))},render:function(t){var e=this;t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]});var n=e.options.animation,i=Ze(t.duration,n&&n.duration),a=t.lazy;if(!1!==Re.notify(e,"beforeRender")){var r=function(t){Re.notify(e,"afterRender"),B.callback(n&&n.onComplete,[t],e)};if(n&&i){var o=new J({numSteps:i/16.66,easing:t.easing||n.easing,render:function(t,e){var n=B.easing.effects[e.easing],i=e.currentStep,a=i/e.numSteps;t.draw(n(a),a,i)},onAnimationProgress:n.onProgress,onAnimationComplete:r});Q.addAnimation(e,o,i,a)}else e.draw(),r(new J({numSteps:0,chart:e}));return e}},draw:function(t){var e,n,i=this;if(i.clear(),B.isNullOrUndef(t)&&(t=1),i.transition(t),!(i.width<=0||i.height<=0)&&!1!==Re.notify(i,"beforeDraw",[t])){for(n=i._layers,e=0;e<n.length&&n[e].z<=0;++e)n[e].draw(i.chartArea);for(i.drawDatasets(t);e<n.length;++e)n[e].draw(i.chartArea);i._drawTooltip(t),Re.notify(i,"afterDraw",[t])}},transition:function(t){for(var e=0,n=(this.data.datasets||[]).length;e<n;++e)this.isDatasetVisible(e)&&this.getDatasetMeta(e).controller.transition(t);this.tooltip.transition(t)},_getSortedDatasetMetas:function(t){var e,n,i=[];for(e=0,n=(this.data.datasets||[]).length;e<n;++e)t&&!this.isDatasetVisible(e)||i.push(this.getDatasetMeta(e));return i.sort(tn("order","index")),i},_getSortedVisibleDatasetMetas:function(){return this._getSortedDatasetMetas(!0)},drawDatasets:function(t){var e,n;if(!1!==Re.notify(this,"beforeDatasetsDraw",[t])){for(n=(e=this._getSortedVisibleDatasetMetas()).length-1;n>=0;--n)this.drawDataset(e[n],t);Re.notify(this,"afterDatasetsDraw",[t])}},drawDataset:function(t,e){var n={meta:t,index:t.index,easingValue:e};!1!==Re.notify(this,"beforeDatasetDraw",[n])&&(t.controller.draw(e),Re.notify(this,"afterDatasetDraw",[n]))},_drawTooltip:function(t){var e=this.tooltip,n={tooltip:e,easingValue:t};!1!==Re.notify(this,"beforeTooltipDraw",[n])&&(e.draw(),Re.notify(this,"afterTooltipDraw",[n]))},getElementAtEvent:function(t){return oe.modes.single(this,t)},getElementsAtEvent:function(t){return oe.modes.label(this,t,{intersect:!0})},getElementsAtXAxis:function(t){return oe.modes["x-axis"](this,t,{intersect:!0})},getElementsAtEventForMode:function(t,e,n){var i=oe.modes[e];return"function"==typeof i?i(this,t,n):[]},getDatasetAtEvent:function(t){return oe.modes.dataset(this,t,{intersect:!0})},getDatasetMeta:function(t){var e=this.data.datasets[t];e._meta||(e._meta={});var n=e._meta[this.id];return n||(n=e._meta[this.id]={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e.order||0,index:t}),n},getVisibleDatasetCount:function(){for(var t=0,e=0,n=this.data.datasets.length;e<n;++e)this.isDatasetVisible(e)&&t++;return t},isDatasetVisible:function(t){var e=this.getDatasetMeta(t);return"boolean"==typeof e.hidden?!e.hidden:!this.data.datasets[t].hidden},generateLegend:function(){return this.options.legendCallback(this)},destroyDatasetMeta:function(t){var e=this.id,n=this.data.datasets[t],i=n._meta&&n._meta[e];i&&(i.controller.destroy(),delete n._meta[e])},destroy:function(){var t,e,n=this,i=n.canvas;for(n.stop(),t=0,e=n.data.datasets.length;t<e;++t)n.destroyDatasetMeta(t);i&&(n.unbindEvents(),B.canvas.clear(n),Le.releaseContext(n.ctx),n.canvas=null,n.ctx=null),Re.notify(n,"destroy"),delete en.instances[n.id]},toBase64Image:function(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function(){var t=this;t.tooltip=new qe({_chart:t,_chartInstance:t,_data:t.data,_options:t.options.tooltips},t)},bindEvents:function(){var t=this,e=t._listeners={},n=function(){t.eventHandler.apply(t,arguments)};B.each(t.options.events,(function(i){Le.addEventListener(t,i,n),e[i]=n})),t.options.responsive&&(n=function(){t.resize()},Le.addEventListener(t,"resize",n),e.resize=n)},unbindEvents:function(){var t=this,e=t._listeners;e&&(delete t._listeners,B.each(e,(function(e,n){Le.removeEventListener(t,n,e)})))},updateHoverStyle:function(t,e,n){var i,a,r,o=n?"set":"remove";for(a=0,r=t.length;a<r;++a)(i=t[a])&&this.getDatasetMeta(i._datasetIndex).controller[o+"HoverStyle"](i);"dataset"===e&&this.getDatasetMeta(t[0]._datasetIndex).controller["_"+o+"DatasetHoverStyle"]()},eventHandler:function(t){var e=this,n=e.tooltip;if(!1!==Re.notify(e,"beforeEvent",[t])){e._bufferedRender=!0,e._bufferedRequest=null;var i=e.handleEvent(t);n&&(i=n._start?n.handleEvent(t):i|n.handleEvent(t)),Re.notify(e,"afterEvent",[t]);var a=e._bufferedRequest;return a?e.render(a):i&&!e.animating&&(e.stop(),e.render({duration:e.options.hover.animationDuration,lazy:!0})),e._bufferedRender=!1,e._bufferedRequest=null,e}},handleEvent:function(t){var e,n=this,i=n.options||{},a=i.hover;return n.lastActive=n.lastActive||[],"mouseout"===t.type?n.active=[]:n.active=n.getElementsAtEventForMode(t,a.mode,a),B.callback(i.onHover||i.hover.onHover,[t.native,n.active],n),"mouseup"!==t.type&&"click"!==t.type||i.onClick&&i.onClick.call(n,t.native,n.active),n.lastActive.length&&n.updateHoverStyle(n.lastActive,a.mode,!1),n.active.length&&a.mode&&n.updateHoverStyle(n.active,a.mode,!0),e=!B.arrayEquals(n.active,n.lastActive),n.lastActive=n.active,e}}),en.instances={};var nn=en;en.Controller=en,en.types={},B.configMerge=Xe,B.scaleMerge=$e;function an(){throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")}function rn(t){this.options=t||{}}B.extend(rn.prototype,{formats:an,parse:an,format:an,add:an,diff:an,startOf:an,endOf:an,_create:function(t){return t}}),rn.override=function(t){B.extend(rn.prototype,t)};var on={_date:rn},sn={formatters:{values:function(t){return B.isArray(t)?t:""+t},linear:function(t,e,n){var i=n.length>3?n[2]-n[1]:n[1]-n[0];Math.abs(i)>1&&t!==Math.floor(t)&&(i=t-Math.floor(t));var a=B.log10(Math.abs(i)),r="";if(0!==t)if(Math.max(Math.abs(n[0]),Math.abs(n[n.length-1]))<1e-4){var o=B.log10(Math.abs(t)),s=Math.floor(o)-Math.floor(a);s=Math.max(Math.min(s,20),0),r=t.toExponential(s)}else{var l=-1*Math.floor(a);l=Math.max(Math.min(l,20),0),r=t.toFixed(l)}else r="0";return r},logarithmic:function(t,e,n){var i=t/Math.pow(10,Math.floor(B.log10(t)));return 0===t?"0":1===i||2===i||5===i||0===e||e===n.length-1?t.toExponential():""}}},ln=B.isArray,un=B.isNullOrUndef,dn=B.valueOrDefault,hn=B.valueAtIndexOrDefault;function cn(t,e,n){var i,a=t.getTicks().length,r=Math.min(e,a-1),o=t.getPixelForTick(r),s=t._startPixel,l=t._endPixel;if(!(n&&(i=1===a?Math.max(o-s,l-o):0===e?(t.getPixelForTick(1)-o)/2:(o-t.getPixelForTick(r-1))/2,(o+=r<e?i:-i)<s-1e-6||o>l+1e-6)))return o}function fn(t,e,n,i){var a,r,o,s,l,u,d,h,c,f,g,m,p,v=n.length,b=[],y=[],x=[],_=0,w=0;for(a=0;a<v;++a){if(s=n[a].label,l=n[a].major?e.major:e.minor,t.font=u=l.string,d=i[u]=i[u]||{data:{},gc:[]},h=l.lineHeight,c=f=0,un(s)||ln(s)){if(ln(s))for(r=0,o=s.length;r<o;++r)g=s[r],un(g)||ln(g)||(c=B.measureText(t,d.data,d.gc,c,g),f+=h)}else c=B.measureText(t,d.data,d.gc,c,s),f=h;b.push(c),y.push(f),x.push(h/2),_=Math.max(c,_),w=Math.max(f,w)}function k(t){return{width:b[t]||0,height:y[t]||0,offset:x[t]||0}}return function(t,e){B.each(t,(function(t){var n,i=t.gc,a=i.length/2;if(a>e){for(n=0;n<a;++n)delete t.data[i[n]];i.splice(0,a)}}))}(i,v),m=b.indexOf(_),p=y.indexOf(w),{first:k(0),last:k(v-1),widest:k(m),highest:k(p)}}function gn(t){return t.drawTicks?t.tickMarkLength:0}function mn(t){var e,n;return t.display?(e=B.options._parseFont(t),n=B.options.toPadding(t.padding),e.lineHeight+n.height):0}function pn(t,e){return B.extend(B.options._parseFont({fontFamily:dn(e.fontFamily,t.fontFamily),fontSize:dn(e.fontSize,t.fontSize),fontStyle:dn(e.fontStyle,t.fontStyle),lineHeight:dn(e.lineHeight,t.lineHeight)}),{color:B.options.resolve([e.fontColor,t.fontColor,Y.global.defaultFontColor])})}function vn(t){var e=pn(t,t.minor);return{minor:e,major:t.major.enabled?pn(t,t.major):e}}function bn(t){var e,n,i,a=[];for(n=0,i=t.length;n<i;++n)void 0!==(e=t[n])._index&&a.push(e);return a}function yn(t,e,n,i){var a,r,o,s,l=dn(n,0),u=Math.min(dn(i,t.length),t.length),d=0;for(e=Math.ceil(e),i&&(e=(a=i-n)/Math.floor(a/e)),s=l;s<0;)d++,s=Math.round(l+d*e);for(r=Math.max(l,0);r<u;r++)o=t[r],r===s?(o._index=r,d++,s=Math.round(l+d*e)):delete o.label}Y._set("scale",{display:!0,position:"left",offset:!1,gridLines:{display:!0,color:"rgba(0,0,0,0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},scaleLabel:{display:!1,labelString:"",padding:{top:4,bottom:4}},ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,callback:sn.formatters.values,minor:{},major:{}}});var xn=X.extend({zeroLineIndex:0,getPadding:function(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}},getTicks:function(){return this._ticks},_getLabels:function(){var t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]},mergeTicksOptions:function(){},beforeUpdate:function(){B.callback(this.options.beforeUpdate,[this])},update:function(t,e,n){var i,a,r,o,s,l=this,u=l.options.ticks,d=u.sampleSize;if(l.beforeUpdate(),l.maxWidth=t,l.maxHeight=e,l.margins=B.extend({left:0,right:0,top:0,bottom:0},n),l._ticks=null,l.ticks=null,l._labelSizes=null,l._maxLabelLines=0,l.longestLabelWidth=0,l.longestTextCache=l.longestTextCache||{},l._gridLineItems=null,l._labelItems=null,l.beforeSetDimensions(),l.setDimensions(),l.afterSetDimensions(),l.beforeDataLimits(),l.determineDataLimits(),l.afterDataLimits(),l.beforeBuildTicks(),o=l.buildTicks()||[],(!(o=l.afterBuildTicks(o)||o)||!o.length)&&l.ticks)for(o=[],i=0,a=l.ticks.length;i<a;++i)o.push({value:l.ticks[i],major:!1});return l._ticks=o,s=d<o.length,r=l._convertTicksToLabels(s?function(t,e){for(var n=[],i=t.length/e,a=0,r=t.length;a<r;a+=i)n.push(t[Math.floor(a)]);return n}(o,d):o),l._configure(),l.beforeCalculateTickRotation(),l.calculateTickRotation(),l.afterCalculateTickRotation(),l.beforeFit(),l.fit(),l.afterFit(),l._ticksToDraw=u.display&&(u.autoSkip||"auto"===u.source)?l._autoSkip(o):o,s&&(r=l._convertTicksToLabels(l._ticksToDraw)),l.ticks=r,l.afterUpdate(),l.minSize},_configure:function(){var t,e,n=this,i=n.options.ticks.reverse;n.isHorizontal()?(t=n.left,e=n.right):(t=n.top,e=n.bottom,i=!i),n._startPixel=t,n._endPixel=e,n._reversePixels=i,n._length=e-t},afterUpdate:function(){B.callback(this.options.afterUpdate,[this])},beforeSetDimensions:function(){B.callback(this.options.beforeSetDimensions,[this])},setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0},afterSetDimensions:function(){B.callback(this.options.afterSetDimensions,[this])},beforeDataLimits:function(){B.callback(this.options.beforeDataLimits,[this])},determineDataLimits:B.noop,afterDataLimits:function(){B.callback(this.options.afterDataLimits,[this])},beforeBuildTicks:function(){B.callback(this.options.beforeBuildTicks,[this])},buildTicks:B.noop,afterBuildTicks:function(t){var e=this;return ln(t)&&t.length?B.callback(e.options.afterBuildTicks,[e,t]):(e.ticks=B.callback(e.options.afterBuildTicks,[e,e.ticks])||e.ticks,t)},beforeTickToLabelConversion:function(){B.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function(){var t=this.options.ticks;this.ticks=this.ticks.map(t.userCallback||t.callback,this)},afterTickToLabelConversion:function(){B.callback(this.options.afterTickToLabelConversion,[this])},beforeCalculateTickRotation:function(){B.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function(){var t,e,n,i,a,r,o,s=this,l=s.options,u=l.ticks,d=s.getTicks().length,h=u.minRotation||0,c=u.maxRotation,f=h;!s._isVisible()||!u.display||h>=c||d<=1||!s.isHorizontal()?s.labelRotation=h:(e=(t=s._getLabelSizes()).widest.width,n=t.highest.height-t.highest.offset,i=Math.min(s.maxWidth,s.chart.width-e),e+6>(a=l.offset?s.maxWidth/d:i/(d-1))&&(a=i/(d-(l.offset?.5:1)),r=s.maxHeight-gn(l.gridLines)-u.padding-mn(l.scaleLabel),o=Math.sqrt(e*e+n*n),f=B.toDegrees(Math.min(Math.asin(Math.min((t.highest.height+6)/a,1)),Math.asin(Math.min(r/o,1))-Math.asin(n/o))),f=Math.max(h,Math.min(c,f))),s.labelRotation=f)},afterCalculateTickRotation:function(){B.callback(this.options.afterCalculateTickRotation,[this])},beforeFit:function(){B.callback(this.options.beforeFit,[this])},fit:function(){var t=this,e=t.minSize={width:0,height:0},n=t.chart,i=t.options,a=i.ticks,r=i.scaleLabel,o=i.gridLines,s=t._isVisible(),l="bottom"===i.position,u=t.isHorizontal();if(u?e.width=t.maxWidth:s&&(e.width=gn(o)+mn(r)),u?s&&(e.height=gn(o)+mn(r)):e.height=t.maxHeight,a.display&&s){var d=vn(a),h=t._getLabelSizes(),c=h.first,f=h.last,g=h.widest,m=h.highest,p=.4*d.minor.lineHeight,v=a.padding;if(u){var b=0!==t.labelRotation,y=B.toRadians(t.labelRotation),x=Math.cos(y),_=Math.sin(y),w=_*g.width+x*(m.height-(b?m.offset:0))+(b?0:p);e.height=Math.min(t.maxHeight,e.height+w+v);var k,M,S=t.getPixelForTick(0)-t.left,D=t.right-t.getPixelForTick(t.getTicks().length-1);b?(k=l?x*c.width+_*c.offset:_*(c.height-c.offset),M=l?_*(f.height-f.offset):x*f.width+_*f.offset):(k=c.width/2,M=f.width/2),t.paddingLeft=Math.max((k-S)*t.width/(t.width-S),0)+3,t.paddingRight=Math.max((M-D)*t.width/(t.width-D),0)+3}else{var C=a.mirror?0:g.width+v+p;e.width=Math.min(t.maxWidth,e.width+C),t.paddingTop=c.height/2,t.paddingBottom=f.height/2}}t.handleMargins(),u?(t.width=t._length=n.width-t.margins.left-t.margins.right,t.height=e.height):(t.width=e.width,t.height=t._length=n.height-t.margins.top-t.margins.bottom)},handleMargins:function(){var t=this;t.margins&&(t.margins.left=Math.max(t.paddingLeft,t.margins.left),t.margins.top=Math.max(t.paddingTop,t.margins.top),t.margins.right=Math.max(t.paddingRight,t.margins.right),t.margins.bottom=Math.max(t.paddingBottom,t.margins.bottom))},afterFit:function(){B.callback(this.options.afterFit,[this])},isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},isFullWidth:function(){return this.options.fullWidth},getRightValue:function(t){if(un(t))return NaN;if(("number"==typeof t||t instanceof Number)&&!isFinite(t))return NaN;if(t)if(this.isHorizontal()){if(void 0!==t.x)return this.getRightValue(t.x)}else if(void 0!==t.y)return this.getRightValue(t.y);return t},_convertTicksToLabels:function(t){var e,n,i,a=this;for(a.ticks=t.map((function(t){return t.value})),a.beforeTickToLabelConversion(),e=a.convertTicksToLabels(t)||a.ticks,a.afterTickToLabelConversion(),n=0,i=t.length;n<i;++n)t[n].label=e[n];return e},_getLabelSizes:function(){var t=this,e=t._labelSizes;return e||(t._labelSizes=e=fn(t.ctx,vn(t.options.ticks),t.getTicks(),t.longestTextCache),t.longestLabelWidth=e.widest.width),e},_parseValue:function(t){var e,n,i,a;return ln(t)?(e=+this.getRightValue(t[0]),n=+this.getRightValue(t[1]),i=Math.min(e,n),a=Math.max(e,n)):(e=void 0,n=t=+this.getRightValue(t),i=t,a=t),{min:i,max:a,start:e,end:n}},_getScaleLabel:function(t){var e=this._parseValue(t);return void 0!==e.start?"["+e.start+", "+e.end+"]":+this.getRightValue(t)},getLabelForIndex:B.noop,getPixelForValue:B.noop,getValueForPixel:B.noop,getPixelForTick:function(t){var e=this.options.offset,n=this._ticks.length,i=1/Math.max(n-(e?0:1),1);return t<0||t>n-1?null:this.getPixelForDecimal(t*i+(e?i/2:0))},getPixelForDecimal:function(t){return this._reversePixels&&(t=1-t),this._startPixel+t*this._length},getDecimalForPixel:function(t){var e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e},getBasePixel:function(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function(){var t=this.min,e=this.max;return this.beginAtZero?0:t<0&&e<0?e:t>0&&e>0?t:0},_autoSkip:function(t){var e,n,i,a,r=this.options.ticks,o=this._length,s=r.maxTicksLimit||o/this._tickSize()+1,l=r.major.enabled?function(t){var e,n,i=[];for(e=0,n=t.length;e<n;e++)t[e].major&&i.push(e);return i}(t):[],u=l.length,d=l[0],h=l[u-1];if(u>s)return function(t,e,n){var i,a,r=0,o=e[0];for(n=Math.ceil(n),i=0;i<t.length;i++)a=t[i],i===o?(a._index=i,o=e[++r*n]):delete a.label}(t,l,u/s),bn(t);if(i=function(t,e,n,i){var a,r,o,s,l=function(t){var e,n,i=t.length;if(i<2)return!1;for(n=t[0],e=1;e<i;++e)if(t[e]-t[e-1]!==n)return!1;return n}(t),u=(e.length-1)/i;if(!l)return Math.max(u,1);for(o=0,s=(a=B.math._factorize(l)).length-1;o<s;o++)if((r=a[o])>u)return r;return Math.max(u,1)}(l,t,0,s),u>0){for(e=0,n=u-1;e<n;e++)yn(t,i,l[e],l[e+1]);return a=u>1?(h-d)/(u-1):null,yn(t,i,B.isNullOrUndef(a)?0:d-a,d),yn(t,i,h,B.isNullOrUndef(a)?t.length:h+a),bn(t)}return yn(t,i),bn(t)},_tickSize:function(){var t=this.options.ticks,e=B.toRadians(this.labelRotation),n=Math.abs(Math.cos(e)),i=Math.abs(Math.sin(e)),a=this._getLabelSizes(),r=t.autoSkipPadding||0,o=a?a.widest.width+r:0,s=a?a.highest.height+r:0;return this.isHorizontal()?s*n>o*i?o/n:s/i:s*i<o*n?s/n:o/i},_isVisible:function(){var t,e,n,i=this.chart,a=this.options.display;if("auto"!==a)return!!a;for(t=0,e=i.data.datasets.length;t<e;++t)if(i.isDatasetVisible(t)&&((n=i.getDatasetMeta(t)).xAxisID===this.id||n.yAxisID===this.id))return!0;return!1},_computeGridLineItems:function(t){var e,n,i,a,r,o,s,l,u,d,h,c,f,g,m,p,v,b=this,y=b.chart,x=b.options,_=x.gridLines,w=x.position,k=_.offsetGridLines,M=b.isHorizontal(),S=b._ticksToDraw,D=S.length+(k?1:0),C=gn(_),P=[],T=_.drawBorder?hn(_.lineWidth,0,0):0,O=T/2,A=B._alignPixel,F=function(t){return A(y,t,T)};for("top"===w?(e=F(b.bottom),s=b.bottom-C,u=e-O,h=F(t.top)+O,f=t.bottom):"bottom"===w?(e=F(b.top),h=t.top,f=F(t.bottom)-O,s=e+O,u=b.top+C):"left"===w?(e=F(b.right),o=b.right-C,l=e-O,d=F(t.left)+O,c=t.right):(e=F(b.left),d=t.left,c=F(t.right)-O,o=e+O,l=b.left+C),n=0;n<D;++n)i=S[n]||{},un(i.label)&&n<S.length||(n===b.zeroLineIndex&&x.offset===k?(g=_.zeroLineWidth,m=_.zeroLineColor,p=_.zeroLineBorderDash||[],v=_.zeroLineBorderDashOffset||0):(g=hn(_.lineWidth,n,1),m=hn(_.color,n,"rgba(0,0,0,0.1)"),p=_.borderDash||[],v=_.borderDashOffset||0),void 0!==(a=cn(b,i._index||n,k))&&(r=A(y,a,g),M?o=l=d=c=r:s=u=h=f=r,P.push({tx1:o,ty1:s,tx2:l,ty2:u,x1:d,y1:h,x2:c,y2:f,width:g,color:m,borderDash:p,borderDashOffset:v})));return P.ticksLength=D,P.borderValue=e,P},_computeLabelItems:function(){var t,e,n,i,a,r,o,s,l,u,d,h,c=this,f=c.options,g=f.ticks,m=f.position,p=g.mirror,v=c.isHorizontal(),b=c._ticksToDraw,y=vn(g),x=g.padding,_=gn(f.gridLines),w=-B.toRadians(c.labelRotation),k=[];for("top"===m?(r=c.bottom-_-x,o=w?"left":"center"):"bottom"===m?(r=c.top+_+x,o=w?"right":"center"):"left"===m?(a=c.right-(p?0:_)-x,o=p?"left":"right"):(a=c.left+(p?0:_)+x,o=p?"right":"left"),t=0,e=b.length;t<e;++t)i=(n=b[t]).label,un(i)||(s=c.getPixelForTick(n._index||t)+g.labelOffset,u=(l=n.major?y.major:y.minor).lineHeight,d=ln(i)?i.length:1,v?(a=s,h="top"===m?((w?1:.5)-d)*u:(w?0:.5)*u):(r=s,h=(1-d)*u/2),k.push({x:a,y:r,rotation:w,label:i,font:l,textOffset:h,textAlign:o}));return k},_drawGrid:function(t){var e=this,n=e.options.gridLines;if(n.display){var i,a,r,o,s,l=e.ctx,u=e.chart,d=B._alignPixel,h=n.drawBorder?hn(n.lineWidth,0,0):0,c=e._gridLineItems||(e._gridLineItems=e._computeGridLineItems(t));for(r=0,o=c.length;r<o;++r)i=(s=c[r]).width,a=s.color,i&&a&&(l.save(),l.lineWidth=i,l.strokeStyle=a,l.setLineDash&&(l.setLineDash(s.borderDash),l.lineDashOffset=s.borderDashOffset),l.beginPath(),n.drawTicks&&(l.moveTo(s.tx1,s.ty1),l.lineTo(s.tx2,s.ty2)),n.drawOnChartArea&&(l.moveTo(s.x1,s.y1),l.lineTo(s.x2,s.y2)),l.stroke(),l.restore());if(h){var f,g,m,p,v=h,b=hn(n.lineWidth,c.ticksLength-1,1),y=c.borderValue;e.isHorizontal()?(f=d(u,e.left,v)-v/2,g=d(u,e.right,b)+b/2,m=p=y):(m=d(u,e.top,v)-v/2,p=d(u,e.bottom,b)+b/2,f=g=y),l.lineWidth=h,l.strokeStyle=hn(n.color,0),l.beginPath(),l.moveTo(f,m),l.lineTo(g,p),l.stroke()}}},_drawLabels:function(){var t=this;if(t.options.ticks.display){var e,n,i,a,r,o,s,l,u=t.ctx,d=t._labelItems||(t._labelItems=t._computeLabelItems());for(e=0,i=d.length;e<i;++e){if(o=(r=d[e]).font,u.save(),u.translate(r.x,r.y),u.rotate(r.rotation),u.font=o.string,u.fillStyle=o.color,u.textBaseline="middle",u.textAlign=r.textAlign,s=r.label,l=r.textOffset,ln(s))for(n=0,a=s.length;n<a;++n)u.fillText(""+s[n],0,l),l+=o.lineHeight;else u.fillText(s,0,l);u.restore()}}},_drawTitle:function(){var t=this,e=t.ctx,n=t.options,i=n.scaleLabel;if(i.display){var a,r,o=dn(i.fontColor,Y.global.defaultFontColor),s=B.options._parseFont(i),l=B.options.toPadding(i.padding),u=s.lineHeight/2,d=n.position,h=0;if(t.isHorizontal())a=t.left+t.width/2,r="bottom"===d?t.bottom-u-l.bottom:t.top+u+l.top;else{var c="left"===d;a=c?t.left+u+l.top:t.right-u-l.top,r=t.top+t.height/2,h=c?-.5*Math.PI:.5*Math.PI}e.save(),e.translate(a,r),e.rotate(h),e.textAlign="center",e.textBaseline="middle",e.fillStyle=o,e.font=s.string,e.fillText(i.labelString,0,0),e.restore()}},draw:function(t){this._isVisible()&&(this._drawGrid(t),this._drawTitle(),this._drawLabels())},_layers:function(){var t=this,e=t.options,n=e.ticks&&e.ticks.z||0,i=e.gridLines&&e.gridLines.z||0;return t._isVisible()&&n!==i&&t.draw===t._draw?[{z:i,draw:function(){t._drawGrid.apply(t,arguments),t._drawTitle.apply(t,arguments)}},{z:n,draw:function(){t._drawLabels.apply(t,arguments)}}]:[{z:n,draw:function(){t.draw.apply(t,arguments)}}]},_getMatchingVisibleMetas:function(t){var e=this,n=e.isHorizontal();return e.chart._getSortedVisibleDatasetMetas().filter((function(i){return(!t||i.type===t)&&(n?i.xAxisID===e.id:i.yAxisID===e.id)}))}});xn.prototype._draw=xn.prototype.draw;var _n=xn,wn=B.isNullOrUndef,kn=_n.extend({determineDataLimits:function(){var t,e=this,n=e._getLabels(),i=e.options.ticks,a=i.min,r=i.max,o=0,s=n.length-1;void 0!==a&&(t=n.indexOf(a))>=0&&(o=t),void 0!==r&&(t=n.indexOf(r))>=0&&(s=t),e.minIndex=o,e.maxIndex=s,e.min=n[o],e.max=n[s]},buildTicks:function(){var t=this._getLabels(),e=this.minIndex,n=this.maxIndex;this.ticks=0===e&&n===t.length-1?t:t.slice(e,n+1)},getLabelForIndex:function(t,e){var n=this.chart;return n.getDatasetMeta(e).controller._getValueScaleId()===this.id?this.getRightValue(n.data.datasets[e].data[t]):this._getLabels()[t]},_configure:function(){var t=this,e=t.options.offset,n=t.ticks;_n.prototype._configure.call(t),t.isHorizontal()||(t._reversePixels=!t._reversePixels),n&&(t._startValue=t.minIndex-(e?.5:0),t._valueRange=Math.max(n.length-(e?0:1),1))},getPixelForValue:function(t,e,n){var i,a,r,o=this;return wn(e)||wn(n)||(t=o.chart.data.datasets[n].data[e]),wn(t)||(i=o.isHorizontal()?t.x:t.y),(void 0!==i||void 0!==t&&isNaN(e))&&(a=o._getLabels(),t=B.valueOrDefault(i,t),e=-1!==(r=a.indexOf(t))?r:e,isNaN(e)&&(e=t)),o.getPixelForDecimal((e-o._startValue)/o._valueRange)},getPixelForTick:function(t){var e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t],t+this.minIndex)},getValueForPixel:function(t){var e=Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange);return Math.min(Math.max(e,0),this.ticks.length-1)},getBasePixel:function(){return this.bottom}}),Mn={position:"bottom"};kn._defaults=Mn;var Sn=B.noop,Dn=B.isNullOrUndef;var Cn=_n.extend({getRightValue:function(t){return"string"==typeof t?+t:_n.prototype.getRightValue.call(this,t)},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;if(e.beginAtZero){var n=B.sign(t.min),i=B.sign(t.max);n<0&&i<0?t.max=0:n>0&&i>0&&(t.min=0)}var a=void 0!==e.min||void 0!==e.suggestedMin,r=void 0!==e.max||void 0!==e.suggestedMax;void 0!==e.min?t.min=e.min:void 0!==e.suggestedMin&&(null===t.min?t.min=e.suggestedMin:t.min=Math.min(t.min,e.suggestedMin)),void 0!==e.max?t.max=e.max:void 0!==e.suggestedMax&&(null===t.max?t.max=e.suggestedMax:t.max=Math.max(t.max,e.suggestedMax)),a!==r&&t.min>=t.max&&(a?t.max=t.min+1:t.min=t.max-1),t.min===t.max&&(t.max++,e.beginAtZero||t.min--)},getTickLimit:function(){var t,e=this.options.ticks,n=e.stepSize,i=e.maxTicksLimit;return n?t=Math.ceil(this.max/n)-Math.floor(this.min/n)+1:(t=this._computeTickLimit(),i=i||11),i&&(t=Math.min(i,t)),t},_computeTickLimit:function(){return Number.POSITIVE_INFINITY},handleDirectionalChanges:Sn,buildTicks:function(){var t=this,e=t.options.ticks,n=t.getTickLimit(),i={maxTicks:n=Math.max(2,n),min:e.min,max:e.max,precision:e.precision,stepSize:B.valueOrDefault(e.fixedStepSize,e.stepSize)},a=t.ticks=function(t,e){var n,i,a,r,o=[],s=t.stepSize,l=s||1,u=t.maxTicks-1,d=t.min,h=t.max,c=t.precision,f=e.min,g=e.max,m=B.niceNum((g-f)/u/l)*l;if(m<1e-14&&Dn(d)&&Dn(h))return[f,g];(r=Math.ceil(g/m)-Math.floor(f/m))>u&&(m=B.niceNum(r*m/u/l)*l),s||Dn(c)?n=Math.pow(10,B._decimalPlaces(m)):(n=Math.pow(10,c),m=Math.ceil(m*n)/n),i=Math.floor(f/m)*m,a=Math.ceil(g/m)*m,s&&(!Dn(d)&&B.almostWhole(d/m,m/1e3)&&(i=d),!Dn(h)&&B.almostWhole(h/m,m/1e3)&&(a=h)),r=(a-i)/m,r=B.almostEquals(r,Math.round(r),m/1e3)?Math.round(r):Math.ceil(r),i=Math.round(i*n)/n,a=Math.round(a*n)/n,o.push(Dn(d)?i:d);for(var p=1;p<r;++p)o.push(Math.round((i+p*m)*n)/n);return o.push(Dn(h)?a:h),o}(i,t);t.handleDirectionalChanges(),t.max=B.max(a),t.min=B.min(a),e.reverse?(a.reverse(),t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max)},convertTicksToLabels:function(){var t=this;t.ticksAsNumbers=t.ticks.slice(),t.zeroLineIndex=t.ticks.indexOf(0),_n.prototype.convertTicksToLabels.call(t)},_configure:function(){var t,e=this,n=e.getTicks(),i=e.min,a=e.max;_n.prototype._configure.call(e),e.options.offset&&n.length&&(i-=t=(a-i)/Math.max(n.length-1,1)/2,a+=t),e._startValue=i,e._endValue=a,e._valueRange=a-i}}),Pn={position:"left",ticks:{callback:sn.formatters.linear}};function Tn(t,e,n,i){var a,r,o=t.options,s=function(t,e,n){var i=[n.type,void 0===e&&void 0===n.stack?n.index:"",n.stack].join(".");return void 0===t[i]&&(t[i]={pos:[],neg:[]}),t[i]}(e,o.stacked,n),l=s.pos,u=s.neg,d=i.length;for(a=0;a<d;++a)r=t._parseValue(i[a]),isNaN(r.min)||isNaN(r.max)||n.data[a].hidden||(l[a]=l[a]||0,u[a]=u[a]||0,o.relativePoints?l[a]=100:r.min<0||r.max<0?u[a]+=r.min:l[a]+=r.max)}function On(t,e,n){var i,a,r=n.length;for(i=0;i<r;++i)a=t._parseValue(n[i]),isNaN(a.min)||isNaN(a.max)||e.data[i].hidden||(t.min=Math.min(t.min,a.min),t.max=Math.max(t.max,a.max))}var An=Cn.extend({determineDataLimits:function(){var t,e,n,i,a=this,r=a.options,o=a.chart.data.datasets,s=a._getMatchingVisibleMetas(),l=r.stacked,u={},d=s.length;if(a.min=Number.POSITIVE_INFINITY,a.max=Number.NEGATIVE_INFINITY,void 0===l)for(t=0;!l&&t<d;++t)l=void 0!==(e=s[t]).stack;for(t=0;t<d;++t)n=o[(e=s[t]).index].data,l?Tn(a,u,e,n):On(a,e,n);B.each(u,(function(t){i=t.pos.concat(t.neg),a.min=Math.min(a.min,B.min(i)),a.max=Math.max(a.max,B.max(i))})),a.min=B.isFinite(a.min)&&!isNaN(a.min)?a.min:0,a.max=B.isFinite(a.max)&&!isNaN(a.max)?a.max:1,a.handleTickRangeOptions()},_computeTickLimit:function(){var t;return this.isHorizontal()?Math.ceil(this.width/40):(t=B.options._parseFont(this.options.ticks),Math.ceil(this.height/t.lineHeight))},handleDirectionalChanges:function(){this.isHorizontal()||this.ticks.reverse()},getLabelForIndex:function(t,e){return this._getScaleLabel(this.chart.data.datasets[e].data[t])},getPixelForValue:function(t){return this.getPixelForDecimal((+this.getRightValue(t)-this._startValue)/this._valueRange)},getValueForPixel:function(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange},getPixelForTick:function(t){var e=this.ticksAsNumbers;return t<0||t>e.length-1?null:this.getPixelForValue(e[t])}}),Fn=Pn;An._defaults=Fn;var In=B.valueOrDefault,Ln=B.math.log10;var Rn={position:"left",ticks:{callback:sn.formatters.logarithmic}};function Nn(t,e){return B.isFinite(t)&&t>=0?t:e}var Wn=_n.extend({determineDataLimits:function(){var t,e,n,i,a,r,o=this,s=o.options,l=o.chart,u=l.data.datasets,d=o.isHorizontal();function h(t){return d?t.xAxisID===o.id:t.yAxisID===o.id}o.min=Number.POSITIVE_INFINITY,o.max=Number.NEGATIVE_INFINITY,o.minNotZero=Number.POSITIVE_INFINITY;var c=s.stacked;if(void 0===c)for(t=0;t<u.length;t++)if(e=l.getDatasetMeta(t),l.isDatasetVisible(t)&&h(e)&&void 0!==e.stack){c=!0;break}if(s.stacked||c){var f={};for(t=0;t<u.length;t++){var g=[(e=l.getDatasetMeta(t)).type,void 0===s.stacked&&void 0===e.stack?t:"",e.stack].join(".");if(l.isDatasetVisible(t)&&h(e))for(void 0===f[g]&&(f[g]=[]),a=0,r=(i=u[t].data).length;a<r;a++){var m=f[g];n=o._parseValue(i[a]),isNaN(n.min)||isNaN(n.max)||e.data[a].hidden||n.min<0||n.max<0||(m[a]=m[a]||0,m[a]+=n.max)}}B.each(f,(function(t){if(t.length>0){var e=B.min(t),n=B.max(t);o.min=Math.min(o.min,e),o.max=Math.max(o.max,n)}}))}else for(t=0;t<u.length;t++)if(e=l.getDatasetMeta(t),l.isDatasetVisible(t)&&h(e))for(a=0,r=(i=u[t].data).length;a<r;a++)n=o._parseValue(i[a]),isNaN(n.min)||isNaN(n.max)||e.data[a].hidden||n.min<0||n.max<0||(o.min=Math.min(n.min,o.min),o.max=Math.max(n.max,o.max),0!==n.min&&(o.minNotZero=Math.min(n.min,o.minNotZero)));o.min=B.isFinite(o.min)?o.min:null,o.max=B.isFinite(o.max)?o.max:null,o.minNotZero=B.isFinite(o.minNotZero)?o.minNotZero:null,this.handleTickRangeOptions()},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;t.min=Nn(e.min,t.min),t.max=Nn(e.max,t.max),t.min===t.max&&(0!==t.min&&null!==t.min?(t.min=Math.pow(10,Math.floor(Ln(t.min))-1),t.max=Math.pow(10,Math.floor(Ln(t.max))+1)):(t.min=1,t.max=10)),null===t.min&&(t.min=Math.pow(10,Math.floor(Ln(t.max))-1)),null===t.max&&(t.max=0!==t.min?Math.pow(10,Math.floor(Ln(t.min))+1):10),null===t.minNotZero&&(t.min>0?t.minNotZero=t.min:t.max<1?t.minNotZero=Math.pow(10,Math.floor(Ln(t.max))):t.minNotZero=1)},buildTicks:function(){var t=this,e=t.options.ticks,n=!t.isHorizontal(),i={min:Nn(e.min),max:Nn(e.max)},a=t.ticks=function(t,e){var n,i,a=[],r=In(t.min,Math.pow(10,Math.floor(Ln(e.min)))),o=Math.floor(Ln(e.max)),s=Math.ceil(e.max/Math.pow(10,o));0===r?(n=Math.floor(Ln(e.minNotZero)),i=Math.floor(e.minNotZero/Math.pow(10,n)),a.push(r),r=i*Math.pow(10,n)):(n=Math.floor(Ln(r)),i=Math.floor(r/Math.pow(10,n)));var l=n<0?Math.pow(10,Math.abs(n)):1;do{a.push(r),10===++i&&(i=1,l=++n>=0?1:l),r=Math.round(i*Math.pow(10,n)*l)/l}while(n<o||n===o&&i<s);var u=In(t.max,r);return a.push(u),a}(i,t);t.max=B.max(a),t.min=B.min(a),e.reverse?(n=!n,t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max),n&&a.reverse()},convertTicksToLabels:function(){this.tickValues=this.ticks.slice(),_n.prototype.convertTicksToLabels.call(this)},getLabelForIndex:function(t,e){return this._getScaleLabel(this.chart.data.datasets[e].data[t])},getPixelForTick:function(t){var e=this.tickValues;return t<0||t>e.length-1?null:this.getPixelForValue(e[t])},_getFirstTickValue:function(t){var e=Math.floor(Ln(t));return Math.floor(t/Math.pow(10,e))*Math.pow(10,e)},_configure:function(){var t=this,e=t.min,n=0;_n.prototype._configure.call(t),0===e&&(e=t._getFirstTickValue(t.minNotZero),n=In(t.options.ticks.fontSize,Y.global.defaultFontSize)/t._length),t._startValue=Ln(e),t._valueOffset=n,t._valueRange=(Ln(t.max)-Ln(e))/(1-n)},getPixelForValue:function(t){var e=this,n=0;return(t=+e.getRightValue(t))>e.min&&t>0&&(n=(Ln(t)-e._startValue)/e._valueRange+e._valueOffset),e.getPixelForDecimal(n)},getValueForPixel:function(t){var e=this,n=e.getDecimalForPixel(t);return 0===n&&0===e.min?0:Math.pow(10,e._startValue+(n-e._valueOffset)*e._valueRange)}}),Yn=Rn;Wn._defaults=Yn;var zn=B.valueOrDefault,En=B.valueAtIndexOrDefault,Vn=B.options.resolve,Hn={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0,0,0,0.1)",lineWidth:1,borderDash:[],borderDashOffset:0},gridLines:{circular:!1},ticks:{showLabelBackdrop:!0,backdropColor:"rgba(255,255,255,0.75)",backdropPaddingY:2,backdropPaddingX:2,callback:sn.formatters.linear},pointLabels:{display:!0,fontSize:10,callback:function(t){return t}}};function Bn(t){var e=t.ticks;return e.display&&t.display?zn(e.fontSize,Y.global.defaultFontSize)+2*e.backdropPaddingY:0}function jn(t,e,n,i,a){return t===i||t===a?{start:e-n/2,end:e+n/2}:t<i||t>a?{start:e-n,end:e}:{start:e,end:e+n}}function Un(t){return 0===t||180===t?"center":t<180?"left":"right"}function Gn(t,e,n,i){var a,r,o=n.y+i/2;if(B.isArray(e))for(a=0,r=e.length;a<r;++a)t.fillText(e[a],n.x,o),o+=i;else t.fillText(e,n.x,o)}function qn(t,e,n){90===t||270===t?n.y-=e.h/2:(t>270||t<90)&&(n.y-=e.h)}function Zn(t){return B.isNumber(t)?t:0}var $n=Cn.extend({setDimensions:function(){var t=this;t.width=t.maxWidth,t.height=t.maxHeight,t.paddingTop=Bn(t.options)/2,t.xCenter=Math.floor(t.width/2),t.yCenter=Math.floor((t.height-t.paddingTop)/2),t.drawingArea=Math.min(t.height-t.paddingTop,t.width)/2},determineDataLimits:function(){var t=this,e=t.chart,n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;B.each(e.data.datasets,(function(a,r){if(e.isDatasetVisible(r)){var o=e.getDatasetMeta(r);B.each(a.data,(function(e,a){var r=+t.getRightValue(e);isNaN(r)||o.data[a].hidden||(n=Math.min(r,n),i=Math.max(r,i))}))}})),t.min=n===Number.POSITIVE_INFINITY?0:n,t.max=i===Number.NEGATIVE_INFINITY?0:i,t.handleTickRangeOptions()},_computeTickLimit:function(){return Math.ceil(this.drawingArea/Bn(this.options))},convertTicksToLabels:function(){var t=this;Cn.prototype.convertTicksToLabels.call(t),t.pointLabels=t.chart.data.labels.map((function(){var e=B.callback(t.options.pointLabels.callback,arguments,t);return e||0===e?e:""}))},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},fit:function(){var t=this.options;t.display&&t.pointLabels.display?function(t){var e,n,i,a=B.options._parseFont(t.options.pointLabels),r={l:0,r:t.width,t:0,b:t.height-t.paddingTop},o={};t.ctx.font=a.string,t._pointLabelSizes=[];var s,l,u,d=t.chart.data.labels.length;for(e=0;e<d;e++){i=t.getPointPosition(e,t.drawingArea+5),s=t.ctx,l=a.lineHeight,u=t.pointLabels[e],n=B.isArray(u)?{w:B.longestText(s,s.font,u),h:u.length*l}:{w:s.measureText(u).width,h:l},t._pointLabelSizes[e]=n;var h=t.getIndexAngle(e),c=B.toDegrees(h)%360,f=jn(c,i.x,n.w,0,180),g=jn(c,i.y,n.h,90,270);f.start<r.l&&(r.l=f.start,o.l=h),f.end>r.r&&(r.r=f.end,o.r=h),g.start<r.t&&(r.t=g.start,o.t=h),g.end>r.b&&(r.b=g.end,o.b=h)}t.setReductions(t.drawingArea,r,o)}(this):this.setCenterPoint(0,0,0,0)},setReductions:function(t,e,n){var i=this,a=e.l/Math.sin(n.l),r=Math.max(e.r-i.width,0)/Math.sin(n.r),o=-e.t/Math.cos(n.t),s=-Math.max(e.b-(i.height-i.paddingTop),0)/Math.cos(n.b);a=Zn(a),r=Zn(r),o=Zn(o),s=Zn(s),i.drawingArea=Math.min(Math.floor(t-(a+r)/2),Math.floor(t-(o+s)/2)),i.setCenterPoint(a,r,o,s)},setCenterPoint:function(t,e,n,i){var a=this,r=a.width-e-a.drawingArea,o=t+a.drawingArea,s=n+a.drawingArea,l=a.height-a.paddingTop-i-a.drawingArea;a.xCenter=Math.floor((o+r)/2+a.left),a.yCenter=Math.floor((s+l)/2+a.top+a.paddingTop)},getIndexAngle:function(t){var e=this.chart,n=(t*(360/e.data.labels.length)+((e.options||{}).startAngle||0))%360;return(n<0?n+360:n)*Math.PI*2/360},getDistanceFromCenterForValue:function(t){var e=this;if(B.isNullOrUndef(t))return NaN;var n=e.drawingArea/(e.max-e.min);return e.options.ticks.reverse?(e.max-t)*n:(t-e.min)*n},getPointPosition:function(t,e){var n=this.getIndexAngle(t)-Math.PI/2;return{x:Math.cos(n)*e+this.xCenter,y:Math.sin(n)*e+this.yCenter}},getPointPositionForValue:function(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))},getBasePosition:function(t){var e=this.min,n=this.max;return this.getPointPositionForValue(t||0,this.beginAtZero?0:e<0&&n<0?n:e>0&&n>0?e:0)},_drawGrid:function(){var t,e,n,i=this,a=i.ctx,r=i.options,o=r.gridLines,s=r.angleLines,l=zn(s.lineWidth,o.lineWidth),u=zn(s.color,o.color);if(r.pointLabels.display&&function(t){var e=t.ctx,n=t.options,i=n.pointLabels,a=Bn(n),r=t.getDistanceFromCenterForValue(n.ticks.reverse?t.min:t.max),o=B.options._parseFont(i);e.save(),e.font=o.string,e.textBaseline="middle";for(var s=t.chart.data.labels.length-1;s>=0;s--){var l=0===s?a/2:0,u=t.getPointPosition(s,r+l+5),d=En(i.fontColor,s,Y.global.defaultFontColor);e.fillStyle=d;var h=t.getIndexAngle(s),c=B.toDegrees(h);e.textAlign=Un(c),qn(c,t._pointLabelSizes[s],u),Gn(e,t.pointLabels[s],u,o.lineHeight)}e.restore()}(i),o.display&&B.each(i.ticks,(function(t,n){0!==n&&(e=i.getDistanceFromCenterForValue(i.ticksAsNumbers[n]),function(t,e,n,i){var a,r=t.ctx,o=e.circular,s=t.chart.data.labels.length,l=En(e.color,i-1),u=En(e.lineWidth,i-1);if((o||s)&&l&&u){if(r.save(),r.strokeStyle=l,r.lineWidth=u,r.setLineDash&&(r.setLineDash(e.borderDash||[]),r.lineDashOffset=e.borderDashOffset||0),r.beginPath(),o)r.arc(t.xCenter,t.yCenter,n,0,2*Math.PI);else{a=t.getPointPosition(0,n),r.moveTo(a.x,a.y);for(var d=1;d<s;d++)a=t.getPointPosition(d,n),r.lineTo(a.x,a.y)}r.closePath(),r.stroke(),r.restore()}}(i,o,e,n))})),s.display&&l&&u){for(a.save(),a.lineWidth=l,a.strokeStyle=u,a.setLineDash&&(a.setLineDash(Vn([s.borderDash,o.borderDash,[]])),a.lineDashOffset=Vn([s.borderDashOffset,o.borderDashOffset,0])),t=i.chart.data.labels.length-1;t>=0;t--)e=i.getDistanceFromCenterForValue(r.ticks.reverse?i.min:i.max),n=i.getPointPosition(t,e),a.beginPath(),a.moveTo(i.xCenter,i.yCenter),a.lineTo(n.x,n.y),a.stroke();a.restore()}},_drawLabels:function(){var t=this,e=t.ctx,n=t.options.ticks;if(n.display){var i,a,r=t.getIndexAngle(0),o=B.options._parseFont(n),s=zn(n.fontColor,Y.global.defaultFontColor);e.save(),e.font=o.string,e.translate(t.xCenter,t.yCenter),e.rotate(r),e.textAlign="center",e.textBaseline="middle",B.each(t.ticks,(function(r,l){(0!==l||n.reverse)&&(i=t.getDistanceFromCenterForValue(t.ticksAsNumbers[l]),n.showLabelBackdrop&&(a=e.measureText(r).width,e.fillStyle=n.backdropColor,e.fillRect(-a/2-n.backdropPaddingX,-i-o.size/2-n.backdropPaddingY,a+2*n.backdropPaddingX,o.size+2*n.backdropPaddingY)),e.fillStyle=s,e.fillText(r,0,-i))})),e.restore()}},_drawTitle:B.noop}),Xn=Hn;$n._defaults=Xn;var Kn=B._deprecated,Jn=B.options.resolve,Qn=B.valueOrDefault,ti=Number.MIN_SAFE_INTEGER||-9007199254740991,ei=Number.MAX_SAFE_INTEGER||9007199254740991,ni={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},ii=Object.keys(ni);function ai(t,e){return t-e}function ri(t){return B.valueOrDefault(t.time.min,t.ticks.min)}function oi(t){return B.valueOrDefault(t.time.max,t.ticks.max)}function si(t,e,n,i){var a=function(t,e,n){for(var i,a,r,o=0,s=t.length-1;o>=0&&o<=s;){if(a=t[(i=o+s>>1)-1]||null,r=t[i],!a)return{lo:null,hi:r};if(r[e]<n)o=i+1;else{if(!(a[e]>n))return{lo:a,hi:r};s=i-1}}return{lo:r,hi:null}}(t,e,n),r=a.lo?a.hi?a.lo:t[t.length-2]:t[0],o=a.lo?a.hi?a.hi:t[t.length-1]:t[1],s=o[e]-r[e],l=s?(n-r[e])/s:0,u=(o[i]-r[i])*l;return r[i]+u}function li(t,e){var n=t._adapter,i=t.options.time,a=i.parser,r=a||i.format,o=e;return"function"==typeof a&&(o=a(o)),B.isFinite(o)||(o="string"==typeof r?n.parse(o,r):n.parse(o)),null!==o?+o:(a||"function"!=typeof r||(o=r(e),B.isFinite(o)||(o=n.parse(o))),o)}function ui(t,e){if(B.isNullOrUndef(e))return null;var n=t.options.time,i=li(t,t.getRightValue(e));return null===i?i:(n.round&&(i=+t._adapter.startOf(i,n.round)),i)}function di(t,e,n,i){var a,r,o,s=ii.length;for(a=ii.indexOf(t);a<s-1;++a)if(o=(r=ni[ii[a]]).steps?r.steps:ei,r.common&&Math.ceil((n-e)/(o*r.size))<=i)return ii[a];return ii[s-1]}function hi(t,e,n){var i,a,r=[],o={},s=e.length;for(i=0;i<s;++i)o[a=e[i]]=i,r.push({value:a,major:!1});return 0!==s&&n?function(t,e,n,i){var a,r,o=t._adapter,s=+o.startOf(e[0].value,i),l=e[e.length-1].value;for(a=s;a<=l;a=+o.add(a,1,i))(r=n[a])>=0&&(e[r].major=!0);return e}(t,r,o,n):r}var ci=_n.extend({initialize:function(){this.mergeTicksOptions(),_n.prototype.initialize.call(this)},update:function(){var t=this,e=t.options,n=e.time||(e.time={}),i=t._adapter=new on._date(e.adapters.date);return Kn("time scale",n.format,"time.format","time.parser"),Kn("time scale",n.min,"time.min","ticks.min"),Kn("time scale",n.max,"time.max","ticks.max"),B.mergeIf(n.displayFormats,i.formats()),_n.prototype.update.apply(t,arguments)},getRightValue:function(t){return t&&void 0!==t.t&&(t=t.t),_n.prototype.getRightValue.call(this,t)},determineDataLimits:function(){var t,e,n,i,a,r,o,s=this,l=s.chart,u=s._adapter,d=s.options,h=d.time.unit||"day",c=ei,f=ti,g=[],m=[],p=[],v=s._getLabels();for(t=0,n=v.length;t<n;++t)p.push(ui(s,v[t]));for(t=0,n=(l.data.datasets||[]).length;t<n;++t)if(l.isDatasetVisible(t))if(a=l.data.datasets[t].data,B.isObject(a[0]))for(m[t]=[],e=0,i=a.length;e<i;++e)r=ui(s,a[e]),g.push(r),m[t][e]=r;else m[t]=p.slice(0),o||(g=g.concat(p),o=!0);else m[t]=[];p.length&&(c=Math.min(c,p[0]),f=Math.max(f,p[p.length-1])),g.length&&(g=n>1?function(t){var e,n,i,a={},r=[];for(e=0,n=t.length;e<n;++e)a[i=t[e]]||(a[i]=!0,r.push(i));return r}(g).sort(ai):g.sort(ai),c=Math.min(c,g[0]),f=Math.max(f,g[g.length-1])),c=ui(s,ri(d))||c,f=ui(s,oi(d))||f,c=c===ei?+u.startOf(Date.now(),h):c,f=f===ti?+u.endOf(Date.now(),h)+1:f,s.min=Math.min(c,f),s.max=Math.max(c+1,f),s._table=[],s._timestamps={data:g,datasets:m,labels:p}},buildTicks:function(){var t,e,n,i=this,a=i.min,r=i.max,o=i.options,s=o.ticks,l=o.time,u=i._timestamps,d=[],h=i.getLabelCapacity(a),c=s.source,f=o.distribution;for(u="data"===c||"auto"===c&&"series"===f?u.data:"labels"===c?u.labels:function(t,e,n,i){var a,r=t._adapter,o=t.options,s=o.time,l=s.unit||di(s.minUnit,e,n,i),u=Jn([s.stepSize,s.unitStepSize,1]),d="week"===l&&s.isoWeekday,h=e,c=[];if(d&&(h=+r.startOf(h,"isoWeek",d)),h=+r.startOf(h,d?"day":l),r.diff(n,e,l)>1e5*u)throw e+" and "+n+" are too far apart with stepSize of "+u+" "+l;for(a=h;a<n;a=+r.add(a,u,l))c.push(a);return a!==n&&"ticks"!==o.bounds||c.push(a),c}(i,a,r,h),"ticks"===o.bounds&&u.length&&(a=u[0],r=u[u.length-1]),a=ui(i,ri(o))||a,r=ui(i,oi(o))||r,t=0,e=u.length;t<e;++t)(n=u[t])>=a&&n<=r&&d.push(n);return i.min=a,i.max=r,i._unit=l.unit||(s.autoSkip?di(l.minUnit,i.min,i.max,h):function(t,e,n,i,a){var r,o;for(r=ii.length-1;r>=ii.indexOf(n);r--)if(o=ii[r],ni[o].common&&t._adapter.diff(a,i,o)>=e-1)return o;return ii[n?ii.indexOf(n):0]}(i,d.length,l.minUnit,i.min,i.max)),i._majorUnit=s.major.enabled&&"year"!==i._unit?function(t){for(var e=ii.indexOf(t)+1,n=ii.length;e<n;++e)if(ni[ii[e]].common)return ii[e]}(i._unit):void 0,i._table=function(t,e,n,i){if("linear"===i||!t.length)return[{time:e,pos:0},{time:n,pos:1}];var a,r,o,s,l,u=[],d=[e];for(a=0,r=t.length;a<r;++a)(s=t[a])>e&&s<n&&d.push(s);for(d.push(n),a=0,r=d.length;a<r;++a)l=d[a+1],o=d[a-1],s=d[a],void 0!==o&&void 0!==l&&Math.round((l+o)/2)===s||u.push({time:s,pos:a/(r-1)});return u}(i._timestamps.data,a,r,f),i._offsets=function(t,e,n,i,a){var r,o,s=0,l=0;return a.offset&&e.length&&(r=si(t,"time",e[0],"pos"),s=1===e.length?1-r:(si(t,"time",e[1],"pos")-r)/2,o=si(t,"time",e[e.length-1],"pos"),l=1===e.length?o:(o-si(t,"time",e[e.length-2],"pos"))/2),{start:s,end:l,factor:1/(s+1+l)}}(i._table,d,0,0,o),s.reverse&&d.reverse(),hi(i,d,i._majorUnit)},getLabelForIndex:function(t,e){var n=this,i=n._adapter,a=n.chart.data,r=n.options.time,o=a.labels&&t<a.labels.length?a.labels[t]:"",s=a.datasets[e].data[t];return B.isObject(s)&&(o=n.getRightValue(s)),r.tooltipFormat?i.format(li(n,o),r.tooltipFormat):"string"==typeof o?o:i.format(li(n,o),r.displayFormats.datetime)},tickFormatFunction:function(t,e,n,i){var a=this._adapter,r=this.options,o=r.time.displayFormats,s=o[this._unit],l=this._majorUnit,u=o[l],d=n[e],h=r.ticks,c=l&&u&&d&&d.major,f=a.format(t,i||(c?u:s)),g=c?h.major:h.minor,m=Jn([g.callback,g.userCallback,h.callback,h.userCallback]);return m?m(f,e,n):f},convertTicksToLabels:function(t){var e,n,i=[];for(e=0,n=t.length;e<n;++e)i.push(this.tickFormatFunction(t[e].value,e,t));return i},getPixelForOffset:function(t){var e=this._offsets,n=si(this._table,"time",t,"pos");return this.getPixelForDecimal((e.start+n)*e.factor)},getPixelForValue:function(t,e,n){var i=null;if(void 0!==e&&void 0!==n&&(i=this._timestamps.datasets[n][e]),null===i&&(i=ui(this,t)),null!==i)return this.getPixelForOffset(i)},getPixelForTick:function(t){var e=this.getTicks();return t>=0&&t<e.length?this.getPixelForOffset(e[t].value):null},getValueForPixel:function(t){var e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end,i=si(this._table,"pos",n,"time");return this._adapter._create(i)},_getLabelSize:function(t){var e=this.options.ticks,n=this.ctx.measureText(t).width,i=B.toRadians(this.isHorizontal()?e.maxRotation:e.minRotation),a=Math.cos(i),r=Math.sin(i),o=Qn(e.fontSize,Y.global.defaultFontSize);return{w:n*a+o*r,h:n*r+o*a}},getLabelWidth:function(t){return this._getLabelSize(t).w},getLabelCapacity:function(t){var e=this,n=e.options.time,i=n.displayFormats,a=i[n.unit]||i.millisecond,r=e.tickFormatFunction(t,0,hi(e,[t],e._majorUnit),a),o=e._getLabelSize(r),s=Math.floor(e.isHorizontal()?e.width/o.w:e.height/o.h);return e.options.offset&&s--,s>0?s:1}}),fi={position:"bottom",distribution:"linear",bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,displayFormat:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{autoSkip:!1,source:"auto",major:{enabled:!1}}};ci._defaults=fi;var gi={category:kn,linear:An,logarithmic:Wn,radialLinear:$n,time:ci},mi=e((function(e,n){e.exports=function(){var n,i;function a(){return n.apply(null,arguments)}function r(t){return t instanceof Array||"[object Array]"===Object.prototype.toString.call(t)}function o(t){return null!=t&&"[object Object]"===Object.prototype.toString.call(t)}function s(t){return void 0===t}function l(t){return"number"==typeof t||"[object Number]"===Object.prototype.toString.call(t)}function u(t){return t instanceof Date||"[object Date]"===Object.prototype.toString.call(t)}function d(t,e){var n,i=[];for(n=0;n<t.length;++n)i.push(e(t[n],n));return i}function h(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function c(t,e){for(var n in e)h(e,n)&&(t[n]=e[n]);return h(e,"toString")&&(t.toString=e.toString),h(e,"valueOf")&&(t.valueOf=e.valueOf),t}function f(t,e,n,i){return Ie(t,e,n,i,!0).utc()}function g(t){return null==t._pf&&(t._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),t._pf}function m(t){if(null==t._isValid){var e=g(t),n=i.call(e.parsedDateParts,(function(t){return null!=t})),a=!isNaN(t._d.getTime())&&e.overflow<0&&!e.empty&&!e.invalidMonth&&!e.invalidWeekday&&!e.weekdayMismatch&&!e.nullInput&&!e.invalidFormat&&!e.userInvalidated&&(!e.meridiem||e.meridiem&&n);if(t._strict&&(a=a&&0===e.charsLeftOver&&0===e.unusedTokens.length&&void 0===e.bigHour),null!=Object.isFrozen&&Object.isFrozen(t))return a;t._isValid=a}return t._isValid}function p(t){var e=f(NaN);return null!=t?c(g(e),t):g(e).userInvalidated=!0,e}i=Array.prototype.some?Array.prototype.some:function(t){for(var e=Object(this),n=e.length>>>0,i=0;i<n;i++)if(i in e&&t.call(this,e[i],i,e))return!0;return!1};var v=a.momentProperties=[];function b(t,e){var n,i,a;if(s(e._isAMomentObject)||(t._isAMomentObject=e._isAMomentObject),s(e._i)||(t._i=e._i),s(e._f)||(t._f=e._f),s(e._l)||(t._l=e._l),s(e._strict)||(t._strict=e._strict),s(e._tzm)||(t._tzm=e._tzm),s(e._isUTC)||(t._isUTC=e._isUTC),s(e._offset)||(t._offset=e._offset),s(e._pf)||(t._pf=g(e)),s(e._locale)||(t._locale=e._locale),v.length>0)for(n=0;n<v.length;n++)s(a=e[i=v[n]])||(t[i]=a);return t}var y=!1;function x(t){b(this,t),this._d=new Date(null!=t._d?t._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===y&&(y=!0,a.updateOffset(this),y=!1)}function _(t){return t instanceof x||null!=t&&null!=t._isAMomentObject}function w(t){return t<0?Math.ceil(t)||0:Math.floor(t)}function k(t){var e=+t,n=0;return 0!==e&&isFinite(e)&&(n=w(e)),n}function M(t,e,n){var i,a=Math.min(t.length,e.length),r=Math.abs(t.length-e.length),o=0;for(i=0;i<a;i++)(n&&t[i]!==e[i]||!n&&k(t[i])!==k(e[i]))&&o++;return o+r}function S(t){!1===a.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+t)}function D(t,e){var n=!0;return c((function(){if(null!=a.deprecationHandler&&a.deprecationHandler(null,t),n){for(var i,r=[],o=0;o<arguments.length;o++){if(i="","object"==typeof arguments[o]){for(var s in i+="\n["+o+"] ",arguments[0])i+=s+": "+arguments[0][s]+", ";i=i.slice(0,-2)}else i=arguments[o];r.push(i)}S(t+"\nArguments: "+Array.prototype.slice.call(r).join("")+"\n"+(new Error).stack),n=!1}return e.apply(this,arguments)}),e)}var C,P={};function T(t,e){null!=a.deprecationHandler&&a.deprecationHandler(t,e),P[t]||(S(e),P[t]=!0)}function O(t){return t instanceof Function||"[object Function]"===Object.prototype.toString.call(t)}function A(t,e){var n,i=c({},t);for(n in e)h(e,n)&&(o(t[n])&&o(e[n])?(i[n]={},c(i[n],t[n]),c(i[n],e[n])):null!=e[n]?i[n]=e[n]:delete i[n]);for(n in t)h(t,n)&&!h(e,n)&&o(t[n])&&(i[n]=c({},i[n]));return i}function F(t){null!=t&&this.set(t)}a.suppressDeprecationWarnings=!1,a.deprecationHandler=null,C=Object.keys?Object.keys:function(t){var e,n=[];for(e in t)h(t,e)&&n.push(e);return n};var I={};function L(t,e){var n=t.toLowerCase();I[n]=I[n+"s"]=I[e]=t}function R(t){return"string"==typeof t?I[t]||I[t.toLowerCase()]:void 0}function N(t){var e,n,i={};for(n in t)h(t,n)&&(e=R(n))&&(i[e]=t[n]);return i}var W={};function Y(t,e){W[t]=e}function z(t,e,n){var i=""+Math.abs(t),a=e-i.length;return(t>=0?n?"+":"":"-")+Math.pow(10,Math.max(0,a)).toString().substr(1)+i}var E=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,V=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,H={},B={};function j(t,e,n,i){var a=i;"string"==typeof i&&(a=function(){return this[i]()}),t&&(B[t]=a),e&&(B[e[0]]=function(){return z(a.apply(this,arguments),e[1],e[2])}),n&&(B[n]=function(){return this.localeData().ordinal(a.apply(this,arguments),t)})}function U(t,e){return t.isValid()?(e=G(e,t.localeData()),H[e]=H[e]||function(t){var e,n,i,a=t.match(E);for(e=0,n=a.length;e<n;e++)B[a[e]]?a[e]=B[a[e]]:a[e]=(i=a[e]).match(/\[[\s\S]/)?i.replace(/^\[|\]$/g,""):i.replace(/\\/g,"");return function(e){var i,r="";for(i=0;i<n;i++)r+=O(a[i])?a[i].call(e,t):a[i];return r}}(e),H[e](t)):t.localeData().invalidDate()}function G(t,e){var n=5;function i(t){return e.longDateFormat(t)||t}for(V.lastIndex=0;n>=0&&V.test(t);)t=t.replace(V,i),V.lastIndex=0,n-=1;return t}var q=/\d/,Z=/\d\d/,$=/\d{3}/,X=/\d{4}/,K=/[+-]?\d{6}/,J=/\d\d?/,Q=/\d\d\d\d?/,tt=/\d\d\d\d\d\d?/,et=/\d{1,3}/,nt=/\d{1,4}/,it=/[+-]?\d{1,6}/,at=/\d+/,rt=/[+-]?\d+/,ot=/Z|[+-]\d\d:?\d\d/gi,st=/Z|[+-]\d\d(?::?\d\d)?/gi,lt=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,ut={};function dt(t,e,n){ut[t]=O(e)?e:function(t,i){return t&&n?n:e}}function ht(t,e){return h(ut,t)?ut[t](e._strict,e._locale):new RegExp(ct(t.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,(function(t,e,n,i,a){return e||n||i||a}))))}function ct(t){return t.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var ft={};function gt(t,e){var n,i=e;for("string"==typeof t&&(t=[t]),l(e)&&(i=function(t,n){n[e]=k(t)}),n=0;n<t.length;n++)ft[t[n]]=i}function mt(t,e){gt(t,(function(t,n,i,a){i._w=i._w||{},e(t,i._w,i,a)}))}function pt(t,e,n){null!=e&&h(ft,t)&&ft[t](e,n._a,n,t)}var vt=0,bt=1,yt=2,xt=3,_t=4,wt=5,kt=6,Mt=7,St=8;function Dt(t){return Ct(t)?366:365}function Ct(t){return t%4==0&&t%100!=0||t%400==0}j("Y",0,0,(function(){var t=this.year();return t<=9999?""+t:"+"+t})),j(0,["YY",2],0,(function(){return this.year()%100})),j(0,["YYYY",4],0,"year"),j(0,["YYYYY",5],0,"year"),j(0,["YYYYYY",6,!0],0,"year"),L("year","y"),Y("year",1),dt("Y",rt),dt("YY",J,Z),dt("YYYY",nt,X),dt("YYYYY",it,K),dt("YYYYYY",it,K),gt(["YYYYY","YYYYYY"],vt),gt("YYYY",(function(t,e){e[vt]=2===t.length?a.parseTwoDigitYear(t):k(t)})),gt("YY",(function(t,e){e[vt]=a.parseTwoDigitYear(t)})),gt("Y",(function(t,e){e[vt]=parseInt(t,10)})),a.parseTwoDigitYear=function(t){return k(t)+(k(t)>68?1900:2e3)};var Pt,Tt=Ot("FullYear",!0);function Ot(t,e){return function(n){return null!=n?(Ft(this,t,n),a.updateOffset(this,e),this):At(this,t)}}function At(t,e){return t.isValid()?t._d["get"+(t._isUTC?"UTC":"")+e]():NaN}function Ft(t,e,n){t.isValid()&&!isNaN(n)&&("FullYear"===e&&Ct(t.year())&&1===t.month()&&29===t.date()?t._d["set"+(t._isUTC?"UTC":"")+e](n,t.month(),It(n,t.month())):t._d["set"+(t._isUTC?"UTC":"")+e](n))}function It(t,e){if(isNaN(t)||isNaN(e))return NaN;var n=function(t,e){return(t%e+e)%e}(e,12);return t+=(e-n)/12,1===n?Ct(t)?29:28:31-n%7%2}Pt=Array.prototype.indexOf?Array.prototype.indexOf:function(t){var e;for(e=0;e<this.length;++e)if(this[e]===t)return e;return-1},j("M",["MM",2],"Mo",(function(){return this.month()+1})),j("MMM",0,0,(function(t){return this.localeData().monthsShort(this,t)})),j("MMMM",0,0,(function(t){return this.localeData().months(this,t)})),L("month","M"),Y("month",8),dt("M",J),dt("MM",J,Z),dt("MMM",(function(t,e){return e.monthsShortRegex(t)})),dt("MMMM",(function(t,e){return e.monthsRegex(t)})),gt(["M","MM"],(function(t,e){e[bt]=k(t)-1})),gt(["MMM","MMMM"],(function(t,e,n,i){var a=n._locale.monthsParse(t,i,n._strict);null!=a?e[bt]=a:g(n).invalidMonth=t}));var Lt=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Rt="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Nt="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Wt(t,e,n){var i,a,r,o=t.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],i=0;i<12;++i)r=f([2e3,i]),this._shortMonthsParse[i]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[i]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===e?-1!==(a=Pt.call(this._shortMonthsParse,o))?a:null:-1!==(a=Pt.call(this._longMonthsParse,o))?a:null:"MMM"===e?-1!==(a=Pt.call(this._shortMonthsParse,o))?a:-1!==(a=Pt.call(this._longMonthsParse,o))?a:null:-1!==(a=Pt.call(this._longMonthsParse,o))?a:-1!==(a=Pt.call(this._shortMonthsParse,o))?a:null}function Yt(t,e){var n;if(!t.isValid())return t;if("string"==typeof e)if(/^\d+$/.test(e))e=k(e);else if(!l(e=t.localeData().monthsParse(e)))return t;return n=Math.min(t.date(),It(t.year(),e)),t._d["set"+(t._isUTC?"UTC":"")+"Month"](e,n),t}function zt(t){return null!=t?(Yt(this,t),a.updateOffset(this,!0),this):At(this,"Month")}var Et=lt,Vt=lt;function Ht(){function t(t,e){return e.length-t.length}var e,n,i=[],a=[],r=[];for(e=0;e<12;e++)n=f([2e3,e]),i.push(this.monthsShort(n,"")),a.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(i.sort(t),a.sort(t),r.sort(t),e=0;e<12;e++)i[e]=ct(i[e]),a[e]=ct(a[e]);for(e=0;e<24;e++)r[e]=ct(r[e]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+a.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+i.join("|")+")","i")}function Bt(t,e,n,i,a,r,o){var s;return t<100&&t>=0?(s=new Date(t+400,e,n,i,a,r,o),isFinite(s.getFullYear())&&s.setFullYear(t)):s=new Date(t,e,n,i,a,r,o),s}function jt(t){var e;if(t<100&&t>=0){var n=Array.prototype.slice.call(arguments);n[0]=t+400,e=new Date(Date.UTC.apply(null,n)),isFinite(e.getUTCFullYear())&&e.setUTCFullYear(t)}else e=new Date(Date.UTC.apply(null,arguments));return e}function Ut(t,e,n){var i=7+e-n;return-(7+jt(t,0,i).getUTCDay()-e)%7+i-1}function Gt(t,e,n,i,a){var r,o,s=1+7*(e-1)+(7+n-i)%7+Ut(t,i,a);return s<=0?o=Dt(r=t-1)+s:s>Dt(t)?(r=t+1,o=s-Dt(t)):(r=t,o=s),{year:r,dayOfYear:o}}function qt(t,e,n){var i,a,r=Ut(t.year(),e,n),o=Math.floor((t.dayOfYear()-r-1)/7)+1;return o<1?i=o+Zt(a=t.year()-1,e,n):o>Zt(t.year(),e,n)?(i=o-Zt(t.year(),e,n),a=t.year()+1):(a=t.year(),i=o),{week:i,year:a}}function Zt(t,e,n){var i=Ut(t,e,n),a=Ut(t+1,e,n);return(Dt(t)-i+a)/7}function $t(t,e){return t.slice(e,7).concat(t.slice(0,e))}j("w",["ww",2],"wo","week"),j("W",["WW",2],"Wo","isoWeek"),L("week","w"),L("isoWeek","W"),Y("week",5),Y("isoWeek",5),dt("w",J),dt("ww",J,Z),dt("W",J),dt("WW",J,Z),mt(["w","ww","W","WW"],(function(t,e,n,i){e[i.substr(0,1)]=k(t)})),j("d",0,"do","day"),j("dd",0,0,(function(t){return this.localeData().weekdaysMin(this,t)})),j("ddd",0,0,(function(t){return this.localeData().weekdaysShort(this,t)})),j("dddd",0,0,(function(t){return this.localeData().weekdays(this,t)})),j("e",0,0,"weekday"),j("E",0,0,"isoWeekday"),L("day","d"),L("weekday","e"),L("isoWeekday","E"),Y("day",11),Y("weekday",11),Y("isoWeekday",11),dt("d",J),dt("e",J),dt("E",J),dt("dd",(function(t,e){return e.weekdaysMinRegex(t)})),dt("ddd",(function(t,e){return e.weekdaysShortRegex(t)})),dt("dddd",(function(t,e){return e.weekdaysRegex(t)})),mt(["dd","ddd","dddd"],(function(t,e,n,i){var a=n._locale.weekdaysParse(t,i,n._strict);null!=a?e.d=a:g(n).invalidWeekday=t})),mt(["d","e","E"],(function(t,e,n,i){e[i]=k(t)}));var Xt="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),Kt="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Jt="Su_Mo_Tu_We_Th_Fr_Sa".split("_");function Qt(t,e,n){var i,a,r,o=t.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],i=0;i<7;++i)r=f([2e3,1]).day(i),this._minWeekdaysParse[i]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[i]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[i]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===e?-1!==(a=Pt.call(this._weekdaysParse,o))?a:null:"ddd"===e?-1!==(a=Pt.call(this._shortWeekdaysParse,o))?a:null:-1!==(a=Pt.call(this._minWeekdaysParse,o))?a:null:"dddd"===e?-1!==(a=Pt.call(this._weekdaysParse,o))?a:-1!==(a=Pt.call(this._shortWeekdaysParse,o))?a:-1!==(a=Pt.call(this._minWeekdaysParse,o))?a:null:"ddd"===e?-1!==(a=Pt.call(this._shortWeekdaysParse,o))?a:-1!==(a=Pt.call(this._weekdaysParse,o))?a:-1!==(a=Pt.call(this._minWeekdaysParse,o))?a:null:-1!==(a=Pt.call(this._minWeekdaysParse,o))?a:-1!==(a=Pt.call(this._weekdaysParse,o))?a:-1!==(a=Pt.call(this._shortWeekdaysParse,o))?a:null}var te=lt,ee=lt,ne=lt;function ie(){function t(t,e){return e.length-t.length}var e,n,i,a,r,o=[],s=[],l=[],u=[];for(e=0;e<7;e++)n=f([2e3,1]).day(e),i=this.weekdaysMin(n,""),a=this.weekdaysShort(n,""),r=this.weekdays(n,""),o.push(i),s.push(a),l.push(r),u.push(i),u.push(a),u.push(r);for(o.sort(t),s.sort(t),l.sort(t),u.sort(t),e=0;e<7;e++)s[e]=ct(s[e]),l[e]=ct(l[e]),u[e]=ct(u[e]);this._weekdaysRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+s.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+o.join("|")+")","i")}function ae(){return this.hours()%12||12}function re(t,e){j(t,0,0,(function(){return this.localeData().meridiem(this.hours(),this.minutes(),e)}))}function oe(t,e){return e._meridiemParse}j("H",["HH",2],0,"hour"),j("h",["hh",2],0,ae),j("k",["kk",2],0,(function(){return this.hours()||24})),j("hmm",0,0,(function(){return""+ae.apply(this)+z(this.minutes(),2)})),j("hmmss",0,0,(function(){return""+ae.apply(this)+z(this.minutes(),2)+z(this.seconds(),2)})),j("Hmm",0,0,(function(){return""+this.hours()+z(this.minutes(),2)})),j("Hmmss",0,0,(function(){return""+this.hours()+z(this.minutes(),2)+z(this.seconds(),2)})),re("a",!0),re("A",!1),L("hour","h"),Y("hour",13),dt("a",oe),dt("A",oe),dt("H",J),dt("h",J),dt("k",J),dt("HH",J,Z),dt("hh",J,Z),dt("kk",J,Z),dt("hmm",Q),dt("hmmss",tt),dt("Hmm",Q),dt("Hmmss",tt),gt(["H","HH"],xt),gt(["k","kk"],(function(t,e,n){var i=k(t);e[xt]=24===i?0:i})),gt(["a","A"],(function(t,e,n){n._isPm=n._locale.isPM(t),n._meridiem=t})),gt(["h","hh"],(function(t,e,n){e[xt]=k(t),g(n).bigHour=!0})),gt("hmm",(function(t,e,n){var i=t.length-2;e[xt]=k(t.substr(0,i)),e[_t]=k(t.substr(i)),g(n).bigHour=!0})),gt("hmmss",(function(t,e,n){var i=t.length-4,a=t.length-2;e[xt]=k(t.substr(0,i)),e[_t]=k(t.substr(i,2)),e[wt]=k(t.substr(a)),g(n).bigHour=!0})),gt("Hmm",(function(t,e,n){var i=t.length-2;e[xt]=k(t.substr(0,i)),e[_t]=k(t.substr(i))})),gt("Hmmss",(function(t,e,n){var i=t.length-4,a=t.length-2;e[xt]=k(t.substr(0,i)),e[_t]=k(t.substr(i,2)),e[wt]=k(t.substr(a))}));var se,le=Ot("Hours",!0),ue={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Rt,monthsShort:Nt,week:{dow:0,doy:6},weekdays:Xt,weekdaysMin:Jt,weekdaysShort:Kt,meridiemParse:/[ap]\.?m?\.?/i},de={},he={};function ce(t){return t?t.toLowerCase().replace("_","-"):t}function fe(n){var i=null;if(!de[n]&&e&&e.exports)try{i=se._abbr,t(),ge(i)}catch(t){}return de[n]}function ge(t,e){var n;return t&&((n=s(e)?pe(t):me(t,e))?se=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+t+" not found. Did you forget to load it?")),se._abbr}function me(t,e){if(null!==e){var n,i=ue;if(e.abbr=t,null!=de[t])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),i=de[t]._config;else if(null!=e.parentLocale)if(null!=de[e.parentLocale])i=de[e.parentLocale]._config;else{if(null==(n=fe(e.parentLocale)))return he[e.parentLocale]||(he[e.parentLocale]=[]),he[e.parentLocale].push({name:t,config:e}),null;i=n._config}return de[t]=new F(A(i,e)),he[t]&&he[t].forEach((function(t){me(t.name,t.config)})),ge(t),de[t]}return delete de[t],null}function pe(t){var e;if(t&&t._locale&&t._locale._abbr&&(t=t._locale._abbr),!t)return se;if(!r(t)){if(e=fe(t))return e;t=[t]}return function(t){for(var e,n,i,a,r=0;r<t.length;){for(e=(a=ce(t[r]).split("-")).length,n=(n=ce(t[r+1]))?n.split("-"):null;e>0;){if(i=fe(a.slice(0,e).join("-")))return i;if(n&&n.length>=e&&M(a,n,!0)>=e-1)break;e--}r++}return se}(t)}function ve(t){var e,n=t._a;return n&&-2===g(t).overflow&&(e=n[bt]<0||n[bt]>11?bt:n[yt]<1||n[yt]>It(n[vt],n[bt])?yt:n[xt]<0||n[xt]>24||24===n[xt]&&(0!==n[_t]||0!==n[wt]||0!==n[kt])?xt:n[_t]<0||n[_t]>59?_t:n[wt]<0||n[wt]>59?wt:n[kt]<0||n[kt]>999?kt:-1,g(t)._overflowDayOfYear&&(e<vt||e>yt)&&(e=yt),g(t)._overflowWeeks&&-1===e&&(e=Mt),g(t)._overflowWeekday&&-1===e&&(e=St),g(t).overflow=e),t}function be(t,e,n){return null!=t?t:null!=e?e:n}function ye(t){var e,n,i,r,o,s=[];if(!t._d){for(i=function(t){var e=new Date(a.now());return t._useUTC?[e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate()]:[e.getFullYear(),e.getMonth(),e.getDate()]}(t),t._w&&null==t._a[yt]&&null==t._a[bt]&&function(t){var e,n,i,a,r,o,s,l;if(null!=(e=t._w).GG||null!=e.W||null!=e.E)r=1,o=4,n=be(e.GG,t._a[vt],qt(Le(),1,4).year),i=be(e.W,1),((a=be(e.E,1))<1||a>7)&&(l=!0);else{r=t._locale._week.dow,o=t._locale._week.doy;var u=qt(Le(),r,o);n=be(e.gg,t._a[vt],u.year),i=be(e.w,u.week),null!=e.d?((a=e.d)<0||a>6)&&(l=!0):null!=e.e?(a=e.e+r,(e.e<0||e.e>6)&&(l=!0)):a=r}i<1||i>Zt(n,r,o)?g(t)._overflowWeeks=!0:null!=l?g(t)._overflowWeekday=!0:(s=Gt(n,i,a,r,o),t._a[vt]=s.year,t._dayOfYear=s.dayOfYear)}(t),null!=t._dayOfYear&&(o=be(t._a[vt],i[vt]),(t._dayOfYear>Dt(o)||0===t._dayOfYear)&&(g(t)._overflowDayOfYear=!0),n=jt(o,0,t._dayOfYear),t._a[bt]=n.getUTCMonth(),t._a[yt]=n.getUTCDate()),e=0;e<3&&null==t._a[e];++e)t._a[e]=s[e]=i[e];for(;e<7;e++)t._a[e]=s[e]=null==t._a[e]?2===e?1:0:t._a[e];24===t._a[xt]&&0===t._a[_t]&&0===t._a[wt]&&0===t._a[kt]&&(t._nextDay=!0,t._a[xt]=0),t._d=(t._useUTC?jt:Bt).apply(null,s),r=t._useUTC?t._d.getUTCDay():t._d.getDay(),null!=t._tzm&&t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),t._nextDay&&(t._a[xt]=24),t._w&&void 0!==t._w.d&&t._w.d!==r&&(g(t).weekdayMismatch=!0)}}var xe=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_e=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,we=/Z|[+-]\d\d(?::?\d\d)?/,ke=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Me=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Se=/^\/?Date\((\-?\d+)/i;function De(t){var e,n,i,a,r,o,s=t._i,l=xe.exec(s)||_e.exec(s);if(l){for(g(t).iso=!0,e=0,n=ke.length;e<n;e++)if(ke[e][1].exec(l[1])){a=ke[e][0],i=!1!==ke[e][2];break}if(null==a)return void(t._isValid=!1);if(l[3]){for(e=0,n=Me.length;e<n;e++)if(Me[e][1].exec(l[3])){r=(l[2]||" ")+Me[e][0];break}if(null==r)return void(t._isValid=!1)}if(!i&&null!=r)return void(t._isValid=!1);if(l[4]){if(!we.exec(l[4]))return void(t._isValid=!1);o="Z"}t._f=a+(r||"")+(o||""),Ae(t)}else t._isValid=!1}var Ce=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function Pe(t){var e=parseInt(t,10);return e<=49?2e3+e:e<=999?1900+e:e}var Te={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Oe(t){var e,n,i,a,r,o,s,l=Ce.exec(t._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(l){var u=(e=l[4],n=l[3],i=l[2],a=l[5],r=l[6],o=l[7],s=[Pe(e),Nt.indexOf(n),parseInt(i,10),parseInt(a,10),parseInt(r,10)],o&&s.push(parseInt(o,10)),s);if(!function(t,e,n){return!t||Kt.indexOf(t)===new Date(e[0],e[1],e[2]).getDay()||(g(n).weekdayMismatch=!0,n._isValid=!1,!1)}(l[1],u,t))return;t._a=u,t._tzm=function(t,e,n){if(t)return Te[t];if(e)return 0;var i=parseInt(n,10),a=i%100;return(i-a)/100*60+a}(l[8],l[9],l[10]),t._d=jt.apply(null,t._a),t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),g(t).rfc2822=!0}else t._isValid=!1}function Ae(t){if(t._f!==a.ISO_8601)if(t._f!==a.RFC_2822){t._a=[],g(t).empty=!0;var e,n,i,r,o,s=""+t._i,l=s.length,u=0;for(i=G(t._f,t._locale).match(E)||[],e=0;e<i.length;e++)r=i[e],(n=(s.match(ht(r,t))||[])[0])&&((o=s.substr(0,s.indexOf(n))).length>0&&g(t).unusedInput.push(o),s=s.slice(s.indexOf(n)+n.length),u+=n.length),B[r]?(n?g(t).empty=!1:g(t).unusedTokens.push(r),pt(r,n,t)):t._strict&&!n&&g(t).unusedTokens.push(r);g(t).charsLeftOver=l-u,s.length>0&&g(t).unusedInput.push(s),t._a[xt]<=12&&!0===g(t).bigHour&&t._a[xt]>0&&(g(t).bigHour=void 0),g(t).parsedDateParts=t._a.slice(0),g(t).meridiem=t._meridiem,t._a[xt]=function(t,e,n){var i;return null==n?e:null!=t.meridiemHour?t.meridiemHour(e,n):null!=t.isPM?((i=t.isPM(n))&&e<12&&(e+=12),i||12!==e||(e=0),e):e}(t._locale,t._a[xt],t._meridiem),ye(t),ve(t)}else Oe(t);else De(t)}function Fe(t){var e=t._i,n=t._f;return t._locale=t._locale||pe(t._l),null===e||void 0===n&&""===e?p({nullInput:!0}):("string"==typeof e&&(t._i=e=t._locale.preparse(e)),_(e)?new x(ve(e)):(u(e)?t._d=e:r(n)?function(t){var e,n,i,a,r;if(0===t._f.length)return g(t).invalidFormat=!0,void(t._d=new Date(NaN));for(a=0;a<t._f.length;a++)r=0,e=b({},t),null!=t._useUTC&&(e._useUTC=t._useUTC),e._f=t._f[a],Ae(e),m(e)&&(r+=g(e).charsLeftOver,r+=10*g(e).unusedTokens.length,g(e).score=r,(null==i||r<i)&&(i=r,n=e));c(t,n||e)}(t):n?Ae(t):function(t){var e=t._i;s(e)?t._d=new Date(a.now()):u(e)?t._d=new Date(e.valueOf()):"string"==typeof e?function(t){var e=Se.exec(t._i);null===e?(De(t),!1===t._isValid&&(delete t._isValid,Oe(t),!1===t._isValid&&(delete t._isValid,a.createFromInputFallback(t)))):t._d=new Date(+e[1])}(t):r(e)?(t._a=d(e.slice(0),(function(t){return parseInt(t,10)})),ye(t)):o(e)?function(t){if(!t._d){var e=N(t._i);t._a=d([e.year,e.month,e.day||e.date,e.hour,e.minute,e.second,e.millisecond],(function(t){return t&&parseInt(t,10)})),ye(t)}}(t):l(e)?t._d=new Date(e):a.createFromInputFallback(t)}(t),m(t)||(t._d=null),t))}function Ie(t,e,n,i,a){var s,l={};return!0!==n&&!1!==n||(i=n,n=void 0),(o(t)&&function(t){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(t).length;var e;for(e in t)if(t.hasOwnProperty(e))return!1;return!0}(t)||r(t)&&0===t.length)&&(t=void 0),l._isAMomentObject=!0,l._useUTC=l._isUTC=a,l._l=n,l._i=t,l._f=e,l._strict=i,(s=new x(ve(Fe(l))))._nextDay&&(s.add(1,"d"),s._nextDay=void 0),s}function Le(t,e,n,i){return Ie(t,e,n,i,!1)}a.createFromInputFallback=D("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",(function(t){t._d=new Date(t._i+(t._useUTC?" UTC":""))})),a.ISO_8601=function(){},a.RFC_2822=function(){};var Re=D("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",(function(){var t=Le.apply(null,arguments);return this.isValid()&&t.isValid()?t<this?this:t:p()})),Ne=D("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",(function(){var t=Le.apply(null,arguments);return this.isValid()&&t.isValid()?t>this?this:t:p()}));function We(t,e){var n,i;if(1===e.length&&r(e[0])&&(e=e[0]),!e.length)return Le();for(n=e[0],i=1;i<e.length;++i)e[i].isValid()&&!e[i][t](n)||(n=e[i]);return n}var Ye=["year","quarter","month","week","day","hour","minute","second","millisecond"];function ze(t){var e=N(t),n=e.year||0,i=e.quarter||0,a=e.month||0,r=e.week||e.isoWeek||0,o=e.day||0,s=e.hour||0,l=e.minute||0,u=e.second||0,d=e.millisecond||0;this._isValid=function(t){for(var e in t)if(-1===Pt.call(Ye,e)||null!=t[e]&&isNaN(t[e]))return!1;for(var n=!1,i=0;i<Ye.length;++i)if(t[Ye[i]]){if(n)return!1;parseFloat(t[Ye[i]])!==k(t[Ye[i]])&&(n=!0)}return!0}(e),this._milliseconds=+d+1e3*u+6e4*l+1e3*s*60*60,this._days=+o+7*r,this._months=+a+3*i+12*n,this._data={},this._locale=pe(),this._bubble()}function Ee(t){return t instanceof ze}function Ve(t){return t<0?-1*Math.round(-1*t):Math.round(t)}function He(t,e){j(t,0,0,(function(){var t=this.utcOffset(),n="+";return t<0&&(t=-t,n="-"),n+z(~~(t/60),2)+e+z(~~t%60,2)}))}He("Z",":"),He("ZZ",""),dt("Z",st),dt("ZZ",st),gt(["Z","ZZ"],(function(t,e,n){n._useUTC=!0,n._tzm=je(st,t)}));var Be=/([\+\-]|\d\d)/gi;function je(t,e){var n=(e||"").match(t);if(null===n)return null;var i=((n[n.length-1]||[])+"").match(Be)||["-",0,0],a=60*i[1]+k(i[2]);return 0===a?0:"+"===i[0]?a:-a}function Ue(t,e){var n,i;return e._isUTC?(n=e.clone(),i=(_(t)||u(t)?t.valueOf():Le(t).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+i),a.updateOffset(n,!1),n):Le(t).local()}function Ge(t){return 15*-Math.round(t._d.getTimezoneOffset()/15)}function qe(){return!!this.isValid()&&this._isUTC&&0===this._offset}a.updateOffset=function(){};var Ze=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,$e=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function Xe(t,e){var n,i,a,r,o,s,u=t,d=null;return Ee(t)?u={ms:t._milliseconds,d:t._days,M:t._months}:l(t)?(u={},e?u[e]=t:u.milliseconds=t):(d=Ze.exec(t))?(n="-"===d[1]?-1:1,u={y:0,d:k(d[yt])*n,h:k(d[xt])*n,m:k(d[_t])*n,s:k(d[wt])*n,ms:k(Ve(1e3*d[kt]))*n}):(d=$e.exec(t))?(n="-"===d[1]?-1:1,u={y:Ke(d[2],n),M:Ke(d[3],n),w:Ke(d[4],n),d:Ke(d[5],n),h:Ke(d[6],n),m:Ke(d[7],n),s:Ke(d[8],n)}):null==u?u={}:"object"==typeof u&&("from"in u||"to"in u)&&(r=Le(u.from),o=Le(u.to),a=r.isValid()&&o.isValid()?(o=Ue(o,r),r.isBefore(o)?s=Je(r,o):((s=Je(o,r)).milliseconds=-s.milliseconds,s.months=-s.months),s):{milliseconds:0,months:0},(u={}).ms=a.milliseconds,u.M=a.months),i=new ze(u),Ee(t)&&h(t,"_locale")&&(i._locale=t._locale),i}function Ke(t,e){var n=t&&parseFloat(t.replace(",","."));return(isNaN(n)?0:n)*e}function Je(t,e){var n={};return n.months=e.month()-t.month()+12*(e.year()-t.year()),t.clone().add(n.months,"M").isAfter(e)&&--n.months,n.milliseconds=+e-+t.clone().add(n.months,"M"),n}function Qe(t,e){return function(n,i){var a;return null===i||isNaN(+i)||(T(e,"moment()."+e+"(period, number) is deprecated. Please use moment()."+e+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),a=n,n=i,i=a),tn(this,Xe(n="string"==typeof n?+n:n,i),t),this}}function tn(t,e,n,i){var r=e._milliseconds,o=Ve(e._days),s=Ve(e._months);t.isValid()&&(i=null==i||i,s&&Yt(t,At(t,"Month")+s*n),o&&Ft(t,"Date",At(t,"Date")+o*n),r&&t._d.setTime(t._d.valueOf()+r*n),i&&a.updateOffset(t,o||s))}Xe.fn=ze.prototype,Xe.invalid=function(){return Xe(NaN)};var en=Qe(1,"add"),nn=Qe(-1,"subtract");function an(t,e){var n=12*(e.year()-t.year())+(e.month()-t.month()),i=t.clone().add(n,"months");return-(n+(e-i<0?(e-i)/(i-t.clone().add(n-1,"months")):(e-i)/(t.clone().add(n+1,"months")-i)))||0}function rn(t){var e;return void 0===t?this._locale._abbr:(null!=(e=pe(t))&&(this._locale=e),this)}a.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",a.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var on=D("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",(function(t){return void 0===t?this.localeData():this.locale(t)}));function sn(){return this._locale}var ln=1e3,un=60*ln,dn=60*un,hn=3506328*dn;function cn(t,e){return(t%e+e)%e}function fn(t,e,n){return t<100&&t>=0?new Date(t+400,e,n)-hn:new Date(t,e,n).valueOf()}function gn(t,e,n){return t<100&&t>=0?Date.UTC(t+400,e,n)-hn:Date.UTC(t,e,n)}function mn(t,e){j(0,[t,t.length],0,e)}function pn(t,e,n,i,a){var r;return null==t?qt(this,i,a).year:(e>(r=Zt(t,i,a))&&(e=r),vn.call(this,t,e,n,i,a))}function vn(t,e,n,i,a){var r=Gt(t,e,n,i,a),o=jt(r.year,0,r.dayOfYear);return this.year(o.getUTCFullYear()),this.month(o.getUTCMonth()),this.date(o.getUTCDate()),this}j(0,["gg",2],0,(function(){return this.weekYear()%100})),j(0,["GG",2],0,(function(){return this.isoWeekYear()%100})),mn("gggg","weekYear"),mn("ggggg","weekYear"),mn("GGGG","isoWeekYear"),mn("GGGGG","isoWeekYear"),L("weekYear","gg"),L("isoWeekYear","GG"),Y("weekYear",1),Y("isoWeekYear",1),dt("G",rt),dt("g",rt),dt("GG",J,Z),dt("gg",J,Z),dt("GGGG",nt,X),dt("gggg",nt,X),dt("GGGGG",it,K),dt("ggggg",it,K),mt(["gggg","ggggg","GGGG","GGGGG"],(function(t,e,n,i){e[i.substr(0,2)]=k(t)})),mt(["gg","GG"],(function(t,e,n,i){e[i]=a.parseTwoDigitYear(t)})),j("Q",0,"Qo","quarter"),L("quarter","Q"),Y("quarter",7),dt("Q",q),gt("Q",(function(t,e){e[bt]=3*(k(t)-1)})),j("D",["DD",2],"Do","date"),L("date","D"),Y("date",9),dt("D",J),dt("DD",J,Z),dt("Do",(function(t,e){return t?e._dayOfMonthOrdinalParse||e._ordinalParse:e._dayOfMonthOrdinalParseLenient})),gt(["D","DD"],yt),gt("Do",(function(t,e){e[yt]=k(t.match(J)[0])}));var bn=Ot("Date",!0);j("DDD",["DDDD",3],"DDDo","dayOfYear"),L("dayOfYear","DDD"),Y("dayOfYear",4),dt("DDD",et),dt("DDDD",$),gt(["DDD","DDDD"],(function(t,e,n){n._dayOfYear=k(t)})),j("m",["mm",2],0,"minute"),L("minute","m"),Y("minute",14),dt("m",J),dt("mm",J,Z),gt(["m","mm"],_t);var yn=Ot("Minutes",!1);j("s",["ss",2],0,"second"),L("second","s"),Y("second",15),dt("s",J),dt("ss",J,Z),gt(["s","ss"],wt);var xn,_n=Ot("Seconds",!1);for(j("S",0,0,(function(){return~~(this.millisecond()/100)})),j(0,["SS",2],0,(function(){return~~(this.millisecond()/10)})),j(0,["SSS",3],0,"millisecond"),j(0,["SSSS",4],0,(function(){return 10*this.millisecond()})),j(0,["SSSSS",5],0,(function(){return 100*this.millisecond()})),j(0,["SSSSSS",6],0,(function(){return 1e3*this.millisecond()})),j(0,["SSSSSSS",7],0,(function(){return 1e4*this.millisecond()})),j(0,["SSSSSSSS",8],0,(function(){return 1e5*this.millisecond()})),j(0,["SSSSSSSSS",9],0,(function(){return 1e6*this.millisecond()})),L("millisecond","ms"),Y("millisecond",16),dt("S",et,q),dt("SS",et,Z),dt("SSS",et,$),xn="SSSS";xn.length<=9;xn+="S")dt(xn,at);function wn(t,e){e[kt]=k(1e3*("0."+t))}for(xn="S";xn.length<=9;xn+="S")gt(xn,wn);var kn=Ot("Milliseconds",!1);j("z",0,0,"zoneAbbr"),j("zz",0,0,"zoneName");var Mn=x.prototype;function Sn(t){return t}Mn.add=en,Mn.calendar=function(t,e){var n=t||Le(),i=Ue(n,this).startOf("day"),r=a.calendarFormat(this,i)||"sameElse",o=e&&(O(e[r])?e[r].call(this,n):e[r]);return this.format(o||this.localeData().calendar(r,this,Le(n)))},Mn.clone=function(){return new x(this)},Mn.diff=function(t,e,n){var i,a,r;if(!this.isValid())return NaN;if(!(i=Ue(t,this)).isValid())return NaN;switch(a=6e4*(i.utcOffset()-this.utcOffset()),e=R(e)){case"year":r=an(this,i)/12;break;case"month":r=an(this,i);break;case"quarter":r=an(this,i)/3;break;case"second":r=(this-i)/1e3;break;case"minute":r=(this-i)/6e4;break;case"hour":r=(this-i)/36e5;break;case"day":r=(this-i-a)/864e5;break;case"week":r=(this-i-a)/6048e5;break;default:r=this-i}return n?r:w(r)},Mn.endOf=function(t){var e;if(void 0===(t=R(t))||"millisecond"===t||!this.isValid())return this;var n=this._isUTC?gn:fn;switch(t){case"year":e=n(this.year()+1,0,1)-1;break;case"quarter":e=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":e=n(this.year(),this.month()+1,1)-1;break;case"week":e=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":e=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":e=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":e=this._d.valueOf(),e+=dn-cn(e+(this._isUTC?0:this.utcOffset()*un),dn)-1;break;case"minute":e=this._d.valueOf(),e+=un-cn(e,un)-1;break;case"second":e=this._d.valueOf(),e+=ln-cn(e,ln)-1}return this._d.setTime(e),a.updateOffset(this,!0),this},Mn.format=function(t){t||(t=this.isUtc()?a.defaultFormatUtc:a.defaultFormat);var e=U(this,t);return this.localeData().postformat(e)},Mn.from=function(t,e){return this.isValid()&&(_(t)&&t.isValid()||Le(t).isValid())?Xe({to:this,from:t}).locale(this.locale()).humanize(!e):this.localeData().invalidDate()},Mn.fromNow=function(t){return this.from(Le(),t)},Mn.to=function(t,e){return this.isValid()&&(_(t)&&t.isValid()||Le(t).isValid())?Xe({from:this,to:t}).locale(this.locale()).humanize(!e):this.localeData().invalidDate()},Mn.toNow=function(t){return this.to(Le(),t)},Mn.get=function(t){return O(this[t=R(t)])?this[t]():this},Mn.invalidAt=function(){return g(this).overflow},Mn.isAfter=function(t,e){var n=_(t)?t:Le(t);return!(!this.isValid()||!n.isValid())&&("millisecond"===(e=R(e)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(e).valueOf())},Mn.isBefore=function(t,e){var n=_(t)?t:Le(t);return!(!this.isValid()||!n.isValid())&&("millisecond"===(e=R(e)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(e).valueOf()<n.valueOf())},Mn.isBetween=function(t,e,n,i){var a=_(t)?t:Le(t),r=_(e)?e:Le(e);return!!(this.isValid()&&a.isValid()&&r.isValid())&&("("===(i=i||"()")[0]?this.isAfter(a,n):!this.isBefore(a,n))&&(")"===i[1]?this.isBefore(r,n):!this.isAfter(r,n))},Mn.isSame=function(t,e){var n,i=_(t)?t:Le(t);return!(!this.isValid()||!i.isValid())&&("millisecond"===(e=R(e)||"millisecond")?this.valueOf()===i.valueOf():(n=i.valueOf(),this.clone().startOf(e).valueOf()<=n&&n<=this.clone().endOf(e).valueOf()))},Mn.isSameOrAfter=function(t,e){return this.isSame(t,e)||this.isAfter(t,e)},Mn.isSameOrBefore=function(t,e){return this.isSame(t,e)||this.isBefore(t,e)},Mn.isValid=function(){return m(this)},Mn.lang=on,Mn.locale=rn,Mn.localeData=sn,Mn.max=Ne,Mn.min=Re,Mn.parsingFlags=function(){return c({},g(this))},Mn.set=function(t,e){if("object"==typeof t)for(var n=function(t){var e=[];for(var n in t)e.push({unit:n,priority:W[n]});return e.sort((function(t,e){return t.priority-e.priority})),e}(t=N(t)),i=0;i<n.length;i++)this[n[i].unit](t[n[i].unit]);else if(O(this[t=R(t)]))return this[t](e);return this},Mn.startOf=function(t){var e;if(void 0===(t=R(t))||"millisecond"===t||!this.isValid())return this;var n=this._isUTC?gn:fn;switch(t){case"year":e=n(this.year(),0,1);break;case"quarter":e=n(this.year(),this.month()-this.month()%3,1);break;case"month":e=n(this.year(),this.month(),1);break;case"week":e=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":e=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":e=n(this.year(),this.month(),this.date());break;case"hour":e=this._d.valueOf(),e-=cn(e+(this._isUTC?0:this.utcOffset()*un),dn);break;case"minute":e=this._d.valueOf(),e-=cn(e,un);break;case"second":e=this._d.valueOf(),e-=cn(e,ln)}return this._d.setTime(e),a.updateOffset(this,!0),this},Mn.subtract=nn,Mn.toArray=function(){var t=this;return[t.year(),t.month(),t.date(),t.hour(),t.minute(),t.second(),t.millisecond()]},Mn.toObject=function(){var t=this;return{years:t.year(),months:t.month(),date:t.date(),hours:t.hours(),minutes:t.minutes(),seconds:t.seconds(),milliseconds:t.milliseconds()}},Mn.toDate=function(){return new Date(this.valueOf())},Mn.toISOString=function(t){if(!this.isValid())return null;var e=!0!==t,n=e?this.clone().utc():this;return n.year()<0||n.year()>9999?U(n,e?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):O(Date.prototype.toISOString)?e?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",U(n,"Z")):U(n,e?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},Mn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var t="moment",e="";this.isLocal()||(t=0===this.utcOffset()?"moment.utc":"moment.parseZone",e="Z");var n="["+t+'("]',i=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",a=e+'[")]';return this.format(n+i+"-MM-DD[T]HH:mm:ss.SSS"+a)},Mn.toJSON=function(){return this.isValid()?this.toISOString():null},Mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},Mn.unix=function(){return Math.floor(this.valueOf()/1e3)},Mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},Mn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},Mn.year=Tt,Mn.isLeapYear=function(){return Ct(this.year())},Mn.weekYear=function(t){return pn.call(this,t,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},Mn.isoWeekYear=function(t){return pn.call(this,t,this.isoWeek(),this.isoWeekday(),1,4)},Mn.quarter=Mn.quarters=function(t){return null==t?Math.ceil((this.month()+1)/3):this.month(3*(t-1)+this.month()%3)},Mn.month=zt,Mn.daysInMonth=function(){return It(this.year(),this.month())},Mn.week=Mn.weeks=function(t){var e=this.localeData().week(this);return null==t?e:this.add(7*(t-e),"d")},Mn.isoWeek=Mn.isoWeeks=function(t){var e=qt(this,1,4).week;return null==t?e:this.add(7*(t-e),"d")},Mn.weeksInYear=function(){var t=this.localeData()._week;return Zt(this.year(),t.dow,t.doy)},Mn.isoWeeksInYear=function(){return Zt(this.year(),1,4)},Mn.date=bn,Mn.day=Mn.days=function(t){if(!this.isValid())return null!=t?this:NaN;var e=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=t?(t=function(t,e){return"string"!=typeof t?t:isNaN(t)?"number"==typeof(t=e.weekdaysParse(t))?t:null:parseInt(t,10)}(t,this.localeData()),this.add(t-e,"d")):e},Mn.weekday=function(t){if(!this.isValid())return null!=t?this:NaN;var e=(this.day()+7-this.localeData()._week.dow)%7;return null==t?e:this.add(t-e,"d")},Mn.isoWeekday=function(t){if(!this.isValid())return null!=t?this:NaN;if(null!=t){var e=function(t,e){return"string"==typeof t?e.weekdaysParse(t)%7||7:isNaN(t)?null:t}(t,this.localeData());return this.day(this.day()%7?e:e-7)}return this.day()||7},Mn.dayOfYear=function(t){var e=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==t?e:this.add(t-e,"d")},Mn.hour=Mn.hours=le,Mn.minute=Mn.minutes=yn,Mn.second=Mn.seconds=_n,Mn.millisecond=Mn.milliseconds=kn,Mn.utcOffset=function(t,e,n){var i,r=this._offset||0;if(!this.isValid())return null!=t?this:NaN;if(null!=t){if("string"==typeof t){if(null===(t=je(st,t)))return this}else Math.abs(t)<16&&!n&&(t*=60);return!this._isUTC&&e&&(i=Ge(this)),this._offset=t,this._isUTC=!0,null!=i&&this.add(i,"m"),r!==t&&(!e||this._changeInProgress?tn(this,Xe(t-r,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?r:Ge(this)},Mn.utc=function(t){return this.utcOffset(0,t)},Mn.local=function(t){return this._isUTC&&(this.utcOffset(0,t),this._isUTC=!1,t&&this.subtract(Ge(this),"m")),this},Mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var t=je(ot,this._i);null!=t?this.utcOffset(t):this.utcOffset(0,!0)}return this},Mn.hasAlignedHourOffset=function(t){return!!this.isValid()&&(t=t?Le(t).utcOffset():0,(this.utcOffset()-t)%60==0)},Mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},Mn.isLocal=function(){return!!this.isValid()&&!this._isUTC},Mn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},Mn.isUtc=qe,Mn.isUTC=qe,Mn.zoneAbbr=function(){return this._isUTC?"UTC":""},Mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},Mn.dates=D("dates accessor is deprecated. Use date instead.",bn),Mn.months=D("months accessor is deprecated. Use month instead",zt),Mn.years=D("years accessor is deprecated. Use year instead",Tt),Mn.zone=D("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",(function(t,e){return null!=t?("string"!=typeof t&&(t=-t),this.utcOffset(t,e),this):-this.utcOffset()})),Mn.isDSTShifted=D("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",(function(){if(!s(this._isDSTShifted))return this._isDSTShifted;var t={};if(b(t,this),(t=Fe(t))._a){var e=t._isUTC?f(t._a):Le(t._a);this._isDSTShifted=this.isValid()&&M(t._a,e.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}));var Dn=F.prototype;function Cn(t,e,n,i){var a=pe(),r=f().set(i,e);return a[n](r,t)}function Pn(t,e,n){if(l(t)&&(e=t,t=void 0),t=t||"",null!=e)return Cn(t,e,n,"month");var i,a=[];for(i=0;i<12;i++)a[i]=Cn(t,i,n,"month");return a}function Tn(t,e,n,i){"boolean"==typeof t?(l(e)&&(n=e,e=void 0),e=e||""):(n=e=t,t=!1,l(e)&&(n=e,e=void 0),e=e||"");var a,r=pe(),o=t?r._week.dow:0;if(null!=n)return Cn(e,(n+o)%7,i,"day");var s=[];for(a=0;a<7;a++)s[a]=Cn(e,(a+o)%7,i,"day");return s}Dn.calendar=function(t,e,n){var i=this._calendar[t]||this._calendar.sameElse;return O(i)?i.call(e,n):i},Dn.longDateFormat=function(t){var e=this._longDateFormat[t],n=this._longDateFormat[t.toUpperCase()];return e||!n?e:(this._longDateFormat[t]=n.replace(/MMMM|MM|DD|dddd/g,(function(t){return t.slice(1)})),this._longDateFormat[t])},Dn.invalidDate=function(){return this._invalidDate},Dn.ordinal=function(t){return this._ordinal.replace("%d",t)},Dn.preparse=Sn,Dn.postformat=Sn,Dn.relativeTime=function(t,e,n,i){var a=this._relativeTime[n];return O(a)?a(t,e,n,i):a.replace(/%d/i,t)},Dn.pastFuture=function(t,e){var n=this._relativeTime[t>0?"future":"past"];return O(n)?n(e):n.replace(/%s/i,e)},Dn.set=function(t){var e,n;for(n in t)O(e=t[n])?this[n]=e:this["_"+n]=e;this._config=t,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},Dn.months=function(t,e){return t?r(this._months)?this._months[t.month()]:this._months[(this._months.isFormat||Lt).test(e)?"format":"standalone"][t.month()]:r(this._months)?this._months:this._months.standalone},Dn.monthsShort=function(t,e){return t?r(this._monthsShort)?this._monthsShort[t.month()]:this._monthsShort[Lt.test(e)?"format":"standalone"][t.month()]:r(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},Dn.monthsParse=function(t,e,n){var i,a,r;if(this._monthsParseExact)return Wt.call(this,t,e,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),i=0;i<12;i++){if(a=f([2e3,i]),n&&!this._longMonthsParse[i]&&(this._longMonthsParse[i]=new RegExp("^"+this.months(a,"").replace(".","")+"$","i"),this._shortMonthsParse[i]=new RegExp("^"+this.monthsShort(a,"").replace(".","")+"$","i")),n||this._monthsParse[i]||(r="^"+this.months(a,"")+"|^"+this.monthsShort(a,""),this._monthsParse[i]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===e&&this._longMonthsParse[i].test(t))return i;if(n&&"MMM"===e&&this._shortMonthsParse[i].test(t))return i;if(!n&&this._monthsParse[i].test(t))return i}},Dn.monthsRegex=function(t){return this._monthsParseExact?(h(this,"_monthsRegex")||Ht.call(this),t?this._monthsStrictRegex:this._monthsRegex):(h(this,"_monthsRegex")||(this._monthsRegex=Vt),this._monthsStrictRegex&&t?this._monthsStrictRegex:this._monthsRegex)},Dn.monthsShortRegex=function(t){return this._monthsParseExact?(h(this,"_monthsRegex")||Ht.call(this),t?this._monthsShortStrictRegex:this._monthsShortRegex):(h(this,"_monthsShortRegex")||(this._monthsShortRegex=Et),this._monthsShortStrictRegex&&t?this._monthsShortStrictRegex:this._monthsShortRegex)},Dn.week=function(t){return qt(t,this._week.dow,this._week.doy).week},Dn.firstDayOfYear=function(){return this._week.doy},Dn.firstDayOfWeek=function(){return this._week.dow},Dn.weekdays=function(t,e){var n=r(this._weekdays)?this._weekdays:this._weekdays[t&&!0!==t&&this._weekdays.isFormat.test(e)?"format":"standalone"];return!0===t?$t(n,this._week.dow):t?n[t.day()]:n},Dn.weekdaysMin=function(t){return!0===t?$t(this._weekdaysMin,this._week.dow):t?this._weekdaysMin[t.day()]:this._weekdaysMin},Dn.weekdaysShort=function(t){return!0===t?$t(this._weekdaysShort,this._week.dow):t?this._weekdaysShort[t.day()]:this._weekdaysShort},Dn.weekdaysParse=function(t,e,n){var i,a,r;if(this._weekdaysParseExact)return Qt.call(this,t,e,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),i=0;i<7;i++){if(a=f([2e3,1]).day(i),n&&!this._fullWeekdaysParse[i]&&(this._fullWeekdaysParse[i]=new RegExp("^"+this.weekdays(a,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[i]=new RegExp("^"+this.weekdaysShort(a,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[i]=new RegExp("^"+this.weekdaysMin(a,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[i]||(r="^"+this.weekdays(a,"")+"|^"+this.weekdaysShort(a,"")+"|^"+this.weekdaysMin(a,""),this._weekdaysParse[i]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===e&&this._fullWeekdaysParse[i].test(t))return i;if(n&&"ddd"===e&&this._shortWeekdaysParse[i].test(t))return i;if(n&&"dd"===e&&this._minWeekdaysParse[i].test(t))return i;if(!n&&this._weekdaysParse[i].test(t))return i}},Dn.weekdaysRegex=function(t){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||ie.call(this),t?this._weekdaysStrictRegex:this._weekdaysRegex):(h(this,"_weekdaysRegex")||(this._weekdaysRegex=te),this._weekdaysStrictRegex&&t?this._weekdaysStrictRegex:this._weekdaysRegex)},Dn.weekdaysShortRegex=function(t){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||ie.call(this),t?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(h(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=ee),this._weekdaysShortStrictRegex&&t?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},Dn.weekdaysMinRegex=function(t){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||ie.call(this),t?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(h(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=ne),this._weekdaysMinStrictRegex&&t?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},Dn.isPM=function(t){return"p"===(t+"").toLowerCase().charAt(0)},Dn.meridiem=function(t,e,n){return t>11?n?"pm":"PM":n?"am":"AM"},ge("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(t){var e=t%10;return t+(1===k(t%100/10)?"th":1===e?"st":2===e?"nd":3===e?"rd":"th")}}),a.lang=D("moment.lang is deprecated. Use moment.locale instead.",ge),a.langData=D("moment.langData is deprecated. Use moment.localeData instead.",pe);var On=Math.abs;function An(t,e,n,i){var a=Xe(e,n);return t._milliseconds+=i*a._milliseconds,t._days+=i*a._days,t._months+=i*a._months,t._bubble()}function Fn(t){return t<0?Math.floor(t):Math.ceil(t)}function In(t){return 4800*t/146097}function Ln(t){return 146097*t/4800}function Rn(t){return function(){return this.as(t)}}var Nn=Rn("ms"),Wn=Rn("s"),Yn=Rn("m"),zn=Rn("h"),En=Rn("d"),Vn=Rn("w"),Hn=Rn("M"),Bn=Rn("Q"),jn=Rn("y");function Un(t){return function(){return this.isValid()?this._data[t]:NaN}}var Gn=Un("milliseconds"),qn=Un("seconds"),Zn=Un("minutes"),$n=Un("hours"),Xn=Un("days"),Kn=Un("months"),Jn=Un("years"),Qn=Math.round,ti={ss:44,s:45,m:45,h:22,d:26,M:11};function ei(t,e,n,i,a){return a.relativeTime(e||1,!!n,t,i)}var ni=Math.abs;function ii(t){return(t>0)-(t<0)||+t}function ai(){if(!this.isValid())return this.localeData().invalidDate();var t,e,n=ni(this._milliseconds)/1e3,i=ni(this._days),a=ni(this._months);t=w(n/60),e=w(t/60),n%=60,t%=60;var r=w(a/12),o=a%=12,s=i,l=e,u=t,d=n?n.toFixed(3).replace(/\.?0+$/,""):"",h=this.asSeconds();if(!h)return"P0D";var c=h<0?"-":"",f=ii(this._months)!==ii(h)?"-":"",g=ii(this._days)!==ii(h)?"-":"",m=ii(this._milliseconds)!==ii(h)?"-":"";return c+"P"+(r?f+r+"Y":"")+(o?f+o+"M":"")+(s?g+s+"D":"")+(l||u||d?"T":"")+(l?m+l+"H":"")+(u?m+u+"M":"")+(d?m+d+"S":"")}var ri=ze.prototype;return ri.isValid=function(){return this._isValid},ri.abs=function(){var t=this._data;return this._milliseconds=On(this._milliseconds),this._days=On(this._days),this._months=On(this._months),t.milliseconds=On(t.milliseconds),t.seconds=On(t.seconds),t.minutes=On(t.minutes),t.hours=On(t.hours),t.months=On(t.months),t.years=On(t.years),this},ri.add=function(t,e){return An(this,t,e,1)},ri.subtract=function(t,e){return An(this,t,e,-1)},ri.as=function(t){if(!this.isValid())return NaN;var e,n,i=this._milliseconds;if("month"===(t=R(t))||"quarter"===t||"year"===t)switch(e=this._days+i/864e5,n=this._months+In(e),t){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(e=this._days+Math.round(Ln(this._months)),t){case"week":return e/7+i/6048e5;case"day":return e+i/864e5;case"hour":return 24*e+i/36e5;case"minute":return 1440*e+i/6e4;case"second":return 86400*e+i/1e3;case"millisecond":return Math.floor(864e5*e)+i;default:throw new Error("Unknown unit "+t)}},ri.asMilliseconds=Nn,ri.asSeconds=Wn,ri.asMinutes=Yn,ri.asHours=zn,ri.asDays=En,ri.asWeeks=Vn,ri.asMonths=Hn,ri.asQuarters=Bn,ri.asYears=jn,ri.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*k(this._months/12):NaN},ri._bubble=function(){var t,e,n,i,a,r=this._milliseconds,o=this._days,s=this._months,l=this._data;return r>=0&&o>=0&&s>=0||r<=0&&o<=0&&s<=0||(r+=864e5*Fn(Ln(s)+o),o=0,s=0),l.milliseconds=r%1e3,t=w(r/1e3),l.seconds=t%60,e=w(t/60),l.minutes=e%60,n=w(e/60),l.hours=n%24,o+=w(n/24),a=w(In(o)),s+=a,o-=Fn(Ln(a)),i=w(s/12),s%=12,l.days=o,l.months=s,l.years=i,this},ri.clone=function(){return Xe(this)},ri.get=function(t){return t=R(t),this.isValid()?this[t+"s"]():NaN},ri.milliseconds=Gn,ri.seconds=qn,ri.minutes=Zn,ri.hours=$n,ri.days=Xn,ri.weeks=function(){return w(this.days()/7)},ri.months=Kn,ri.years=Jn,ri.humanize=function(t){if(!this.isValid())return this.localeData().invalidDate();var e=this.localeData(),n=function(t,e,n){var i=Xe(t).abs(),a=Qn(i.as("s")),r=Qn(i.as("m")),o=Qn(i.as("h")),s=Qn(i.as("d")),l=Qn(i.as("M")),u=Qn(i.as("y")),d=a<=ti.ss&&["s",a]||a<ti.s&&["ss",a]||r<=1&&["m"]||r<ti.m&&["mm",r]||o<=1&&["h"]||o<ti.h&&["hh",o]||s<=1&&["d"]||s<ti.d&&["dd",s]||l<=1&&["M"]||l<ti.M&&["MM",l]||u<=1&&["y"]||["yy",u];return d[2]=e,d[3]=+t>0,d[4]=n,ei.apply(null,d)}(this,!t,e);return t&&(n=e.pastFuture(+this,n)),e.postformat(n)},ri.toISOString=ai,ri.toString=ai,ri.toJSON=ai,ri.locale=rn,ri.localeData=sn,ri.toIsoString=D("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",ai),ri.lang=on,j("X",0,0,"unix"),j("x",0,0,"valueOf"),dt("x",rt),dt("X",/[+-]?\d+(\.\d{1,3})?/),gt("X",(function(t,e,n){n._d=new Date(1e3*parseFloat(t,10))})),gt("x",(function(t,e,n){n._d=new Date(k(t))})),a.version="2.24.0",n=Le,a.fn=Mn,a.min=function(){return We("isBefore",[].slice.call(arguments,0))},a.max=function(){return We("isAfter",[].slice.call(arguments,0))},a.now=function(){return Date.now?Date.now():+new Date},a.utc=f,a.unix=function(t){return Le(1e3*t)},a.months=function(t,e){return Pn(t,e,"months")},a.isDate=u,a.locale=ge,a.invalid=p,a.duration=Xe,a.isMoment=_,a.weekdays=function(t,e,n){return Tn(t,e,n,"weekdays")},a.parseZone=function(){return Le.apply(null,arguments).parseZone()},a.localeData=pe,a.isDuration=Ee,a.monthsShort=function(t,e){return Pn(t,e,"monthsShort")},a.weekdaysMin=function(t,e,n){return Tn(t,e,n,"weekdaysMin")},a.defineLocale=me,a.updateLocale=function(t,e){if(null!=e){var n,i,a=ue;null!=(i=fe(t))&&(a=i._config),e=A(a,e),(n=new F(e)).parentLocale=de[t],de[t]=n,ge(t)}else null!=de[t]&&(null!=de[t].parentLocale?de[t]=de[t].parentLocale:null!=de[t]&&delete de[t]);return de[t]},a.locales=function(){return C(de)},a.weekdaysShort=function(t,e,n){return Tn(t,e,n,"weekdaysShort")},a.normalizeUnits=R,a.relativeTimeRounding=function(t){return void 0===t?Qn:"function"==typeof t&&(Qn=t,!0)},a.relativeTimeThreshold=function(t,e){return void 0!==ti[t]&&(void 0===e?ti[t]:(ti[t]=e,"s"===t&&(ti.ss=e-1),!0))},a.calendarFormat=function(t,e){var n=t.diff(e,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},a.prototype=Mn,a.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},a}()})),pi={datetime:"MMM D, YYYY, h:mm:ss a",millisecond:"h:mm:ss.SSS a",second:"h:mm:ss a",minute:"h:mm a",hour:"hA",day:"MMM D",week:"ll",month:"MMM YYYY",quarter:"[Q]Q - YYYY",year:"YYYY"};on._date.override("function"==typeof mi?{_id:"moment",formats:function(){return pi},parse:function(t,e){return"string"==typeof t&&"string"==typeof e?t=mi(t,e):t instanceof mi||(t=mi(t)),t.isValid()?t.valueOf():null},format:function(t,e){return mi(t).format(e)},add:function(t,e,n){return mi(t).add(e,n).valueOf()},diff:function(t,e,n){return mi(t).diff(mi(e),n)},startOf:function(t,e,n){return t=mi(t),"isoWeek"===e?t.isoWeekday(n).valueOf():t.startOf(e).valueOf()},endOf:function(t,e){return mi(t).endOf(e).valueOf()},_create:function(t){return mi(t)}}:{}),Y._set("global",{plugins:{filler:{propagate:!0}}});var vi={dataset:function(t){var e=t.fill,n=t.chart,i=n.getDatasetMeta(e),a=i&&n.isDatasetVisible(e)&&i.dataset._children||[],r=a.length||0;return r?function(t,e){return e<r&&a[e]._view||null}:null},boundary:function(t){var e=t.boundary,n=e?e.x:null,i=e?e.y:null;return B.isArray(e)?function(t,n){return e[n]}:function(t){return{x:null===n?t.x:n,y:null===i?t.y:i}}}};function bi(t,e,n){var i,a=t._model||{},r=a.fill;if(void 0===r&&(r=!!a.backgroundColor),!1===r||null===r)return!1;if(!0===r)return"origin";if(i=parseFloat(r,10),isFinite(i)&&Math.floor(i)===i)return"-"!==r[0]&&"+"!==r[0]||(i=e+i),!(i===e||i<0||i>=n)&&i;switch(r){case"bottom":return"start";case"top":return"end";case"zero":return"origin";case"origin":case"start":case"end":return r;default:return!1}}function yi(t){return(t.el._scale||{}).getPointPositionForValue?function(t){var e,n,i,a,r,o=t.el._scale,s=o.options,l=o.chart.data.labels.length,u=t.fill,d=[];if(!l)return null;for(e=s.ticks.reverse?o.max:o.min,n=s.ticks.reverse?o.min:o.max,i=o.getPointPositionForValue(0,e),a=0;a<l;++a)r="start"===u||"end"===u?o.getPointPositionForValue(a,"start"===u?e:n):o.getBasePosition(a),s.gridLines.circular&&(r.cx=i.x,r.cy=i.y,r.angle=o.getIndexAngle(a)-Math.PI/2),d.push(r);return d}(t):function(t){var e,n=t.el._model||{},i=t.el._scale||{},a=t.fill,r=null;if(isFinite(a))return null;if("start"===a?r=void 0===n.scaleBottom?i.bottom:n.scaleBottom:"end"===a?r=void 0===n.scaleTop?i.top:n.scaleTop:void 0!==n.scaleZero?r=n.scaleZero:i.getBasePixel&&(r=i.getBasePixel()),null!=r){if(void 0!==r.x&&void 0!==r.y)return r;if(B.isFinite(r))return{x:(e=i.isHorizontal())?r:null,y:e?null:r}}return null}(t)}function xi(t,e,n){var i,a=t[e].fill,r=[e];if(!n)return a;for(;!1!==a&&-1===r.indexOf(a);){if(!isFinite(a))return a;if(!(i=t[a]))return!1;if(i.visible)return a;r.push(a),a=i.fill}return!1}function _i(t){var e=t.fill,n="dataset";return!1===e?null:(isFinite(e)||(n="boundary"),vi[n](t))}function wi(t){return t&&!t.skip}function ki(t,e,n,i,a){var r,o,s,l;if(i&&a){for(t.moveTo(e[0].x,e[0].y),r=1;r<i;++r)B.canvas.lineTo(t,e[r-1],e[r]);if(void 0===n[0].angle)for(t.lineTo(n[a-1].x,n[a-1].y),r=a-1;r>0;--r)B.canvas.lineTo(t,n[r],n[r-1],!0);else for(o=n[0].cx,s=n[0].cy,l=Math.sqrt(Math.pow(n[0].x-o,2)+Math.pow(n[0].y-s,2)),r=a-1;r>0;--r)t.arc(o,s,l,n[r].angle,n[r-1].angle,!0)}}function Mi(t,e,n,i,a,r){var o,s,l,u,d,h,c,f,g=e.length,m=i.spanGaps,p=[],v=[],b=0,y=0;for(t.beginPath(),o=0,s=g;o<s;++o)d=n(u=e[l=o%g]._view,l,i),h=wi(u),c=wi(d),r&&void 0===f&&h&&(s=g+(f=o+1)),h&&c?(b=p.push(u),y=v.push(d)):b&&y&&(m?(h&&p.push(u),c&&v.push(d)):(ki(t,p,v,b,y),b=y=0,p=[],v=[]));ki(t,p,v,b,y),t.closePath(),t.fillStyle=a,t.fill()}var Si={id:"filler",afterDatasetsUpdate:function(t,e){var n,i,a,r,o=(t.data.datasets||[]).length,s=e.propagate,l=[];for(i=0;i<o;++i)r=null,(a=(n=t.getDatasetMeta(i)).dataset)&&a._model&&a instanceof kt.Line&&(r={visible:t.isDatasetVisible(i),fill:bi(a,i,o),chart:t,el:a}),n.$filler=r,l.push(r);for(i=0;i<o;++i)(r=l[i])&&(r.fill=xi(l,i,s),r.boundary=yi(r),r.mapper=_i(r))},beforeDatasetsDraw:function(t){var e,n,i,a,r,o,s,l=t._getSortedVisibleDatasetMetas(),u=t.ctx;for(n=l.length-1;n>=0;--n)(e=l[n].$filler)&&e.visible&&(a=(i=e.el)._view,r=i._children||[],o=e.mapper,s=a.backgroundColor||Y.global.defaultColor,o&&s&&r.length&&(B.canvas.clipArea(u,t.chartArea),Mi(u,r,o,a,s,i._loop),B.canvas.unclipArea(u)))}},Di=B.rtl.getRtlAdapter,Ci=B.noop,Pi=B.valueOrDefault;function Ti(t,e){return t.usePointStyle&&t.boxWidth>e?e:t.boxWidth}Y._set("global",{legend:{display:!0,position:"top",align:"center",fullWidth:!0,reverse:!1,weight:1e3,onClick:function(t,e){var n=e.datasetIndex,i=this.chart,a=i.getDatasetMeta(n);a.hidden=null===a.hidden?!i.data.datasets[n].hidden:null,i.update()},onHover:null,onLeave:null,labels:{boxWidth:40,padding:10,generateLabels:function(t){var e=t.data.datasets,n=t.options.legend||{},i=n.labels&&n.labels.usePointStyle;return t._getSortedDatasetMetas().map((function(n){var a=n.controller.getStyle(i?0:void 0);return{text:e[n.index].label,fillStyle:a.backgroundColor,hidden:!t.isDatasetVisible(n.index),lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:a.borderWidth,strokeStyle:a.borderColor,pointStyle:a.pointStyle,rotation:a.rotation,datasetIndex:n.index}}),this)}}},legendCallback:function(t){var e,n,i,a=document.createElement("ul"),r=t.data.datasets;for(a.setAttribute("class",t.id+"-legend"),e=0,n=r.length;e<n;e++)(i=a.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor=r[e].backgroundColor,r[e].label&&i.appendChild(document.createTextNode(r[e].label));return a.outerHTML}});var Oi=X.extend({initialize:function(t){B.extend(this,t),this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1},beforeUpdate:Ci,update:function(t,e,n){var i=this;return i.beforeUpdate(),i.maxWidth=t,i.maxHeight=e,i.margins=n,i.beforeSetDimensions(),i.setDimensions(),i.afterSetDimensions(),i.beforeBuildLabels(),i.buildLabels(),i.afterBuildLabels(),i.beforeFit(),i.fit(),i.afterFit(),i.afterUpdate(),i.minSize},afterUpdate:Ci,beforeSetDimensions:Ci,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:Ci,beforeBuildLabels:Ci,buildLabels:function(){var t=this,e=t.options.labels||{},n=B.callback(e.generateLabels,[t.chart],t)||[];e.filter&&(n=n.filter((function(n){return e.filter(n,t.chart.data)}))),t.options.reverse&&n.reverse(),t.legendItems=n},afterBuildLabels:Ci,beforeFit:Ci,fit:function(){var t=this,e=t.options,n=e.labels,i=e.display,a=t.ctx,r=B.options._parseFont(n),o=r.size,s=t.legendHitBoxes=[],l=t.minSize,u=t.isHorizontal();if(u?(l.width=t.maxWidth,l.height=i?10:0):(l.width=i?10:0,l.height=t.maxHeight),i){if(a.font=r.string,u){var d=t.lineWidths=[0],h=0;a.textAlign="left",a.textBaseline="middle",B.each(t.legendItems,(function(t,e){var i=Ti(n,o)+o/2+a.measureText(t.text).width;(0===e||d[d.length-1]+i+2*n.padding>l.width)&&(h+=o+n.padding,d[d.length-(e>0?0:1)]=0),s[e]={left:0,top:0,width:i,height:o},d[d.length-1]+=i+n.padding})),l.height+=h}else{var c=n.padding,f=t.columnWidths=[],g=t.columnHeights=[],m=n.padding,p=0,v=0;B.each(t.legendItems,(function(t,e){var i=Ti(n,o)+o/2+a.measureText(t.text).width;e>0&&v+o+2*c>l.height&&(m+=p+n.padding,f.push(p),g.push(v),p=0,v=0),p=Math.max(p,i),v+=o+c,s[e]={left:0,top:0,width:i,height:o}})),m+=p,f.push(p),g.push(v),l.width+=m}t.width=l.width,t.height=l.height}else t.width=l.width=t.height=l.height=0},afterFit:Ci,isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},draw:function(){var t=this,e=t.options,n=e.labels,i=Y.global,a=i.defaultColor,r=i.elements.line,o=t.height,s=t.columnHeights,l=t.width,u=t.lineWidths;if(e.display){var d,h=Di(e.rtl,t.left,t.minSize.width),c=t.ctx,f=Pi(n.fontColor,i.defaultFontColor),g=B.options._parseFont(n),m=g.size;c.textAlign=h.textAlign("left"),c.textBaseline="middle",c.lineWidth=.5,c.strokeStyle=f,c.fillStyle=f,c.font=g.string;var p=Ti(n,m),v=t.legendHitBoxes,b=function(t,i){switch(e.align){case"start":return n.padding;case"end":return t-i;default:return(t-i+n.padding)/2}},y=t.isHorizontal();d=y?{x:t.left+b(l,u[0]),y:t.top+n.padding,line:0}:{x:t.left+n.padding,y:t.top+b(o,s[0]),line:0},B.rtl.overrideTextDirection(t.ctx,e.textDirection);var x=m+n.padding;B.each(t.legendItems,(function(e,i){var f=c.measureText(e.text).width,g=p+m/2+f,_=d.x,w=d.y;h.setWidth(t.minSize.width),y?i>0&&_+g+n.padding>t.left+t.minSize.width&&(w=d.y+=x,d.line++,_=d.x=t.left+b(l,u[d.line])):i>0&&w+x>t.top+t.minSize.height&&(_=d.x=_+t.columnWidths[d.line]+n.padding,d.line++,w=d.y=t.top+b(o,s[d.line]));var k=h.x(_);!function(t,e,i){if(!(isNaN(p)||p<=0)){c.save();var o=Pi(i.lineWidth,r.borderWidth);if(c.fillStyle=Pi(i.fillStyle,a),c.lineCap=Pi(i.lineCap,r.borderCapStyle),c.lineDashOffset=Pi(i.lineDashOffset,r.borderDashOffset),c.lineJoin=Pi(i.lineJoin,r.borderJoinStyle),c.lineWidth=o,c.strokeStyle=Pi(i.strokeStyle,a),c.setLineDash&&c.setLineDash(Pi(i.lineDash,r.borderDash)),n&&n.usePointStyle){var s=p*Math.SQRT2/2,l=h.xPlus(t,p/2),u=e+m/2;B.canvas.drawPoint(c,i.pointStyle,s,l,u,i.rotation)}else c.fillRect(h.leftForLtr(t,p),e,p,m),0!==o&&c.strokeRect(h.leftForLtr(t,p),e,p,m);c.restore()}}(k,w,e),v[i].left=h.leftForLtr(k,v[i].width),v[i].top=w,function(t,e,n,i){var a=m/2,r=h.xPlus(t,p+a),o=e+a;c.fillText(n.text,r,o),n.hidden&&(c.beginPath(),c.lineWidth=2,c.moveTo(r,o),c.lineTo(h.xPlus(r,i),o),c.stroke())}(k,w,e,f),y?d.x+=g+n.padding:d.y+=x})),B.rtl.restoreTextDirection(t.ctx,e.textDirection)}},_getLegendItemAt:function(t,e){var n,i,a,r=this;if(t>=r.left&&t<=r.right&&e>=r.top&&e<=r.bottom)for(a=r.legendHitBoxes,n=0;n<a.length;++n)if(t>=(i=a[n]).left&&t<=i.left+i.width&&e>=i.top&&e<=i.top+i.height)return r.legendItems[n];return null},handleEvent:function(t){var e,n=this,i=n.options,a="mouseup"===t.type?"click":t.type;if("mousemove"===a){if(!i.onHover&&!i.onLeave)return}else{if("click"!==a)return;if(!i.onClick)return}e=n._getLegendItemAt(t.x,t.y),"click"===a?e&&i.onClick&&i.onClick.call(n,t.native,e):(i.onLeave&&e!==n._hoveredItem&&(n._hoveredItem&&i.onLeave.call(n,t.native,n._hoveredItem),n._hoveredItem=e),i.onHover&&e&&i.onHover.call(n,t.native,e))}});function Ai(t,e){var n=new Oi({ctx:t.ctx,options:e,chart:t});pe.configure(t,n,e),pe.addBox(t,n),t.legend=n}var Fi={id:"legend",_element:Oi,beforeInit:function(t){var e=t.options.legend;e&&Ai(t,e)},beforeUpdate:function(t){var e=t.options.legend,n=t.legend;e?(B.mergeIf(e,Y.global.legend),n?(pe.configure(t,n,e),n.options=e):Ai(t,e)):n&&(pe.removeBox(t,n),delete t.legend)},afterEvent:function(t,e){var n=t.legend;n&&n.handleEvent(e)}},Ii=B.noop;Y._set("global",{title:{display:!1,fontStyle:"bold",fullWidth:!0,padding:10,position:"top",text:"",weight:2e3}});var Li=X.extend({initialize:function(t){B.extend(this,t),this.legendHitBoxes=[]},beforeUpdate:Ii,update:function(t,e,n){var i=this;return i.beforeUpdate(),i.maxWidth=t,i.maxHeight=e,i.margins=n,i.beforeSetDimensions(),i.setDimensions(),i.afterSetDimensions(),i.beforeBuildLabels(),i.buildLabels(),i.afterBuildLabels(),i.beforeFit(),i.fit(),i.afterFit(),i.afterUpdate(),i.minSize},afterUpdate:Ii,beforeSetDimensions:Ii,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:Ii,beforeBuildLabels:Ii,buildLabels:Ii,afterBuildLabels:Ii,beforeFit:Ii,fit:function(){var t,e=this,n=e.options,i=e.minSize={},a=e.isHorizontal();n.display?(t=(B.isArray(n.text)?n.text.length:1)*B.options._parseFont(n).lineHeight+2*n.padding,e.width=i.width=a?e.maxWidth:t,e.height=i.height=a?t:e.maxHeight):e.width=i.width=e.height=i.height=0},afterFit:Ii,isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},draw:function(){var t=this,e=t.ctx,n=t.options;if(n.display){var i,a,r,o=B.options._parseFont(n),s=o.lineHeight,l=s/2+n.padding,u=0,d=t.top,h=t.left,c=t.bottom,f=t.right;e.fillStyle=B.valueOrDefault(n.fontColor,Y.global.defaultFontColor),e.font=o.string,t.isHorizontal()?(a=h+(f-h)/2,r=d+l,i=f-h):(a="left"===n.position?h+l:f-l,r=d+(c-d)/2,i=c-d,u=Math.PI*("left"===n.position?-.5:.5)),e.save(),e.translate(a,r),e.rotate(u),e.textAlign="center",e.textBaseline="middle";var g=n.text;if(B.isArray(g))for(var m=0,p=0;p<g.length;++p)e.fillText(g[p],0,m,i),m+=s;else e.fillText(g,0,0,i);e.restore()}}});function Ri(t,e){var n=new Li({ctx:t.ctx,options:e,chart:t});pe.configure(t,n,e),pe.addBox(t,n),t.titleBlock=n}var Ni={},Wi=Si,Yi=Fi,zi={id:"title",_element:Li,beforeInit:function(t){var e=t.options.title;e&&Ri(t,e)},beforeUpdate:function(t){var e=t.options.title,n=t.titleBlock;e?(B.mergeIf(e,Y.global.title),n?(pe.configure(t,n,e),n.options=e):Ri(t,e)):n&&(pe.removeBox(t,n),delete t.titleBlock)}};for(var Ei in Ni.filler=Wi,Ni.legend=Yi,Ni.title=zi,nn.helpers=B,function(){function t(t,e,n){var i;return"string"==typeof t?(i=parseInt(t,10),-1!==t.indexOf("%")&&(i=i/100*e.parentNode[n])):i=t,i}function e(t){return null!=t&&"none"!==t}function n(n,i,a){var r=document.defaultView,o=B._getParentNode(n),s=r.getComputedStyle(n)[i],l=r.getComputedStyle(o)[i],u=e(s),d=e(l),h=Number.POSITIVE_INFINITY;return u||d?Math.min(u?t(s,n,a):h,d?t(l,o,a):h):"none"}B.where=function(t,e){if(B.isArray(t)&&Array.prototype.filter)return t.filter(e);var n=[];return B.each(t,(function(t){e(t)&&n.push(t)})),n},B.findIndex=Array.prototype.findIndex?function(t,e,n){return t.findIndex(e,n)}:function(t,e,n){n=void 0===n?t:n;for(var i=0,a=t.length;i<a;++i)if(e.call(n,t[i],i,t))return i;return-1},B.findNextWhere=function(t,e,n){B.isNullOrUndef(n)&&(n=-1);for(var i=n+1;i<t.length;i++){var a=t[i];if(e(a))return a}},B.findPreviousWhere=function(t,e,n){B.isNullOrUndef(n)&&(n=t.length);for(var i=n-1;i>=0;i--){var a=t[i];if(e(a))return a}},B.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},B.almostEquals=function(t,e,n){return Math.abs(t-e)<n},B.almostWhole=function(t,e){var n=Math.round(t);return n-e<=t&&n+e>=t},B.max=function(t){return t.reduce((function(t,e){return isNaN(e)?t:Math.max(t,e)}),Number.NEGATIVE_INFINITY)},B.min=function(t){return t.reduce((function(t,e){return isNaN(e)?t:Math.min(t,e)}),Number.POSITIVE_INFINITY)},B.sign=Math.sign?function(t){return Math.sign(t)}:function(t){return 0===(t=+t)||isNaN(t)?t:t>0?1:-1},B.toRadians=function(t){return t*(Math.PI/180)},B.toDegrees=function(t){return t*(180/Math.PI)},B._decimalPlaces=function(t){if(B.isFinite(t)){for(var e=1,n=0;Math.round(t*e)/e!==t;)e*=10,n++;return n}},B.getAngleFromPoint=function(t,e){var n=e.x-t.x,i=e.y-t.y,a=Math.sqrt(n*n+i*i),r=Math.atan2(i,n);return r<-.5*Math.PI&&(r+=2*Math.PI),{angle:r,distance:a}},B.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},B.aliasPixel=function(t){return t%2==0?0:.5},B._alignPixel=function(t,e,n){var i=t.currentDevicePixelRatio,a=n/2;return Math.round((e-a)*i)/i+a},B.splineCurve=function(t,e,n,i){var a=t.skip?e:t,r=e,o=n.skip?e:n,s=Math.sqrt(Math.pow(r.x-a.x,2)+Math.pow(r.y-a.y,2)),l=Math.sqrt(Math.pow(o.x-r.x,2)+Math.pow(o.y-r.y,2)),u=s/(s+l),d=l/(s+l),h=i*(u=isNaN(u)?0:u),c=i*(d=isNaN(d)?0:d);return{previous:{x:r.x-h*(o.x-a.x),y:r.y-h*(o.y-a.y)},next:{x:r.x+c*(o.x-a.x),y:r.y+c*(o.y-a.y)}}},B.EPSILON=Number.EPSILON||1e-14,B.splineCurveMonotone=function(t){var e,n,i,a,r,o,s,l,u,d=(t||[]).map((function(t){return{model:t._model,deltaK:0,mK:0}})),h=d.length;for(e=0;e<h;++e)if(!(i=d[e]).model.skip){if(n=e>0?d[e-1]:null,(a=e<h-1?d[e+1]:null)&&!a.model.skip){var c=a.model.x-i.model.x;i.deltaK=0!==c?(a.model.y-i.model.y)/c:0}!n||n.model.skip?i.mK=i.deltaK:!a||a.model.skip?i.mK=n.deltaK:this.sign(n.deltaK)!==this.sign(i.deltaK)?i.mK=0:i.mK=(n.deltaK+i.deltaK)/2}for(e=0;e<h-1;++e)i=d[e],a=d[e+1],i.model.skip||a.model.skip||(B.almostEquals(i.deltaK,0,this.EPSILON)?i.mK=a.mK=0:(r=i.mK/i.deltaK,o=a.mK/i.deltaK,(l=Math.pow(r,2)+Math.pow(o,2))<=9||(s=3/Math.sqrt(l),i.mK=r*s*i.deltaK,a.mK=o*s*i.deltaK)));for(e=0;e<h;++e)(i=d[e]).model.skip||(n=e>0?d[e-1]:null,a=e<h-1?d[e+1]:null,n&&!n.model.skip&&(u=(i.model.x-n.model.x)/3,i.model.controlPointPreviousX=i.model.x-u,i.model.controlPointPreviousY=i.model.y-u*i.mK),a&&!a.model.skip&&(u=(a.model.x-i.model.x)/3,i.model.controlPointNextX=i.model.x+u,i.model.controlPointNextY=i.model.y+u*i.mK))},B.nextItem=function(t,e,n){return n?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},B.previousItem=function(t,e,n){return n?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},B.niceNum=function(t,e){var n=Math.floor(B.log10(t)),i=t/Math.pow(10,n);return(e?i<1.5?1:i<3?2:i<7?5:10:i<=1?1:i<=2?2:i<=5?5:10)*Math.pow(10,n)},B.requestAnimFrame="undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)},B.getRelativePosition=function(t,e){var n,i,a=t.originalEvent||t,r=t.target||t.srcElement,o=r.getBoundingClientRect(),s=a.touches;s&&s.length>0?(n=s[0].clientX,i=s[0].clientY):(n=a.clientX,i=a.clientY);var l=parseFloat(B.getStyle(r,"padding-left")),u=parseFloat(B.getStyle(r,"padding-top")),d=parseFloat(B.getStyle(r,"padding-right")),h=parseFloat(B.getStyle(r,"padding-bottom")),c=o.right-o.left-l-d,f=o.bottom-o.top-u-h;return{x:n=Math.round((n-o.left-l)/c*r.width/e.currentDevicePixelRatio),y:i=Math.round((i-o.top-u)/f*r.height/e.currentDevicePixelRatio)}},B.getConstraintWidth=function(t){return n(t,"max-width","clientWidth")},B.getConstraintHeight=function(t){return n(t,"max-height","clientHeight")},B._calculatePadding=function(t,e,n){return(e=B.getStyle(t,e)).indexOf("%")>-1?n*parseInt(e,10)/100:parseInt(e,10)},B._getParentNode=function(t){var e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e},B.getMaximumWidth=function(t){var e=B._getParentNode(t);if(!e)return t.clientWidth;var n=e.clientWidth,i=n-B._calculatePadding(e,"padding-left",n)-B._calculatePadding(e,"padding-right",n),a=B.getConstraintWidth(t);return isNaN(a)?i:Math.min(i,a)},B.getMaximumHeight=function(t){var e=B._getParentNode(t);if(!e)return t.clientHeight;var n=e.clientHeight,i=n-B._calculatePadding(e,"padding-top",n)-B._calculatePadding(e,"padding-bottom",n),a=B.getConstraintHeight(t);return isNaN(a)?i:Math.min(i,a)},B.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},B.retinaScale=function(t,e){var n=t.currentDevicePixelRatio=e||"undefined"!=typeof window&&window.devicePixelRatio||1;if(1!==n){var i=t.canvas,a=t.height,r=t.width;i.height=a*n,i.width=r*n,t.ctx.scale(n,n),i.style.height||i.style.width||(i.style.height=a+"px",i.style.width=r+"px")}},B.fontString=function(t,e,n){return e+" "+t+"px "+n},B.longestText=function(t,e,n,i){var a=(i=i||{}).data=i.data||{},r=i.garbageCollect=i.garbageCollect||[];i.font!==e&&(a=i.data={},r=i.garbageCollect=[],i.font=e),t.font=e;var o,s,l,u,d,h=0,c=n.length;for(o=0;o<c;o++)if(null!=(u=n[o])&&!0!==B.isArray(u))h=B.measureText(t,a,r,h,u);else if(B.isArray(u))for(s=0,l=u.length;s<l;s++)null==(d=u[s])||B.isArray(d)||(h=B.measureText(t,a,r,h,d));var f=r.length/2;if(f>n.length){for(o=0;o<f;o++)delete a[r[o]];r.splice(0,f)}return h},B.measureText=function(t,e,n,i,a){var r=e[a];return r||(r=e[a]=t.measureText(a).width,n.push(a)),r>i&&(i=r),i},B.numberOfLabelLines=function(t){var e=1;return B.each(t,(function(t){B.isArray(t)&&t.length>e&&(e=t.length)})),e},B.color=w?function(t){return t instanceof CanvasGradient&&(t=Y.global.defaultColor),w(t)}:function(t){return console.error("Color.js not found!"),t},B.getHoverColor=function(t){return t instanceof CanvasPattern||t instanceof CanvasGradient?t:B.color(t).saturate(.5).darken(.1).rgbString()}}(),nn._adapters=on,nn.Animation=J,nn.animationService=Q,nn.controllers=Qt,nn.DatasetController=at,nn.defaults=Y,nn.Element=X,nn.elements=kt,nn.Interaction=oe,nn.layouts=pe,nn.platform=Le,nn.plugins=Re,nn.Scale=_n,nn.scaleService=Ne,nn.Ticks=sn,nn.Tooltip=qe,nn.helpers.each(gi,(function(t,e){nn.scaleService.registerScaleType(e,t,t._defaults)})),Ni)Ni.hasOwnProperty(Ei)&&nn.plugins.register(Ni[Ei]);nn.platform.initialize();var Vi=nn;return"undefined"!=typeof window&&(window.Chart=nn),nn.Chart=nn,nn.Legend=Ni.legend._element,nn.Title=Ni.title._element,nn.pluginService=nn.plugins,nn.PluginBase=nn.Element.extend({}),nn.canvasHelpers=nn.helpers.canvas,nn.layoutService=nn.layouts,nn.LinearScaleBase=Cn,nn.helpers.each(["Bar","Bubble","Doughnut","Line","PolarArea","Radar","Scatter"],(function(t){nn[t]=function(e,n){return new nn(e,nn.helpers.merge(n||{},{type:t.charAt(0).toLowerCase()+t.slice(1)}))}})),Vi}));
  admin-Public-Admin-plugins-chart.js-Chart.css: "/*\n * DOM element rendering detection\n
    * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation
    {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor
    {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing
    detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink
    {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom:
    0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index:
    -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth:
    1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink
    > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop:
    0;\n}\n"
  admin-Public-Admin-plugins-chart.js-Chart.js: "/*!\n * Chart.js v2.9.4\n * https://www.chartjs.org\n
    * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\n(function
    (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined'
    ? module.exports = factory(function() { try { return require('moment'); } catch(e)
    { } }()) :\ntypeof define === 'function' && define.amd ? define(['require'], function(require)
    { return factory(function() { try { return require('moment'); } catch(e) { } }());
    }) :\n(global = global || self, global.Chart = factory(global.moment));\n}(this,
    (function (moment) { 'use strict';\n\nmoment = moment && moment.hasOwnProperty('default')
    ? moment['default'] : moment;\n\nfunction createCommonjsModule(fn, module) {\n\treturn
    module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nfunction
    getCjsExportFromNamespace (n) {\n\treturn n && n['default'] || n;\n}\n\nvar colorName
    = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\":
    [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255,
    255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\":
    [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\":
    [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184,
    135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\":
    [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100,
    149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\":
    [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\":
    [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100,
    0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\":
    [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255,
    140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\":
    [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\":
    [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47,
    79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0,
    211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\":
    [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30,
    144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250,
    240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\":
    [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215,
    0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\":
    [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\":
    [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205,
    92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\":
    [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255,
    240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250,
    205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\":
    [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\":
    [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211,
    211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160,
    122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206,
    250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119,
    136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255,
    255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\":
    [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\":
    [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186,
    85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60,
    179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\":
    [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\":
    [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245,
    255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228,
    181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\":
    [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142,
    35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\":
    [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\":
    [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\":
    [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255,
    218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\":
    [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128,
    0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\":
    [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139,
    69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\":
    [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82,
    45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\":
    [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112,
    128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\":
    [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\":
    [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224,
    208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\":
    [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255,
    255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\nvar conversions = createCommonjsModule(function
    (module) {\n/* MIT license */\n\n\n// NOTE: conversions should only return primitive
    values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//
    \      do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords
    = {};\nfor (var key in colorName) {\n\tif (colorName.hasOwnProperty(key)) {\n\t\treverseKeywords[colorName[key]]
    = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels:
    'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb:
    {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz:
    {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels:
    3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels:
    1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256:
    {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple:
    {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n//
    hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model))
    {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing
    channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model]))
    {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif
    (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new
    Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels
    = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete
    convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model],
    'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels',
    {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0]
    / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r,
    g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar
    s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th
    = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t}
    else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h *
    60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif
    (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max +
    min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100,
    l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar
    bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar
    b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r,
    g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif
    (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif
    = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t}
    else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v)
    {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t}
    else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts
    * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r =
    rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar
    w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r,
    Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk =
    function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b =
    rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r,
    1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k)
    || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100,
    k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n
    * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0],
    2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword
    = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn
    reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor
    (var keyword in colorName) {\n\t\tif (colorName.hasOwnProperty(keyword)) {\n\t\t\tvar
    value = colorName[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar
    distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if
    so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance
    = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn
    currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn
    colorName[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0]
    / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr
    = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g >
    0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045
    ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124)
    + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar
    z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100,
    z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar
    x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx
    /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1
    / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787
    * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16
    / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn
    [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar
    s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar
    rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val,
    val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l
    + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i =
    0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif
    (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2
    - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if
    (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval
    = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv
    = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2]
    / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl
    *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv
    = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn
    [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0]
    / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h)
    % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q =
    255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch
    (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v,
    p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase
    4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl
    = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2]
    / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl
    = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1)
    ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n//
    http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb)
    {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar
    ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant
    be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6
    * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1
    - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar
    g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g
    = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r =
    wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4:
    r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn
    [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar
    c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar
    k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c *
    (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1,
    y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb
    = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z
    = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372)
    + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x
    * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t?
    ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t?
    ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t?
    ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0,
    r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn
    [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar
    x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx
    /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1
    / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787
    * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16
    / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn
    [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar
    a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16)
    / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar
    x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y
    - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz
    = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz
    *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar
    l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar
    c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0)
    {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab
    = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar
    a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb
    = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function
    (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value
    = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue
    = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar
    ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t|
    Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn
    ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we
    already know the value and don't need to get\n\t// it converted for us.\n\treturn
    convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256
    = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t//
    we use the extended greyscale palette here, with the exception of\n\t// black
    and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g ===
    b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn
    231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar
    ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255
    * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb
    = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color
    === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor
    = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult
    = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g =
    (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn
    [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif
    (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs
    -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem
    = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g,
    b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0])
    & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2])
    & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length)
    + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif
    (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif
    (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function
    (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer =
    parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer
    >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg
    = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b
    = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r,
    g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma
    < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif
    (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b)
    / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t}
    else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn
    [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function
    (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar
    f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s
    * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn
    [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s
    = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif
    (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f *
    100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar
    c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g
    * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1)
    * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi))
    {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase
    1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0]
    = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1]
    = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2]
    = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg
    = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1]
    + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function
    (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g *
    (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn
    [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c
    = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar
    s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l
    >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s *
    100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar
    g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100,
    (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] /
    100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif
    (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb
    = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) *
    255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn
    [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb
    = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0]
    / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn
    [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100,
    gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab
    = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function
    (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer =
    (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn
    '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function
    (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n});\nvar
    conversions_1 = conversions.rgb;\nvar conversions_2 = conversions.hsl;\nvar conversions_3
    = conversions.hsv;\nvar conversions_4 = conversions.hwb;\nvar conversions_5 =
    conversions.cmyk;\nvar conversions_6 = conversions.xyz;\nvar conversions_7 = conversions.lab;\nvar
    conversions_8 = conversions.lch;\nvar conversions_9 = conversions.hex;\nvar conversions_10
    = conversions.keyword;\nvar conversions_11 = conversions.ansi16;\nvar conversions_12
    = conversions.ansi256;\nvar conversions_13 = conversions.hcg;\nvar conversions_14
    = conversions.apple;\nvar conversions_15 = conversions.gray;\n\n/*\n\tthis function
    routes a model to all other models.\n\n\tall functions that are routed have a
    property `.conversion` attached\n\tto the returned synthetic function. This property
    is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor
    models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction
    buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar
    models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i
    < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t//
    micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn
    graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel)
    {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue
    -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar
    current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor
    (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar
    node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance
    = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn
    graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn
    to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path
    = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar
    cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn
    = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion
    = path;\n\treturn fn;\n}\n\nvar route = function (fromModel) {\n\tvar graph =
    deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor
    (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar
    node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible
    conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel]
    = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\nvar convert
    = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar
    wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn
    args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn
    fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion'
    in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction
    wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined
    || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1)
    {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result
    = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see
    notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif
    (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i <
    len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn
    result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion'
    in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function
    (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel],
    'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel],
    'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar
    routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel)
    {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw
    = wrapRaw(fn);\n\t});\n});\n\nvar colorConvert = convert;\n\nvar colorName$1 =
    {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\":
    [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255,
    255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\":
    [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\":
    [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184,
    135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\":
    [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100,
    149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\":
    [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\":
    [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100,
    0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\":
    [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255,
    140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\":
    [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\":
    [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47,
    79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0,
    211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\":
    [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30,
    144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250,
    240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\":
    [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215,
    0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\":
    [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\":
    [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205,
    92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\":
    [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255,
    240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250,
    205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\":
    [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\":
    [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211,
    211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160,
    122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206,
    250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119,
    136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255,
    255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\":
    [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\":
    [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186,
    85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60,
    179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\":
    [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\":
    [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245,
    255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228,
    181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\":
    [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142,
    35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\":
    [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\":
    [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\":
    [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255,
    218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\":
    [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128,
    0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\":
    [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139,
    69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\":
    [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82,
    45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\":
    [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112,
    128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\":
    [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\":
    [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224,
    208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\":
    [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255,
    255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\n/* MIT license */\n\n\nvar
    colorString = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n
    \  getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString:
    hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString:
    percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n
    \  hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n};\n\nfunction
    getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3,4})$/i,\n
    \      hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n
    \      per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n
    \      keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match
    = string.match(abbr),\n       hexAlpha = \"\";\n   if (match) {\n      match =
    match[1];\n      hexAlpha = match[3];\n      for (var i = 0; i < rgb.length; i++)
    {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n      if (hexAlpha)
    {\n         a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) /
    100;\n      }\n   }\n   else if (match = string.match(hex)) {\n      hexAlpha
    = match[2];\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++)
    {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n      if
    (hexAlpha) {\n         a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) /
    100;\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var
    i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n
    \     a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per))
    {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i
    + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match
    = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return
    [0, 0, 0, 0];\n      }\n      rgb = colorName$1[match[1]];\n      if (!rgb) {\n
    \        return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n
    \     rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a =
    1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return
    rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n
    \  var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n
    \  var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n
    \     var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]),
    0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha)
    ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string)
    {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n
    \  var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n
    \     var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]),
    0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha)
    ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string)
    {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction
    getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0,
    3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals)
    {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return
    vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n
    \  }\n}\n\n// generators\nfunction hexString(rgba, a) {\n   var a = (a !== undefined
    && rgba.length === 3) ? a : rgba[3];\n   return \"#\" + hexDouble(rgba[0]) \n
    \             + hexDouble(rgba[1])\n              + hexDouble(rgba[2])\n              +
    (\n                 (a >= 0 && a < 1)\n                 ? hexDouble(Math.round(a
    * 255))\n                 : \"\"\n              );\n}\n\nfunction rgbString(rgba,
    alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba,
    alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]
    + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined)
    {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\"
    + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha +
    \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3]
    && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r
    = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n
    \      b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \"
    + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var
    r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n
    \      b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" +
    g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla,
    alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla,
    alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2]
    + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined)
    {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\"
    + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha
    + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no
    alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction
    hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3]
    !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1]
    + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ?
    \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0,
    3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min,
    num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n
    \ return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse
    color names\nvar reverseNames = {};\nfor (var name in colorName$1) {\n   reverseNames[colorName$1[name]]
    = name;\n}\n\n/* MIT license */\n\n\n\nvar Color = function (obj) {\n\tif (obj
    instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn
    new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0,
    0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk:
    [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif
    (typeof obj === 'string') {\n\t\tvals = colorString.getRgba(obj);\n\t\tif (vals)
    {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = colorString.getHsla(obj))
    {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = colorString.getHwb(obj))
    {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object')
    {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb',
    vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl',
    vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv',
    vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb',
    vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk',
    vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn
    this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl:
    function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function
    () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn
    this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk',
    arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray:
    function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn
    this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif
    (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn
    values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray:
    function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray:
    function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha:
    function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha',
    val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb',
    0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1,
    val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue:
    function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360
    + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation:
    function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness:
    function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv:
    function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness:
    function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness:
    function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function
    (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val)
    {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val)
    {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val)
    {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val)
    {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function
    () {\n\t\treturn colorString.hexString(this.values.rgb);\n\t},\n\trgbString: function
    () {\n\t\treturn colorString.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString:
    function () {\n\t\treturn colorString.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString:
    function () {\n\t\treturn colorString.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString:
    function () {\n\t\treturn colorString.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString:
    function () {\n\t\treturn colorString.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString:
    function () {\n\t\treturn colorString.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword:
    function () {\n\t\treturn colorString.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber:
    function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1]
    << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar
    rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length;
    i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan
    / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 *
    lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2)
    {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar
    lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05)
    / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel:
    function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio
    >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA'
    : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar
    rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] *
    114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn
    !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var
    i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb',
    rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl =
    this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn
    this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2]
    -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate:
    function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl',
    hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl
    = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn
    this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1]
    += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken:
    function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb',
    hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t//
    http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar
    val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb',
    [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar
    alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn
    this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha',
    alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees)
    {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0]
    = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t
    * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t
    */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2
    = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w =
    2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w
    * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn
    this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1
    * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha()
    * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn
    this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone
    creates a dependency to Buffer when using browserify,\n\t\t// making the final
    build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming
    that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except
    'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar
    target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source)
    {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype
    = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop]
    = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop]
    = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:',
    value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces
    = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv:
    ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk:
    ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb:
    [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360,
    100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function
    (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0;
    i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif
    (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255,
    b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space,
    vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes
    = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space
    === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10,
    10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t}
    else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor
    (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha
    = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red:
    10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i
    < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha
    = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined
    ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar
    capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i
    = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i],
    values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert
    to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !==
    space) {\n\t\t\tvalues[sname] = colorConvert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn
    true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals =
    args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t//
    color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space,
    vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index,
    val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t//
    color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index])
    {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index]
    = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof
    window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nvar chartjsColor = Color;\n\nfunction
    isValidKey(key) {\r\n\treturn ['__proto__', 'prototype', 'constructor'].indexOf(key)
    === -1;\r\n}\r\n\r\n/**\r\n * @namespace Chart.helpers\r\n */\r\nvar helpers =
    {\r\n\t/**\r\n\t * An empty function that can be used, for example, for optional
    callback.\r\n\t */\r\n\tnoop: function() {},\r\n\r\n\t/**\r\n\t * Returns a unique
    id, sequentially generated from a global variable.\r\n\t * @returns {number}\r\n\t
    * @function\r\n\t */\r\n\tuid: (function() {\r\n\t\tvar id = 0;\r\n\t\treturn
    function() {\r\n\t\t\treturn id++;\r\n\t\t};\r\n\t}()),\r\n\r\n\t/**\r\n\t * Returns
    true if `value` is neither null nor undefined, else returns false.\r\n\t * @param
    {*} value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @since 2.7.0\r\n\t
    */\r\n\tisNullOrUndef: function(value) {\r\n\t\treturn value === null || typeof
    value === 'undefined';\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is
    an array (including typed arrays), else returns false.\r\n\t * @param {*} value
    - The value to test.\r\n\t * @returns {boolean}\r\n\t * @function\r\n\t */\r\n\tisArray:
    function(value) {\r\n\t\tif (Array.isArray && Array.isArray(value)) {\r\n\t\t\treturn
    true;\r\n\t\t}\r\n\t\tvar type = Object.prototype.toString.call(value);\r\n\t\tif
    (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\r\n\t\t\treturn
    true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true
    if `value` is an object (excluding null), else returns false.\r\n\t * @param {*}
    value - The value to test.\r\n\t * @returns {boolean}\r\n\t * @since 2.7.0\r\n\t
    */\r\n\tisObject: function(value) {\r\n\t\treturn value !== null && Object.prototype.toString.call(value)
    === '[object Object]';\r\n\t},\r\n\r\n\t/**\r\n\t * Returns true if `value` is
    a finite number, else returns false\r\n\t * @param {*} value  - The value to test.\r\n\t
    * @returns {boolean}\r\n\t */\r\n\tisFinite: function(value) {\r\n\t\treturn (typeof
    value === 'number' || value instanceof Number) && isFinite(value);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns `value` if defined, else returns `defaultValue`.\r\n\t * @param {*}
    value - The value to return if defined.\r\n\t * @param {*} defaultValue - The
    value to return if `value` is undefined.\r\n\t * @returns {*}\r\n\t */\r\n\tvalueOrDefault:
    function(value, defaultValue) {\r\n\t\treturn typeof value === 'undefined' ? defaultValue
    : value;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns value at the given `index` in array
    if defined, else returns `defaultValue`.\r\n\t * @param {Array} value - The array
    to lookup for value at `index`.\r\n\t * @param {number} index - The index in `value`
    to lookup for value.\r\n\t * @param {*} defaultValue - The value to return if
    `value[index]` is undefined.\r\n\t * @returns {*}\r\n\t */\r\n\tvalueAtIndexOrDefault:
    function(value, index, defaultValue) {\r\n\t\treturn helpers.valueOrDefault(helpers.isArray(value)
    ? value[index] : value, defaultValue);\r\n\t},\r\n\r\n\t/**\r\n\t * Calls `fn`
    with the given `args` in the scope defined by `thisArg` and returns the\r\n\t
    * value returned by `fn`. If `fn` is not a function, this method returns undefined.\r\n\t
    * @param {function} fn - The function to call.\r\n\t * @param {Array|undefined|null}
    args - The arguments with which `fn` should be called.\r\n\t * @param {object}
    [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @returns
    {*}\r\n\t */\r\n\tcallback: function(fn, args, thisArg) {\r\n\t\tif (fn && typeof
    fn.call === 'function') {\r\n\t\t\treturn fn.apply(thisArg, args);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Note(SB) for performance sake, this method should only be used when loopable
    type\r\n\t * is unknown or in none intensive code (not called often and small
    loopable). Else\r\n\t * it's preferable to use a regular for() loop and save extra
    function calls.\r\n\t * @param {object|Array} loopable - The object or array to
    be iterated.\r\n\t * @param {function} fn - The function to call for each item.\r\n\t
    * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t
    * @param {boolean} [reverse] - If true, iterates backward on the loopable.\r\n\t
    */\r\n\teach: function(loopable, fn, thisArg, reverse) {\r\n\t\tvar i, len, keys;\r\n\t\tif
    (helpers.isArray(loopable)) {\r\n\t\t\tlen = loopable.length;\r\n\t\t\tif (reverse)
    {\r\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i],
    i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\t\tfn.call(thisArg,
    loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (helpers.isObject(loopable))
    {\r\n\t\t\tkeys = Object.keys(loopable);\r\n\t\t\tlen = keys.length;\r\n\t\t\tfor
    (i = 0; i < len; i++) {\r\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns true if the `a0` and `a1` arrays have the same content, else returns
    false.\r\n\t * @see https://stackoverflow.com/a/14853974\r\n\t * @param {Array}
    a0 - The array to compare\r\n\t * @param {Array} a1 - The array to compare\r\n\t
    * @returns {boolean}\r\n\t */\r\n\tarrayEquals: function(a0, a1) {\r\n\t\tvar
    i, ilen, v0, v1;\r\n\r\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\r\n\t\t\treturn
    false;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n\t\t\tv0
    = a0[i];\r\n\t\t\tv1 = a1[i];\r\n\r\n\t\t\tif (v0 instanceof Array && v1 instanceof
    Array) {\r\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}
    else if (v0 !== v1) {\r\n\t\t\t\t// NOTE: two different object instances will
    never be equal: {x:20} != {x:20}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    true;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a deep copy of `source` without keeping
    references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t
    * @returns {*}\r\n\t */\r\n\tclone: function(source) {\r\n\t\tif (helpers.isArray(source))
    {\r\n\t\t\treturn source.map(helpers.clone);\r\n\t\t}\r\n\r\n\t\tif (helpers.isObject(source))
    {\r\n\t\t\tvar target = Object.create(source);\r\n\t\t\tvar keys = Object.keys(source);\r\n\t\t\tvar
    klen = keys.length;\r\n\t\t\tvar k = 0;\r\n\r\n\t\t\tfor (; k < klen; ++k) {\r\n\t\t\t\ttarget[keys[k]]
    = helpers.clone(source[keys[k]]);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\treturn
    source;\r\n\t},\r\n\r\n\t/**\r\n\t * The default merger when Chart.helpers.merge
    is called without merger option.\r\n\t * Note(SB): also used by mergeConfig and
    mergeScaleConfig as fallback.\r\n\t * @private\r\n\t */\r\n\t_merger: function(key,
    target, source, options) {\r\n\t\tif (!isValidKey(key)) {\r\n\t\t\t// We want
    to ensure we do not copy prototypes over\r\n\t\t\t// as this can pollute global
    namespaces\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tval = target[key];\r\n\t\tvar
    sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval))
    {\r\n\t\t\thelpers.merge(tval, sval, options);\r\n\t\t} else {\r\n\t\t\ttarget[key]
    = helpers.clone(sval);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Merges source[key]
    in target[key] only if target[key] is undefined.\r\n\t * @private\r\n\t */\r\n\t_mergerIf:
    function(key, target, source) {\r\n\t\tif (!isValidKey(key)) {\r\n\t\t\t// We
    want to ensure we do not copy prototypes over\r\n\t\t\t// as this can pollute
    global namespaces\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tval = target[key];\r\n\t\tvar
    sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval))
    {\r\n\t\t\thelpers.mergeIf(tval, sval);\r\n\t\t} else if (!target.hasOwnProperty(key))
    {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Recursively deep copies `source` properties into `target` with the given `options`.\r\n\t
    * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t
    * @param {object} target - The target object in which all sources are merged into.\r\n\t
    * @param {object|object[]} source - Object(s) to merge into `target`.\r\n\t *
    @param {object} [options] - Merging options:\r\n\t * @param {function} [options.merger]
    - The merge method (key, target, source, options)\r\n\t * @returns {object} The
    `target` object.\r\n\t */\r\n\tmerge: function(target, source, options) {\r\n\t\tvar
    sources = helpers.isArray(source) ? source : [source];\r\n\t\tvar ilen = sources.length;\r\n\t\tvar
    merge, i, keys, klen, k;\r\n\r\n\t\tif (!helpers.isObject(target)) {\r\n\t\t\treturn
    target;\r\n\t\t}\r\n\r\n\t\toptions = options || {};\r\n\t\tmerge = options.merger
    || helpers._merger;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tsource =
    sources[i];\r\n\t\t\tif (!helpers.isObject(source)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tkeys
    = Object.keys(source);\r\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k)
    {\r\n\t\t\t\tmerge(keys[k], target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    target;\r\n\t},\r\n\r\n\t/**\r\n\t * Recursively deep copies `source` properties
    into `target` *only* if not defined in target.\r\n\t * IMPORTANT: `target` is
    not cloned and will be updated with `source` properties.\r\n\t * @param {object}
    target - The target object in which all sources are merged into.\r\n\t * @param
    {object|object[]} source - Object(s) to merge into `target`.\r\n\t * @returns
    {object} The `target` object.\r\n\t */\r\n\tmergeIf: function(target, source)
    {\r\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\r\n\t},\r\n\r\n\t/**\r\n\t
    * Applies the contents of two or more objects together into the first object.\r\n\t
    * @param {object} target - The target object in which all objects are merged into.\r\n\t
    * @param {object} arg1 - Object containing additional properties to merge in target.\r\n\t
    * @param {object} argN - Additional objects containing properties to merge in
    target.\r\n\t * @returns {object} The `target` object.\r\n\t */\r\n\textend: Object.assign
    || function(target) {\r\n\t\treturn helpers.merge(target, [].slice.call(arguments,
    1), {\r\n\t\t\tmerger: function(key, dst, src) {\r\n\t\t\t\tdst[key] = src[key];\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t
    * Basic javascript inheritance based on the model created in Backbone.js\r\n\t
    */\r\n\tinherits: function(extensions) {\r\n\t\tvar me = this;\r\n\t\tvar ChartElement
    = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor
    : function() {\r\n\t\t\treturn me.apply(this, arguments);\r\n\t\t};\r\n\r\n\t\tvar
    Surrogate = function() {\r\n\t\t\tthis.constructor = ChartElement;\r\n\t\t};\r\n\r\n\t\tSurrogate.prototype
    = me.prototype;\r\n\t\tChartElement.prototype = new Surrogate();\r\n\t\tChartElement.extend
    = helpers.inherits;\r\n\r\n\t\tif (extensions) {\r\n\t\t\thelpers.extend(ChartElement.prototype,
    extensions);\r\n\t\t}\r\n\r\n\t\tChartElement.__super__ = me.prototype;\r\n\t\treturn
    ChartElement;\r\n\t},\r\n\r\n\t_deprecated: function(scope, value, previous, current)
    {\r\n\t\tif (value !== undefined) {\r\n\t\t\tconsole.warn(scope + ': \"' + previous
    +\r\n\t\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar
    helpers_core = helpers;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward
    compatibility, use Chart.helpers.callback instead.\r\n * @function Chart.helpers.callCallback\r\n
    * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nhelpers.callCallback = helpers.callback;\r\n\r\n/**\r\n * Provided for backward
    compatibility, use Array.prototype.indexOf instead.\r\n * Array.prototype.indexOf
    compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\r\n * @function Chart.helpers.indexOf\r\n
    * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nhelpers.indexOf = function(array, item, fromIndex) {\r\n\treturn Array.prototype.indexOf.call(array,
    item, fromIndex);\r\n};\r\n\r\n/**\r\n * Provided for backward compatibility,
    use Chart.helpers.valueOrDefault instead.\r\n * @function Chart.helpers.getValueOrDefault\r\n
    * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nhelpers.getValueOrDefault = helpers.valueOrDefault;\r\n\r\n/**\r\n * Provided
    for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\r\n
    * @function Chart.helpers.getValueAtIndexOrDefault\r\n * @deprecated since version
    2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.getValueAtIndexOrDefault
    = helpers.valueAtIndexOrDefault;\n\n/**\r\n * Easing functions adapted from Robert
    Penner's easing equations.\r\n * @namespace Chart.helpers.easingEffects\r\n *
    @see http://www.robertpenner.com/easing/\r\n */\r\nvar effects = {\r\n\tlinear:
    function(t) {\r\n\t\treturn t;\r\n\t},\r\n\r\n\teaseInQuad: function(t) {\r\n\t\treturn
    t * t;\r\n\t},\r\n\r\n\teaseOutQuad: function(t) {\r\n\t\treturn -t * (t - 2);\r\n\t},\r\n\r\n\teaseInOutQuad:
    function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t;\r\n\t\t}\r\n\t\treturn
    -0.5 * ((--t) * (t - 2) - 1);\r\n\t},\r\n\r\n\teaseInCubic: function(t) {\r\n\t\treturn
    t * t * t;\r\n\t},\r\n\r\n\teaseOutCubic: function(t) {\r\n\t\treturn (t = t -
    1) * t * t + 1;\r\n\t},\r\n\r\n\teaseInOutCubic: function(t) {\r\n\t\tif ((t /=
    0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t;\r\n\t\t}\r\n\t\treturn 0.5 * ((t
    -= 2) * t * t + 2);\r\n\t},\r\n\r\n\teaseInQuart: function(t) {\r\n\t\treturn
    t * t * t * t;\r\n\t},\r\n\r\n\teaseOutQuart: function(t) {\r\n\t\treturn -((t
    = t - 1) * t * t * t - 1);\r\n\t},\r\n\r\n\teaseInOutQuart: function(t) {\r\n\t\tif
    ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t * t;\r\n\t\t}\r\n\t\treturn
    -0.5 * ((t -= 2) * t * t * t - 2);\r\n\t},\r\n\r\n\teaseInQuint: function(t) {\r\n\t\treturn
    t * t * t * t * t;\r\n\t},\r\n\r\n\teaseOutQuint: function(t) {\r\n\t\treturn
    (t = t - 1) * t * t * t * t + 1;\r\n\t},\r\n\r\n\teaseInOutQuint: function(t)
    {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * t * t * t * t * t;\r\n\t\t}\r\n\t\treturn
    0.5 * ((t -= 2) * t * t * t * t + 2);\r\n\t},\r\n\r\n\teaseInSine: function(t)
    {\r\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\r\n\t},\r\n\r\n\teaseOutSine:
    function(t) {\r\n\t\treturn Math.sin(t * (Math.PI / 2));\r\n\t},\r\n\r\n\teaseInOutSine:
    function(t) {\r\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\r\n\t},\r\n\r\n\teaseInExpo:
    function(t) {\r\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\r\n\t},\r\n\r\n\teaseOutExpo:
    function(t) {\r\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\r\n\t},\r\n\r\n\teaseInOutExpo:
    function(t) {\r\n\t\tif (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t ===
    1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn
    0.5 * Math.pow(2, 10 * (t - 1));\r\n\t\t}\r\n\t\treturn 0.5 * (-Math.pow(2, -10
    * --t) + 2);\r\n\t},\r\n\r\n\teaseInCirc: function(t) {\r\n\t\tif (t >= 1) {\r\n\t\t\treturn
    t;\r\n\t\t}\r\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\r\n\t},\r\n\r\n\teaseOutCirc:
    function(t) {\r\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\r\n\t},\r\n\r\n\teaseInOutCirc:
    function(t) {\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn -0.5 * (Math.sqrt(1
    - t * t) - 1);\r\n\t\t}\r\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\r\n\t},\r\n\r\n\teaseInElastic:
    function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif
    (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn
    1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.3;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta
    = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1
    / a);\r\n\t\t}\r\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t -
    s) * (2 * Math.PI) / p));\r\n\t},\r\n\r\n\teaseOutElastic: function(t) {\r\n\t\tvar
    s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif (t === 0) {\r\n\t\t\treturn
    0;\r\n\t\t}\r\n\t\tif (t === 1) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp
    = 0.3;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta = 1;\r\n\t\t\ts = p / 4;\r\n\t\t}
    else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\r\n\t\t}\r\n\t\treturn
    a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\r\n\t},\r\n\r\n\teaseInOutElastic:
    function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tvar p = 0;\r\n\t\tvar a = 1;\r\n\t\tif
    (t === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif ((t /= 0.5) === 2) {\r\n\t\t\treturn
    1;\r\n\t\t}\r\n\t\tif (!p) {\r\n\t\t\tp = 0.45;\r\n\t\t}\r\n\t\tif (a < 1) {\r\n\t\t\ta
    = 1;\r\n\t\t\ts = p / 4;\r\n\t\t} else {\r\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1
    / a);\r\n\t\t}\r\n\t\tif (t < 1) {\r\n\t\t\treturn -0.5 * (a * Math.pow(2, 10
    * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\r\n\t\t}\r\n\t\treturn a
    * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 +
    1;\r\n\t},\r\n\teaseInBack: function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\treturn
    t * t * ((s + 1) * t - s);\r\n\t},\r\n\r\n\teaseOutBack: function(t) {\r\n\t\tvar
    s = 1.70158;\r\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\r\n\t},\r\n\r\n\teaseInOutBack:
    function(t) {\r\n\t\tvar s = 1.70158;\r\n\t\tif ((t /= 0.5) < 1) {\r\n\t\t\treturn
    0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n\t\t}\r\n\t\treturn 0.5 * ((t
    -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n\t},\r\n\r\n\teaseInBounce:
    function(t) {\r\n\t\treturn 1 - effects.easeOutBounce(1 - t);\r\n\t},\r\n\r\n\teaseOutBounce:
    function(t) {\r\n\t\tif (t < (1 / 2.75)) {\r\n\t\t\treturn 7.5625 * t * t;\r\n\t\t}\r\n\t\tif
    (t < (2 / 2.75)) {\r\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\r\n\t\t}\r\n\t\tif
    (t < (2.5 / 2.75)) {\r\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\r\n\t\t}\r\n\t\treturn
    7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\r\n\t},\r\n\r\n\teaseInOutBounce:
    function(t) {\r\n\t\tif (t < 0.5) {\r\n\t\t\treturn effects.easeInBounce(t * 2)
    * 0.5;\r\n\t\t}\r\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\r\n\t}\r\n};\r\n\r\nvar
    helpers_easing = {\r\n\teffects: effects\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\r\n
    * @function Chart.helpers.easingEffects\r\n * @deprecated since version 2.7.0\r\n
    * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.easingEffects
    = effects;\n\nvar PI = Math.PI;\r\nvar RAD_PER_DEG = PI / 180;\r\nvar DOUBLE_PI
    = PI * 2;\r\nvar HALF_PI = PI / 2;\r\nvar QUARTER_PI = PI / 4;\r\nvar TWO_THIRDS_PI
    = PI * 2 / 3;\r\n\r\n/**\r\n * @namespace Chart.helpers.canvas\r\n */\r\nvar exports$1
    = {\r\n\t/**\r\n\t * Clears the entire canvas associated to the given `chart`.\r\n\t
    * @param {Chart} chart - The chart for which to clear the canvas.\r\n\t */\r\n\tclear:
    function(chart) {\r\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with
    a\r\n\t * given size (width, height) and the same `radius` for all corners.\r\n\t
    * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n\t * @param
    {number} x - The x axis of the coordinate for the rectangle starting point.\r\n\t
    * @param {number} y - The y axis of the coordinate for the rectangle starting
    point.\r\n\t * @param {number} width - The rectangle's width.\r\n\t * @param {number}
    height - The rectangle's height.\r\n\t * @param {number} radius - The rounded
    amount (in pixels) for the four corners.\r\n\t * @todo handle `radius` as top-left,
    top-right, bottom-right, bottom-left array/object?\r\n\t */\r\n\troundedRect:
    function(ctx, x, y, width, height, radius) {\r\n\t\tif (radius) {\r\n\t\t\tvar
    r = Math.min(radius, height / 2, width / 2);\r\n\t\t\tvar left = x + r;\r\n\t\t\tvar
    top = y + r;\r\n\t\t\tvar right = x + width - r;\r\n\t\t\tvar bottom = y + height
    - r;\r\n\r\n\t\t\tctx.moveTo(x, top);\r\n\t\t\tif (left < right && top < bottom)
    {\r\n\t\t\t\tctx.arc(left, top, r, -PI, -HALF_PI);\r\n\t\t\t\tctx.arc(right, top,
    r, -HALF_PI, 0);\r\n\t\t\t\tctx.arc(right, bottom, r, 0, HALF_PI);\r\n\t\t\t\tctx.arc(left,
    bottom, r, HALF_PI, PI);\r\n\t\t\t} else if (left < right) {\r\n\t\t\t\tctx.moveTo(left,
    y);\r\n\t\t\t\tctx.arc(right, top, r, -HALF_PI, HALF_PI);\r\n\t\t\t\tctx.arc(left,
    top, r, HALF_PI, PI + HALF_PI);\r\n\t\t\t} else if (top < bottom) {\r\n\t\t\t\tctx.arc(left,
    top, r, -PI, 0);\r\n\t\t\t\tctx.arc(left, bottom, r, 0, PI);\r\n\t\t\t} else {\r\n\t\t\t\tctx.arc(left,
    top, r, -PI, PI);\r\n\t\t\t}\r\n\t\t\tctx.closePath();\r\n\t\t\tctx.moveTo(x,
    y);\r\n\t\t} else {\r\n\t\t\tctx.rect(x, y, width, height);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawPoint:
    function(ctx, style, radius, x, y, rotation) {\r\n\t\tvar type, xOffset, yOffset,
    size, cornerRadius;\r\n\t\tvar rad = (rotation || 0) * RAD_PER_DEG;\r\n\r\n\t\tif
    (style && typeof style === 'object') {\r\n\t\t\ttype = style.toString();\r\n\t\t\tif
    (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]')
    {\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.translate(x, y);\r\n\t\t\t\tctx.rotate(rad);\r\n\t\t\t\tctx.drawImage(style,
    -style.width / 2, -style.height / 2, style.width, style.height);\r\n\t\t\t\tctx.restore();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (isNaN(radius) || radius <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\r\n\t\tswitch
    (style) {\r\n\t\t// Default includes circle\r\n\t\tdefault:\r\n\t\t\tctx.arc(x,
    y, radius, 0, DOUBLE_PI);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'triangle':\r\n\t\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad)
    * radius);\r\n\t\t\trad += TWO_THIRDS_PI;\r\n\t\t\tctx.lineTo(x + Math.sin(rad)
    * radius, y - Math.cos(rad) * radius);\r\n\t\t\trad += TWO_THIRDS_PI;\r\n\t\t\tctx.lineTo(x
    + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'rectRounded':\r\n\t\t\t// NOTE: the rounded rect implementation changed to use
    `arc` instead of\r\n\t\t\t// `quadraticCurveTo` since it generates better results
    when rect is\r\n\t\t\t// almost a circle. 0.516 (instead of 0.5) produces results
    with visually\r\n\t\t\t// closer proportion to the previous impl and it is inscribed
    in the\r\n\t\t\t// circle with `radius`. For more details, see the following PRs:\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/5597\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5858\r\n\t\t\tcornerRadius
    = radius * 0.516;\r\n\t\t\tsize = radius - cornerRadius;\r\n\t\t\txOffset = Math.cos(rad
    + QUARTER_PI) * size;\r\n\t\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\r\n\t\t\tctx.arc(x
    - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n\t\t\tctx.arc(x
    + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n\t\t\tctx.arc(x
    + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n\t\t\tctx.arc(x
    - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'rect':\r\n\t\t\tif (!rotation) {\r\n\t\t\t\tsize = Math.SQRT1_2 * radius;\r\n\t\t\t\tctx.rect(x
    - size, y - size, 2 * size, 2 * size);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trad
    += QUARTER_PI;\r\n\t\t\t/* falls through */\r\n\t\tcase 'rectRot':\r\n\t\t\txOffset
    = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x
    - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x
    + xOffset, y + yOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase
    'crossRot':\r\n\t\t\trad += QUARTER_PI;\r\n\t\t\t/* falls through */\r\n\t\tcase
    'cross':\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad)
    * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x
    + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x
    - yOffset, y + xOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'star':\r\n\t\t\txOffset
    = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x
    - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x
    + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\r\n\t\t\trad
    += QUARTER_PI;\r\n\t\t\txOffset = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad)
    * radius;\r\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x
    + xOffset, y + yOffset);\r\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\r\n\t\t\tctx.lineTo(x
    - yOffset, y + xOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'line':\r\n\t\t\txOffset
    = Math.cos(rad) * radius;\r\n\t\t\tyOffset = Math.sin(rad) * radius;\r\n\t\t\tctx.moveTo(x
    - xOffset, y - yOffset);\r\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\r\n\t\t\tbreak;\r\n\t\tcase
    'dash':\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t\tctx.lineTo(x + Math.cos(rad) * radius,
    y + Math.sin(rad) * radius);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tctx.fill();\r\n\t\tctx.stroke();\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns true if the point is inside the rectangle\r\n\t * @param {object} point
    - The point to test\r\n\t * @param {object} area - The rectangle\r\n\t * @returns
    {boolean}\r\n\t * @private\r\n\t */\r\n\t_isPointInArea: function(point, area)
    {\r\n\t\tvar epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n\r\n\t\treturn
    point.x > area.left - epsilon && point.x < area.right + epsilon &&\r\n\t\t\tpoint.y
    > area.top - epsilon && point.y < area.bottom + epsilon;\r\n\t},\r\n\r\n\tclipArea:
    function(ctx, area) {\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(area.left,
    area.top, area.right - area.left, area.bottom - area.top);\r\n\t\tctx.clip();\r\n\t},\r\n\r\n\tunclipArea:
    function(ctx) {\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tlineTo: function(ctx, previous,
    target, flip) {\r\n\t\tvar stepped = target.steppedLine;\r\n\t\tif (stepped) {\r\n\t\t\tif
    (stepped === 'middle') {\r\n\t\t\t\tvar midpoint = (previous.x + target.x) / 2.0;\r\n\t\t\t\tctx.lineTo(midpoint,
    flip ? target.y : previous.y);\r\n\t\t\t\tctx.lineTo(midpoint, flip ? previous.y
    : target.y);\r\n\t\t\t} else if ((stepped === 'after' && !flip) || (stepped !==
    'after' && flip)) {\r\n\t\t\t\tctx.lineTo(previous.x, target.y);\r\n\t\t\t} else
    {\r\n\t\t\t\tctx.lineTo(target.x, previous.y);\r\n\t\t\t}\r\n\t\t\tctx.lineTo(target.x,
    target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!target.tension) {\r\n\t\t\tctx.lineTo(target.x,
    target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.bezierCurveTo(\r\n\t\t\tflip
    ? previous.controlPointPreviousX : previous.controlPointNextX,\r\n\t\t\tflip ?
    previous.controlPointPreviousY : previous.controlPointNextY,\r\n\t\t\tflip ? target.controlPointNextX
    : target.controlPointPreviousX,\r\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\r\n\t\t\ttarget.x,\r\n\t\t\ttarget.y);\r\n\t}\r\n};\r\n\r\nvar
    helpers_canvas = exports$1;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for
    backward compatibility, use Chart.helpers.canvas.clear instead.\r\n * @namespace
    Chart.helpers.clear\r\n * @deprecated since version 2.7.0\r\n * @todo remove at
    version 3\r\n * @private\r\n */\r\nhelpers_core.clear = exports$1.clear;\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\r\n
    * @namespace Chart.helpers.drawRoundedRectangle\r\n * @deprecated since version
    2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.drawRoundedRectangle
    = function(ctx) {\r\n\tctx.beginPath();\r\n\texports$1.roundedRect.apply(exports$1,
    arguments);\r\n};\n\nvar defaults = {\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_set:
    function(scope, values) {\r\n\t\treturn helpers_core.merge(this[scope] || (this[scope]
    = {}), values);\r\n\t}\r\n};\r\n\r\n// TODO(v3): remove 'global' from namespace.
    \ all default are global and\r\n// there's inconsistency around which options
    are under 'global'\r\ndefaults._set('global', {\r\n\tdefaultColor: 'rgba(0,0,0,0.1)',\r\n\tdefaultFontColor:
    '#666',\r\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n\tdefaultFontSize:
    12,\r\n\tdefaultFontStyle: 'normal',\r\n\tdefaultLineHeight: 1.2,\r\n\tshowLines:
    true\r\n});\r\n\r\nvar core_defaults = defaults;\n\nvar valueOrDefault = helpers_core.valueOrDefault;\r\n\r\n/**\r\n
    * Converts the given font object into a CSS font string.\r\n * @param {object}
    font - A font object.\r\n * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n
    * @private\r\n */\r\nfunction toFontString(font) {\r\n\tif (!font || helpers_core.isNullOrUndef(font.size)
    || helpers_core.isNullOrUndef(font.family)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn
    (font.style ? font.style + ' ' : '')\r\n\t\t+ (font.weight ? font.weight + ' '
    : '')\r\n\t\t+ font.size + 'px '\r\n\t\t+ font.family;\r\n}\r\n\r\n/**\r\n * @alias
    Chart.helpers.options\r\n * @namespace\r\n */\r\nvar helpers_options = {\r\n\t/**\r\n\t
    * Converts the given line height `value` in pixels for a specific font `size`.\r\n\t
    * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%',
    '1.6em').\r\n\t * @param {number} size - The font size (in pixels) used to resolve
    relative `value`.\r\n\t * @returns {number} The effective line height in pixels
    (size * 1.2 if value is invalid).\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\r\n\t
    * @since 2.7.0\r\n\t */\r\n\ttoLineHeight: function(value, size) {\r\n\t\tvar
    matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\r\n\t\tif
    (!matches || matches[1] === 'normal') {\r\n\t\t\treturn size * 1.2;\r\n\t\t}\r\n\r\n\t\tvalue
    = +matches[2];\r\n\r\n\t\tswitch (matches[3]) {\r\n\t\tcase 'px':\r\n\t\t\treturn
    value;\r\n\t\tcase '%':\r\n\t\t\tvalue /= 100;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn
    size * value;\r\n\t},\r\n\r\n\t/**\r\n\t * Converts the given value into a padding
    object with pre-computed width/height.\r\n\t * @param {number|object} value -
    If a number, set the value to all TRBL component,\r\n\t *  else, if and object,
    use defined properties and sets undefined ones to 0.\r\n\t * @returns {object}
    The padding values (top, right, bottom, left, width, height)\r\n\t * @since 2.7.0\r\n\t
    */\r\n\ttoPadding: function(value) {\r\n\t\tvar t, r, b, l;\r\n\r\n\t\tif (helpers_core.isObject(value))
    {\r\n\t\t\tt = +value.top || 0;\r\n\t\t\tr = +value.right || 0;\r\n\t\t\tb = +value.bottom
    || 0;\r\n\t\t\tl = +value.left || 0;\r\n\t\t} else {\r\n\t\t\tt = r = b = l =
    +value || 0;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttop: t,\r\n\t\t\tright: r,\r\n\t\t\tbottom:
    b,\r\n\t\t\tleft: l,\r\n\t\t\theight: t + b,\r\n\t\t\twidth: l + r\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * Parses font options and returns the font object.\r\n\t * @param {object} options
    - A object that contains font options to be parsed.\r\n\t * @return {object} The
    font object.\r\n\t * @todo Support font.* options and renamed to toFont().\r\n\t
    * @private\r\n\t */\r\n\t_parseFont: function(options) {\r\n\t\tvar globalDefaults
    = core_defaults.global;\r\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\r\n\t\tvar
    font = {\r\n\t\t\tfamily: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\r\n\t\t\tlineHeight:
    helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight),
    size),\r\n\t\t\tsize: size,\r\n\t\t\tstyle: valueOrDefault(options.fontStyle,
    globalDefaults.defaultFontStyle),\r\n\t\t\tweight: null,\r\n\t\t\tstring: ''\r\n\t\t};\r\n\r\n\t\tfont.string
    = toFontString(font);\r\n\t\treturn font;\r\n\t},\r\n\r\n\t/**\r\n\t * Evaluates
    the given `inputs` sequentially and returns the first defined value.\r\n\t * @param
    {Array} inputs - An array of values, falling back to the last value.\r\n\t * @param
    {object} [context] - If defined and the current value is a function, the value\r\n\t
    * is called with `context` as first argument and the result becomes the new input.\r\n\t
    * @param {number} [index] - If defined and the current value is an array, the
    value\r\n\t * at `index` become the new input.\r\n\t * @param {object} [info]
    - object to return information about resolution in\r\n\t * @param {boolean} [info.cacheable]
    - Will be set to `false` if option is not cacheable.\r\n\t * @since 2.7.0\r\n\t
    */\r\n\tresolve: function(inputs, context, index, info) {\r\n\t\tvar cacheable
    = true;\r\n\t\tvar i, ilen, value;\r\n\r\n\t\tfor (i = 0, ilen = inputs.length;
    i < ilen; ++i) {\r\n\t\t\tvalue = inputs[i];\r\n\t\t\tif (value === undefined)
    {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (context !== undefined && typeof
    value === 'function') {\r\n\t\t\t\tvalue = value(context);\r\n\t\t\t\tcacheable
    = false;\r\n\t\t\t}\r\n\t\t\tif (index !== undefined && helpers_core.isArray(value))
    {\r\n\t\t\t\tvalue = value[index];\r\n\t\t\t\tcacheable = false;\r\n\t\t\t}\r\n\t\t\tif
    (value !== undefined) {\r\n\t\t\t\tif (info && !cacheable) {\r\n\t\t\t\t\tinfo.cacheable
    = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\n/**\r\n
    * @alias Chart.helpers.math\r\n * @namespace\r\n */\r\nvar exports$2 = {\r\n\t/**\r\n\t
    * Returns an array of factors sorted from 1 to sqrt(value)\r\n\t * @private\r\n\t
    */\r\n\t_factorize: function(value) {\r\n\t\tvar result = [];\r\n\t\tvar sqrt
    = Math.sqrt(value);\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 1; i < sqrt; i++) {\r\n\t\t\tif
    (value % i === 0) {\r\n\t\t\t\tresult.push(i);\r\n\t\t\t\tresult.push(value /
    i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sqrt === (sqrt | 0)) { // if value is a square
    number\r\n\t\t\tresult.push(sqrt);\r\n\t\t}\r\n\r\n\t\tresult.sort(function(a,
    b) {\r\n\t\t\treturn a - b;\r\n\t\t}).pop();\r\n\t\treturn result;\r\n\t},\r\n\r\n\tlog10:
    Math.log10 || function(x) {\r\n\t\tvar exponent = Math.log(x) * Math.LOG10E; //
    Math.LOG10E = 1 / Math.LN10.\r\n\t\t// Check for whole powers of 10,\r\n\t\t//
    which due to floating point rounding error should be corrected.\r\n\t\tvar powerOf10
    = Math.round(exponent);\r\n\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\r\n\r\n\t\treturn
    isPowerOf10 ? powerOf10 : exponent;\r\n\t}\r\n};\r\n\r\nvar helpers_math = exports$2;\r\n\r\n//
    DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.math.log10
    instead.\r\n * @namespace Chart.helpers.log10\r\n * @deprecated since version
    2.9.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers_core.log10
    = exports$2.log10;\n\nvar getRtlAdapter = function(rectX, width) {\r\n\treturn
    {\r\n\t\tx: function(x) {\r\n\t\t\treturn rectX + rectX + width - x;\r\n\t\t},\r\n\t\tsetWidth:
    function(w) {\r\n\t\t\twidth = w;\r\n\t\t},\r\n\t\ttextAlign: function(align)
    {\r\n\t\t\tif (align === 'center') {\r\n\t\t\t\treturn align;\r\n\t\t\t}\r\n\t\t\treturn
    align === 'right' ? 'left' : 'right';\r\n\t\t},\r\n\t\txPlus: function(x, value)
    {\r\n\t\t\treturn x - value;\r\n\t\t},\r\n\t\tleftForLtr: function(x, itemWidth)
    {\r\n\t\t\treturn x - itemWidth;\r\n\t\t},\r\n\t};\r\n};\r\n\r\nvar getLtrAdapter
    = function() {\r\n\treturn {\r\n\t\tx: function(x) {\r\n\t\t\treturn x;\r\n\t\t},\r\n\t\tsetWidth:
    function(w) { // eslint-disable-line no-unused-vars\r\n\t\t},\r\n\t\ttextAlign:
    function(align) {\r\n\t\t\treturn align;\r\n\t\t},\r\n\t\txPlus: function(x, value)
    {\r\n\t\t\treturn x + value;\r\n\t\t},\r\n\t\tleftForLtr: function(x, _itemWidth)
    { // eslint-disable-line no-unused-vars\r\n\t\t\treturn x;\r\n\t\t},\r\n\t};\r\n};\r\n\r\nvar
    getAdapter = function(rtl, rectX, width) {\r\n\treturn rtl ? getRtlAdapter(rectX,
    width) : getLtrAdapter();\r\n};\r\n\r\nvar overrideTextDirection = function(ctx,
    direction) {\r\n\tvar style, original;\r\n\tif (direction === 'ltr' || direction
    === 'rtl') {\r\n\t\tstyle = ctx.canvas.style;\r\n\t\toriginal = [\r\n\t\t\tstyle.getPropertyValue('direction'),\r\n\t\t\tstyle.getPropertyPriority('direction'),\r\n\t\t];\r\n\r\n\t\tstyle.setProperty('direction',
    direction, 'important');\r\n\t\tctx.prevTextDirection = original;\r\n\t}\r\n};\r\n\r\nvar
    restoreTextDirection = function(ctx) {\r\n\tvar original = ctx.prevTextDirection;\r\n\tif
    (original !== undefined) {\r\n\t\tdelete ctx.prevTextDirection;\r\n\t\tctx.canvas.style.setProperty('direction',
    original[0], original[1]);\r\n\t}\r\n};\r\n\r\nvar helpers_rtl = {\r\n\tgetRtlAdapter:
    getAdapter,\r\n\toverrideTextDirection: overrideTextDirection,\r\n\trestoreTextDirection:
    restoreTextDirection,\r\n};\n\nvar helpers$1 = helpers_core;\r\nvar easing = helpers_easing;\r\nvar
    canvas = helpers_canvas;\r\nvar options = helpers_options;\r\nvar math = helpers_math;\r\nvar
    rtl = helpers_rtl;\nhelpers$1.easing = easing;\nhelpers$1.canvas = canvas;\nhelpers$1.options
    = options;\nhelpers$1.math = math;\nhelpers$1.rtl = rtl;\n\nfunction interpolate(start,
    view, model, ease) {\r\n\tvar keys = Object.keys(model);\r\n\tvar i, ilen, key,
    actual, origin, target, type, c0, c1;\r\n\r\n\tfor (i = 0, ilen = keys.length;
    i < ilen; ++i) {\r\n\t\tkey = keys[i];\r\n\r\n\t\ttarget = model[key];\r\n\r\n\t\t//
    if a value is added to the model after pivot() has been called, the view\r\n\t\t//
    doesn't contain it, so let's initialize the view to the target value.\r\n\t\tif
    (!view.hasOwnProperty(key)) {\r\n\t\t\tview[key] = target;\r\n\t\t}\r\n\r\n\t\tactual
    = view[key];\r\n\r\n\t\tif (actual === target || key[0] === '_') {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif
    (!start.hasOwnProperty(key)) {\r\n\t\t\tstart[key] = actual;\r\n\t\t}\r\n\r\n\t\torigin
    = start[key];\r\n\r\n\t\ttype = typeof target;\r\n\r\n\t\tif (type === typeof
    origin) {\r\n\t\t\tif (type === 'string') {\r\n\t\t\t\tc0 = chartjsColor(origin);\r\n\t\t\t\tif
    (c0.valid) {\r\n\t\t\t\t\tc1 = chartjsColor(target);\r\n\t\t\t\t\tif (c1.valid)
    {\r\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}
    else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\r\n\t\t\t\tview[key]
    = origin + (target - origin) * ease;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tview[key]
    = target;\r\n\t}\r\n}\r\n\r\nvar Element = function(configuration) {\r\n\thelpers$1.extend(this,
    configuration);\r\n\tthis.initialize.apply(this, arguments);\r\n};\r\n\r\nhelpers$1.extend(Element.prototype,
    {\r\n\t_type: undefined,\r\n\r\n\tinitialize: function() {\r\n\t\tthis.hidden
    = false;\r\n\t},\r\n\r\n\tpivot: function() {\r\n\t\tvar me = this;\r\n\t\tif
    (!me._view) {\r\n\t\t\tme._view = helpers$1.extend({}, me._model);\r\n\t\t}\r\n\t\tme._start
    = {};\r\n\t\treturn me;\r\n\t},\r\n\r\n\ttransition: function(ease) {\r\n\t\tvar
    me = this;\r\n\t\tvar model = me._model;\r\n\t\tvar start = me._start;\r\n\t\tvar
    view = me._view;\r\n\r\n\t\t// No animation -> No Transition\r\n\t\tif (!model
    || ease === 1) {\r\n\t\t\tme._view = helpers$1.extend({}, model);\r\n\t\t\tme._start
    = null;\r\n\t\t\treturn me;\r\n\t\t}\r\n\r\n\t\tif (!view) {\r\n\t\t\tview = me._view
    = {};\r\n\t\t}\r\n\r\n\t\tif (!start) {\r\n\t\t\tstart = me._start = {};\r\n\t\t}\r\n\r\n\t\tinterpolate(start,
    view, model, ease);\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\ttooltipPosition: function()
    {\r\n\t\treturn {\r\n\t\t\tx: this._model.x,\r\n\t\t\ty: this._model.y\r\n\t\t};\r\n\t},\r\n\r\n\thasValue:
    function() {\r\n\t\treturn helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\r\n\t}\r\n});\r\n\r\nElement.extend
    = helpers$1.inherits;\r\n\r\nvar core_element = Element;\n\nvar exports$3 = core_element.extend({\r\n\tchart:
    null, // the animation associated chart instance\r\n\tcurrentStep: 0, // the current
    animation step\r\n\tnumSteps: 60, // default number of steps\r\n\teasing: '',
    // the easing to use for this animation\r\n\trender: null, // render function
    used by the animation service\r\n\r\n\tonAnimationProgress: null, // user specified
    callback to fire on each step of the animation\r\n\tonAnimationComplete: null,
    // user specified callback to fire when the animation finishes\r\n});\r\n\r\nvar
    core_animation = exports$3;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for
    backward compatibility, use Chart.Animation instead\r\n * @prop Chart.Animation#animationObject\r\n
    * @deprecated since version 2.6.0\r\n * @todo remove at version 3\r\n */\r\nObject.defineProperty(exports$3.prototype,
    'animationObject', {\r\n\tget: function() {\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.Animation#chart instead\r\n *
    @prop Chart.Animation#chartInstance\r\n * @deprecated since version 2.6.0\r\n
    * @todo remove at version 3\r\n */\r\nObject.defineProperty(exports$3.prototype,
    'chartInstance', {\r\n\tget: function() {\r\n\t\treturn this.chart;\r\n\t},\r\n\tset:
    function(value) {\r\n\t\tthis.chart = value;\r\n\t}\r\n});\n\ncore_defaults._set('global',
    {\r\n\tanimation: {\r\n\t\tduration: 1000,\r\n\t\teasing: 'easeOutQuart',\r\n\t\tonProgress:
    helpers$1.noop,\r\n\t\tonComplete: helpers$1.noop\r\n\t}\r\n});\r\n\r\nvar core_animations
    = {\r\n\tanimations: [],\r\n\trequest: null,\r\n\r\n\t/**\r\n\t * @param {Chart}
    chart - The chart to animate.\r\n\t * @param {Chart.Animation} animation - The
    animation that we will animate.\r\n\t * @param {number} duration - The animation
    duration in ms.\r\n\t * @param {boolean} lazy - if true, the chart is not marked
    as animating to enable more responsive interactions\r\n\t */\r\n\taddAnimation:
    function(chart, animation, duration, lazy) {\r\n\t\tvar animations = this.animations;\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tanimation.chart = chart;\r\n\t\tanimation.startTime = Date.now();\r\n\t\tanimation.duration
    = duration;\r\n\r\n\t\tif (!lazy) {\r\n\t\t\tchart.animating = true;\r\n\t\t}\r\n\r\n\t\tfor
    (i = 0, ilen = animations.length; i < ilen; ++i) {\r\n\t\t\tif (animations[i].chart
    === chart) {\r\n\t\t\t\tanimations[i] = animation;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tanimations.push(animation);\r\n\r\n\t\t//
    If there are no animations queued, manually kickstart a digest, for lack of a
    better word\r\n\t\tif (animations.length === 1) {\r\n\t\t\tthis.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\tcancelAnimation:
    function(chart) {\r\n\t\tvar index = helpers$1.findIndex(this.animations, function(animation)
    {\r\n\t\t\treturn animation.chart === chart;\r\n\t\t});\r\n\r\n\t\tif (index !==
    -1) {\r\n\t\t\tthis.animations.splice(index, 1);\r\n\t\t\tchart.animating = false;\r\n\t\t}\r\n\t},\r\n\r\n\trequestAnimationFrame:
    function() {\r\n\t\tvar me = this;\r\n\t\tif (me.request === null) {\r\n\t\t\t//
    Skip animation frame requests until the active one is executed.\r\n\t\t\t// This
    can happen when processing mouse events, e.g. 'mousemove'\r\n\t\t\t// and 'mouseout'
    events will trigger multiple renders.\r\n\t\t\tme.request = helpers$1.requestAnimFrame.call(window,
    function() {\r\n\t\t\t\tme.request = null;\r\n\t\t\t\tme.startDigest();\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tstartDigest: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tme.advance();\r\n\r\n\t\t//
    Do we have more stuff to animate?\r\n\t\tif (me.animations.length > 0) {\r\n\t\t\tme.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tadvance: function() {\r\n\t\tvar animations = this.animations;\r\n\t\tvar
    animation, chart, numSteps, nextStep;\r\n\t\tvar i = 0;\r\n\r\n\t\t// 1 animation
    per chart, so we are looping charts here\r\n\t\twhile (i < animations.length)
    {\r\n\t\t\tanimation = animations[i];\r\n\t\t\tchart = animation.chart;\r\n\t\t\tnumSteps
    = animation.numSteps;\r\n\r\n\t\t\t// Make sure that currentStep starts at 1\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/6104\r\n\t\t\tnextStep = Math.floor((Date.now()
    - animation.startTime) / animation.duration * numSteps) + 1;\r\n\t\t\tanimation.currentStep
    = Math.min(nextStep, numSteps);\r\n\r\n\t\t\thelpers$1.callback(animation.render,
    [chart, animation], chart);\r\n\t\t\thelpers$1.callback(animation.onAnimationProgress,
    [animation], chart);\r\n\r\n\t\t\tif (animation.currentStep >= numSteps) {\r\n\t\t\t\thelpers$1.callback(animation.onAnimationComplete,
    [animation], chart);\r\n\t\t\t\tchart.animating = false;\r\n\t\t\t\tanimations.splice(i,
    1);\r\n\t\t\t} else {\r\n\t\t\t\t++i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\nvar
    resolve = helpers$1.options.resolve;\r\n\r\nvar arrayEvents = ['push', 'pop',
    'shift', 'splice', 'unshift'];\r\n\r\n/**\r\n * Hooks the array methods that add
    or remove values ('push', pop', 'shift', 'splice',\r\n * 'unshift') and notify
    the listener AFTER the array has been altered. Listeners are\r\n * called on the
    'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\r\n */\r\nfunction
    listenArrayEvents(array, listener) {\r\n\tif (array._chartjs) {\r\n\t\tarray._chartjs.listeners.push(listener);\r\n\t\treturn;\r\n\t}\r\n\r\n\tObject.defineProperty(array,
    '_chartjs', {\r\n\t\tconfigurable: true,\r\n\t\tenumerable: false,\r\n\t\tvalue:
    {\r\n\t\t\tlisteners: [listener]\r\n\t\t}\r\n\t});\r\n\r\n\tarrayEvents.forEach(function(key)
    {\r\n\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\r\n\t\tvar
    base = array[key];\r\n\r\n\t\tObject.defineProperty(array, key, {\r\n\t\t\tconfigurable:
    true,\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: function() {\r\n\t\t\t\tvar
    args = Array.prototype.slice.call(arguments);\r\n\t\t\t\tvar res = base.apply(this,
    args);\r\n\r\n\t\t\t\thelpers$1.each(array._chartjs.listeners, function(object)
    {\r\n\t\t\t\t\tif (typeof object[method] === 'function') {\r\n\t\t\t\t\t\tobject[method].apply(object,
    args);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn res;\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n
    * Removes the given array event listener and cleanup extra attached properties
    (such as\r\n * the _chartjs stub and overridden methods) if array doesn't have
    any more listeners.\r\n */\r\nfunction unlistenArrayEvents(array, listener) {\r\n\tvar
    stub = array._chartjs;\r\n\tif (!stub) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar listeners
    = stub.listeners;\r\n\tvar index = listeners.indexOf(listener);\r\n\tif (index
    !== -1) {\r\n\t\tlisteners.splice(index, 1);\r\n\t}\r\n\r\n\tif (listeners.length
    > 0) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tarrayEvents.forEach(function(key) {\r\n\t\tdelete
    array[key];\r\n\t});\r\n\r\n\tdelete array._chartjs;\r\n}\r\n\r\n// Base class
    for all dataset controllers (line, bar, etc)\r\nvar DatasetController = function(chart,
    datasetIndex) {\r\n\tthis.initialize(chart, datasetIndex);\r\n};\r\n\r\nhelpers$1.extend(DatasetController.prototype,
    {\r\n\r\n\t/**\r\n\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\r\n\t
    * @type {Chart.core.element}\r\n\t */\r\n\tdatasetElementType: null,\r\n\r\n\t/**\r\n\t
    * Element type used to generate a meta data (e.g. Chart.element.Point).\r\n\t
    * @type {Chart.core.element}\r\n\t */\r\n\tdataElementType: null,\r\n\r\n\t/**\r\n\t
    * Dataset element option keys to be resolved in _resolveDatasetElementOptions.\r\n\t
    * A derived controller may override this to resolve controller-specific options.\r\n\t
    * The keys defined here are for backward compatibility for legend styles.\r\n\t
    * @private\r\n\t */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderColor',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'borderWidth'\r\n\t],\r\n\r\n\t/**\r\n\t
    * Data element option keys to be resolved in _resolveDataElementOptions.\r\n\t
    * A derived controller may override this to resolve controller-specific options.\r\n\t
    * The keys defined here are for backward compatibility for legend styles.\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'pointStyle'\r\n\t],\r\n\r\n\tinitialize:
    function(chart, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tme.chart = chart;\r\n\t\tme.index
    = datasetIndex;\r\n\t\tme.linkScales();\r\n\t\tme.addElements();\r\n\t\tme._type
    = me.getMeta().type;\r\n\t},\r\n\r\n\tupdateIndex: function(datasetIndex) {\r\n\t\tthis.index
    = datasetIndex;\r\n\t},\r\n\r\n\tlinkScales: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar chart = me.chart;\r\n\t\tvar scales = chart.scales;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar scalesOpts = chart.options.scales;\r\n\r\n\t\tif
    (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {\r\n\t\t\tmeta.xAxisID
    = dataset.xAxisID || scalesOpts.xAxes[0].id;\r\n\t\t}\r\n\t\tif (meta.yAxisID
    === null || !(meta.yAxisID in scales) || dataset.yAxisID) {\r\n\t\t\tmeta.yAxisID
    = dataset.yAxisID || scalesOpts.yAxes[0].id;\r\n\t\t}\r\n\t},\r\n\r\n\tgetDataset:
    function() {\r\n\t\treturn this.chart.data.datasets[this.index];\r\n\t},\r\n\r\n\tgetMeta:
    function() {\r\n\t\treturn this.chart.getDatasetMeta(this.index);\r\n\t},\r\n\r\n\tgetScaleForId:
    function(scaleID) {\r\n\t\treturn this.chart.scales[scaleID];\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.getMeta().yAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.getMeta().xAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScale: function() {\r\n\t\treturn this.getScaleForId(this._getValueScaleId());\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScale: function() {\r\n\t\treturn this.getScaleForId(this._getIndexScaleId());\r\n\t},\r\n\r\n\treset:
    function() {\r\n\t\tthis._update(true);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tdestroy: function() {\r\n\t\tif (this._data) {\r\n\t\t\tunlistenArrayEvents(this._data,
    this);\r\n\t\t}\r\n\t},\r\n\r\n\tcreateMetaDataset: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar type = me.datasetElementType;\r\n\t\treturn type && new type({\r\n\t\t\t_chart:
    me.chart,\r\n\t\t\t_datasetIndex: me.index\r\n\t\t});\r\n\t},\r\n\r\n\tcreateMetaData:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar type = me.dataElementType;\r\n\t\treturn
    type && new type({\r\n\t\t\t_chart: me.chart,\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index:
    index\r\n\t\t});\r\n\t},\r\n\r\n\taddElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar data = me.getDataset().data || [];\r\n\t\tvar
    metaData = meta.data;\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = data.length;
    i < ilen; ++i) {\r\n\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\r\n\t\t}\r\n\r\n\t\tmeta.dataset
    = meta.dataset || me.createMetaDataset();\r\n\t},\r\n\r\n\taddElementAndReset:
    function(index) {\r\n\t\tvar element = this.createMetaData(index);\r\n\t\tthis.getMeta().data.splice(index,
    0, element);\r\n\t\tthis.updateElement(element, index, true);\r\n\t},\r\n\r\n\tbuildOrUpdateElements:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar
    data = dataset.data || (dataset.data = []);\r\n\r\n\t\t// In order to correctly
    handle data addition/deletion animation (an thus simulate\r\n\t\t// real-time
    charts), we need to monitor these data modifications and synchronize\r\n\t\t//
    the internal meta data accordingly.\r\n\t\tif (me._data !== data) {\r\n\t\t\tif
    (me._data) {\r\n\t\t\t\t// This case happens when the user replaced the data array
    instance.\r\n\t\t\t\tunlistenArrayEvents(me._data, me);\r\n\t\t\t}\r\n\r\n\t\t\tif
    (data && Object.isExtensible(data)) {\r\n\t\t\t\tlistenArrayEvents(data, me);\r\n\t\t\t}\r\n\t\t\tme._data
    = data;\r\n\t\t}\r\n\r\n\t\t// Re-sync meta data in case the user replaced the
    data array or if we missed\r\n\t\t// any updates and so make sure that we handle
    number of datapoints changing.\r\n\t\tme.resyncElements();\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the merged user-supplied and default dataset-level options\r\n\t * @private\r\n\t
    */\r\n\t_configure: function() {\r\n\t\tvar me = this;\r\n\t\tme._config = helpers$1.merge(Object.create(null),
    [\r\n\t\t\tme.chart.options.datasets[me._type],\r\n\t\t\tme.getDataset(),\r\n\t\t],
    {\r\n\t\t\tmerger: function(key, target, source) {\r\n\t\t\t\tif (key !== '_meta'
    && key !== 'data') {\r\n\t\t\t\t\thelpers$1._merger(key, target, source);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_update:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tme._configure();\r\n\t\tme._cachedDataOpts
    = null;\r\n\t\tme.update(reset);\r\n\t},\r\n\r\n\tupdate: helpers$1.noop,\r\n\r\n\ttransition:
    function(easingValue) {\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar elements
    = meta.data || [];\r\n\t\tvar ilen = elements.length;\r\n\t\tvar i = 0;\r\n\r\n\t\tfor
    (; i < ilen; ++i) {\r\n\t\t\telements[i].transition(easingValue);\r\n\t\t}\r\n\r\n\t\tif
    (meta.dataset) {\r\n\t\t\tmeta.dataset.transition(easingValue);\r\n\t\t}\r\n\t},\r\n\r\n\tdraw:
    function() {\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar elements = meta.data
    || [];\r\n\t\tvar ilen = elements.length;\r\n\t\tvar i = 0;\r\n\r\n\t\tif (meta.dataset)
    {\r\n\t\t\tmeta.dataset.draw();\r\n\t\t}\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\telements[i].draw();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns a set of predefined style properties that should be used to represent
    the dataset\r\n\t * or the data if the index is specified\r\n\t * @param {number}
    index - data index\r\n\t * @return {IStyleInterface} style object\r\n\t */\r\n\tgetStyle:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    dataset = meta.dataset;\r\n\t\tvar style;\r\n\r\n\t\tme._configure();\r\n\t\tif
    (dataset && index === undefined) {\r\n\t\t\tstyle = me._resolveDatasetElementOptions(dataset
    || {});\r\n\t\t} else {\r\n\t\t\tindex = index || 0;\r\n\t\t\tstyle = me._resolveDataElementOptions(meta.data[index]
    || {}, index);\r\n\t\t}\r\n\r\n\t\tif (style.fill === false || style.fill ===
    null) {\r\n\t\t\tstyle.backgroundColor = style.borderColor;\r\n\t\t}\r\n\r\n\t\treturn
    style;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_resolveDatasetElementOptions:
    function(element, hover) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasetOpts = me._config;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar
    options = chart.options.elements[me.datasetElementType.prototype._type] || {};\r\n\t\tvar
    elementOptions = me._datasetElementOptions;\r\n\t\tvar values = {};\r\n\t\tvar
    i, ilen, key, readKey;\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart:
    chart,\r\n\t\t\tdataset: me.getDataset(),\r\n\t\t\tdatasetIndex: me.index,\r\n\t\t\thover:
    hover\r\n\t\t};\r\n\r\n\t\tfor (i = 0, ilen = elementOptions.length; i < ilen;
    ++i) {\r\n\t\t\tkey = elementOptions[i];\r\n\t\t\treadKey = hover ? 'hover' +
    key.charAt(0).toUpperCase() + key.slice(1) : key;\r\n\t\t\tvalues[key] = resolve([\r\n\t\t\t\tcustom[readKey],\r\n\t\t\t\tdatasetOpts[readKey],\r\n\t\t\t\toptions[readKey]\r\n\t\t\t],
    context);\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_resolveDataElementOptions: function(element, index) {\r\n\t\tvar me =
    this;\r\n\t\tvar custom = element && element.custom;\r\n\t\tvar cached = me._cachedDataOpts;\r\n\t\tif
    (cached && !custom) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasetOpts = me._config;\r\n\t\tvar options = chart.options.elements[me.dataElementType.prototype._type]
    || {};\r\n\t\tvar elementOptions = me._dataElementOptions;\r\n\t\tvar values =
    {};\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart: chart,\r\n\t\t\tdataIndex:
    index,\r\n\t\t\tdataset: me.getDataset(),\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\t//
    `resolve` sets cacheable to `false` if any option is indexed or scripted\r\n\t\tvar
    info = {cacheable: !custom};\r\n\r\n\t\tvar keys, i, ilen, key;\r\n\r\n\t\tcustom
    = custom || {};\r\n\r\n\t\tif (helpers$1.isArray(elementOptions)) {\r\n\t\t\tfor
    (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\r\n\t\t\t\tkey = elementOptions[i];\r\n\t\t\t\tvalues[key]
    = resolve([\r\n\t\t\t\t\tcustom[key],\r\n\t\t\t\t\tdatasetOpts[key],\r\n\t\t\t\t\toptions[key]\r\n\t\t\t\t],
    context, index, info);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tkeys = Object.keys(elementOptions);\r\n\t\t\tfor
    (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n\t\t\t\tkey = keys[i];\r\n\t\t\t\tvalues[key]
    = resolve([\r\n\t\t\t\t\tcustom[key],\r\n\t\t\t\t\tdatasetOpts[elementOptions[key]],\r\n\t\t\t\t\tdatasetOpts[key],\r\n\t\t\t\t\toptions[key]\r\n\t\t\t\t],
    context, index, info);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (info.cacheable) {\r\n\t\t\tme._cachedDataOpts
    = Object.freeze(values);\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tremoveHoverStyle:
    function(element) {\r\n\t\thelpers$1.merge(element._model, element.$previousStyle
    || {});\r\n\t\tdelete element.$previousStyle;\r\n\t},\r\n\r\n\tsetHoverStyle:
    function(element) {\r\n\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\r\n\t\tvar
    index = element._index;\r\n\t\tvar custom = element.custom || {};\r\n\t\tvar model
    = element._model;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\telement.$previousStyle
    = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = resolve([custom.hoverBackgroundColor,
    dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined,
    index);\r\n\t\tmodel.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor,
    getHoverColor(model.borderColor)], undefined, index);\r\n\t\tmodel.borderWidth
    = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth],
    undefined, index);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_removeDatasetHoverStyle:
    function() {\r\n\t\tvar element = this.getMeta().dataset;\r\n\r\n\t\tif (element)
    {\r\n\t\t\tthis.removeHoverStyle(element);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_setDatasetHoverStyle: function() {\r\n\t\tvar element
    = this.getMeta().dataset;\r\n\t\tvar prev = {};\r\n\t\tvar i, ilen, key, keys,
    hoverOptions, model;\r\n\r\n\t\tif (!element) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodel
    = element._model;\r\n\t\thoverOptions = this._resolveDatasetElementOptions(element,
    true);\r\n\r\n\t\tkeys = Object.keys(hoverOptions);\r\n\t\tfor (i = 0, ilen =
    keys.length; i < ilen; ++i) {\r\n\t\t\tkey = keys[i];\r\n\t\t\tprev[key] = model[key];\r\n\t\t\tmodel[key]
    = hoverOptions[key];\r\n\t\t}\r\n\r\n\t\telement.$previousStyle = prev;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tresyncElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar data = me.getDataset().data;\r\n\t\tvar numMeta
    = meta.data.length;\r\n\t\tvar numData = data.length;\r\n\r\n\t\tif (numData <
    numMeta) {\r\n\t\t\tmeta.data.splice(numData, numMeta - numData);\r\n\t\t} else
    if (numData > numMeta) {\r\n\t\t\tme.insertElements(numMeta, numData - numMeta);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tinsertElements: function(start, count) {\r\n\t\tfor (var
    i = 0; i < count; ++i) {\r\n\t\t\tthis.addElementAndReset(start + i);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tonDataPush: function() {\r\n\t\tvar count = arguments.length;\r\n\t\tthis.insertElements(this.getDataset().data.length
    - count, count);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tonDataPop:
    function() {\r\n\t\tthis.getMeta().data.pop();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tonDataShift: function() {\r\n\t\tthis.getMeta().data.shift();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tonDataSplice: function(start, count) {\r\n\t\tthis.getMeta().data.splice(start,
    count);\r\n\t\tthis.insertElements(start, arguments.length - 2);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tonDataUnshift: function() {\r\n\t\tthis.insertElements(0,
    arguments.length);\r\n\t}\r\n});\r\n\r\nDatasetController.extend = helpers$1.inherits;\r\n\r\nvar
    core_datasetController = DatasetController;\n\nvar TAU = Math.PI * 2;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {\r\n\t\tarc: {\r\n\t\t\tbackgroundColor: core_defaults.global.defaultColor,\r\n\t\t\tborderColor:
    '#fff',\r\n\t\t\tborderWidth: 2,\r\n\t\t\tborderAlign: 'center'\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction
    clipArc(ctx, arc) {\r\n\tvar startAngle = arc.startAngle;\r\n\tvar endAngle =
    arc.endAngle;\r\n\tvar pixelMargin = arc.pixelMargin;\r\n\tvar angleMargin = pixelMargin
    / arc.outerRadius;\r\n\tvar x = arc.x;\r\n\tvar y = arc.y;\r\n\r\n\t// Draw an
    inner border by cliping the arc and drawing a double-width border\r\n\t// Enlarge
    the clipping arc by 0.33 pixels to eliminate glitches between borders\r\n\tctx.beginPath();\r\n\tctx.arc(x,
    y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n\tif
    (arc.innerRadius > pixelMargin) {\r\n\t\tangleMargin = pixelMargin / arc.innerRadius;\r\n\t\tctx.arc(x,
    y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin,
    true);\r\n\t} else {\r\n\t\tctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2,
    startAngle - Math.PI / 2);\r\n\t}\r\n\tctx.closePath();\r\n\tctx.clip();\r\n}\r\n\r\nfunction
    drawFullCircleBorders(ctx, vm, arc, inner) {\r\n\tvar endAngle = arc.endAngle;\r\n\tvar
    i;\r\n\r\n\tif (inner) {\r\n\t\tarc.endAngle = arc.startAngle + TAU;\r\n\t\tclipArc(ctx,
    arc);\r\n\t\tarc.endAngle = endAngle;\r\n\t\tif (arc.endAngle === arc.startAngle
    && arc.fullCircles) {\r\n\t\t\tarc.endAngle += TAU;\r\n\t\t\tarc.fullCircles--;\r\n\t\t}\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x,
    arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);\r\n\tfor
    (i = 0; i < arc.fullCircles; ++i) {\r\n\t\tctx.stroke();\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x,
    arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);\r\n\tfor (i = 0;
    i < arc.fullCircles; ++i) {\r\n\t\tctx.stroke();\r\n\t}\r\n}\r\n\r\nfunction drawBorder(ctx,
    vm, arc) {\r\n\tvar inner = vm.borderAlign === 'inner';\r\n\r\n\tif (inner) {\r\n\t\tctx.lineWidth
    = vm.borderWidth * 2;\r\n\t\tctx.lineJoin = 'round';\r\n\t} else {\r\n\t\tctx.lineWidth
    = vm.borderWidth;\r\n\t\tctx.lineJoin = 'bevel';\r\n\t}\r\n\r\n\tif (arc.fullCircles)
    {\r\n\t\tdrawFullCircleBorders(ctx, vm, arc, inner);\r\n\t}\r\n\r\n\tif (inner)
    {\r\n\t\tclipArc(ctx, arc);\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.arc(arc.x,
    arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);\r\n\tctx.arc(arc.x, arc.y,
    arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n}\r\n\r\nvar
    element_arc = core_element.extend({\r\n\t_type: 'arc',\r\n\r\n\tinLabelRange:
    function(mouseX) {\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif (vm) {\r\n\t\t\treturn
    (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\r\n\t\t}\r\n\t\treturn
    false;\r\n\t},\r\n\r\n\tinRange: function(chartX, chartY) {\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif
    (vm) {\r\n\t\t\tvar pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x:
    chartX, y: chartY});\r\n\t\t\tvar angle = pointRelativePosition.angle;\r\n\t\t\tvar
    distance = pointRelativePosition.distance;\r\n\r\n\t\t\t// Sanitise angle range\r\n\t\t\tvar
    startAngle = vm.startAngle;\r\n\t\t\tvar endAngle = vm.endAngle;\r\n\t\t\twhile
    (endAngle < startAngle) {\r\n\t\t\t\tendAngle += TAU;\r\n\t\t\t}\r\n\t\t\twhile
    (angle > endAngle) {\r\n\t\t\t\tangle -= TAU;\r\n\t\t\t}\r\n\t\t\twhile (angle
    < startAngle) {\r\n\t\t\t\tangle += TAU;\r\n\t\t\t}\r\n\r\n\t\t\t// Check if within
    the range of the open/close angle\r\n\t\t\tvar betweenAngles = (angle >= startAngle
    && angle <= endAngle);\r\n\t\t\tvar withinRadius = (distance >= vm.innerRadius
    && distance <= vm.outerRadius);\r\n\r\n\t\t\treturn (betweenAngles && withinRadius);\r\n\t\t}\r\n\t\treturn
    false;\r\n\t},\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar
    halfAngle = (vm.startAngle + vm.endAngle) / 2;\r\n\t\tvar halfRadius = (vm.innerRadius
    + vm.outerRadius) / 2;\r\n\t\treturn {\r\n\t\t\tx: vm.x + Math.cos(halfAngle)
    * halfRadius,\r\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\r\n\t\t};\r\n\t},\r\n\r\n\tgetArea:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn Math.PI * ((vm.endAngle
    - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius,
    2));\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar
    centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\r\n\t\tvar
    rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\r\n\r\n\t\treturn
    {\r\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\r\n\t\t\ty: vm.y
    + (Math.sin(centreAngle) * rangeFromCentre)\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function()
    {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar pixelMargin
    = (vm.borderAlign === 'inner') ? 0.33 : 0;\r\n\t\tvar arc = {\r\n\t\t\tx: vm.x,\r\n\t\t\ty:
    vm.y,\r\n\t\t\tinnerRadius: vm.innerRadius,\r\n\t\t\touterRadius: Math.max(vm.outerRadius
    - pixelMargin, 0),\r\n\t\t\tpixelMargin: pixelMargin,\r\n\t\t\tstartAngle: vm.startAngle,\r\n\t\t\tendAngle:
    vm.endAngle,\r\n\t\t\tfullCircles: Math.floor(vm.circumference / TAU)\r\n\t\t};\r\n\t\tvar
    i;\r\n\r\n\t\tctx.save();\r\n\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle
    = vm.borderColor;\r\n\r\n\t\tif (arc.fullCircles) {\r\n\t\t\tarc.endAngle = arc.startAngle
    + TAU;\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.arc(arc.x, arc.y, arc.outerRadius,
    arc.startAngle, arc.endAngle);\r\n\t\t\tctx.arc(arc.x, arc.y, arc.innerRadius,
    arc.endAngle, arc.startAngle, true);\r\n\t\t\tctx.closePath();\r\n\t\t\tfor (i
    = 0; i < arc.fullCircles; ++i) {\r\n\t\t\t\tctx.fill();\r\n\t\t\t}\r\n\t\t\tarc.endAngle
    = arc.startAngle + vm.circumference % TAU;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(arc.x,
    arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\r\n\t\tctx.arc(arc.x, arc.y,
    arc.innerRadius, arc.endAngle, arc.startAngle, true);\r\n\t\tctx.closePath();\r\n\t\tctx.fill();\r\n\r\n\t\tif
    (vm.borderWidth) {\r\n\t\t\tdrawBorder(ctx, vm, arc);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n});\n\nvar
    valueOrDefault$1 = helpers$1.valueOrDefault;\r\n\r\nvar defaultColor = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {\r\n\t\tline: {\r\n\t\t\ttension: 0.4,\r\n\t\t\tbackgroundColor:
    defaultColor,\r\n\t\t\tborderWidth: 3,\r\n\t\t\tborderColor: defaultColor,\r\n\t\t\tborderCapStyle:
    'butt',\r\n\t\t\tborderDash: [],\r\n\t\t\tborderDashOffset: 0.0,\r\n\t\t\tborderJoinStyle:
    'miter',\r\n\t\t\tcapBezierPoints: true,\r\n\t\t\tfill: true, // do we fill in
    the area between the line and its base axis\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    element_line = core_element.extend({\r\n\t_type: 'line',\r\n\r\n\tdraw: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar vm = me._view;\r\n\t\tvar ctx = me._chart.ctx;\r\n\t\tvar
    spanGaps = vm.spanGaps;\r\n\t\tvar points = me._children.slice(); // clone array\r\n\t\tvar
    globalDefaults = core_defaults.global;\r\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\r\n\t\tvar
    lastDrawnIndex = -1;\r\n\t\tvar closePath = me._loop;\r\n\t\tvar index, previous,
    currentVM;\r\n\r\n\t\tif (!points.length) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif
    (me._loop) {\r\n\t\t\tfor (index = 0; index < points.length; ++index) {\r\n\t\t\t\tprevious
    = helpers$1.previousItem(points, index);\r\n\t\t\t\t// If the line has an open
    path, shift the point array\r\n\t\t\t\tif (!points[index]._view.skip && previous._view.skip)
    {\r\n\t\t\t\t\tpoints = points.slice(index).concat(points.slice(0, index));\r\n\t\t\t\t\tclosePath
    = spanGaps;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If the line
    has a close path, add the first point again\r\n\t\t\tif (closePath) {\r\n\t\t\t\tpoints.push(points[0]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\r\n\t\t//
    Stroke Line Options\r\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\r\n\r\n\t\t//
    IE 9 and 10 do not support line dash\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(vm.borderDash
    || globalOptionLineElements.borderDash);\r\n\t\t}\r\n\r\n\t\tctx.lineDashOffset
    = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\r\n\t\tctx.lineJoin
    = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\r\n\t\tctx.lineWidth
    = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\r\n\t\tctx.strokeStyle
    = vm.borderColor || globalDefaults.defaultColor;\r\n\r\n\t\t// Stroke Line\r\n\t\tctx.beginPath();\r\n\r\n\t\t//
    First point moves to it's starting position no matter what\r\n\t\tcurrentVM =
    points[0]._view;\r\n\t\tif (!currentVM.skip) {\r\n\t\t\tctx.moveTo(currentVM.x,
    currentVM.y);\r\n\t\t\tlastDrawnIndex = 0;\r\n\t\t}\r\n\r\n\t\tfor (index = 1;
    index < points.length; ++index) {\r\n\t\t\tcurrentVM = points[index]._view;\r\n\t\t\tprevious
    = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];\r\n\r\n\t\t\tif
    (!currentVM.skip) {\r\n\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps)
    || lastDrawnIndex === -1) {\r\n\t\t\t\t\t// There was a gap and this is the first
    point after the gap\r\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\t// Line to next point\r\n\t\t\t\t\thelpers$1.canvas.lineTo(ctx,
    previous._view, currentVM);\r\n\t\t\t\t}\r\n\t\t\t\tlastDrawnIndex = index;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (closePath) {\r\n\t\t\tctx.closePath();\r\n\t\t}\r\n\r\n\t\tctx.stroke();\r\n\t\tctx.restore();\r\n\t}\r\n});\n\nvar
    valueOrDefault$2 = helpers$1.valueOrDefault;\r\n\r\nvar defaultColor$1 = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {\r\n\t\tpoint: {\r\n\t\t\tradius: 3,\r\n\t\t\tpointStyle: 'circle',\r\n\t\t\tbackgroundColor:
    defaultColor$1,\r\n\t\t\tborderColor: defaultColor$1,\r\n\t\t\tborderWidth: 1,\r\n\t\t\t//
    Hover\r\n\t\t\thitRadius: 1,\r\n\t\t\thoverRadius: 4,\r\n\t\t\thoverBorderWidth:
    1\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction xRange(mouseX) {\r\n\tvar vm = this._view;\r\n\treturn
    vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\r\n}\r\n\r\nfunction
    yRange(mouseY) {\r\n\tvar vm = this._view;\r\n\treturn vm ? (Math.abs(mouseY -
    vm.y) < vm.radius + vm.hitRadius) : false;\r\n}\r\n\r\nvar element_point = core_element.extend({\r\n\t_type:
    'point',\r\n\r\n\tinRange: function(mouseX, mouseY) {\r\n\t\tvar vm = this._view;\r\n\t\treturn
    vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius
    + vm.radius, 2)) : false;\r\n\t},\r\n\r\n\tinLabelRange: xRange,\r\n\tinXRange:
    xRange,\r\n\tinYRange: yRange,\r\n\r\n\tgetCenterPoint: function() {\r\n\t\tvar
    vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\t},\r\n\r\n\tgetArea:
    function() {\r\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\r\n\t},\r\n\r\n\ttooltipPosition:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty:
    vm.y,\r\n\t\t\tpadding: vm.radius + vm.borderWidth\r\n\t\t};\r\n\t},\r\n\r\n\tdraw:
    function(chartArea) {\r\n\t\tvar vm = this._view;\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar
    pointStyle = vm.pointStyle;\r\n\t\tvar rotation = vm.rotation;\r\n\t\tvar radius
    = vm.radius;\r\n\t\tvar x = vm.x;\r\n\t\tvar y = vm.y;\r\n\t\tvar globalDefaults
    = core_defaults.global;\r\n\t\tvar defaultColor = globalDefaults.defaultColor;
    // eslint-disable-line no-shadow\r\n\r\n\t\tif (vm.skip) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//
    Clipping for Points.\r\n\t\tif (chartArea === undefined || helpers$1.canvas._isPointInArea(vm,
    chartArea)) {\r\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\r\n\t\t\tctx.lineWidth
    = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\r\n\t\t\tctx.fillStyle
    = vm.backgroundColor || defaultColor;\r\n\t\t\thelpers$1.canvas.drawPoint(ctx,
    pointStyle, radius, x, y, rotation);\r\n\t\t}\r\n\t}\r\n});\n\nvar defaultColor$2
    = core_defaults.global.defaultColor;\r\n\r\ncore_defaults._set('global', {\r\n\telements:
    {\r\n\t\trectangle: {\r\n\t\t\tbackgroundColor: defaultColor$2,\r\n\t\t\tborderColor:
    defaultColor$2,\r\n\t\t\tborderSkipped: 'bottom',\r\n\t\t\tborderWidth: 0\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction
    isVertical(vm) {\r\n\treturn vm && vm.width !== undefined;\r\n}\r\n\r\n/**\r\n
    * Helper function to get the bounds of the bar regardless of the orientation\r\n
    * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of
    the bar\r\n * @private\r\n */\r\nfunction getBarBounds(vm) {\r\n\tvar x1, x2,
    y1, y2, half;\r\n\r\n\tif (isVertical(vm)) {\r\n\t\thalf = vm.width / 2;\r\n\t\tx1
    = vm.x - half;\r\n\t\tx2 = vm.x + half;\r\n\t\ty1 = Math.min(vm.y, vm.base);\r\n\t\ty2
    = Math.max(vm.y, vm.base);\r\n\t} else {\r\n\t\thalf = vm.height / 2;\r\n\t\tx1
    = Math.min(vm.x, vm.base);\r\n\t\tx2 = Math.max(vm.x, vm.base);\r\n\t\ty1 = vm.y
    - half;\r\n\t\ty2 = vm.y + half;\r\n\t}\r\n\r\n\treturn {\r\n\t\tleft: x1,\r\n\t\ttop:
    y1,\r\n\t\tright: x2,\r\n\t\tbottom: y2\r\n\t};\r\n}\r\n\r\nfunction swap(orig,
    v1, v2) {\r\n\treturn orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\n\r\nfunction
    parseBorderSkipped(vm) {\r\n\tvar edge = vm.borderSkipped;\r\n\tvar res = {};\r\n\r\n\tif
    (!edge) {\r\n\t\treturn res;\r\n\t}\r\n\r\n\tif (vm.horizontal) {\r\n\t\tif (vm.base
    > vm.x) {\r\n\t\t\tedge = swap(edge, 'left', 'right');\r\n\t\t}\r\n\t} else if
    (vm.base < vm.y) {\r\n\t\tedge = swap(edge, 'bottom', 'top');\r\n\t}\r\n\r\n\tres[edge]
    = true;\r\n\treturn res;\r\n}\r\n\r\nfunction parseBorderWidth(vm, maxW, maxH)
    {\r\n\tvar value = vm.borderWidth;\r\n\tvar skip = parseBorderSkipped(vm);\r\n\tvar
    t, r, b, l;\r\n\r\n\tif (helpers$1.isObject(value)) {\r\n\t\tt = +value.top ||
    0;\r\n\t\tr = +value.right || 0;\r\n\t\tb = +value.bottom || 0;\r\n\t\tl = +value.left
    || 0;\r\n\t} else {\r\n\t\tt = r = b = l = +value || 0;\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tt: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,\r\n\t\tr: skip.right
    || (r < 0) ? 0 : r > maxW ? maxW : r,\r\n\t\tb: skip.bottom || (b < 0) ? 0 : b
    > maxH ? maxH : b,\r\n\t\tl: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l\r\n\t};\r\n}\r\n\r\nfunction
    boundingRects(vm) {\r\n\tvar bounds = getBarBounds(vm);\r\n\tvar width = bounds.right
    - bounds.left;\r\n\tvar height = bounds.bottom - bounds.top;\r\n\tvar border =
    parseBorderWidth(vm, width / 2, height / 2);\r\n\r\n\treturn {\r\n\t\touter: {\r\n\t\t\tx:
    bounds.left,\r\n\t\t\ty: bounds.top,\r\n\t\t\tw: width,\r\n\t\t\th: height\r\n\t\t},\r\n\t\tinner:
    {\r\n\t\t\tx: bounds.left + border.l,\r\n\t\t\ty: bounds.top + border.t,\r\n\t\t\tw:
    width - border.l - border.r,\r\n\t\t\th: height - border.t - border.b\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction
    inRange(vm, x, y) {\r\n\tvar skipX = x === null;\r\n\tvar skipY = y === null;\r\n\tvar
    bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);\r\n\r\n\treturn bounds\r\n\t\t&&
    (skipX || x >= bounds.left && x <= bounds.right)\r\n\t\t&& (skipY || y >= bounds.top
    && y <= bounds.bottom);\r\n}\r\n\r\nvar element_rectangle = core_element.extend({\r\n\t_type:
    'rectangle',\r\n\r\n\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar
    vm = this._view;\r\n\t\tvar rects = boundingRects(vm);\r\n\t\tvar outer = rects.outer;\r\n\t\tvar
    inner = rects.inner;\r\n\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.fillRect(outer.x,
    outer.y, outer.w, outer.h);\r\n\r\n\t\tif (outer.w === inner.w && outer.h ===
    inner.h) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(outer.x,
    outer.y, outer.w, outer.h);\r\n\t\tctx.clip();\r\n\t\tctx.fillStyle = vm.borderColor;\r\n\t\tctx.rect(inner.x,
    inner.y, inner.w, inner.h);\r\n\t\tctx.fill('evenodd');\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\theight:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\treturn vm.base - vm.y;\r\n\t},\r\n\r\n\tinRange:
    function(mouseX, mouseY) {\r\n\t\treturn inRange(this._view, mouseX, mouseY);\r\n\t},\r\n\r\n\tinLabelRange:
    function(mouseX, mouseY) {\r\n\t\tvar vm = this._view;\r\n\t\treturn isVertical(vm)\r\n\t\t\t?
    inRange(vm, mouseX, null)\r\n\t\t\t: inRange(vm, null, mouseY);\r\n\t},\r\n\r\n\tinXRange:
    function(mouseX) {\r\n\t\treturn inRange(this._view, mouseX, null);\r\n\t},\r\n\r\n\tinYRange:
    function(mouseY) {\r\n\t\treturn inRange(this._view, null, mouseY);\r\n\t},\r\n\r\n\tgetCenterPoint:
    function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar x, y;\r\n\t\tif (isVertical(vm))
    {\r\n\t\t\tx = vm.x;\r\n\t\t\ty = (vm.y + vm.base) / 2;\r\n\t\t} else {\r\n\t\t\tx
    = (vm.x + vm.base) / 2;\r\n\t\t\ty = vm.y;\r\n\t\t}\r\n\r\n\t\treturn {x: x, y:
    y};\r\n\t},\r\n\r\n\tgetArea: function() {\r\n\t\tvar vm = this._view;\r\n\r\n\t\treturn
    isVertical(vm)\r\n\t\t\t? vm.width * Math.abs(vm.y - vm.base)\r\n\t\t\t: vm.height
    * Math.abs(vm.x - vm.base);\r\n\t},\r\n\r\n\ttooltipPosition: function() {\r\n\t\tvar
    vm = this._view;\r\n\t\treturn {\r\n\t\t\tx: vm.x,\r\n\t\t\ty: vm.y\r\n\t\t};\r\n\t}\r\n});\n\nvar
    elements = {};\r\nvar Arc = element_arc;\r\nvar Line = element_line;\r\nvar Point
    = element_point;\r\nvar Rectangle = element_rectangle;\nelements.Arc = Arc;\nelements.Line
    = Line;\nelements.Point = Point;\nelements.Rectangle = Rectangle;\n\nvar deprecated
    = helpers$1._deprecated;\r\nvar valueOrDefault$3 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('bar',
    {\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes:
    [{\r\n\t\t\ttype: 'category',\r\n\t\t\toffset: true,\r\n\t\t\tgridLines: {\r\n\t\t\t\toffsetGridLines:
    true\r\n\t\t\t}\r\n\t\t}],\r\n\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global',
    {\r\n\tdatasets: {\r\n\t\tbar: {\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage:
    0.9\r\n\t\t}\r\n\t}\r\n});\r\n\r\n/**\r\n * Computes the \"optimal\" sample size
    to maintain bars equally sized while preventing overlap.\r\n * @private\r\n */\r\nfunction
    computeMinSampleSize(scale, pixels) {\r\n\tvar min = scale._length;\r\n\tvar prev,
    curr, i, ilen;\r\n\r\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\r\n\t\tmin
    = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\r\n\t}\r\n\r\n\tfor (i =
    0, ilen = scale.getTicks().length; i < ilen; ++i) {\r\n\t\tcurr = scale.getPixelForTick(i);\r\n\t\tmin
    = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;\r\n\t\tprev = curr;\r\n\t}\r\n\r\n\treturn
    min;\r\n}\r\n\r\n/**\r\n * Computes an \"ideal\" category based on the absolute
    bar thickness or, if undefined or null,\r\n * uses the smallest interval (see
    computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently
    always generates bars equally sized (until we introduce scriptable options?).\r\n
    * @private\r\n */\r\nfunction computeFitCategoryTraits(index, ruler, options)
    {\r\n\tvar thickness = options.barThickness;\r\n\tvar count = ruler.stackCount;\r\n\tvar
    curr = ruler.pixels[index];\r\n\tvar min = helpers$1.isNullOrUndef(thickness)\r\n\t\t?
    computeMinSampleSize(ruler.scale, ruler.pixels)\r\n\t\t: -1;\r\n\tvar size, ratio;\r\n\r\n\tif
    (helpers$1.isNullOrUndef(thickness)) {\r\n\t\tsize = min * options.categoryPercentage;\r\n\t\tratio
    = options.barPercentage;\r\n\t} else {\r\n\t\t// When bar thickness is enforced,
    category and bar percentages are ignored.\r\n\t\t// Note(SB): we could add support
    for relative bar thickness (e.g. barThickness: '50%')\r\n\t\t// and deprecate
    barPercentage since this value is ignored when thickness is absolute.\r\n\t\tsize
    = thickness * count;\r\n\t\tratio = 1;\r\n\t}\r\n\r\n\treturn {\r\n\t\tchunk:
    size / count,\r\n\t\tratio: ratio,\r\n\t\tstart: curr - (size / 2)\r\n\t};\r\n}\r\n\r\n/**\r\n
    * Computes an \"optimal\" category that globally arranges bars side by side (no
    gap when\r\n * percentage options are 1), based on the previous and following
    categories. This mode\r\n * generates bars with different widths when data are
    not evenly spaced.\r\n * @private\r\n */\r\nfunction computeFlexCategoryTraits(index,
    ruler, options) {\r\n\tvar pixels = ruler.pixels;\r\n\tvar curr = pixels[index];\r\n\tvar
    prev = index > 0 ? pixels[index - 1] : null;\r\n\tvar next = index < pixels.length
    - 1 ? pixels[index + 1] : null;\r\n\tvar percent = options.categoryPercentage;\r\n\tvar
    start, size;\r\n\r\n\tif (prev === null) {\r\n\t\t// first data: its size is double
    based on the next point or,\r\n\t\t// if it's also the last data, we use the scale
    size.\r\n\t\tprev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n\t}\r\n\r\n\tif
    (next === null) {\r\n\t\t// last data: its size is also double based on the previous
    point.\r\n\t\tnext = curr + curr - prev;\r\n\t}\r\n\r\n\tstart = curr - (curr
    - Math.min(prev, next)) / 2 * percent;\r\n\tsize = Math.abs(next - prev) / 2 *
    percent;\r\n\r\n\treturn {\r\n\t\tchunk: size / ruler.stackCount,\r\n\t\tratio:
    options.barPercentage,\r\n\t\tstart: start\r\n\t};\r\n}\r\n\r\nvar controller_bar
    = core_datasetController.extend({\r\n\r\n\tdataElementType: elements.Rectangle,\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderSkipped',\r\n\t\t'borderWidth',\r\n\t\t'barPercentage',\r\n\t\t'barThickness',\r\n\t\t'categoryPercentage',\r\n\t\t'maxBarThickness',\r\n\t\t'minBarLength'\r\n\t],\r\n\r\n\tinitialize:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar meta, scaleOpts;\r\n\r\n\t\tcore_datasetController.prototype.initialize.apply(me,
    arguments);\r\n\r\n\t\tmeta = me.getMeta();\r\n\t\tmeta.stack = me.getDataset().stack;\r\n\t\tmeta.bar
    = true;\r\n\r\n\t\tscaleOpts = me._getIndexScale().options;\r\n\t\tdeprecated('bar
    chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');\r\n\t\tdeprecated('bar
    chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');\r\n\t\tdeprecated('bar
    chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');\r\n\t\tdeprecated('bar
    chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength',
    'dataset.minBarLength');\r\n\t\tdeprecated('bar chart', scaleOpts.maxBarThickness,
    'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');\r\n\t},\r\n\r\n\tupdate:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar rects = me.getMeta().data;\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tme._ruler = me.getRuler();\r\n\r\n\t\tfor (i = 0, ilen = rects.length;
    i < ilen; ++i) {\r\n\t\t\tme.updateElement(rects[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(rectangle, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar options = me._resolveDataElementOptions(rectangle,
    index);\r\n\r\n\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\trectangle._yScale
    = me.getScaleForId(meta.yAxisID);\r\n\t\trectangle._datasetIndex = me.index;\r\n\t\trectangle._index
    = index;\r\n\t\trectangle._model = {\r\n\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\tborderColor:
    options.borderColor,\r\n\t\t\tborderSkipped: options.borderSkipped,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\tdatasetLabel: dataset.label,\r\n\t\t\tlabel: me.chart.data.labels[index]\r\n\t\t};\r\n\r\n\t\tif
    (helpers$1.isArray(dataset.data[index])) {\r\n\t\t\trectangle._model.borderSkipped
    = null;\r\n\t\t}\r\n\r\n\t\tme._updateElementGeometry(rectangle, index, reset,
    options);\r\n\r\n\t\trectangle.pivot();\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_updateElementGeometry: function(rectangle, index, reset, options) {\r\n\t\tvar
    me = this;\r\n\t\tvar model = rectangle._model;\r\n\t\tvar vscale = me._getValueScale();\r\n\t\tvar
    base = vscale.getBasePixel();\r\n\t\tvar horizontal = vscale.isHorizontal();\r\n\t\tvar
    ruler = me._ruler || me.getRuler();\r\n\t\tvar vpixels = me.calculateBarValuePixels(me.index,
    index, options);\r\n\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index,
    ruler, options);\r\n\r\n\t\tmodel.horizontal = horizontal;\r\n\t\tmodel.base =
    reset ? base : vpixels.base;\r\n\t\tmodel.x = horizontal ? reset ? base : vpixels.head
    : ipixels.center;\r\n\t\tmodel.y = horizontal ? ipixels.center : reset ? base
    : vpixels.head;\r\n\t\tmodel.height = horizontal ? ipixels.size : undefined;\r\n\t\tmodel.width
    = horizontal ? undefined : ipixels.size;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns
    the stacks based on groups and bar visibility.\r\n\t * @param {number} [last]
    - The dataset index\r\n\t * @returns {string[]} The list of stack IDs\r\n\t *
    @private\r\n\t */\r\n\t_getStacks: function(last) {\r\n\t\tvar me = this;\r\n\t\tvar
    scale = me._getIndexScale();\r\n\t\tvar metasets = scale._getMatchingVisibleMetas(me._type);\r\n\t\tvar
    stacked = scale.options.stacked;\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar
    stacks = [];\r\n\t\tvar i, meta;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tmeta
    = metasets[i];\r\n\t\t\t// stacked   | meta.stack\r\n\t\t\t//           | found
    | not found | undefined\r\n\t\t\t// false     |   x   |     x     |     x\r\n\t\t\t//
    true      |       |     x     |\r\n\t\t\t// undefined |       |     x     |     x\r\n\t\t\tif
    (stacked === false || stacks.indexOf(meta.stack) === -1 ||\r\n\t\t\t\t(stacked
    === undefined && meta.stack === undefined)) {\r\n\t\t\t\tstacks.push(meta.stack);\r\n\t\t\t}\r\n\t\t\tif
    (meta.index === last) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    stacks;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the effective number of stacks based
    on groups and bar visibility.\r\n\t * @private\r\n\t */\r\n\tgetStackCount: function()
    {\r\n\t\treturn this._getStacks().length;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns
    the stack index for the given dataset based on groups and bar visibility.\r\n\t
    * @param {number} [datasetIndex] - The dataset index\r\n\t * @param {string} [name]
    - The stack name to find\r\n\t * @returns {number} The stack index\r\n\t * @private\r\n\t
    */\r\n\tgetStackIndex: function(datasetIndex, name) {\r\n\t\tvar stacks = this._getStacks(datasetIndex);\r\n\t\tvar
    index = (name !== undefined)\r\n\t\t\t? stacks.indexOf(name)\r\n\t\t\t: -1; //
    indexOf returns -1 if element is not present\r\n\r\n\t\treturn (index === -1)\r\n\t\t\t?
    stacks.length - 1\r\n\t\t\t: index;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tgetRuler: function() {\r\n\t\tvar me = this;\r\n\t\tvar scale = me._getIndexScale();\r\n\t\tvar
    pixels = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = me.getMeta().data.length;
    i < ilen; ++i) {\r\n\t\t\tpixels.push(scale.getPixelForValue(null, i, me.index));\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tpixels: pixels,\r\n\t\t\tstart: scale._startPixel,\r\n\t\t\tend: scale._endPixel,\r\n\t\t\tstackCount:
    me.getStackCount(),\r\n\t\t\tscale: scale\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * Note: pixel values are not clamped to the scale area.\r\n\t * @private\r\n\t
    */\r\n\tcalculateBarValuePixels: function(datasetIndex, index, options) {\r\n\t\tvar
    me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar scale = me._getValueScale();\r\n\t\tvar
    isHorizontal = scale.isHorizontal();\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar
    metasets = scale._getMatchingVisibleMetas(me._type);\r\n\t\tvar value = scale._parseValue(datasets[datasetIndex].data[index]);\r\n\t\tvar
    minBarLength = options.minBarLength;\r\n\t\tvar stacked = scale.options.stacked;\r\n\t\tvar
    stack = me.getMeta().stack;\r\n\t\tvar start = value.start === undefined ? 0 :
    value.max >= 0 && value.min >= 0 ? value.min : value.max;\r\n\t\tvar length =
    value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max
    - value.min : value.min - value.max;\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar
    i, imeta, ivalue, base, head, size, stackLength;\r\n\r\n\t\tif (stacked || (stacked
    === undefined && stack !== undefined)) {\r\n\t\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\t\timeta
    = metasets[i];\r\n\r\n\t\t\t\tif (imeta.index === datasetIndex) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif
    (imeta.stack === stack) {\r\n\t\t\t\t\tstackLength = scale._parseValue(datasets[imeta.index].data[index]);\r\n\t\t\t\t\tivalue
    = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 &&
    stackLength.max >= 0 ? stackLength.max : stackLength.min;\r\n\r\n\t\t\t\t\tif
    ((value.min < 0 && ivalue < 0) || (value.max >= 0 && ivalue > 0)) {\r\n\t\t\t\t\t\tstart
    += ivalue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbase = scale.getPixelForValue(start);\r\n\t\thead
    = scale.getPixelForValue(start + length);\r\n\t\tsize = head - base;\r\n\r\n\t\tif
    (minBarLength !== undefined && Math.abs(size) < minBarLength) {\r\n\t\t\tsize
    = minBarLength;\r\n\t\t\tif (length >= 0 && !isHorizontal || length < 0 && isHorizontal)
    {\r\n\t\t\t\thead = base - minBarLength;\r\n\t\t\t} else {\r\n\t\t\t\thead = base
    + minBarLength;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tbase:
    base,\r\n\t\t\thead: head,\r\n\t\t\tcenter: head + size / 2\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tcalculateBarIndexPixels: function(datasetIndex, index,
    ruler, options) {\r\n\t\tvar me = this;\r\n\t\tvar range = options.barThickness
    === 'flex'\r\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\r\n\t\t\t:
    computeFitCategoryTraits(index, ruler, options);\r\n\r\n\t\tvar stackIndex = me.getStackIndex(datasetIndex,
    me.getMeta().stack);\r\n\t\tvar center = range.start + (range.chunk * stackIndex)
    + (range.chunk / 2);\r\n\t\tvar size = Math.min(\r\n\t\t\tvalueOrDefault$3(options.maxBarThickness,
    Infinity),\r\n\t\t\trange.chunk * range.ratio);\r\n\r\n\t\treturn {\r\n\t\t\tbase:
    center - size / 2,\r\n\t\t\thead: center + size / 2,\r\n\t\t\tcenter: center,\r\n\t\t\tsize:
    size\r\n\t\t};\r\n\t},\r\n\r\n\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar scale = me._getValueScale();\r\n\t\tvar rects = me.getMeta().data;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar ilen = rects.length;\r\n\t\tvar i = 0;\r\n\r\n\t\thelpers$1.canvas.clipArea(chart.ctx,
    chart.chartArea);\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tvar val = scale._parseValue(dataset.data[i]);\r\n\t\t\tif
    (!isNaN(val.min) && !isNaN(val.max)) {\r\n\t\t\t\trects[i].draw();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers$1.canvas.unclipArea(chart.ctx);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_resolveDataElementOptions: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me,
    arguments));\r\n\t\tvar indexOpts = me._getIndexScale().options;\r\n\t\tvar valueOpts
    = me._getValueScale().options;\r\n\r\n\t\tvalues.barPercentage = valueOrDefault$3(indexOpts.barPercentage,
    values.barPercentage);\r\n\t\tvalues.barThickness = valueOrDefault$3(indexOpts.barThickness,
    values.barThickness);\r\n\t\tvalues.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage,
    values.categoryPercentage);\r\n\t\tvalues.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness,
    values.maxBarThickness);\r\n\t\tvalues.minBarLength = valueOrDefault$3(valueOpts.minBarLength,
    values.minBarLength);\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n});\n\nvar valueOrDefault$4
    = helpers$1.valueOrDefault;\r\nvar resolve$1 = helpers$1.options.resolve;\r\n\r\ncore_defaults._set('bubble',
    {\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes:
    [{\r\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\r\n\t\t\tposition:
    'bottom',\r\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the
    scale\r\n\t\t}],\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition:
    'left',\r\n\t\t\tid: 'y-axis-0'\r\n\t\t}]\r\n\t},\r\n\r\n\ttooltips: {\r\n\t\tcallbacks:
    {\r\n\t\t\ttitle: function() {\r\n\t\t\t\t// Title doesn't make sense for scatter
    since we format the data as a point\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel:
    function(item, data) {\r\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label
    || '';\r\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\r\n\t\t\t\treturn
    datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r +
    ')';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_bubble = core_datasetController.extend({\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tdataElementType: elements.Point,\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t\t'hoverRadius',\r\n\t\t'hitRadius',\r\n\t\t'pointStyle',\r\n\t\t'rotation'\r\n\t],\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar points = meta.data;\r\n\r\n\t\t// Update Points\r\n\t\thelpers$1.each(points,
    function(point, index) {\r\n\t\t\tme.updateElement(point, index, reset);\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tupdateElement: function(point, index, reset) {\r\n\t\tvar
    me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar custom = point.custom ||
    {};\r\n\t\tvar xScale = me.getScaleForId(meta.xAxisID);\r\n\t\tvar yScale = me.getScaleForId(meta.yAxisID);\r\n\t\tvar
    options = me._resolveDataElementOptions(point, index);\r\n\t\tvar data = me.getDataset().data[index];\r\n\t\tvar
    dsIndex = me.index;\r\n\r\n\t\tvar x = reset ? xScale.getPixelForDecimal(0.5)
    : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\r\n\t\tvar
    y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\r\n\r\n\t\tpoint._xScale
    = xScale;\r\n\t\tpoint._yScale = yScale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex
    = dsIndex;\r\n\t\tpoint._index = index;\r\n\t\tpoint._model = {\r\n\t\t\tbackgroundColor:
    options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\thitRadius: options.hitRadius,\r\n\t\t\tpointStyle:
    options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tradius: reset
    ? 0 : options.radius,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\tx:
    x,\r\n\t\t\ty: y,\r\n\t\t};\r\n\r\n\t\tpoint.pivot();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model =
    point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor =
    helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor:
    model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor
    = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor
    = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth
    = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius
    = options.radius + options.hoverRadius;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_resolveDataElementOptions: function(point, index) {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar custom = point.custom
    || {};\r\n\t\tvar data = dataset.data[index] || {};\r\n\t\tvar values = core_datasetController.prototype._resolveDataElementOptions.apply(me,
    arguments);\r\n\r\n\t\t// Scriptable options\r\n\t\tvar context = {\r\n\t\t\tchart:
    chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset: dataset,\r\n\t\t\tdatasetIndex:
    me.index\r\n\t\t};\r\n\r\n\t\t// In case values were cached (and thus frozen),
    we need to clone the values\r\n\t\tif (me._cachedDataOpts === values) {\r\n\t\t\tvalues
    = helpers$1.extend({}, values);\r\n\t\t}\r\n\r\n\t\t// Custom radius resolution\r\n\t\tvalues.radius
    = resolve$1([\r\n\t\t\tcustom.radius,\r\n\t\t\tdata.r,\r\n\t\t\tme._config.radius,\r\n\t\t\tchart.options.elements.point.radius\r\n\t\t],
    context, index);\r\n\r\n\t\treturn values;\r\n\t}\r\n});\n\nvar valueOrDefault$5
    = helpers$1.valueOrDefault;\r\n\r\nvar PI$1 = Math.PI;\r\nvar DOUBLE_PI$1 = PI$1
    * 2;\r\nvar HALF_PI$1 = PI$1 / 2;\r\n\r\ncore_defaults._set('doughnut', {\r\n\tanimation:
    {\r\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\r\n\t\tanimateRotate:
    true,\r\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\r\n\t\tanimateScale:
    false\r\n\t},\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\tlegendCallback:
    function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar data
    = chart.data;\r\n\t\tvar datasets = data.datasets;\r\n\t\tvar labels = data.labels;\r\n\t\tvar
    i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id
    + '-legend');\r\n\t\tif (datasets.length) {\r\n\t\t\tfor (i = 0, ilen = datasets[0].data.length;
    i < ilen; ++i) {\r\n\t\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\t\tlistItemSpan
    = listItem.appendChild(document.createElement('span'));\r\n\t\t\t\tlistItemSpan.style.backgroundColor
    = datasets[0].backgroundColor[i];\r\n\t\t\t\tif (labels[i]) {\r\n\t\t\t\t\tlistItem.appendChild(document.createTextNode(labels[i]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    list.outerHTML;\r\n\t},\r\n\tlegend: {\r\n\t\tlabels: {\r\n\t\t\tgenerateLabels:
    function(chart) {\r\n\t\t\t\tvar data = chart.data;\r\n\t\t\t\tif (data.labels.length
    && data.datasets.length) {\r\n\t\t\t\t\treturn data.labels.map(function(label,
    i) {\r\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\r\n\t\t\t\t\t\tvar style
    = meta.controller.getStyle(i);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttext:
    label,\r\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\t\tstrokeStyle:
    style.borderColor,\r\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\t\thidden:
    isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\r\n\r\n\t\t\t\t\t\t\t//
    Extra data used for toggling the correct item\r\n\t\t\t\t\t\t\tindex: i\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn
    [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar
    index = legendItem.index;\r\n\t\t\tvar chart = this.chart;\r\n\t\t\tvar i, ilen,
    meta;\r\n\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i <
    ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\t// toggle visibility
    of index if exists\r\n\t\t\t\tif (meta.data[index]) {\r\n\t\t\t\t\tmeta.data[index].hidden
    = !meta.data[index].hidden;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tchart.update();\r\n\t\t}\r\n\t},\r\n\r\n\t//
    The percentage of the chart that we cut out of the middle.\r\n\tcutoutPercentage:
    50,\r\n\r\n\t// The rotation of the chart, where the first data arc begins.\r\n\trotation:
    -HALF_PI$1,\r\n\r\n\t// The total circumference of the chart.\r\n\tcircumference:
    DOUBLE_PI$1,\r\n\r\n\t// Need to override these to give a nice default\r\n\ttooltips:
    {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel:
    function(tooltipItem, data) {\r\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\r\n\t\t\t\tvar
    value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\r\n\r\n\t\t\t\tif
    (helpers$1.isArray(dataLabel)) {\r\n\t\t\t\t\t// show value on first line of multiline
    label\r\n\t\t\t\t\t// need to clone because we are changing the value\r\n\t\t\t\t\tdataLabel
    = dataLabel.slice();\r\n\t\t\t\t\tdataLabel[0] += value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdataLabel
    += value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn dataLabel;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    controller_doughnut = core_datasetController.extend({\r\n\r\n\tdataElementType:
    elements.Arc,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'borderAlign',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t],\r\n\r\n\t//
    Get index of the dataset in relation to the visible datasets. This allows determining
    the inner and outer radius correctly\r\n\tgetRingIndex: function(datasetIndex)
    {\r\n\t\tvar ringIndex = 0;\r\n\r\n\t\tfor (var j = 0; j < datasetIndex; ++j)
    {\r\n\t\t\tif (this.chart.isDatasetVisible(j)) {\r\n\t\t\t\t++ringIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    ringIndex;\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar
    ratioX = 1;\r\n\t\tvar ratioY = 1;\r\n\t\tvar offsetX = 0;\r\n\t\tvar offsetY
    = 0;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar arcs = meta.data;\r\n\t\tvar cutout
    = opts.cutoutPercentage / 100 || 0;\r\n\t\tvar circumference = opts.circumference;\r\n\t\tvar
    chartWeight = me._getRingWeight(me.index);\r\n\t\tvar maxWidth, maxHeight, i,
    ilen;\r\n\r\n\t\t// If the chart's circumference isn't a full circle, calculate
    size as a ratio of the width/height of the arc\r\n\t\tif (circumference < DOUBLE_PI$1)
    {\r\n\t\t\tvar startAngle = opts.rotation % DOUBLE_PI$1;\r\n\t\t\tstartAngle +=
    startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;\r\n\t\t\tvar
    endAngle = startAngle + circumference;\r\n\t\t\tvar startX = Math.cos(startAngle);\r\n\t\t\tvar
    startY = Math.sin(startAngle);\r\n\t\t\tvar endX = Math.cos(endAngle);\r\n\t\t\tvar
    endY = Math.sin(endAngle);\r\n\t\t\tvar contains0 = (startAngle <= 0 && endAngle
    >= 0) || endAngle >= DOUBLE_PI$1;\r\n\t\t\tvar contains90 = (startAngle <= HALF_PI$1
    && endAngle >= HALF_PI$1) || endAngle >= DOUBLE_PI$1 + HALF_PI$1;\r\n\t\t\tvar
    contains180 = startAngle === -PI$1 || endAngle >= PI$1;\r\n\t\t\tvar contains270
    = (startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1) || endAngle >= PI$1 + HALF_PI$1;\r\n\t\t\tvar
    minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);\r\n\t\t\tvar
    minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);\r\n\t\t\tvar
    maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);\r\n\t\t\tvar
    maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);\r\n\t\t\tratioX
    = (maxX - minX) / 2;\r\n\t\t\tratioY = (maxY - minY) / 2;\r\n\t\t\toffsetX = -(maxX
    + minX) / 2;\r\n\t\t\toffsetY = -(maxY + minY) / 2;\r\n\t\t}\r\n\r\n\t\tfor (i
    = 0, ilen = arcs.length; i < ilen; ++i) {\r\n\t\t\tarcs[i]._options = me._resolveDataElementOptions(arcs[i],
    i);\r\n\t\t}\r\n\r\n\t\tchart.borderWidth = me.getMaxBorderWidth();\r\n\t\tmaxWidth
    = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;\r\n\t\tmaxHeight
    = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;\r\n\t\tchart.outerRadius
    = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n\t\tchart.innerRadius = Math.max(chart.outerRadius
    * cutout, 0);\r\n\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius)
    / (me._getVisibleDatasetWeightTotal() || 1);\r\n\t\tchart.offsetX = offsetX *
    chart.outerRadius;\r\n\t\tchart.offsetY = offsetY * chart.outerRadius;\r\n\r\n\t\tmeta.total
    = me.calculateTotal();\r\n\r\n\t\tme.outerRadius = chart.outerRadius - chart.radiusLength
    * me._getRingWeightOffset(me.index);\r\n\t\tme.innerRadius = Math.max(me.outerRadius
    - chart.radiusLength * chartWeight, 0);\r\n\r\n\t\tfor (i = 0, ilen = arcs.length;
    i < ilen; ++i) {\r\n\t\t\tme.updateElement(arcs[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(arc, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar animationOpts
    = opts.animation;\r\n\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\r\n\t\tvar
    centerY = (chartArea.top + chartArea.bottom) / 2;\r\n\t\tvar startAngle = opts.rotation;
    // non reset case handled later\r\n\t\tvar endAngle = opts.rotation; // non reset
    case handled later\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar circumference
    = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index])
    * (opts.circumference / DOUBLE_PI$1);\r\n\t\tvar innerRadius = reset && animationOpts.animateScale
    ? 0 : me.innerRadius;\r\n\t\tvar outerRadius = reset && animationOpts.animateScale
    ? 0 : me.outerRadius;\r\n\t\tvar options = arc._options || {};\r\n\r\n\t\thelpers$1.extend(arc,
    {\r\n\t\t\t// Utility\r\n\t\t\t_datasetIndex: me.index,\r\n\t\t\t_index: index,\r\n\r\n\t\t\t//
    Desired view properties\r\n\t\t\t_model: {\r\n\t\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\t\tborderColor:
    options.borderColor,\r\n\t\t\t\tborderWidth: options.borderWidth,\r\n\t\t\t\tborderAlign:
    options.borderAlign,\r\n\t\t\t\tx: centerX + chart.offsetX,\r\n\t\t\t\ty: centerY
    + chart.offsetY,\r\n\t\t\t\tstartAngle: startAngle,\r\n\t\t\t\tendAngle: endAngle,\r\n\t\t\t\tcircumference:
    circumference,\r\n\t\t\t\touterRadius: outerRadius,\r\n\t\t\t\tinnerRadius: innerRadius,\r\n\t\t\t\tlabel:
    helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar
    model = arc._model;\r\n\r\n\t\t// Set correct angles if not resetting\r\n\t\tif
    (!reset || !animationOpts.animateRotate) {\r\n\t\t\tif (index === 0) {\r\n\t\t\t\tmodel.startAngle
    = opts.rotation;\r\n\t\t\t} else {\r\n\t\t\t\tmodel.startAngle = me.getMeta().data[index
    - 1]._model.endAngle;\r\n\t\t\t}\r\n\r\n\t\t\tmodel.endAngle = model.startAngle
    + model.circumference;\r\n\t\t}\r\n\r\n\t\tarc.pivot();\r\n\t},\r\n\r\n\tcalculateTotal:
    function() {\r\n\t\tvar dataset = this.getDataset();\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar
    total = 0;\r\n\t\tvar value;\r\n\r\n\t\thelpers$1.each(meta.data, function(element,
    index) {\r\n\t\t\tvalue = dataset.data[index];\r\n\t\t\tif (!isNaN(value) && !element.hidden)
    {\r\n\t\t\t\ttotal += Math.abs(value);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t/* if
    (total === 0) {\r\n\t\t\ttotal = NaN;\r\n\t\t}*/\r\n\r\n\t\treturn total;\r\n\t},\r\n\r\n\tcalculateCircumference:
    function(value) {\r\n\t\tvar total = this.getMeta().total;\r\n\t\tif (total >
    0 && !isNaN(value)) {\r\n\t\t\treturn DOUBLE_PI$1 * (Math.abs(value) / total);\r\n\t\t}\r\n\t\treturn
    0;\r\n\t},\r\n\r\n\t// gets the max border or hover width to properly scale pie
    charts\r\n\tgetMaxBorderWidth: function(arcs) {\r\n\t\tvar me = this;\r\n\t\tvar
    max = 0;\r\n\t\tvar chart = me.chart;\r\n\t\tvar i, ilen, meta, arc, controller,
    options, borderWidth, hoverWidth;\r\n\r\n\t\tif (!arcs) {\r\n\t\t\t// Find the
    outmost visible dataset\r\n\t\t\tfor (i = 0, ilen = chart.data.datasets.length;
    i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tmeta
    = chart.getDatasetMeta(i);\r\n\t\t\t\t\tarcs = meta.data;\r\n\t\t\t\t\tif (i !==
    me.index) {\r\n\t\t\t\t\t\tcontroller = meta.controller;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (!arcs) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length;
    i < ilen; ++i) {\r\n\t\t\tarc = arcs[i];\r\n\t\t\tif (controller) {\r\n\t\t\t\tcontroller._configure();\r\n\t\t\t\toptions
    = controller._resolveDataElementOptions(arc, i);\r\n\t\t\t} else {\r\n\t\t\t\toptions
    = arc._options;\r\n\t\t\t}\r\n\t\t\tif (options.borderAlign !== 'inner') {\r\n\t\t\t\tborderWidth
    = options.borderWidth;\r\n\t\t\t\thoverWidth = options.hoverBorderWidth;\r\n\r\n\t\t\t\tmax
    = borderWidth > max ? borderWidth : max;\r\n\t\t\t\tmax = hoverWidth > max ? hoverWidth
    : max;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn max;\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t
    */\r\n\tsetHoverStyle: function(arc) {\r\n\t\tvar model = arc._model;\r\n\t\tvar
    options = arc._options;\r\n\t\tvar getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tarc.$previousStyle
    = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor,
    getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault$5(options.hoverBorderColor,
    getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault$5(options.hoverBorderWidth,
    options.borderWidth);\r\n\t},\r\n\r\n\t/**\r\n\t * Get radius length offset of
    the dataset in relation to the visible datasets weights. This allows determining
    the inner and outer radius correctly\r\n\t * @private\r\n\t */\r\n\t_getRingWeightOffset:
    function(datasetIndex) {\r\n\t\tvar ringWeightOffset = 0;\r\n\r\n\t\tfor (var
    i = 0; i < datasetIndex; ++i) {\r\n\t\t\tif (this.chart.isDatasetVisible(i)) {\r\n\t\t\t\tringWeightOffset
    += this._getRingWeight(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ringWeightOffset;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getRingWeight: function(dataSetIndex) {\r\n\t\treturn
    Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the sum of all visibile data set weights.  This value can be 0.\r\n\t
    * @private\r\n\t */\r\n\t_getVisibleDatasetWeightTotal: function() {\r\n\t\treturn
    this._getRingWeightOffset(this.chart.data.datasets.length);\r\n\t}\r\n});\n\ncore_defaults._set('horizontalBar',
    {\r\n\thover: {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t},\r\n\r\n\tscales:
    {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\r\n\t\tyAxes:
    [{\r\n\t\t\ttype: 'category',\r\n\t\t\tposition: 'left',\r\n\t\t\toffset: true,\r\n\t\t\tgridLines:
    {\r\n\t\t\t\toffsetGridLines: true\r\n\t\t\t}\r\n\t\t}]\r\n\t},\r\n\r\n\telements:
    {\r\n\t\trectangle: {\r\n\t\t\tborderSkipped: 'left'\r\n\t\t}\r\n\t},\r\n\r\n\ttooltips:
    {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global',
    {\r\n\tdatasets: {\r\n\t\thorizontalBar: {\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage:
    0.9\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar controller_horizontalBar = controller_bar.extend({\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.getMeta().xAxisID;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.getMeta().yAxisID;\r\n\t}\r\n});\n\nvar
    valueOrDefault$6 = helpers$1.valueOrDefault;\r\nvar resolve$2 = helpers$1.options.resolve;\r\nvar
    isPointInArea = helpers$1.canvas._isPointInArea;\r\n\r\ncore_defaults._set('line',
    {\r\n\tshowLines: true,\r\n\tspanGaps: false,\r\n\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales:
    {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'category',\r\n\t\t\tid: 'x-axis-0'\r\n\t\t}],\r\n\t\tyAxes:
    [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tid: 'y-axis-0'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\nfunction
    scaleClip(scale, halfBorderWidth) {\r\n\tvar tickOpts = scale && scale.options.ticks
    || {};\r\n\tvar reverse = tickOpts.reverse;\r\n\tvar min = tickOpts.min === undefined
    ? halfBorderWidth : 0;\r\n\tvar max = tickOpts.max === undefined ? halfBorderWidth
    : 0;\r\n\treturn {\r\n\t\tstart: reverse ? max : min,\r\n\t\tend: reverse ? min
    : max\r\n\t};\r\n}\r\n\r\nfunction defaultClip(xScale, yScale, borderWidth) {\r\n\tvar
    halfBorderWidth = borderWidth / 2;\r\n\tvar x = scaleClip(xScale, halfBorderWidth);\r\n\tvar
    y = scaleClip(yScale, halfBorderWidth);\r\n\r\n\treturn {\r\n\t\ttop: y.end,\r\n\t\tright:
    x.end,\r\n\t\tbottom: y.start,\r\n\t\tleft: x.start\r\n\t};\r\n}\r\n\r\nfunction
    toClip(value) {\r\n\tvar t, r, b, l;\r\n\r\n\tif (helpers$1.isObject(value)) {\r\n\t\tt
    = value.top;\r\n\t\tr = value.right;\r\n\t\tb = value.bottom;\r\n\t\tl = value.left;\r\n\t}
    else {\r\n\t\tt = r = b = l = value;\r\n\t}\r\n\r\n\treturn {\r\n\t\ttop: t,\r\n\t\tright:
    r,\r\n\t\tbottom: b,\r\n\t\tleft: l\r\n\t};\r\n}\r\n\r\n\r\nvar controller_line
    = core_datasetController.extend({\r\n\r\n\tdatasetElementType: elements.Line,\r\n\r\n\tdataElementType:
    elements.Point,\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_datasetElementOptions:
    [\r\n\t\t'backgroundColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderColor',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'borderWidth',\r\n\t\t'cubicInterpolationMode',\r\n\t\t'fill'\r\n\t],\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: {\r\n\t\tbackgroundColor: 'pointBackgroundColor',\r\n\t\tborderColor:
    'pointBorderColor',\r\n\t\tborderWidth: 'pointBorderWidth',\r\n\t\thitRadius:
    'pointHitRadius',\r\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\r\n\t\thoverBorderColor:
    'pointHoverBorderColor',\r\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\r\n\t\thoverRadius:
    'pointHoverRadius',\r\n\t\tpointStyle: 'pointStyle',\r\n\t\tradius: 'pointRadius',\r\n\t\trotation:
    'pointRotation'\r\n\t},\r\n\r\n\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar line = meta.dataset;\r\n\t\tvar points = meta.data
    || [];\r\n\t\tvar options = me.chart.options;\r\n\t\tvar config = me._config;\r\n\t\tvar
    showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tme._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\tme._yScale
    = me.getScaleForId(meta.yAxisID);\r\n\r\n\t\t// Update Line\r\n\t\tif (showLine)
    {\r\n\t\t\t// Compatibility: If the properties are defined with only the old name,
    use those values\r\n\t\t\tif (config.tension !== undefined && config.lineTension
    === undefined) {\r\n\t\t\t\tconfig.lineTension = config.tension;\r\n\t\t\t}\r\n\r\n\t\t\t//
    Utility\r\n\t\t\tline._scale = me._yScale;\r\n\t\t\tline._datasetIndex = me.index;\r\n\t\t\t//
    Data\r\n\t\t\tline._children = points;\r\n\t\t\t// Model\r\n\t\t\tline._model
    = me._resolveDatasetElementOptions(line);\r\n\r\n\t\t\tline.pivot();\r\n\t\t}\r\n\r\n\t\t//
    Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i],
    i, reset);\r\n\t\t}\r\n\r\n\t\tif (showLine && line._model.tension !== 0) {\r\n\t\t\tme.updateBezierControlPoints();\r\n\t\t}\r\n\r\n\t\t//
    Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i <
    ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    custom = point.custom || {};\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar
    datasetIndex = me.index;\r\n\t\tvar value = dataset.data[index];\r\n\t\tvar xScale
    = me._xScale;\r\n\t\tvar yScale = me._yScale;\r\n\t\tvar lineModel = meta.dataset._model;\r\n\t\tvar
    x, y;\r\n\r\n\t\tvar options = me._resolveDataElementOptions(point, index);\r\n\r\n\t\tx
    = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\r\n\t\ty
    = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\r\n\r\n\t\t//
    Utility\r\n\t\tpoint._xScale = xScale;\r\n\t\tpoint._yScale = yScale;\r\n\t\tpoint._options
    = options;\r\n\t\tpoint._datasetIndex = datasetIndex;\r\n\t\tpoint._index = index;\r\n\r\n\t\t//
    Desired view properties\r\n\t\tpoint._model = {\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t\tskip:
    custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\t// Appearance\r\n\t\t\tradius: options.radius,\r\n\t\t\tpointStyle:
    options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tbackgroundColor:
    options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\ttension: valueOrDefault$6(custom.tension, lineModel
    ? lineModel.tension : 0),\r\n\t\t\tsteppedLine: lineModel ? lineModel.steppedLine
    : false,\r\n\t\t\t// Tooltip\r\n\t\t\thitRadius: options.hitRadius\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function(element) {\r\n\t\tvar
    me = this;\r\n\t\tvar config = me._config;\r\n\t\tvar custom = element.custom
    || {};\r\n\t\tvar options = me.chart.options;\r\n\t\tvar lineOptions = options.elements.line;\r\n\t\tvar
    values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me,
    arguments);\r\n\r\n\t\t// The default behavior of lines is to break at null values,
    according\r\n\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\r\n\t\t//
    This option gives lines the ability to span gaps\r\n\t\tvalues.spanGaps = valueOrDefault$6(config.spanGaps,
    options.spanGaps);\r\n\t\tvalues.tension = valueOrDefault$6(config.lineTension,
    lineOptions.tension);\r\n\t\tvalues.steppedLine = resolve$2([custom.steppedLine,
    config.steppedLine, lineOptions.stepped]);\r\n\t\tvalues.clip = toClip(valueOrDefault$6(config.clip,
    defaultClip(me._xScale, me._yScale, values.borderWidth)));\r\n\r\n\t\treturn values;\r\n\t},\r\n\r\n\tcalculatePointY:
    function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar chart
    = me.chart;\r\n\t\tvar yScale = me._yScale;\r\n\t\tvar sumPos = 0;\r\n\t\tvar
    sumNeg = 0;\r\n\t\tvar i, ds, dsMeta, stackedRightValue, rightValue, metasets,
    ilen;\r\n\r\n\t\tif (yScale.options.stacked) {\r\n\t\t\trightValue = +yScale.getRightValue(value);\r\n\t\t\tmetasets
    = chart._getSortedVisibleDatasetMetas();\r\n\t\t\tilen = metasets.length;\r\n\r\n\t\t\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\t\t\tdsMeta = metasets[i];\r\n\t\t\t\tif (dsMeta.index
    === datasetIndex) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tds = chart.data.datasets[dsMeta.index];\r\n\t\t\t\tif
    (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {\r\n\t\t\t\t\tstackedRightValue
    = +yScale.getRightValue(ds.data[index]);\r\n\t\t\t\t\tif (stackedRightValue <
    0) {\r\n\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsumPos
    += stackedRightValue || 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif
    (rightValue < 0) {\r\n\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\r\n\t\t\t}\r\n\t\t\treturn
    yScale.getPixelForValue(sumPos + rightValue);\r\n\t\t}\r\n\t\treturn yScale.getPixelForValue(value);\r\n\t},\r\n\r\n\tupdateBezierControlPoints:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta
    = me.getMeta();\r\n\t\tvar lineModel = meta.dataset._model;\r\n\t\tvar area =
    chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model,
    controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps
    option is used\r\n\t\tif (lineModel.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt)
    {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction
    capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif
    (lineModel.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers$1.splineCurveMonotone(points);\r\n\t\t}
    else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel
    = points[i]._model;\r\n\t\t\t\tcontrolPoints = helpers$1.splineCurve(\r\n\t\t\t\t\thelpers$1.previousItem(points,
    i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers$1.nextItem(points, i)._model,\r\n\t\t\t\t\tlineModel.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX
    = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX
    = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length;
    i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tif (isPointInArea(model,
    area)) {\r\n\t\t\t\t\tif (i > 0 && isPointInArea(points[i - 1]._model, area))
    {\r\n\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX,
    area.left, area.right);\r\n\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY,
    area.top, area.bottom);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i < points.length - 1
    && isPointInArea(points[i + 1]._model, area)) {\r\n\t\t\t\t\t\tmodel.controlPointNextX
    = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\t\t\tmodel.controlPointNextY
    = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdraw:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta
    = me.getMeta();\r\n\t\tvar points = meta.data || [];\r\n\t\tvar area = chart.chartArea;\r\n\t\tvar
    canvas = chart.canvas;\r\n\t\tvar i = 0;\r\n\t\tvar ilen = points.length;\r\n\t\tvar
    clip;\r\n\r\n\t\tif (me._showLine) {\r\n\t\t\tclip = meta.dataset._model.clip;\r\n\r\n\t\t\thelpers$1.canvas.clipArea(chart.ctx,
    {\r\n\t\t\t\tleft: clip.left === false ? 0 : area.left - clip.left,\r\n\t\t\t\tright:
    clip.right === false ? canvas.width : area.right + clip.right,\r\n\t\t\t\ttop:
    clip.top === false ? 0 : area.top - clip.top,\r\n\t\t\t\tbottom: clip.bottom ===
    false ? canvas.height : area.bottom + clip.bottom\r\n\t\t\t});\r\n\r\n\t\t\tmeta.dataset.draw();\r\n\r\n\t\t\thelpers$1.canvas.unclipArea(chart.ctx);\r\n\t\t}\r\n\r\n\t\t//
    Draw the points\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tpoints[i].draw(area);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @protected\r\n\t */\r\n\tsetHoverStyle: function(point) {\r\n\t\tvar model =
    point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar getHoverColor =
    helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor:
    model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor
    = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor
    = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth
    = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius
    = valueOrDefault$6(options.hoverRadius, options.radius);\r\n\t},\r\n});\n\nvar
    resolve$3 = helpers$1.options.resolve;\r\n\r\ncore_defaults._set('polarArea',
    {\r\n\tscale: {\r\n\t\ttype: 'radialLinear',\r\n\t\tangleLines: {\r\n\t\t\tdisplay:
    false\r\n\t\t},\r\n\t\tgridLines: {\r\n\t\t\tcircular: true\r\n\t\t},\r\n\t\tpointLabels:
    {\r\n\t\t\tdisplay: false\r\n\t\t},\r\n\t\tticks: {\r\n\t\t\tbeginAtZero: true\r\n\t\t}\r\n\t},\r\n\r\n\t//
    Boolean - Whether to animate the rotation of the chart\r\n\tanimation: {\r\n\t\tanimateRotate:
    true,\r\n\t\tanimateScale: true\r\n\t},\r\n\r\n\tstartAngle: -0.5 * Math.PI,\r\n\tlegendCallback:
    function(chart) {\r\n\t\tvar list = document.createElement('ul');\r\n\t\tvar data
    = chart.data;\r\n\t\tvar datasets = data.datasets;\r\n\t\tvar labels = data.labels;\r\n\t\tvar
    i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id
    + '-legend');\r\n\t\tif (datasets.length) {\r\n\t\t\tfor (i = 0, ilen = datasets[0].data.length;
    i < ilen; ++i) {\r\n\t\t\t\tlistItem = list.appendChild(document.createElement('li'));\r\n\t\t\t\tlistItemSpan
    = listItem.appendChild(document.createElement('span'));\r\n\t\t\t\tlistItemSpan.style.backgroundColor
    = datasets[0].backgroundColor[i];\r\n\t\t\t\tif (labels[i]) {\r\n\t\t\t\t\tlistItem.appendChild(document.createTextNode(labels[i]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    list.outerHTML;\r\n\t},\r\n\tlegend: {\r\n\t\tlabels: {\r\n\t\t\tgenerateLabels:
    function(chart) {\r\n\t\t\t\tvar data = chart.data;\r\n\t\t\t\tif (data.labels.length
    && data.datasets.length) {\r\n\t\t\t\t\treturn data.labels.map(function(label,
    i) {\r\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\r\n\t\t\t\t\t\tvar style
    = meta.controller.getStyle(i);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttext:
    label,\r\n\t\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\t\tstrokeStyle:
    style.borderColor,\r\n\t\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\t\thidden:
    isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\r\n\r\n\t\t\t\t\t\t\t//
    Extra data used for toggling the correct item\r\n\t\t\t\t\t\t\tindex: i\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn
    [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar
    index = legendItem.index;\r\n\t\t\tvar chart = this.chart;\r\n\t\t\tvar i, ilen,
    meta;\r\n\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i <
    ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tmeta.data[index].hidden
    = !meta.data[index].hidden;\r\n\t\t\t}\r\n\r\n\t\t\tchart.update();\r\n\t\t}\r\n\t},\r\n\r\n\t//
    Need to override these to give a nice default\r\n\ttooltips: {\r\n\t\tcallbacks:
    {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';\r\n\t\t\t},\r\n\t\t\tlabel:
    function(item, data) {\r\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    controller_polarArea = core_datasetController.extend({\r\n\r\n\tdataElementType:
    elements.Arc,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_dataElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderColor',\r\n\t\t'borderWidth',\r\n\t\t'borderAlign',\r\n\t\t'hoverBackgroundColor',\r\n\t\t'hoverBorderColor',\r\n\t\t'hoverBorderWidth',\r\n\t],\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getIndexScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\tupdate:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar
    meta = me.getMeta();\r\n\t\tvar start = me.chart.options.startAngle || 0;\r\n\t\tvar
    starts = me._starts = [];\r\n\t\tvar angles = me._angles = [];\r\n\t\tvar arcs
    = meta.data;\r\n\t\tvar i, ilen, angle;\r\n\r\n\t\tme._updateRadius();\r\n\r\n\t\tmeta.count
    = me.countVisibleElements();\r\n\r\n\t\tfor (i = 0, ilen = dataset.data.length;
    i < ilen; i++) {\r\n\t\t\tstarts[i] = start;\r\n\t\t\tangle = me._computeAngle(i);\r\n\t\t\tangles[i]
    = angle;\r\n\t\t\tstart += angle;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = arcs.length;
    i < ilen; ++i) {\r\n\t\t\tarcs[i]._options = me._resolveDataElementOptions(arcs[i],
    i);\r\n\t\t\tme.updateElement(arcs[i], i, reset);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_updateRadius: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar chartArea = chart.chartArea;\r\n\t\tvar opts = chart.options;\r\n\t\tvar
    minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n\r\n\t\tchart.outerRadius
    = Math.max(minSize / 2, 0);\r\n\t\tchart.innerRadius = Math.max(opts.cutoutPercentage
    ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n\t\tchart.radiusLength
    = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\r\n\r\n\t\tme.outerRadius
    = chart.outerRadius - (chart.radiusLength * me.index);\r\n\t\tme.innerRadius =
    me.outerRadius - chart.radiusLength;\r\n\t},\r\n\r\n\tupdateElement: function(arc,
    index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar opts = chart.options;\r\n\t\tvar animationOpts
    = opts.animation;\r\n\t\tvar scale = chart.scale;\r\n\t\tvar labels = chart.data.labels;\r\n\r\n\t\tvar
    centerX = scale.xCenter;\r\n\t\tvar centerY = scale.yCenter;\r\n\r\n\t\t// var
    negHalfPI = -0.5 * Math.PI;\r\n\t\tvar datasetStartAngle = opts.startAngle;\r\n\t\tvar
    distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\t\tvar
    startAngle = me._starts[index];\r\n\t\tvar endAngle = startAngle + (arc.hidden
    ? 0 : me._angles[index]);\r\n\r\n\t\tvar resetRadius = animationOpts.animateScale
    ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\t\tvar options
    = arc._options || {};\r\n\r\n\t\thelpers$1.extend(arc, {\r\n\t\t\t// Utility\r\n\t\t\t_datasetIndex:
    me.index,\r\n\t\t\t_index: index,\r\n\t\t\t_scale: scale,\r\n\r\n\t\t\t// Desired
    view properties\r\n\t\t\t_model: {\r\n\t\t\t\tbackgroundColor: options.backgroundColor,\r\n\t\t\t\tborderColor:
    options.borderColor,\r\n\t\t\t\tborderWidth: options.borderWidth,\r\n\t\t\t\tborderAlign:
    options.borderAlign,\r\n\t\t\t\tx: centerX,\r\n\t\t\t\ty: centerY,\r\n\t\t\t\tinnerRadius:
    0,\r\n\t\t\t\touterRadius: reset ? resetRadius : distance,\r\n\t\t\t\tstartAngle:
    reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\r\n\t\t\t\tendAngle:
    reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\r\n\t\t\t\tlabel:
    helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tarc.pivot();\r\n\t},\r\n\r\n\tcountVisibleElements:
    function() {\r\n\t\tvar dataset = this.getDataset();\r\n\t\tvar meta = this.getMeta();\r\n\t\tvar
    count = 0;\r\n\r\n\t\thelpers$1.each(meta.data, function(element, index) {\r\n\t\t\tif
    (!isNaN(dataset.data[index]) && !element.hidden) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn
    count;\r\n\t},\r\n\r\n\t/**\r\n\t * @protected\r\n\t */\r\n\tsetHoverStyle: function(arc)
    {\r\n\t\tvar model = arc._model;\r\n\t\tvar options = arc._options;\r\n\t\tvar
    getHoverColor = helpers$1.getHoverColor;\r\n\t\tvar valueOrDefault = helpers$1.valueOrDefault;\r\n\r\n\t\tarc.$previousStyle
    = {\r\n\t\t\tbackgroundColor: model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor = valueOrDefault(options.hoverBackgroundColor,
    getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor = valueOrDefault(options.hoverBorderColor,
    getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth = valueOrDefault(options.hoverBorderWidth,
    options.borderWidth);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeAngle:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar count = this.getMeta().count;\r\n\t\tvar
    dataset = me.getDataset();\r\n\t\tvar meta = me.getMeta();\r\n\r\n\t\tif (isNaN(dataset.data[index])
    || meta.data[index].hidden) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Scriptable
    options\r\n\t\tvar context = {\r\n\t\t\tchart: me.chart,\r\n\t\t\tdataIndex: index,\r\n\t\t\tdataset:
    dataset,\r\n\t\t\tdatasetIndex: me.index\r\n\t\t};\r\n\r\n\t\treturn resolve$3([\r\n\t\t\tme.chart.options.elements.arc.angle,\r\n\t\t\t(2
    * Math.PI) / count\r\n\t\t], context, index);\r\n\t}\r\n});\n\ncore_defaults._set('pie',
    helpers$1.clone(core_defaults.doughnut));\r\ncore_defaults._set('pie', {\r\n\tcutoutPercentage:
    0\r\n});\r\n\r\n// Pie charts are Doughnut chart with different defaults\r\nvar
    controller_pie = controller_doughnut;\n\nvar valueOrDefault$7 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('radar',
    {\r\n\tspanGaps: false,\r\n\tscale: {\r\n\t\ttype: 'radialLinear'\r\n\t},\r\n\telements:
    {\r\n\t\tline: {\r\n\t\t\tfill: 'start',\r\n\t\t\ttension: 0 // no bezier in radar\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    controller_radar = core_datasetController.extend({\r\n\tdatasetElementType: elements.Line,\r\n\r\n\tdataElementType:
    elements.Point,\r\n\r\n\tlinkScales: helpers$1.noop,\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_datasetElementOptions: [\r\n\t\t'backgroundColor',\r\n\t\t'borderWidth',\r\n\t\t'borderColor',\r\n\t\t'borderCapStyle',\r\n\t\t'borderDash',\r\n\t\t'borderDashOffset',\r\n\t\t'borderJoinStyle',\r\n\t\t'fill'\r\n\t],\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_dataElementOptions: {\r\n\t\tbackgroundColor: 'pointBackgroundColor',\r\n\t\tborderColor:
    'pointBorderColor',\r\n\t\tborderWidth: 'pointBorderWidth',\r\n\t\thitRadius:
    'pointHitRadius',\r\n\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\r\n\t\thoverBorderColor:
    'pointHoverBorderColor',\r\n\t\thoverBorderWidth: 'pointHoverBorderWidth',\r\n\t\thoverRadius:
    'pointHoverRadius',\r\n\t\tpointStyle: 'pointStyle',\r\n\t\tradius: 'pointRadius',\r\n\t\trotation:
    'pointRotation'\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getIndexScaleId:
    function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_getValueScaleId: function() {\r\n\t\treturn this.chart.scale.id;\r\n\t},\r\n\r\n\tupdate:
    function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar
    line = meta.dataset;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar scale = me.chart.scale;\r\n\t\tvar
    config = me._config;\r\n\t\tvar i, ilen;\r\n\r\n\t\t// Compatibility: If the properties
    are defined with only the old name, use those values\r\n\t\tif (config.tension
    !== undefined && config.lineTension === undefined) {\r\n\t\t\tconfig.lineTension
    = config.tension;\r\n\t\t}\r\n\r\n\t\t// Utility\r\n\t\tline._scale = scale;\r\n\t\tline._datasetIndex
    = me.index;\r\n\t\t// Data\r\n\t\tline._children = points;\r\n\t\tline._loop =
    true;\r\n\t\t// Model\r\n\t\tline._model = me._resolveDatasetElementOptions(line);\r\n\r\n\t\tline.pivot();\r\n\r\n\t\t//
    Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i],
    i, reset);\r\n\t\t}\r\n\r\n\t\t// Update bezier control points\r\n\t\tme.updateBezierControlPoints();\r\n\r\n\t\t//
    Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i <
    ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r\n\r\n\tupdateElement:
    function(point, index, reset) {\r\n\t\tvar me = this;\r\n\t\tvar custom = point.custom
    || {};\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar scale = me.chart.scale;\r\n\t\tvar
    pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\r\n\t\tvar
    options = me._resolveDataElementOptions(point, index);\r\n\t\tvar lineModel =
    me.getMeta().dataset._model;\r\n\t\tvar x = reset ? scale.xCenter : pointPosition.x;\r\n\t\tvar
    y = reset ? scale.yCenter : pointPosition.y;\r\n\r\n\t\t// Utility\r\n\t\tpoint._scale
    = scale;\r\n\t\tpoint._options = options;\r\n\t\tpoint._datasetIndex = me.index;\r\n\t\tpoint._index
    = index;\r\n\r\n\t\t// Desired view properties\r\n\t\tpoint._model = {\r\n\t\t\tx:
    x, // value not used in dataset scale, but we want a consistent API between scales\r\n\t\t\ty:
    y,\r\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\r\n\t\t\t// Appearance\r\n\t\t\tradius:
    options.radius,\r\n\t\t\tpointStyle: options.pointStyle,\r\n\t\t\trotation: options.rotation,\r\n\t\t\tbackgroundColor:
    options.backgroundColor,\r\n\t\t\tborderColor: options.borderColor,\r\n\t\t\tborderWidth:
    options.borderWidth,\r\n\t\t\ttension: valueOrDefault$7(custom.tension, lineModel
    ? lineModel.tension : 0),\r\n\r\n\t\t\t// Tooltip\r\n\t\t\thitRadius: options.hitRadius\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_resolveDatasetElementOptions: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar config = me._config;\r\n\t\tvar options = me.chart.options;\r\n\t\tvar
    values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me,
    arguments);\r\n\r\n\t\tvalues.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);\r\n\t\tvalues.tension
    = valueOrDefault$7(config.lineTension, options.elements.line.tension);\r\n\r\n\t\treturn
    values;\r\n\t},\r\n\r\n\tupdateBezierControlPoints: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar
    points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\t//
    Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif
    (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt)
    {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction
    capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor
    (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints
    = helpers$1.splineCurve(\r\n\t\t\t\thelpers$1.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers$1.nextItem(points,
    i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent
    the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX
    = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY
    = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX
    = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY
    = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r\n\r\n\tsetHoverStyle:
    function(point) {\r\n\t\tvar model = point._model;\r\n\t\tvar options = point._options;\r\n\t\tvar
    getHoverColor = helpers$1.getHoverColor;\r\n\r\n\t\tpoint.$previousStyle = {\r\n\t\t\tbackgroundColor:
    model.backgroundColor,\r\n\t\t\tborderColor: model.borderColor,\r\n\t\t\tborderWidth:
    model.borderWidth,\r\n\t\t\tradius: model.radius\r\n\t\t};\r\n\r\n\t\tmodel.backgroundColor
    = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\r\n\t\tmodel.borderColor
    = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));\r\n\t\tmodel.borderWidth
    = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);\r\n\t\tmodel.radius
    = valueOrDefault$7(options.hoverRadius, options.radius);\r\n\t}\r\n});\n\ncore_defaults._set('scatter',
    {\r\n\thover: {\r\n\t\tmode: 'single'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes:
    [{\r\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\r\n\t\t\ttype:
    'linear',    // scatter should not use a category axis\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\t\tyAxes:
    [{\r\n\t\t\tid: 'y-axis-1',\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'left'\r\n\t\t}]\r\n\t},\r\n\r\n\ttooltips:
    {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function() {\r\n\t\t\t\treturn '';     //
    doesn't make sense for scatter since data are formatted as a point\r\n\t\t\t},\r\n\t\t\tlabel:
    function(item) {\r\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\ncore_defaults._set('global',
    {\r\n\tdatasets: {\r\n\t\tscatter: {\r\n\t\t\tshowLine: false\r\n\t\t}\r\n\t}\r\n});\r\n\r\n//
    Scatter charts use line controllers\r\nvar controller_scatter = controller_line;\n\n//
    NOTE export a map in which the key represents the controller type, not\r\n// the
    class, and so must be CamelCase in order to be correctly retrieved\r\n// by the
    controller in core.controller.js (`controllers[meta.type]`).\r\n\r\nvar controllers
    = {\r\n\tbar: controller_bar,\r\n\tbubble: controller_bubble,\r\n\tdoughnut: controller_doughnut,\r\n\thorizontalBar:
    controller_horizontalBar,\r\n\tline: controller_line,\r\n\tpolarArea: controller_polarArea,\r\n\tpie:
    controller_pie,\r\n\tradar: controller_radar,\r\n\tscatter: controller_scatter\r\n};\n\n/**\r\n
    * Helper function to get relative position for an event\r\n * @param {Event|IEvent}
    event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n
    * @returns {object} the event position\r\n */\r\nfunction getRelativePosition(e,
    chart) {\r\n\tif (e.native) {\r\n\t\treturn {\r\n\t\t\tx: e.x,\r\n\t\t\ty: e.y\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    helpers$1.getRelativePosition(e, chart);\r\n}\r\n\r\n/**\r\n * Helper function
    to traverse all of the visible elements in the chart\r\n * @param {Chart} chart
    - the chart\r\n * @param {function} handler - the callback to execute for each
    visible item\r\n */\r\nfunction parseVisibleItems(chart, handler) {\r\n\tvar metasets
    = chart._getSortedVisibleDatasetMetas();\r\n\tvar metadata, i, j, ilen, jlen,
    element;\r\n\r\n\tfor (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n\t\tmetadata
    = metasets[i].data;\r\n\t\tfor (j = 0, jlen = metadata.length; j < jlen; ++j)
    {\r\n\t\t\telement = metadata[j];\r\n\t\t\tif (!element._view.skip) {\r\n\t\t\t\thandler(element);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n
    * Helper function to get the items that intersect the event position\r\n * @param
    {ChartElement[]} items - elements to filter\r\n * @param {object} position - the
    point to be nearest to\r\n * @return {ChartElement[]} the nearest items\r\n */\r\nfunction
    getIntersectItems(chart, position) {\r\n\tvar elements = [];\r\n\r\n\tparseVisibleItems(chart,
    function(element) {\r\n\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn
    elements;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the
    event position considering all visible items in teh chart\r\n * @param {Chart}
    chart - the chart to look at elements from\r\n * @param {object} position - the
    point to be nearest to\r\n * @param {boolean} intersect - if true, only consider
    items that intersect the position\r\n * @param {function} distanceMetric - function
    to provide the distance between points\r\n * @return {ChartElement[]} the nearest
    items\r\n */\r\nfunction getNearestItems(chart, position, intersect, distanceMetric)
    {\r\n\tvar minDistance = Number.POSITIVE_INFINITY;\r\n\tvar nearestItems = [];\r\n\r\n\tparseVisibleItems(chart,
    function(element) {\r\n\t\tif (intersect && !element.inRange(position.x, position.y))
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar center = element.getCenterPoint();\r\n\t\tvar
    distance = distanceMetric(position, center);\r\n\t\tif (distance < minDistance)
    {\r\n\t\t\tnearestItems = [element];\r\n\t\t\tminDistance = distance;\r\n\t\t}
    else if (distance === minDistance) {\r\n\t\t\t// Can have multiple items at the
    same distance in which case we sort by size\r\n\t\t\tnearestItems.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn
    nearestItems;\r\n}\r\n\r\n/**\r\n * Get a distance metric function for two points
    based on the\r\n * axis mode setting\r\n * @param {string} axis - the axis mode.
    x|y|xy\r\n */\r\nfunction getDistanceMetricForAxis(axis) {\r\n\tvar useX = axis.indexOf('x')
    !== -1;\r\n\tvar useY = axis.indexOf('y') !== -1;\r\n\r\n\treturn function(pt1,
    pt2) {\r\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n\t\tvar deltaY
    = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n\t\treturn Math.sqrt(Math.pow(deltaX,
    2) + Math.pow(deltaY, 2));\r\n\t};\r\n}\r\n\r\nfunction indexMode(chart, e, options)
    {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for
    index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar
    distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect
    ? getIntersectItems(chart, position) : getNearestItems(chart, position, false,
    distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn
    [];\r\n\t}\r\n\r\n\tchart._getSortedVisibleDatasetMetas().forEach(function(meta)
    {\r\n\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t// don't count items
    that are skipped (null data)\r\n\t\tif (element && !element._view.skip) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn
    elements;\r\n}\r\n\r\n/**\r\n * @interface IInteractionOptions\r\n */\r\n/**\r\n
    * If true, only consider items that intersect the point\r\n * @name IInterfaceOptions#boolean\r\n
    * @type Boolean\r\n */\r\n\r\n/**\r\n * Contains interaction related functions\r\n
    * @namespace Chart.Interaction\r\n */\r\nvar core_interaction = {\r\n\t// Helper
    function for different modes\r\n\tmodes: {\r\n\t\tsingle: function(chart, e) {\r\n\t\t\tvar
    position = getRelativePosition(e, chart);\r\n\t\t\tvar elements = [];\r\n\r\n\t\t\tparseVisibleItems(chart,
    function(element) {\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\telements.push(element);\r\n\t\t\t\t\treturn
    elements;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn elements.slice(0, 1);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * @function Chart.Interaction.modes.label\r\n\t\t * @deprecated since version
    2.4.0\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\tlabel:
    indexMode,\r\n\r\n\t\t/**\r\n\t\t * Returns items at the same index. If the options.intersect
    parameter is true, we only return items if we intersect something\r\n\t\t * If
    the options.intersect mode is false, we find the nearest item and return the items
    at the same index as that item\r\n\t\t * @function Chart.Interaction.modes.index\r\n\t\t
    * @since v2.4.0\r\n\t\t * @param {Chart} chart - the chart we are returning items
    from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param
    {IInteractionOptions} options - options to use during interaction\r\n\t\t * @return
    {Chart.Element[]} Array of elements that are under the point. If none are found,
    an empty array is returned\r\n\t\t */\r\n\t\tindex: indexMode,\r\n\r\n\t\t/**\r\n\t\t
    * Returns items in the same dataset. If the options.intersect parameter is true,
    we only return items if we intersect something\r\n\t\t * If the options.intersect
    is false, we find the nearest item and return the items in that dataset\r\n\t\t
    * @function Chart.Interaction.modes.dataset\r\n\t\t * @param {Chart} chart - the
    chart we are returning items from\r\n\t\t * @param {Event} e - the event we are
    find things at\r\n\t\t * @param {IInteractionOptions} options - options to use
    during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that
    are under the point. If none are found, an empty array is returned\r\n\t\t */\r\n\t\tdataset:
    function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis
    = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar
    items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart,
    position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems
    = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn
    items;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @function Chart.Interaction.modes.x-axis\r\n\t\t
    * @deprecated since version 2.4.0. Use index mode and intersect == true\r\n\t\t
    * @todo remove at version 3\r\n\t\t * @private\r\n\t\t */\r\n\t\t'x-axis': function(chart,
    e) {\r\n\t\t\treturn indexMode(chart, e, {intersect: false});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * Point mode returns all elements that hit test based on the event position\r\n\t\t
    * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t *
    @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param
    {Event} e - the event we are find things at\r\n\t\t * @return {Chart.Element[]}
    Array of elements that are under the point. If none are found, an empty array
    is returned\r\n\t\t */\r\n\t\tpoint: function(chart, e) {\r\n\t\t\tvar position
    = getRelativePosition(e, chart);\r\n\t\t\treturn getIntersectItems(chart, position);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t
    * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param
    {Event} e - the event we are find things at\r\n\t\t * @param {IInteractionOptions}
    options - options to use\r\n\t\t * @return {Chart.Element[]} Array of elements
    that are under the point. If none are found, an empty array is returned\r\n\t\t
    */\r\n\t\tnearest: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e,
    chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric
    = getDistanceMetricForAxis(options.axis);\r\n\t\t\treturn getNearestItems(chart,
    position, options.intersect, distanceMetric);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * x mode returns the elements that hit-test at the current x coordinate\r\n\t\t
    * @function Chart.Interaction.modes.x\r\n\t\t * @param {Chart} chart - the chart
    we are returning items from\r\n\t\t * @param {Event} e - the event we are find
    things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t
    * @return {Chart.Element[]} Array of elements that are under the point. If none
    are found, an empty array is returned\r\n\t\t */\r\n\t\tx: function(chart, e,
    options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar
    items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart,
    function(element) {\r\n\t\t\t\tif (element.inXRange(position.x)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif
    (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t//
    If we want to trigger on an intersect and we don't have any items\r\n\t\t\t//
    that intersect the position, return nothing\r\n\t\t\tif (options.intersect &&
    !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t
    * y mode returns the elements that hit-test at the current y coordinate\r\n\t\t
    * @function Chart.Interaction.modes.y\r\n\t\t * @param {Chart} chart - the chart
    we are returning items from\r\n\t\t * @param {Event} e - the event we are find
    things at\r\n\t\t * @param {IInteractionOptions} options - options to use\r\n\t\t
    * @return {Chart.Element[]} Array of elements that are under the point. If none
    are found, an empty array is returned\r\n\t\t */\r\n\t\ty: function(chart, e,
    options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar
    items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart,
    function(element) {\r\n\t\t\t\tif (element.inYRange(position.y)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif
    (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t//
    If we want to trigger on an intersect and we don't have any items\r\n\t\t\t//
    that intersect the position, return nothing\r\n\t\t\tif (options.intersect &&
    !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t}\r\n\t}\r\n};\n\nvar
    extend = helpers$1.extend;\r\n\r\nfunction filterByPosition(array, position) {\r\n\treturn
    helpers$1.where(array, function(v) {\r\n\t\treturn v.pos === position;\r\n\t});\r\n}\r\n\r\nfunction
    sortByWeight(array, reverse) {\r\n\treturn array.sort(function(a, b) {\r\n\t\tvar
    v0 = reverse ? b : a;\r\n\t\tvar v1 = reverse ? a : b;\r\n\t\treturn v0.weight
    === v1.weight ?\r\n\t\t\tv0.index - v1.index :\r\n\t\t\tv0.weight - v1.weight;\r\n\t});\r\n}\r\n\r\nfunction
    wrapBoxes(boxes) {\r\n\tvar layoutBoxes = [];\r\n\tvar i, ilen, box;\r\n\r\n\tfor
    (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n\t\tbox = boxes[i];\r\n\t\tlayoutBoxes.push({\r\n\t\t\tindex:
    i,\r\n\t\t\tbox: box,\r\n\t\t\tpos: box.position,\r\n\t\t\thorizontal: box.isHorizontal(),\r\n\t\t\tweight:
    box.weight\r\n\t\t});\r\n\t}\r\n\treturn layoutBoxes;\r\n}\r\n\r\nfunction setLayoutDims(layouts,
    params) {\r\n\tvar i, ilen, layout;\r\n\tfor (i = 0, ilen = layouts.length; i
    < ilen; ++i) {\r\n\t\tlayout = layouts[i];\r\n\t\t// store width used instead
    of chartArea.w in fitBoxes\r\n\t\tlayout.width = layout.horizontal\r\n\t\t\t?
    layout.box.fullWidth && params.availableWidth\r\n\t\t\t: params.vBoxMaxWidth;\r\n\t\t//
    store height used instead of chartArea.h in fitBoxes\r\n\t\tlayout.height = layout.horizontal
    && params.hBoxMaxHeight;\r\n\t}\r\n}\r\n\r\nfunction buildLayoutBoxes(boxes) {\r\n\tvar
    layoutBoxes = wrapBoxes(boxes);\r\n\tvar left = sortByWeight(filterByPosition(layoutBoxes,
    'left'), true);\r\n\tvar right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n\tvar
    top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n\tvar bottom
    = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n\r\n\treturn {\r\n\t\tleftAndTop:
    left.concat(top),\r\n\t\trightAndBottom: right.concat(bottom),\r\n\t\tchartArea:
    filterByPosition(layoutBoxes, 'chartArea'),\r\n\t\tvertical: left.concat(right),\r\n\t\thorizontal:
    top.concat(bottom)\r\n\t};\r\n}\r\n\r\nfunction getCombinedMax(maxPadding, chartArea,
    a, b) {\r\n\treturn Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b],
    chartArea[b]);\r\n}\r\n\r\nfunction updateDims(chartArea, params, layout) {\r\n\tvar
    box = layout.box;\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\tvar newWidth,
    newHeight;\r\n\r\n\tif (layout.size) {\r\n\t\t// this layout was already counted
    for, lets first reduce old size\r\n\t\tchartArea[layout.pos] -= layout.size;\r\n\t}\r\n\tlayout.size
    = layout.horizontal ? box.height : box.width;\r\n\tchartArea[layout.pos] += layout.size;\r\n\r\n\tif
    (box.getPadding) {\r\n\t\tvar boxPadding = box.getPadding();\r\n\t\tmaxPadding.top
    = Math.max(maxPadding.top, boxPadding.top);\r\n\t\tmaxPadding.left = Math.max(maxPadding.left,
    boxPadding.left);\r\n\t\tmaxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n\t\tmaxPadding.right
    = Math.max(maxPadding.right, boxPadding.right);\r\n\t}\r\n\r\n\tnewWidth = params.outerWidth
    - getCombinedMax(maxPadding, chartArea, 'left', 'right');\r\n\tnewHeight = params.outerHeight
    - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');\r\n\r\n\tif (newWidth
    !== chartArea.w || newHeight !== chartArea.h) {\r\n\t\tchartArea.w = newWidth;\r\n\t\tchartArea.h
    = newHeight;\r\n\r\n\t\t// return true if chart area changed in layout's direction\r\n\t\tvar
    sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];\r\n\t\treturn
    sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));\r\n\t}\r\n}\r\n\r\nfunction
    handleMaxPadding(chartArea) {\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\r\n\tfunction
    updatePos(pos) {\r\n\t\tvar change = Math.max(maxPadding[pos] - chartArea[pos],
    0);\r\n\t\tchartArea[pos] += change;\r\n\t\treturn change;\r\n\t}\r\n\tchartArea.y
    += updatePos('top');\r\n\tchartArea.x += updatePos('left');\r\n\tupdatePos('right');\r\n\tupdatePos('bottom');\r\n}\r\n\r\nfunction
    getMargins(horizontal, chartArea) {\r\n\tvar maxPadding = chartArea.maxPadding;\r\n\r\n\tfunction
    marginForPositions(positions) {\r\n\t\tvar margin = {left: 0, top: 0, right: 0,
    bottom: 0};\r\n\t\tpositions.forEach(function(pos) {\r\n\t\t\tmargin[pos] = Math.max(chartArea[pos],
    maxPadding[pos]);\r\n\t\t});\r\n\t\treturn margin;\r\n\t}\r\n\r\n\treturn horizontal\r\n\t\t?
    marginForPositions(['left', 'right'])\r\n\t\t: marginForPositions(['top', 'bottom']);\r\n}\r\n\r\nfunction
    fitBoxes(boxes, chartArea, params) {\r\n\tvar refitBoxes = [];\r\n\tvar i, ilen,
    layout, box, refit, changed;\r\n\r\n\tfor (i = 0, ilen = boxes.length; i < ilen;
    ++i) {\r\n\t\tlayout = boxes[i];\r\n\t\tbox = layout.box;\r\n\r\n\t\tbox.update(\r\n\t\t\tlayout.width
    || chartArea.w,\r\n\t\t\tlayout.height || chartArea.h,\r\n\t\t\tgetMargins(layout.horizontal,
    chartArea)\r\n\t\t);\r\n\t\tif (updateDims(chartArea, params, layout)) {\r\n\t\t\tchanged
    = true;\r\n\t\t\tif (refitBoxes.length) {\r\n\t\t\t\t// Dimensions changed and
    there were non full width boxes before this\r\n\t\t\t\t// -> we have to refit
    those\r\n\t\t\t\trefit = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!box.fullWidth)
    { // fullWidth boxes don't need to be re-fitted in any case\r\n\t\t\trefitBoxes.push(layout);\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;\r\n}\r\n\r\nfunction
    placeBoxes(boxes, chartArea, params) {\r\n\tvar userPadding = params.padding;\r\n\tvar
    x = chartArea.x;\r\n\tvar y = chartArea.y;\r\n\tvar i, ilen, layout, box;\r\n\r\n\tfor
    (i = 0, ilen = boxes.length; i < ilen; ++i) {\r\n\t\tlayout = boxes[i];\r\n\t\tbox
    = layout.box;\r\n\t\tif (layout.horizontal) {\r\n\t\t\tbox.left = box.fullWidth
    ? userPadding.left : chartArea.left;\r\n\t\t\tbox.right = box.fullWidth ? params.outerWidth
    - userPadding.right : chartArea.left + chartArea.w;\r\n\t\t\tbox.top = y;\r\n\t\t\tbox.bottom
    = y + box.height;\r\n\t\t\tbox.width = box.right - box.left;\r\n\t\t\ty = box.bottom;\r\n\t\t}
    else {\r\n\t\t\tbox.left = x;\r\n\t\t\tbox.right = x + box.width;\r\n\t\t\tbox.top
    = chartArea.top;\r\n\t\t\tbox.bottom = chartArea.top + chartArea.h;\r\n\t\t\tbox.height
    = box.bottom - box.top;\r\n\t\t\tx = box.right;\r\n\t\t}\r\n\t}\r\n\r\n\tchartArea.x
    = x;\r\n\tchartArea.y = y;\r\n}\r\n\r\ncore_defaults._set('global', {\r\n\tlayout:
    {\r\n\t\tpadding: {\r\n\t\t\ttop: 0,\r\n\t\t\tright: 0,\r\n\t\t\tbottom: 0,\r\n\t\t\tleft:
    0\r\n\t\t}\r\n\t}\r\n});\r\n\r\n/**\r\n * @interface ILayoutItem\r\n * @prop {string}
    position - The position of the item in the chart layout. Possible values are\r\n
    * 'left', 'top', 'right', 'bottom', and 'chartArea'\r\n * @prop {number} weight
    - The weight used to sort the item. Higher weights are further away from the chart
    area\r\n * @prop {boolean} fullWidth - if true, and the item is horizontal, then
    push vertical boxes down\r\n * @prop {function} isHorizontal - returns true if
    the layout item is horizontal (ie. top or bottom)\r\n * @prop {function} update
    - Takes two parameters: width and height. Returns size of item\r\n * @prop {function}
    getPadding -  Returns an object with padding on the edges\r\n * @prop {number}
    width - Width of item. Must be valid after update()\r\n * @prop {number} height
    - Height of item. Must be valid after update()\r\n * @prop {number} left - Left
    edge of the item. Set by layout system and cannot be used in update\r\n * @prop
    {number} top - Top edge of the item. Set by layout system and cannot be used in
    update\r\n * @prop {number} right - Right edge of the item. Set by layout system
    and cannot be used in update\r\n * @prop {number} bottom - Bottom edge of the
    item. Set by layout system and cannot be used in update\r\n */\r\n\r\n// The layout
    service is very self explanatory.  It's responsible for the layout within a chart.\r\n//
    Scales, Legends and Plugins all rely on the layout service and can easily register
    to be placed anywhere they need\r\n// It is this service's responsibility of carrying
    out that layout.\r\nvar core_layouts = {\r\n\tdefaults: {},\r\n\r\n\t/**\r\n\t
    * Register a box to a chart.\r\n\t * A box is simply a reference to an object
    that requires layout. eg. Scales, Legend, Title.\r\n\t * @param {Chart} chart
    - the chart to use\r\n\t * @param {ILayoutItem} item - the item to add to be layed
    out\r\n\t */\r\n\taddBox: function(chart, item) {\r\n\t\tif (!chart.boxes) {\r\n\t\t\tchart.boxes
    = [];\r\n\t\t}\r\n\r\n\t\t// initialize item with default values\r\n\t\titem.fullWidth
    = item.fullWidth || false;\r\n\t\titem.position = item.position || 'top';\r\n\t\titem.weight
    = item.weight || 0;\r\n\t\titem._layers = item._layers || function() {\r\n\t\t\treturn
    [{\r\n\t\t\t\tz: 0,\r\n\t\t\t\tdraw: function() {\r\n\t\t\t\t\titem.draw.apply(item,
    arguments);\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t};\r\n\r\n\t\tchart.boxes.push(item);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Remove a layoutItem from a chart\r\n\t * @param {Chart} chart - the chart to
    remove the box from\r\n\t * @param {ILayoutItem} layoutItem - the item to remove
    from the layout\r\n\t */\r\n\tremoveBox: function(chart, layoutItem) {\r\n\t\tvar
    index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n\t\tif (index !==
    -1) {\r\n\t\t\tchart.boxes.splice(index, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Sets (or updates) options on the given `item`.\r\n\t * @param {Chart} chart
    - the chart in which the item lives (or will be added to)\r\n\t * @param {ILayoutItem}
    item - the item to configure with the given options\r\n\t * @param {object} options
    - the new item options.\r\n\t */\r\n\tconfigure: function(chart, item, options)
    {\r\n\t\tvar props = ['fullWidth', 'position', 'weight'];\r\n\t\tvar ilen = props.length;\r\n\t\tvar
    i = 0;\r\n\t\tvar prop;\r\n\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tprop = props[i];\r\n\t\t\tif
    (options.hasOwnProperty(prop)) {\r\n\t\t\t\titem[prop] = options[prop];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Fits boxes of the given chart into the given size by having each box measure
    itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart -
    the chart\r\n\t * @param {number} width - the width to fit into\r\n\t * @param
    {number} height - the height to fit into\r\n\t */\r\n\tupdate: function(chart,
    width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar
    layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers$1.options.toPadding(layoutOptions.padding);\r\n\r\n\t\tvar
    availableWidth = width - padding.width;\r\n\t\tvar availableHeight = height -
    padding.height;\r\n\t\tvar boxes = buildLayoutBoxes(chart.boxes);\r\n\t\tvar verticalBoxes
    = boxes.vertical;\r\n\t\tvar horizontalBoxes = boxes.horizontal;\r\n\r\n\t\t//
    Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t//
    Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left
    axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom
    axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead
    of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box
    locations only, when trying to register a chartArea location that is already taken,\r\n\t\t//
    an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t//
    |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//
    |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t//
    |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|
    \                          |----|    |\r\n\t\t// |    |    |                                     |
    \   |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t//
    |    |    |                                     |    |\r\n\t\t// |    |    |----|
    \                          |----|    |\r\n\t\t// |    |    | C3 |                           |
    C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t//
    |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//
    |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\r\n\t\tvar
    params = Object.freeze({\r\n\t\t\touterWidth: width,\r\n\t\t\touterHeight: height,\r\n\t\t\tpadding:
    padding,\r\n\t\t\tavailableWidth: availableWidth,\r\n\t\t\tvBoxMaxWidth: availableWidth
    / 2 / verticalBoxes.length,\r\n\t\t\thBoxMaxHeight: availableHeight / 2\r\n\t\t});\r\n\t\tvar
    chartArea = extend({\r\n\t\t\tmaxPadding: extend({}, padding),\r\n\t\t\tw: availableWidth,\r\n\t\t\th:
    availableHeight,\r\n\t\t\tx: padding.left,\r\n\t\t\ty: padding.top\r\n\t\t}, padding);\r\n\r\n\t\tsetLayoutDims(verticalBoxes.concat(horizontalBoxes),
    params);\r\n\r\n\t\t// First fit vertical boxes\r\n\t\tfitBoxes(verticalBoxes,
    chartArea, params);\r\n\r\n\t\t// Then fit horizontal boxes\r\n\t\tif (fitBoxes(horizontalBoxes,
    chartArea, params)) {\r\n\t\t\t// if the area changed, re-fit vertical boxes\r\n\t\t\tfitBoxes(verticalBoxes,
    chartArea, params);\r\n\t\t}\r\n\r\n\t\thandleMaxPadding(chartArea);\r\n\r\n\t\t//
    Finally place the boxes to correct coordinates\r\n\t\tplaceBoxes(boxes.leftAndTop,
    chartArea, params);\r\n\r\n\t\t// Move to opposite side of chart\r\n\t\tchartArea.x
    += chartArea.w;\r\n\t\tchartArea.y += chartArea.h;\r\n\r\n\t\tplaceBoxes(boxes.rightAndBottom,
    chartArea, params);\r\n\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: chartArea.left,\r\n\t\t\ttop:
    chartArea.top,\r\n\t\t\tright: chartArea.left + chartArea.w,\r\n\t\t\tbottom:
    chartArea.top + chartArea.h\r\n\t\t};\r\n\r\n\t\t// Finally update boxes in chartArea
    (radial scale for example)\r\n\t\thelpers$1.each(boxes.chartArea, function(layout)
    {\r\n\t\t\tvar box = layout.box;\r\n\t\t\textend(box, chart.chartArea);\r\n\t\t\tbox.update(chartArea.w,
    chartArea.h);\r\n\t\t});\r\n\t}\r\n};\n\n/**\r\n * Platform fallback implementation
    (minimal).\r\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\r\n
    */\r\n\r\nvar platform_basic = {\r\n\tacquireContext: function(item) {\r\n\t\tif
    (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas
    (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\treturn
    item && item.getContext('2d') || null;\r\n\t}\r\n};\n\nvar platform_dom = \"/*\\r\\n
    * DOM element rendering detection\\r\\n * https://davidwalsh.name/detect-node-insertion\\r\\n
    */\\r\\n@keyframes chartjs-render-animation {\\r\\n\\tfrom { opacity: 0.99; }\\r\\n\\tto
    { opacity: 1; }\\r\\n}\\r\\n\\r\\n.chartjs-render-monitor {\\r\\n\\tanimation:
    chartjs-render-animation 0.001s;\\r\\n}\\r\\n\\r\\n/*\\r\\n * DOM element resizing
    detection\\r\\n * https://github.com/marcj/css-element-queries\\r\\n */\\r\\n.chartjs-size-monitor,\\r\\n.chartjs-size-monitor-expand,\\r\\n.chartjs-size-monitor-shrink
    {\\r\\n\\tposition: absolute;\\r\\n\\tdirection: ltr;\\r\\n\\tleft: 0;\\r\\n\\ttop:
    0;\\r\\n\\tright: 0;\\r\\n\\tbottom: 0;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events:
    none;\\r\\n\\tvisibility: hidden;\\r\\n\\tz-index: -1;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-expand
    > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 1000000px;\\r\\n\\theight:
    1000000px;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\\r\\n.chartjs-size-monitor-shrink
    > div {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 200%;\\r\\n\\theight: 200%;\\r\\n\\tleft:
    0;\\r\\n\\ttop: 0;\\r\\n}\\r\\n\";\n\nvar platform_dom$1 = /*#__PURE__*/Object.freeze({\n__proto__:
    null,\n'default': platform_dom\n});\n\nvar stylesheet = getCjsExportFromNamespace(platform_dom$1);\n\nvar
    EXPANDO_KEY = '$chartjs';\r\nvar CSS_PREFIX = 'chartjs-';\r\nvar CSS_SIZE_MONITOR
    = CSS_PREFIX + 'size-monitor';\r\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\r\nvar
    CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\r\nvar ANIMATION_START_EVENTS
    = ['animationstart', 'webkitAnimationStart'];\r\n\r\n/**\r\n * DOM event types
    -> Chart.js event types.\r\n * Note: only events with different types are mapped.\r\n
    * @see https://developer.mozilla.org/en-US/docs/Web/Events\r\n */\r\nvar EVENT_TYPES
    = {\r\n\ttouchstart: 'mousedown',\r\n\ttouchmove: 'mousemove',\r\n\ttouchend:
    'mouseup',\r\n\tpointerenter: 'mouseenter',\r\n\tpointerdown: 'mousedown',\r\n\tpointermove:
    'mousemove',\r\n\tpointerup: 'mouseup',\r\n\tpointerleave: 'mouseout',\r\n\tpointerout:
    'mouseout'\r\n};\r\n\r\n/**\r\n * The \"used\" size is the final value of a dimension
    property after all calculations have\r\n * been performed. This method uses the
    computed style of `element` but returns undefined\r\n * if the computed style
    is not expressed in pixels. That can happen in some cases where\r\n * `element`
    has a size relative to its parent and this last one is not yet displayed,\r\n
    * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n
    * @returns {number} Size in pixels or undefined if unknown.\r\n */\r\nfunction
    readUsedSize(element, property) {\r\n\tvar value = helpers$1.getStyle(element,
    property);\r\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n\treturn
    matches ? Number(matches[1]) : undefined;\r\n}\r\n\r\n/**\r\n * Initializes the
    canvas style and render size without modifying the canvas display size,\r\n *
    since responsiveness is handled by the controller.resize() method. The config
    is used\r\n * to determine the aspect ratio to apply in case no explicit height
    has been specified.\r\n */\r\nfunction initCanvas(canvas, config) {\r\n\tvar style
    = canvas.style;\r\n\r\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width:
    in the first case it\r\n\t// returns null or '' if no explicit value has been
    set to the canvas attribute.\r\n\tvar renderHeight = canvas.getAttribute('height');\r\n\tvar
    renderWidth = canvas.getAttribute('width');\r\n\r\n\t// Chart.js modifies some
    canvas values that we want to restore on destroy\r\n\tcanvas[EXPANDO_KEY] = {\r\n\t\tinitial:
    {\r\n\t\t\theight: renderHeight,\r\n\t\t\twidth: renderWidth,\r\n\t\t\tstyle:
    {\r\n\t\t\t\tdisplay: style.display,\r\n\t\t\t\theight: style.height,\r\n\t\t\t\twidth:
    style.width\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Force canvas to display as
    block to avoid extra space caused by inline\r\n\t// elements, which would interfere
    with the responsive resize process.\r\n\t// https://github.com/chartjs/Chart.js/issues/2538\r\n\tstyle.display
    = style.display || 'block';\r\n\r\n\tif (renderWidth === null || renderWidth ===
    '') {\r\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\r\n\t\tif (displayWidth
    !== undefined) {\r\n\t\t\tcanvas.width = displayWidth;\r\n\t\t}\r\n\t}\r\n\r\n\tif
    (renderHeight === null || renderHeight === '') {\r\n\t\tif (canvas.style.height
    === '') {\r\n\t\t\t// If no explicit render height and style height, let's apply
    the aspect ratio,\r\n\t\t\t// which one can be specified by the user but also
    by charts as default option\r\n\t\t\t// (i.e. options.aspectRatio). If not specified,
    use canvas aspect ratio of 2.\r\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio
    || 2);\r\n\t\t} else {\r\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\r\n\t\t\tif
    (displayWidth !== undefined) {\r\n\t\t\t\tcanvas.height = displayHeight;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    canvas;\r\n}\r\n\r\n/**\r\n * Detects support for options object argument in addEventListener.\r\n
    * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n
    * @private\r\n */\r\nvar supportsEventListenerOptions = (function() {\r\n\tvar
    supports = false;\r\n\ttry {\r\n\t\tvar options = Object.defineProperty({}, 'passive',
    {\r\n\t\t\t// eslint-disable-next-line getter-return\r\n\t\t\tget: function()
    {\r\n\t\t\t\tsupports = true;\r\n\t\t\t}\r\n\t\t});\r\n\t\twindow.addEventListener('e',
    null, options);\r\n\t} catch (e) {\r\n\t\t// continue regardless of error\r\n\t}\r\n\treturn
    supports;\r\n}());\r\n\r\n// Default passive to true as expected by Chrome for
    'touchstart' and 'touchend' events.\r\n// https://github.com/chartjs/Chart.js/issues/4287\r\nvar
    eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n\r\nfunction
    addListener(node, type, listener) {\r\n\tnode.addEventListener(type, listener,
    eventListenerOptions);\r\n}\r\n\r\nfunction removeListener(node, type, listener)
    {\r\n\tnode.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction
    createEvent(type, chart, x, y, nativeEvent) {\r\n\treturn {\r\n\t\ttype: type,\r\n\t\tchart:
    chart,\r\n\t\tnative: nativeEvent || null,\r\n\t\tx: x !== undefined ? x : null,\r\n\t\ty:
    y !== undefined ? y : null,\r\n\t};\r\n}\r\n\r\nfunction fromNativeEvent(event,
    chart) {\r\n\tvar type = EVENT_TYPES[event.type] || event.type;\r\n\tvar pos =
    helpers$1.getRelativePosition(event, chart);\r\n\treturn createEvent(type, chart,
    pos.x, pos.y, event);\r\n}\r\n\r\nfunction throttled(fn, thisArg) {\r\n\tvar ticking
    = false;\r\n\tvar args = [];\r\n\r\n\treturn function() {\r\n\t\targs = Array.prototype.slice.call(arguments);\r\n\t\tthisArg
    = thisArg || this;\r\n\r\n\t\tif (!ticking) {\r\n\t\t\tticking = true;\r\n\t\t\thelpers$1.requestAnimFrame.call(window,
    function() {\r\n\t\t\t\tticking = false;\r\n\t\t\t\tfn.apply(thisArg, args);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction
    createDiv(cls) {\r\n\tvar el = document.createElement('div');\r\n\tel.className
    = cls || '';\r\n\treturn el;\r\n}\r\n\r\n// Implementation based on https://github.com/marcj/css-element-queries\r\nfunction
    createResizer(handler) {\r\n\tvar maxSize = 1000000;\r\n\r\n\t// NOTE(SB) Don't
    use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar
    resizer = createDiv(CSS_SIZE_MONITOR);\r\n\tvar expand = createDiv(CSS_SIZE_MONITOR
    + '-expand');\r\n\tvar shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\r\n\r\n\texpand.appendChild(createDiv());\r\n\tshrink.appendChild(createDiv());\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset
    = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft
    = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll =
    function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddListener(expand,
    'scroll', onScroll.bind(expand, 'expand'));\r\n\taddListener(shrink, 'scroll',
    onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r\n\r\n// https://davidwalsh.name/detect-node-insertion\r\nfunction
    watchForRender(node, handler) {\r\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY]
    = {});\r\n\tvar proxy = expando.renderProxy = function(e) {\r\n\t\tif (e.animationName
    === CSS_RENDER_ANIMATION) {\r\n\t\t\thandler();\r\n\t\t}\r\n\t};\r\n\r\n\thelpers$1.each(ANIMATION_START_EVENTS,
    function(type) {\r\n\t\taddListener(node, type, proxy);\r\n\t});\r\n\r\n\t// #4737:
    Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\r\n\t//
    is removed then added back immediately (same animation frame?). Accessing the\r\n\t//
    `offsetParent` property will force a reflow and re-evaluate the CSS animation.\r\n\t//
    https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\r\n\t// https://github.com/chartjs/Chart.js/issues/4737\r\n\texpando.reflow
    = !!node.offsetParent;\r\n\r\n\tnode.classList.add(CSS_RENDER_MONITOR);\r\n}\r\n\r\nfunction
    unwatchForRender(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar
    proxy = expando.renderProxy;\r\n\r\n\tif (proxy) {\r\n\t\thelpers$1.each(ANIMATION_START_EVENTS,
    function(type) {\r\n\t\t\tremoveListener(node, type, proxy);\r\n\t\t});\r\n\r\n\t\tdelete
    expando.renderProxy;\r\n\t}\r\n\r\n\tnode.classList.remove(CSS_RENDER_MONITOR);\r\n}\r\n\r\nfunction
    addResizeListener(node, listener, chart) {\r\n\tvar expando = node[EXPANDO_KEY]
    || (node[EXPANDO_KEY] = {});\r\n\r\n\t// Let's keep track of this added resizer
    and thus avoid DOM query when removing it.\r\n\tvar resizer = expando.resizer
    = createResizer(throttled(function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\tvar
    container = chart.options.maintainAspectRatio && node.parentNode;\r\n\t\t\tvar
    w = container ? container.clientWidth : 0;\r\n\t\t\tlistener(createEvent('resize',
    chart));\r\n\t\t\tif (container && container.clientWidth < w && chart.canvas)
    {\r\n\t\t\t\t// If the container size shrank during chart resize, let's assume\r\n\t\t\t\t//
    scrollbar appeared. So we resize again with the scrollbar visible -\r\n\t\t\t\t//
    effectively making chart smaller and the scrollbar hidden again.\r\n\t\t\t\t//
    Because we are inside `throttled`, and currently `ticking`, scroll\r\n\t\t\t\t//
    events are ignored during this whole 2 resize process.\r\n\t\t\t\t// If we assumed
    wrong and something else happened, we are resizing\r\n\t\t\t\t// twice in a frame
    (potential performance issue)\r\n\t\t\t\tlistener(createEvent('resize', chart));\r\n\t\t\t}\r\n\t\t}\r\n\t}));\r\n\r\n\t//
    The resizer needs to be attached to the node parent, so we first need to be\r\n\t//
    sure that `node` is attached to the DOM before injecting the resizer element.\r\n\twatchForRender(node,
    function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\tvar container = node.parentNode;\r\n\t\t\tif
    (container && container !== resizer.parentNode) {\r\n\t\t\t\tcontainer.insertBefore(resizer,
    container.firstChild);\r\n\t\t\t}\r\n\r\n\t\t\t// The container size might have
    changed, let's reset the resizer state.\r\n\t\t\tresizer._reset();\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction
    removeResizeListener(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar
    resizer = expando.resizer;\r\n\r\n\tdelete expando.resizer;\r\n\tunwatchForRender(node);\r\n\r\n\tif
    (resizer && resizer.parentNode) {\r\n\t\tresizer.parentNode.removeChild(resizer);\r\n\t}\r\n}\r\n\r\n/**\r\n
    * Injects CSS styles inline if the styles are not already present.\r\n * @param
    {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.\r\n * @param
    {string} css - the CSS to be injected.\r\n */\r\nfunction injectCSS(rootNode,
    css) {\r\n\t// https://stackoverflow.com/q/3922139\r\n\tvar expando = rootNode[EXPANDO_KEY]
    || (rootNode[EXPANDO_KEY] = {});\r\n\tif (!expando.containsStyles) {\r\n\t\texpando.containsStyles
    = true;\r\n\t\tcss = '/* Chart.js */\\n' + css;\r\n\t\tvar style = document.createElement('style');\r\n\t\tstyle.setAttribute('type',
    'text/css');\r\n\t\tstyle.appendChild(document.createTextNode(css));\r\n\t\trootNode.appendChild(style);\r\n\t}\r\n}\r\n\r\nvar
    platform_dom$2 = {\r\n\t/**\r\n\t * When `true`, prevents the automatic injection
    of the stylesheet required to\r\n\t * correctly detect when the chart is added
    to the DOM and then resized. This\r\n\t * switch has been added to allow external
    stylesheet (`dist/Chart(.min)?.js`)\r\n\t * to be manually imported to make this
    library compatible with any CSP.\r\n\t * See https://github.com/chartjs/Chart.js/issues/5208\r\n\t
    */\r\n\tdisableCSSInjection: false,\r\n\r\n\t/**\r\n\t * This property holds whether
    this platform is enabled for the current environment.\r\n\t * Currently used by
    platform.js to select the proper implementation.\r\n\t * @private\r\n\t */\r\n\t_enabled:
    typeof window !== 'undefined' && typeof document !== 'undefined',\r\n\r\n\t/**\r\n\t
    * Initializes resources that depend on platform options.\r\n\t * @param {HTMLCanvasElement}
    canvas - The Canvas element.\r\n\t * @private\r\n\t */\r\n\t_ensureLoaded: function(canvas)
    {\r\n\t\tif (!this.disableCSSInjection) {\r\n\t\t\t// If the canvas is in a shadow
    DOM, then the styles must also be inserted\r\n\t\t\t// into the same shadow DOM.\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/5763\r\n\t\t\tvar root = canvas.getRootNode
    ? canvas.getRootNode() : document;\r\n\t\t\tvar targetNode = root.host ? root
    : document.head;\r\n\t\t\tinjectCSS(targetNode, stylesheet);\r\n\t\t}\r\n\t},\r\n\r\n\tacquireContext:
    function(item, config) {\r\n\t\tif (typeof item === 'string') {\r\n\t\t\titem
    = document.getElementById(item);\r\n\t\t} else if (item.length) {\r\n\t\t\t//
    Support for array based queries (such as jQuery)\r\n\t\t\titem = item[0];\r\n\t\t}\r\n\r\n\t\tif
    (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas
    (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\t// To
    prevent canvas fingerprinting, some add-ons undefine the getContext\r\n\t\t//
    method, for example: https://github.com/kkapsner/CanvasBlocker\r\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\r\n\t\tvar
    context = item && item.getContext && item.getContext('2d');\r\n\r\n\t\t// `instanceof
    HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\r\n\t\t// inside
    an iframe or when running in a protected environment. We could guess the\r\n\t\t//
    types from their toString() value but let's keep things flexible and assume it's\r\n\t\t//
    a sufficient condition if the item has a context2D which has item as `canvas`.\r\n\t\t//
    https://github.com/chartjs/Chart.js/issues/3887\r\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\r\n\t\t//
    https://github.com/chartjs/Chart.js/issues/4152\r\n\t\tif (context && context.canvas
    === item) {\r\n\t\t\t// Load platform resources on first chart creation, to make
    it possible to\r\n\t\t\t// import the library before setting platform options.\r\n\t\t\tthis._ensureLoaded(item);\r\n\t\t\tinitCanvas(item,
    config);\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\treleaseContext:
    function(context) {\r\n\t\tvar canvas = context.canvas;\r\n\t\tif (!canvas[EXPANDO_KEY])
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\r\n\t\t['height',
    'width'].forEach(function(prop) {\r\n\t\t\tvar value = initial[prop];\r\n\t\t\tif
    (helpers$1.isNullOrUndef(value)) {\r\n\t\t\t\tcanvas.removeAttribute(prop);\r\n\t\t\t}
    else {\r\n\t\t\t\tcanvas.setAttribute(prop, value);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.each(initial.style
    || {}, function(value, key) {\r\n\t\t\tcanvas.style[key] = value;\r\n\t\t});\r\n\r\n\t\t//
    The canvas render size might have been changed (and thus the state stack discarded),\r\n\t\t//
    we can't use save() and restore() to restore the initial state. So make sure that
    at\r\n\t\t// least the canvas context is reset to the default state by setting
    the canvas width.\r\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\r\n\t\t//
    eslint-disable-next-line no-self-assign\r\n\t\tcanvas.width = canvas.width;\r\n\r\n\t\tdelete
    canvas[EXPANDO_KEY];\r\n\t},\r\n\r\n\taddEventListener: function(chart, type,
    listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif (type === 'resize') {\r\n\t\t\t//
    Note: the resize event is not supported on all browsers.\r\n\t\t\taddResizeListener(canvas,
    listener, chart);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar expando = listener[EXPANDO_KEY]
    || (listener[EXPANDO_KEY] = {});\r\n\t\tvar proxies = expando.proxies || (expando.proxies
    = {});\r\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\r\n\t\t\tlistener(fromNativeEvent(event,
    chart));\r\n\t\t};\r\n\r\n\t\taddListener(canvas, type, proxy);\r\n\t},\r\n\r\n\tremoveEventListener:
    function(chart, type, listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif
    (type === 'resize') {\r\n\t\t\t// Note: the resize event is not supported on all
    browsers.\r\n\t\t\tremoveResizeListener(canvas);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar
    expando = listener[EXPANDO_KEY] || {};\r\n\t\tvar proxies = expando.proxies ||
    {};\r\n\t\tvar proxy = proxies[chart.id + '_' + type];\r\n\t\tif (!proxy) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tremoveListener(canvas,
    type, proxy);\r\n\t}\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for
    backward compatibility, use EventTarget.addEventListener instead.\r\n * EventTarget.addEventListener
    compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\r\n
    * @function Chart.helpers.addEvent\r\n * @deprecated since version 2.7.0\r\n *
    @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.addEvent = addListener;\r\n\r\n/**\r\n
    * Provided for backward compatibility, use EventTarget.removeEventListener instead.\r\n
    * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+,
    IE9+\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\r\n
    * @function Chart.helpers.removeEvent\r\n * @deprecated since version 2.7.0\r\n
    * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers$1.removeEvent = removeListener;\n\n//
    @TODO Make possible to select another platform at build time.\r\nvar implementation
    = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\r\n\r\n/**\r\n *
    @namespace Chart.platform\r\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\r\n
    * @since 2.4.0\r\n */\r\nvar platform = helpers$1.extend({\r\n\t/**\r\n\t * @since
    2.7.0\r\n\t */\r\n\tinitialize: function() {},\r\n\r\n\t/**\r\n\t * Called at
    chart construction time, returns a context2d instance implementing\r\n\t * the
    [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\r\n\t
    * @param {*} item - The native item from which to acquire context (platform specific)\r\n\t
    * @param {object} options - The chart options\r\n\t * @returns {CanvasRenderingContext2D}
    context2d instance\r\n\t */\r\n\tacquireContext: function() {},\r\n\r\n\t/**\r\n\t
    * Called at chart destruction time, releases any resources associated to the context\r\n\t
    * previously returned by the acquireContext() method.\r\n\t * @param {CanvasRenderingContext2D}
    context - The context2d instance\r\n\t * @returns {boolean} true if the method
    succeeded, else false\r\n\t */\r\n\treleaseContext: function() {},\r\n\r\n\t/**\r\n\t
    * Registers the specified listener on the given chart.\r\n\t * @param {Chart}
    chart - Chart from which to listen for event\r\n\t * @param {string} type - The
    ({@link IEvent}) type to listen for\r\n\t * @param {function} listener - Receives
    a notification (an object that implements\r\n\t * the {@link IEvent} interface)
    when an event of the specified type occurs.\r\n\t */\r\n\taddEventListener: function()
    {},\r\n\r\n\t/**\r\n\t * Removes the specified listener previously registered
    with addEventListener.\r\n\t * @param {Chart} chart - Chart from which to remove
    the listener\r\n\t * @param {string} type - The ({@link IEvent}) type to remove\r\n\t
    * @param {function} listener - The listener function to remove from the event
    target.\r\n\t */\r\n\tremoveEventListener: function() {}\r\n\r\n}, implementation);\n\ncore_defaults._set('global',
    {\r\n\tplugins: {}\r\n});\r\n\r\n/**\r\n * The plugin service singleton\r\n *
    @namespace Chart.plugins\r\n * @since 2.1.0\r\n */\r\nvar core_plugins = {\r\n\t/**\r\n\t
    * Globally registered plugins.\r\n\t * @private\r\n\t */\r\n\t_plugins: [],\r\n\r\n\t/**\r\n\t
    * This identifier is used to invalidate the descriptors cache attached to each
    chart\r\n\t * when a global plugin is registered or unregistered. In this case,
    the cache ID is\r\n\t * incremented and descriptors are regenerated during following
    API calls.\r\n\t * @private\r\n\t */\r\n\t_cacheId: 0,\r\n\r\n\t/**\r\n\t * Registers
    the given plugin(s) if not already registered.\r\n\t * @param {IPlugin[]|IPlugin}
    plugins plugin instance(s).\r\n\t */\r\n\tregister: function(plugins) {\r\n\t\tvar
    p = this._plugins;\r\n\t\t([]).concat(plugins).forEach(function(plugin) {\r\n\t\t\tif
    (p.indexOf(plugin) === -1) {\r\n\t\t\t\tp.push(plugin);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Unregisters the given plugin(s) only if registered.\r\n\t * @param {IPlugin[]|IPlugin}
    plugins plugin instance(s).\r\n\t */\r\n\tunregister: function(plugins) {\r\n\t\tvar
    p = this._plugins;\r\n\t\t([]).concat(plugins).forEach(function(plugin) {\r\n\t\t\tvar
    idx = p.indexOf(plugin);\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\tp.splice(idx, 1);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Remove all registered plugins.\r\n\t * @since 2.1.5\r\n\t */\r\n\tclear: function()
    {\r\n\t\tthis._plugins = [];\r\n\t\tthis._cacheId++;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the number of registered plugins?\r\n\t * @returns {number}\r\n\t *
    @since 2.1.5\r\n\t */\r\n\tcount: function() {\r\n\t\treturn this._plugins.length;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns all registered plugin instances.\r\n\t * @returns {IPlugin[]} array
    of plugin objects.\r\n\t * @since 2.1.5\r\n\t */\r\n\tgetAll: function() {\r\n\t\treturn
    this._plugins;\r\n\t},\r\n\r\n\t/**\r\n\t * Calls enabled plugins for `chart`
    on the specified hook and with the given args.\r\n\t * This method immediately
    returns as soon as a plugin explicitly returns false. The\r\n\t * returned value
    can be used, for instance, to interrupt the current action.\r\n\t * @param {Chart}
    chart - The chart instance for which plugins should be called.\r\n\t * @param
    {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t
    * @param {Array} [args] - Extra arguments to apply to the hook call.\r\n\t * @returns
    {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n\tnotify:
    function(chart, hook, args) {\r\n\t\tvar descriptors = this.descriptors(chart);\r\n\t\tvar
    ilen = descriptors.length;\r\n\t\tvar i, descriptor, plugin, params, method;\r\n\r\n\t\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\t\tdescriptor = descriptors[i];\r\n\t\t\tplugin
    = descriptor.plugin;\r\n\t\t\tmethod = plugin[hook];\r\n\t\t\tif (typeof method
    === 'function') {\r\n\t\t\t\tparams = [chart].concat(args || []);\r\n\t\t\t\tparams.push(descriptor.options);\r\n\t\t\t\tif
    (method.apply(plugin, params) === false) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    true;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns descriptors of enabled plugins for
    the given chart.\r\n\t * @returns {object[]} [{ plugin, options }]\r\n\t * @private\r\n\t
    */\r\n\tdescriptors: function(chart) {\r\n\t\tvar cache = chart.$plugins || (chart.$plugins
    = {});\r\n\t\tif (cache.id === this._cacheId) {\r\n\t\t\treturn cache.descriptors;\r\n\t\t}\r\n\r\n\t\tvar
    plugins = [];\r\n\t\tvar descriptors = [];\r\n\t\tvar config = (chart && chart.config)
    || {};\r\n\t\tvar options = (config.options && config.options.plugins) || {};\r\n\r\n\t\tthis._plugins.concat(config.plugins
    || []).forEach(function(plugin) {\r\n\t\t\tvar idx = plugins.indexOf(plugin);\r\n\t\t\tif
    (idx !== -1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar id = plugin.id;\r\n\t\t\tvar
    opts = options[id];\r\n\t\t\tif (opts === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (opts === true) {\r\n\t\t\t\topts = helpers$1.clone(core_defaults.global.plugins[id]);\r\n\t\t\t}\r\n\r\n\t\t\tplugins.push(plugin);\r\n\t\t\tdescriptors.push({\r\n\t\t\t\tplugin:
    plugin,\r\n\t\t\t\toptions: opts || {}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tcache.descriptors
    = descriptors;\r\n\t\tcache.id = this._cacheId;\r\n\t\treturn descriptors;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Invalidates cache for the given chart: descriptors hold a reference on plugin
    option,\r\n\t * but in some cases, this reference can be changed by the user when
    updating options.\r\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t
    * @private\r\n\t */\r\n\t_invalidate: function(chart) {\r\n\t\tdelete chart.$plugins;\r\n\t}\r\n};\n\nvar
    core_scaleService = {\r\n\t// Scale registration object. Extensions can register
    new scale types (such as log or DB scales) and then\r\n\t// use the new chart
    options to grab the correct scale\r\n\tconstructors: {},\r\n\t// Use a registration
    function so that we can move to an ES6 map when we no longer need to support\r\n\t//
    old browsers\r\n\r\n\t// Scale config defaults\r\n\tdefaults: {},\r\n\tregisterScaleType:
    function(type, scaleConstructor, scaleDefaults) {\r\n\t\tthis.constructors[type]
    = scaleConstructor;\r\n\t\tthis.defaults[type] = helpers$1.clone(scaleDefaults);\r\n\t},\r\n\tgetScaleConstructor:
    function(type) {\r\n\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type]
    : undefined;\r\n\t},\r\n\tgetScaleDefaults: function(type) {\r\n\t\t// Return
    the scale defaults merged with the global settings so that we always use the latest
    ones\r\n\t\treturn this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null),
    [core_defaults.scale, this.defaults[type]]) : {};\r\n\t},\r\n\tupdateScaleDefaults:
    function(type, additions) {\r\n\t\tvar me = this;\r\n\t\tif (me.defaults.hasOwnProperty(type))
    {\r\n\t\t\tme.defaults[type] = helpers$1.extend(me.defaults[type], additions);\r\n\t\t}\r\n\t},\r\n\taddScalesToLayout:
    function(chart) {\r\n\t\t// Adds each scale to the chart.boxes array to be sized
    accordingly\r\n\t\thelpers$1.each(chart.scales, function(scale) {\r\n\t\t\t//
    Set ILayoutItem parameters for backwards compatibility\r\n\t\t\tscale.fullWidth
    = scale.options.fullWidth;\r\n\t\t\tscale.position = scale.options.position;\r\n\t\t\tscale.weight
    = scale.options.weight;\r\n\t\t\tcore_layouts.addBox(chart, scale);\r\n\t\t});\r\n\t}\r\n};\n\nvar
    valueOrDefault$8 = helpers$1.valueOrDefault;\r\nvar getRtlHelper = helpers$1.rtl.getRtlAdapter;\r\n\r\ncore_defaults._set('global',
    {\r\n\ttooltips: {\r\n\t\tenabled: true,\r\n\t\tcustom: null,\r\n\t\tmode: 'nearest',\r\n\t\tposition:
    'average',\r\n\t\tintersect: true,\r\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\r\n\t\ttitleFontStyle:
    'bold',\r\n\t\ttitleSpacing: 2,\r\n\t\ttitleMarginBottom: 6,\r\n\t\ttitleFontColor:
    '#fff',\r\n\t\ttitleAlign: 'left',\r\n\t\tbodySpacing: 2,\r\n\t\tbodyFontColor:
    '#fff',\r\n\t\tbodyAlign: 'left',\r\n\t\tfooterFontStyle: 'bold',\r\n\t\tfooterSpacing:
    2,\r\n\t\tfooterMarginTop: 6,\r\n\t\tfooterFontColor: '#fff',\r\n\t\tfooterAlign:
    'left',\r\n\t\tyPadding: 6,\r\n\t\txPadding: 6,\r\n\t\tcaretPadding: 2,\r\n\t\tcaretSize:
    5,\r\n\t\tcornerRadius: 6,\r\n\t\tmultiKeyBackground: '#fff',\r\n\t\tdisplayColors:
    true,\r\n\t\tborderColor: 'rgba(0,0,0,0)',\r\n\t\tborderWidth: 0,\r\n\t\tcallbacks:
    {\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeTitle: helpers$1.noop,\r\n\t\t\ttitle:
    function(tooltipItems, data) {\r\n\t\t\t\tvar title = '';\r\n\t\t\t\tvar labels
    = data.labels;\r\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\r\n\r\n\t\t\t\tif
    (tooltipItems.length > 0) {\r\n\t\t\t\t\tvar item = tooltipItems[0];\r\n\t\t\t\t\tif
    (item.label) {\r\n\t\t\t\t\t\ttitle = item.label;\r\n\t\t\t\t\t} else if (item.xLabel)
    {\r\n\t\t\t\t\t\ttitle = item.xLabel;\r\n\t\t\t\t\t} else if (labelCount > 0 &&
    item.index < labelCount) {\r\n\t\t\t\t\t\ttitle = labels[item.index];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn
    title;\r\n\t\t\t},\r\n\t\t\tafterTitle: helpers$1.noop,\r\n\r\n\t\t\t// Args are:
    (tooltipItems, data)\r\n\t\t\tbeforeBody: helpers$1.noop,\r\n\r\n\t\t\t// Args
    are: (tooltipItem, data)\r\n\t\t\tbeforeLabel: helpers$1.noop,\r\n\t\t\tlabel:
    function(tooltipItem, data) {\r\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label
    || '';\r\n\r\n\t\t\t\tif (label) {\r\n\t\t\t\t\tlabel += ': ';\r\n\t\t\t\t}\r\n\t\t\t\tif
    (!helpers$1.isNullOrUndef(tooltipItem.value)) {\r\n\t\t\t\t\tlabel += tooltipItem.value;\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\tlabel += tooltipItem.yLabel;\r\n\t\t\t\t}\r\n\t\t\t\treturn
    label;\r\n\t\t\t},\r\n\t\t\tlabelColor: function(tooltipItem, chart) {\r\n\t\t\t\tvar
    meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n\t\t\t\tvar activeElement
    = meta.data[tooltipItem.index];\r\n\t\t\t\tvar view = activeElement._view;\r\n\t\t\t\treturn
    {\r\n\t\t\t\t\tborderColor: view.borderColor,\r\n\t\t\t\t\tbackgroundColor: view.backgroundColor\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\tlabelTextColor:
    function() {\r\n\t\t\t\treturn this._options.bodyFontColor;\r\n\t\t\t},\r\n\t\t\tafterLabel:
    helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tafterBody:
    helpers$1.noop,\r\n\r\n\t\t\t// Args are: (tooltipItems, data)\r\n\t\t\tbeforeFooter:
    helpers$1.noop,\r\n\t\t\tfooter: helpers$1.noop,\r\n\t\t\tafterFooter: helpers$1.noop\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    positioners = {\r\n\t/**\r\n\t * Average mode places the tooltip at the average
    position of the elements shown\r\n\t * @function Chart.Tooltip.positioners.average\r\n\t
    * @param elements {ChartElement[]} the elements being displayed in the tooltip\r\n\t
    * @returns {object} tooltip position\r\n\t */\r\n\taverage: function(elements)
    {\r\n\t\tif (!elements.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar
    i, len;\r\n\t\tvar x = 0;\r\n\t\tvar y = 0;\r\n\t\tvar count = 0;\r\n\r\n\t\tfor
    (i = 0, len = elements.length; i < len; ++i) {\r\n\t\t\tvar el = elements[i];\r\n\t\t\tif
    (el && el.hasValue()) {\r\n\t\t\t\tvar pos = el.tooltipPosition();\r\n\t\t\t\tx
    += pos.x;\r\n\t\t\t\ty += pos.y;\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tx: x / count,\r\n\t\t\ty: y / count\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t
    * Gets the tooltip position nearest of the item nearest to the event position\r\n\t
    * @function Chart.Tooltip.positioners.nearest\r\n\t * @param elements {Chart.Element[]}
    the tooltip elements\r\n\t * @param eventPosition {object} the position of the
    event in canvas coordinates\r\n\t * @returns {object} the tooltip position\r\n\t
    */\r\n\tnearest: function(elements, eventPosition) {\r\n\t\tvar x = eventPosition.x;\r\n\t\tvar
    y = eventPosition.y;\r\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\r\n\t\tvar
    i, len, nearestElement;\r\n\r\n\t\tfor (i = 0, len = elements.length; i < len;
    ++i) {\r\n\t\t\tvar el = elements[i];\r\n\t\t\tif (el && el.hasValue()) {\r\n\t\t\t\tvar
    center = el.getCenterPoint();\r\n\t\t\t\tvar d = helpers$1.distanceBetweenPoints(eventPosition,
    center);\r\n\r\n\t\t\t\tif (d < minDistance) {\r\n\t\t\t\t\tminDistance = d;\r\n\t\t\t\t\tnearestElement
    = el;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (nearestElement) {\r\n\t\t\tvar
    tp = nearestElement.tooltipPosition();\r\n\t\t\tx = tp.x;\r\n\t\t\ty = tp.y;\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tx: x,\r\n\t\t\ty: y\r\n\t\t};\r\n\t}\r\n};\r\n\r\n// Helper to push
    or concat based on if the 2nd parameter is an array or not\r\nfunction pushOrConcat(base,
    toPush) {\r\n\tif (toPush) {\r\n\t\tif (helpers$1.isArray(toPush)) {\r\n\t\t\t//
    base = base.concat(toPush);\r\n\t\t\tArray.prototype.push.apply(base, toPush);\r\n\t\t}
    else {\r\n\t\t\tbase.push(toPush);\r\n\t\t}\r\n\t}\r\n\r\n\treturn base;\r\n}\r\n\r\n/**\r\n
    * Returns array of strings split by newline\r\n * @param {string} value - The
    value to split by newline.\r\n * @returns {string[]} value if newline present
    - Returned from String split() method\r\n * @function\r\n */\r\nfunction splitNewlines(str)
    {\r\n\tif ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n')
    > -1) {\r\n\t\treturn str.split('\\n');\r\n\t}\r\n\treturn str;\r\n}\r\n\r\n\r\n/**\r\n
    * Private helper to create a tooltip item model\r\n * @param element - the chart
    element (point, arc, bar) to create the tooltip item for\r\n * @return new tooltip
    item\r\n */\r\nfunction createTooltipItem(element) {\r\n\tvar xScale = element._xScale;\r\n\tvar
    yScale = element._yScale || element._scale; // handle radar || polarArea charts\r\n\tvar
    index = element._index;\r\n\tvar datasetIndex = element._datasetIndex;\r\n\tvar
    controller = element._chart.getDatasetMeta(datasetIndex).controller;\r\n\tvar
    indexScale = controller._getIndexScale();\r\n\tvar valueScale = controller._getValueScale();\r\n\r\n\treturn
    {\r\n\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tyLabel:
    yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tlabel: indexScale
    ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tvalue: valueScale
    ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\r\n\t\tindex: index,\r\n\t\tdatasetIndex:
    datasetIndex,\r\n\t\tx: element._model.x,\r\n\t\ty: element._model.y\r\n\t};\r\n}\r\n\r\n/**\r\n
    * Helper to get the reset model for the tooltip\r\n * @param tooltipOpts {object}
    the tooltip options\r\n */\r\nfunction getBaseModel(tooltipOpts) {\r\n\tvar globalDefaults
    = core_defaults.global;\r\n\r\n\treturn {\r\n\t\t// Positioning\r\n\t\txPadding:
    tooltipOpts.xPadding,\r\n\t\tyPadding: tooltipOpts.yPadding,\r\n\t\txAlign: tooltipOpts.xAlign,\r\n\t\tyAlign:
    tooltipOpts.yAlign,\r\n\r\n\t\t// Drawing direction and text direction\r\n\t\trtl:
    tooltipOpts.rtl,\r\n\t\ttextDirection: tooltipOpts.textDirection,\r\n\r\n\t\t//
    Body\r\n\t\tbodyFontColor: tooltipOpts.bodyFontColor,\r\n\t\t_bodyFontFamily:
    valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_bodyFontStyle:
    valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\r\n\t\t_bodyAlign:
    tooltipOpts.bodyAlign,\r\n\t\tbodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize,
    globalDefaults.defaultFontSize),\r\n\t\tbodySpacing: tooltipOpts.bodySpacing,\r\n\r\n\t\t//
    Title\r\n\t\ttitleFontColor: tooltipOpts.titleFontColor,\r\n\t\t_titleFontFamily:
    valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_titleFontStyle:
    valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\r\n\t\ttitleFontSize:
    valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\r\n\t\t_titleAlign:
    tooltipOpts.titleAlign,\r\n\t\ttitleSpacing: tooltipOpts.titleSpacing,\r\n\t\ttitleMarginBottom:
    tooltipOpts.titleMarginBottom,\r\n\r\n\t\t// Footer\r\n\t\tfooterFontColor: tooltipOpts.footerFontColor,\r\n\t\t_footerFontFamily:
    valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\r\n\t\t_footerFontStyle:
    valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\r\n\t\tfooterFontSize:
    valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\r\n\t\t_footerAlign:
    tooltipOpts.footerAlign,\r\n\t\tfooterSpacing: tooltipOpts.footerSpacing,\r\n\t\tfooterMarginTop:
    tooltipOpts.footerMarginTop,\r\n\r\n\t\t// Appearance\r\n\t\tcaretSize: tooltipOpts.caretSize,\r\n\t\tcornerRadius:
    tooltipOpts.cornerRadius,\r\n\t\tbackgroundColor: tooltipOpts.backgroundColor,\r\n\t\topacity:
    0,\r\n\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\r\n\t\tdisplayColors:
    tooltipOpts.displayColors,\r\n\t\tborderColor: tooltipOpts.borderColor,\r\n\t\tborderWidth:
    tooltipOpts.borderWidth\r\n\t};\r\n}\r\n\r\n/**\r\n * Get the size of the tooltip\r\n
    */\r\nfunction getTooltipSize(tooltip, model) {\r\n\tvar ctx = tooltip._chart.ctx;\r\n\r\n\tvar
    height = model.yPadding * 2; // Tooltip Padding\r\n\tvar width = 0;\r\n\r\n\t//
    Count of all lines in the body\r\n\tvar body = model.body;\r\n\tvar combinedBodyLength
    = body.reduce(function(count, bodyItem) {\r\n\t\treturn count + bodyItem.before.length
    + bodyItem.lines.length + bodyItem.after.length;\r\n\t}, 0);\r\n\tcombinedBodyLength
    += model.beforeBody.length + model.afterBody.length;\r\n\r\n\tvar titleLineCount
    = model.title.length;\r\n\tvar footerLineCount = model.footer.length;\r\n\tvar
    titleFontSize = model.titleFontSize;\r\n\tvar bodyFontSize = model.bodyFontSize;\r\n\tvar
    footerFontSize = model.footerFontSize;\r\n\r\n\theight += titleLineCount * titleFontSize;
    // Title Lines\r\n\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing
    : 0; // Title Line Spacing\r\n\theight += titleLineCount ? model.titleMarginBottom
    : 0; // Title's bottom Margin\r\n\theight += combinedBodyLength * bodyFontSize;
    // Body Lines\r\n\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing
    : 0; // Body Line Spacing\r\n\theight += footerLineCount ? model.footerMarginTop
    : 0; // Footer Margin\r\n\theight += footerLineCount * (footerFontSize); // Footer
    Lines\r\n\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing
    : 0; // Footer Line Spacing\r\n\r\n\t// Title width\r\n\tvar widthPadding = 0;\r\n\tvar
    maxLineWidth = function(line) {\r\n\t\twidth = Math.max(width, ctx.measureText(line).width
    + widthPadding);\r\n\t};\r\n\r\n\tctx.font = helpers$1.fontString(titleFontSize,
    model._titleFontStyle, model._titleFontFamily);\r\n\thelpers$1.each(model.title,
    maxLineWidth);\r\n\r\n\t// Body width\r\n\tctx.font = helpers$1.fontString(bodyFontSize,
    model._bodyFontStyle, model._bodyFontFamily);\r\n\thelpers$1.each(model.beforeBody.concat(model.afterBody),
    maxLineWidth);\r\n\r\n\t// Body lines may include some extra width due to the
    color box\r\n\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\r\n\thelpers$1.each(body,
    function(bodyItem) {\r\n\t\thelpers$1.each(bodyItem.before, maxLineWidth);\r\n\t\thelpers$1.each(bodyItem.lines,
    maxLineWidth);\r\n\t\thelpers$1.each(bodyItem.after, maxLineWidth);\r\n\t});\r\n\r\n\t//
    Reset back to 0\r\n\twidthPadding = 0;\r\n\r\n\t// Footer width\r\n\tctx.font
    = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\r\n\thelpers$1.each(model.footer,
    maxLineWidth);\r\n\r\n\t// Add padding\r\n\twidth += 2 * model.xPadding;\r\n\r\n\treturn
    {\r\n\t\twidth: width,\r\n\t\theight: height\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper
    to get the alignment of a tooltip given the size\r\n */\r\nfunction determineAlignment(tooltip,
    size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar
    chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign
    = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t}
    else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar
    lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; //
    functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar
    yf; // function to get the y alignment if the tooltip goes outside of the left
    or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar
    midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center')
    {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x)
    {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn
    x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >=
    (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x)
    {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf
    = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding
    < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif
    (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and
    goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign
    = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x))
    {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside
    left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign
    = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn
    {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign
    ? opts.yAlign : yAlign\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper to get the location
    a tooltip needs to be placed at given the initial position (via the vm) and the
    size and alignment\r\n */\r\nfunction getBackgroundPoint(vm, size, alignment,
    chart) {\r\n\t// Background Position\r\n\tvar x = vm.x;\r\n\tvar y = vm.y;\r\n\r\n\tvar
    caretSize = vm.caretSize;\r\n\tvar caretPadding = vm.caretPadding;\r\n\tvar cornerRadius
    = vm.cornerRadius;\r\n\tvar xAlign = alignment.xAlign;\r\n\tvar yAlign = alignment.yAlign;\r\n\tvar
    paddingAndSize = caretSize + caretPadding;\r\n\tvar radiusAndPadding = cornerRadius
    + caretPadding;\r\n\r\n\tif (xAlign === 'right') {\r\n\t\tx -= size.width;\r\n\t}
    else if (xAlign === 'center') {\r\n\t\tx -= (size.width / 2);\r\n\t\tif (x + size.width
    > chart.width) {\r\n\t\t\tx = chart.width - size.width;\r\n\t\t}\r\n\t\tif (x
    < 0) {\r\n\t\t\tx = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (yAlign === 'top') {\r\n\t\ty
    += paddingAndSize;\r\n\t} else if (yAlign === 'bottom') {\r\n\t\ty -= size.height
    + paddingAndSize;\r\n\t} else {\r\n\t\ty -= (size.height / 2);\r\n\t}\r\n\r\n\tif
    (yAlign === 'center') {\r\n\t\tif (xAlign === 'left') {\r\n\t\t\tx += paddingAndSize;\r\n\t\t}
    else if (xAlign === 'right') {\r\n\t\t\tx -= paddingAndSize;\r\n\t\t}\r\n\t} else
    if (xAlign === 'left') {\r\n\t\tx -= radiusAndPadding;\r\n\t} else if (xAlign
    === 'right') {\r\n\t\tx += radiusAndPadding;\r\n\t}\r\n\r\n\treturn {\r\n\t\tx:
    x,\r\n\t\ty: y\r\n\t};\r\n}\r\n\r\nfunction getAlignedX(vm, align) {\r\n\treturn
    align === 'center'\r\n\t\t? vm.x + vm.width / 2\r\n\t\t: align === 'right'\r\n\t\t\t?
    vm.x + vm.width - vm.xPadding\r\n\t\t\t: vm.x + vm.xPadding;\r\n}\r\n\r\n/**\r\n
    * Helper to build before and after body lines\r\n */\r\nfunction getBeforeAfterBodyLines(callback)
    {\r\n\treturn pushOrConcat([], splitNewlines(callback));\r\n}\r\n\r\nvar exports$4
    = core_element.extend({\r\n\tinitialize: function() {\r\n\t\tthis._model = getBaseModel(this._options);\r\n\t\tthis._lastActive
    = [];\r\n\t},\r\n\r\n\t// Get the title\r\n\t// Args are: (tooltipItem, data)\r\n\tgetTitle:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks
    = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me,
    arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar
    afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines =
    [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines
    = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines,
    splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r\n\r\n\t// Args
    are: (tooltipItem, data)\r\n\tgetBeforeBody: function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this,
    arguments));\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetBody: function(tooltipItems,
    data) {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\t\tvar
    bodyItems = [];\r\n\r\n\t\thelpers$1.each(tooltipItems, function(tooltipItem)
    {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter:
    []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me,
    tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me,
    tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me,
    tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r\n\r\n\t\treturn
    bodyItems;\r\n\t},\r\n\r\n\t// Args are: (tooltipItem, data)\r\n\tgetAfterBody:
    function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this,
    arguments));\r\n\t},\r\n\r\n\t// Get the footer and beforeFooter and afterFooter
    lines\r\n\t// Args are: (tooltipItem, data)\r\n\tgetFooter: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter
    = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me,
    arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar
    lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines
    = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines,
    splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r\n\r\n\tupdate:
    function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t//
    Need to regenerate the model because its faster than using extend and it is necessary
    due to the optimization in Chart.Element.transition\r\n\t\t// that does _view
    = _model if ease === 1. This causes the 2nd tooltip update to set properties in
    both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar
    existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar
    active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case
    where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar
    alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar
    backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar
    tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar
    tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar
    i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar
    labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition
    = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar
    tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t//
    If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif
    (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn
    opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided
    a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort)
    {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn
    opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine
    colors for boxes\r\n\t\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me,
    tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me,
    tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title
    = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems,
    data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody
    = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems,
    data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y
    = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors
    = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t//
    data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need
    to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this,
    model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t//
    Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize,
    alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign
    = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y
    = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height
    = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points
    to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model
    = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me,
    model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tdrawCaret: function(tooltipPoint,
    size) {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar
    caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\r\n\r\n\t\tctx.lineTo(caretPosition.x1,
    caretPosition.y1);\r\n\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n\t\tctx.lineTo(caretPosition.x3,
    caretPosition.y3);\r\n\t},\r\n\tgetCaretPosition: function(tooltipPoint, size,
    vm) {\r\n\t\tvar x1, x2, x3, y1, y2, y3;\r\n\t\tvar caretSize = vm.caretSize;\r\n\t\tvar
    cornerRadius = vm.cornerRadius;\r\n\t\tvar xAlign = vm.xAlign;\r\n\t\tvar yAlign
    = vm.yAlign;\r\n\t\tvar ptX = tooltipPoint.x;\r\n\t\tvar ptY = tooltipPoint.y;\r\n\t\tvar
    width = size.width;\r\n\t\tvar height = size.height;\r\n\r\n\t\tif (yAlign ===
    'center') {\r\n\t\t\ty2 = ptY + (height / 2);\r\n\r\n\t\t\tif (xAlign === 'left')
    {\r\n\t\t\t\tx1 = ptX;\r\n\t\t\t\tx2 = x1 - caretSize;\r\n\t\t\t\tx3 = x1;\r\n\r\n\t\t\t\ty1
    = y2 + caretSize;\r\n\t\t\t\ty3 = y2 - caretSize;\r\n\t\t\t} else {\r\n\t\t\t\tx1
    = ptX + width;\r\n\t\t\t\tx2 = x1 + caretSize;\r\n\t\t\t\tx3 = x1;\r\n\r\n\t\t\t\ty1
    = y2 - caretSize;\r\n\t\t\t\ty3 = y2 + caretSize;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif
    (xAlign === 'left') {\r\n\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\r\n\t\t\t\tx1
    = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t} else if (xAlign ===
    'right') {\r\n\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\r\n\t\t\t\tx1
    = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t} else {\r\n\t\t\t\tx2
    = vm.caretX;\r\n\t\t\t\tx1 = x2 - caretSize;\r\n\t\t\t\tx3 = x2 + caretSize;\r\n\t\t\t}\r\n\t\t\tif
    (yAlign === 'top') {\r\n\t\t\t\ty1 = ptY;\r\n\t\t\t\ty2 = y1 - caretSize;\r\n\t\t\t\ty3
    = y1;\r\n\t\t\t} else {\r\n\t\t\t\ty1 = ptY + height;\r\n\t\t\t\ty2 = y1 + caretSize;\r\n\t\t\t\ty3
    = y1;\r\n\t\t\t\t// invert drawing order\r\n\t\t\t\tvar tmp = x3;\r\n\t\t\t\tx3
    = x1;\r\n\t\t\t\tx1 = tmp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {x1: x1, x2: x2,
    x3: x3, y1: y1, y2: y2, y3: y3};\r\n\t},\r\n\r\n\tdrawTitle: function(pt, vm,
    ctx) {\r\n\t\tvar title = vm.title;\r\n\t\tvar length = title.length;\r\n\t\tvar
    titleFontSize, titleSpacing, i;\r\n\r\n\t\tif (length) {\r\n\t\t\tvar rtlHelper
    = getRtlHelper(vm.rtl, vm.x, vm.width);\r\n\r\n\t\t\tpt.x = getAlignedX(vm, vm._titleAlign);\r\n\r\n\t\t\tctx.textAlign
    = rtlHelper.textAlign(vm._titleAlign);\r\n\t\t\tctx.textBaseline = 'middle';\r\n\r\n\t\t\ttitleFontSize
    = vm.titleFontSize;\r\n\t\t\ttitleSpacing = vm.titleSpacing;\r\n\r\n\t\t\tctx.fillStyle
    = vm.titleFontColor;\r\n\t\t\tctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle,
    vm._titleFontFamily);\r\n\r\n\t\t\tfor (i = 0; i < length; ++i) {\r\n\t\t\t\tctx.fillText(title[i],
    rtlHelper.x(pt.x), pt.y + titleFontSize / 2);\r\n\t\t\t\tpt.y += titleFontSize
    + titleSpacing; // Line Height and spacing\r\n\r\n\t\t\t\tif (i + 1 === length)
    {\r\n\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin,
    remove spacing\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdrawBody: function(pt,
    vm, ctx) {\r\n\t\tvar bodyFontSize = vm.bodyFontSize;\r\n\t\tvar bodySpacing =
    vm.bodySpacing;\r\n\t\tvar bodyAlign = vm._bodyAlign;\r\n\t\tvar body = vm.body;\r\n\t\tvar
    drawColorBoxes = vm.displayColors;\r\n\t\tvar xLinePadding = 0;\r\n\t\tvar colorX
    = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\r\n\r\n\t\tvar rtlHelper = getRtlHelper(vm.rtl,
    vm.x, vm.width);\r\n\r\n\t\tvar fillLineOfText = function(line) {\r\n\t\t\tctx.fillText(line,
    rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);\r\n\t\t\tpt.y += bodyFontSize
    + bodySpacing;\r\n\t\t};\r\n\r\n\t\tvar bodyItem, textColor, labelColors, lines,
    i, j, ilen, jlen;\r\n\t\tvar bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n\r\n\t\tctx.textAlign
    = bodyAlign;\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.font = helpers$1.fontString(bodyFontSize,
    vm._bodyFontStyle, vm._bodyFontFamily);\r\n\r\n\t\tpt.x = getAlignedX(vm, bodyAlignForCalculation);\r\n\r\n\t\t//
    Before body lines\r\n\t\tctx.fillStyle = vm.bodyFontColor;\r\n\t\thelpers$1.each(vm.beforeBody,
    fillLineOfText);\r\n\r\n\t\txLinePadding = drawColorBoxes && bodyAlignForCalculation
    !== 'right'\r\n\t\t\t? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize
    + 2)\r\n\t\t\t: 0;\r\n\r\n\t\t// Draw body lines now\r\n\t\tfor (i = 0, ilen =
    body.length; i < ilen; ++i) {\r\n\t\t\tbodyItem = body[i];\r\n\t\t\ttextColor
    = vm.labelTextColors[i];\r\n\t\t\tlabelColors = vm.labelColors[i];\r\n\r\n\t\t\tctx.fillStyle
    = textColor;\r\n\t\t\thelpers$1.each(bodyItem.before, fillLineOfText);\r\n\r\n\t\t\tlines
    = bodyItem.lines;\r\n\t\t\tfor (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n\t\t\t\t//
    Draw Legend-like boxes if needed\r\n\t\t\t\tif (drawColorBoxes) {\r\n\t\t\t\t\tvar
    rtlColorX = rtlHelper.x(colorX);\r\n\r\n\t\t\t\t\t// Fill a white rect so that
    colours merge nicely if the opacity is < 1\r\n\t\t\t\t\tctx.fillStyle = vm.legendColorBackground;\r\n\t\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(rtlColorX,
    bodyFontSize), pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Border\r\n\t\t\t\t\tctx.lineWidth
    = 1;\r\n\t\t\t\t\tctx.strokeStyle = labelColors.borderColor;\r\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(rtlColorX,
    bodyFontSize), pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Inner square\r\n\t\t\t\t\tctx.fillStyle
    = labelColors.backgroundColor;\r\n\t\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX,
    1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\r\n\t\t\t\t\tctx.fillStyle
    = textColor;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfillLineOfText(lines[j]);\r\n\t\t\t}\r\n\r\n\t\t\thelpers$1.each(bodyItem.after,
    fillLineOfText);\r\n\t\t}\r\n\r\n\t\t// Reset back to 0 for after body\r\n\t\txLinePadding
    = 0;\r\n\r\n\t\t// After body lines\r\n\t\thelpers$1.each(vm.afterBody, fillLineOfText);\r\n\t\tpt.y
    -= bodySpacing; // Remove last body spacing\r\n\t},\r\n\r\n\tdrawFooter: function(pt,
    vm, ctx) {\r\n\t\tvar footer = vm.footer;\r\n\t\tvar length = footer.length;\r\n\t\tvar
    footerFontSize, i;\r\n\r\n\t\tif (length) {\r\n\t\t\tvar rtlHelper = getRtlHelper(vm.rtl,
    vm.x, vm.width);\r\n\r\n\t\t\tpt.x = getAlignedX(vm, vm._footerAlign);\r\n\t\t\tpt.y
    += vm.footerMarginTop;\r\n\r\n\t\t\tctx.textAlign = rtlHelper.textAlign(vm._footerAlign);\r\n\t\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\t\tfooterFontSize = vm.footerFontSize;\r\n\r\n\t\t\tctx.fillStyle
    = vm.footerFontColor;\r\n\t\t\tctx.font = helpers$1.fontString(footerFontSize,
    vm._footerFontStyle, vm._footerFontFamily);\r\n\r\n\t\t\tfor (i = 0; i < length;
    ++i) {\r\n\t\t\t\tctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize
    / 2);\r\n\t\t\t\tpt.y += footerFontSize + vm.footerSpacing;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdrawBackground:
    function(pt, vm, ctx, tooltipSize) {\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle
    = vm.borderColor;\r\n\t\tctx.lineWidth = vm.borderWidth;\r\n\t\tvar xAlign = vm.xAlign;\r\n\t\tvar
    yAlign = vm.yAlign;\r\n\t\tvar x = pt.x;\r\n\t\tvar y = pt.y;\r\n\t\tvar width
    = tooltipSize.width;\r\n\t\tvar height = tooltipSize.height;\r\n\t\tvar radius
    = vm.cornerRadius;\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(x + radius, y);\r\n\t\tif
    (yAlign === 'top') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x
    + width - radius, y);\r\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y +
    radius);\r\n\t\tif (yAlign === 'center' && xAlign === 'right') {\r\n\t\t\tthis.drawCaret(pt,
    tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + width, y + height - radius);\r\n\t\tctx.quadraticCurveTo(x
    + width, y + height, x + width - radius, y + height);\r\n\t\tif (yAlign === 'bottom')
    {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x + radius,
    y + height);\r\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n\t\tif
    (yAlign === 'center' && xAlign === 'left') {\r\n\t\t\tthis.drawCaret(pt, tooltipSize);\r\n\t\t}\r\n\t\tctx.lineTo(x,
    y + radius);\r\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\r\n\t\tctx.closePath();\r\n\r\n\t\tctx.fill();\r\n\r\n\t\tif
    (vm.borderWidth > 0) {\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\tdraw:
    function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\r\n\t\tif
    (vm.opacity === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth:
    vm.width,\r\n\t\t\theight: vm.height\r\n\t\t};\r\n\t\tvar pt = {\r\n\t\t\tx: vm.x,\r\n\t\t\ty:
    vm.y\r\n\t\t};\r\n\r\n\t\t// IE11/Edge does not like very small opacities, so
    snap to 0\r\n\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\r\n\r\n\t\t//
    Truthy/falsey value for empty tooltip\r\n\t\tvar hasTooltipContent = vm.title.length
    || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\r\n\r\n\t\tif
    (this._options.enabled && hasTooltipContent) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.globalAlpha
    = opacity;\r\n\r\n\t\t\t// Draw Background\r\n\t\t\tthis.drawBackground(pt, vm,
    ctx, tooltipSize);\r\n\r\n\t\t\t// Draw Title, Body, and Footer\r\n\t\t\tpt.y
    += vm.yPadding;\r\n\r\n\t\t\thelpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);\r\n\r\n\t\t\t//
    Titles\r\n\t\t\tthis.drawTitle(pt, vm, ctx);\r\n\r\n\t\t\t// Body\r\n\t\t\tthis.drawBody(pt,
    vm, ctx);\r\n\r\n\t\t\t// Footer\r\n\t\t\tthis.drawFooter(pt, vm, ctx);\r\n\r\n\t\t\thelpers$1.rtl.restoreTextDirection(ctx,
    vm.textDirection);\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event - The event to
    handle\r\n\t * @returns {boolean} true if the tooltip changed\r\n\t */\r\n\thandleEvent:
    function(e) {\r\n\t\tvar me = this;\r\n\t\tvar options = me._options;\r\n\t\tvar
    changed = false;\r\n\r\n\t\tme._lastActive = me._lastActive || [];\r\n\r\n\t\t//
    Find Active Elements for tooltips\r\n\t\tif (e.type === 'mouseout') {\r\n\t\t\tme._active
    = [];\r\n\t\t} else {\r\n\t\t\tme._active = me._chart.getElementsAtEventForMode(e,
    options.mode, options);\r\n\t\t\tif (options.reverse) {\r\n\t\t\t\tme._active.reverse();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//
    Remember Last Actives\r\n\t\tchanged = !helpers$1.arrayEquals(me._active, me._lastActive);\r\n\r\n\t\t//
    Only handle target event on tooltip change\r\n\t\tif (changed) {\r\n\t\t\tme._lastActive
    = me._active;\r\n\r\n\t\t\tif (options.enabled || options.custom) {\r\n\t\t\t\tme._eventPosition
    = {\r\n\t\t\t\t\tx: e.x,\r\n\t\t\t\t\ty: e.y\r\n\t\t\t\t};\r\n\r\n\t\t\t\tme.update(true);\r\n\t\t\t\tme.pivot();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    changed;\r\n\t}\r\n});\r\n\r\n/**\r\n * @namespace Chart.Tooltip.positioners\r\n
    */\r\nvar positioners_1 = positioners;\r\n\r\nvar core_tooltip = exports$4;\ncore_tooltip.positioners
    = positioners_1;\n\nvar valueOrDefault$9 = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('global',
    {\r\n\telements: {},\r\n\tevents: [\r\n\t\t'mousemove',\r\n\t\t'mouseout',\r\n\t\t'click',\r\n\t\t'touchstart',\r\n\t\t'touchmove'\r\n\t],\r\n\thover:
    {\r\n\t\tonHover: null,\r\n\t\tmode: 'nearest',\r\n\t\tintersect: true,\r\n\t\tanimationDuration:
    400\r\n\t},\r\n\tonClick: null,\r\n\tmaintainAspectRatio: true,\r\n\tresponsive:
    true,\r\n\tresponsiveAnimationDuration: 0\r\n});\r\n\r\n/**\r\n * Recursively
    merge the given config objects representing the `scales` option\r\n * by incorporating
    scale defaults in `xAxes` and `yAxes` array items, then\r\n * returns a deep copy
    of the result, thus doesn't alter inputs.\r\n */\r\nfunction mergeScaleConfig(/*
    config objects ... */) {\r\n\treturn helpers$1.merge(Object.create(null), [].slice.call(arguments),
    {\r\n\t\tmerger: function(key, target, source, options) {\r\n\t\t\tif (key ===
    'xAxes' || key === 'yAxes') {\r\n\t\t\t\tvar slen = source[key].length;\r\n\t\t\t\tvar
    i, type, scale;\r\n\r\n\t\t\t\tif (!target[key]) {\r\n\t\t\t\t\ttarget[key] =
    [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (i = 0; i < slen; ++i) {\r\n\t\t\t\t\tscale
    = source[key][i];\r\n\t\t\t\t\ttype = valueOrDefault$9(scale.type, key === 'xAxes'
    ? 'category' : 'linear');\r\n\r\n\t\t\t\t\tif (i >= target[key].length) {\r\n\t\t\t\t\t\ttarget[key].push({});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif
    (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\r\n\t\t\t\t\t\t//
    new/untyped scale or type changed: let's apply the new defaults\r\n\t\t\t\t\t\t//
    then merge source scale to correctly overwrite the defaults.\r\n\t\t\t\t\t\thelpers$1.merge(target[key][i],
    [core_scaleService.getScaleDefaults(type), scale]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//
    scales type are the same\r\n\t\t\t\t\t\thelpers$1.merge(target[key][i], scale);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}
    else {\r\n\t\t\t\thelpers$1._merger(key, target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n
    * Recursively merge the given config objects as the root options by handling\r\n
    * default scale options for the `scales` and `scale` properties, then returns\r\n
    * a deep copy of the result, thus doesn't alter inputs.\r\n */\r\nfunction mergeConfig(/*
    config objects ... */) {\r\n\treturn helpers$1.merge(Object.create(null), [].slice.call(arguments),
    {\r\n\t\tmerger: function(key, target, source, options) {\r\n\t\t\tvar tval =
    target[key] || Object.create(null);\r\n\t\t\tvar sval = source[key];\r\n\r\n\t\t\tif
    (key === 'scales') {\r\n\t\t\t\t// scale config merging is complex. Add our own
    function here for that\r\n\t\t\t\ttarget[key] = mergeScaleConfig(tval, sval);\r\n\t\t\t}
    else if (key === 'scale') {\r\n\t\t\t\t// used in polar area & radar charts since
    there is only one scale\r\n\t\t\t\ttarget[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type),
    sval]);\r\n\t\t\t} else {\r\n\t\t\t\thelpers$1._merger(key, target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction
    initConfig(config) {\r\n\tconfig = config || Object.create(null);\r\n\r\n\t//
    Do NOT use mergeConfig for the data object because this method merges arrays\r\n\t//
    and so would change references to labels and datasets, preventing data updates.\r\n\tvar
    data = config.data = config.data || {};\r\n\tdata.datasets = data.datasets ||
    [];\r\n\tdata.labels = data.labels || [];\r\n\r\n\tconfig.options = mergeConfig(\r\n\t\tcore_defaults.global,\r\n\t\tcore_defaults[config.type],\r\n\t\tconfig.options
    || {});\r\n\r\n\treturn config;\r\n}\r\n\r\nfunction updateConfig(chart) {\r\n\tvar
    newOptions = chart.options;\r\n\r\n\thelpers$1.each(chart.scales, function(scale)
    {\r\n\t\tcore_layouts.removeBox(chart, scale);\r\n\t});\r\n\r\n\tnewOptions =
    mergeConfig(\r\n\t\tcore_defaults.global,\r\n\t\tcore_defaults[chart.config.type],\r\n\t\tnewOptions);\r\n\r\n\tchart.options
    = chart.config.options = newOptions;\r\n\tchart.ensureScalesHaveIDs();\r\n\tchart.buildOrUpdateScales();\r\n\r\n\t//
    Tooltip\r\n\tchart.tooltip._options = newOptions.tooltips;\r\n\tchart.tooltip.initialize();\r\n}\r\n\r\nfunction
    nextAvailableScaleId(axesOpts, prefix, index) {\r\n\tvar id;\r\n\tvar hasId =
    function(obj) {\r\n\t\treturn obj.id === id;\r\n\t};\r\n\r\n\tdo {\r\n\t\tid =
    prefix + index++;\r\n\t} while (helpers$1.findIndex(axesOpts, hasId) >= 0);\r\n\r\n\treturn
    id;\r\n}\r\n\r\nfunction positionIsHorizontal(position) {\r\n\treturn position
    === 'top' || position === 'bottom';\r\n}\r\n\r\nfunction compare2Level(l1, l2)
    {\r\n\treturn function(a, b) {\r\n\t\treturn a[l1] === b[l1]\r\n\t\t\t? a[l2]
    - b[l2]\r\n\t\t\t: a[l1] - b[l1];\r\n\t};\r\n}\r\n\r\nvar Chart = function(item,
    config) {\r\n\tthis.construct(item, config);\r\n\treturn this;\r\n};\r\n\r\nhelpers$1.extend(Chart.prototype,
    /** @lends Chart */ {\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tconstruct: function(item,
    config) {\r\n\t\tvar me = this;\r\n\r\n\t\tconfig = initConfig(config);\r\n\r\n\t\tvar
    context = platform.acquireContext(item, config);\r\n\t\tvar canvas = context &&
    context.canvas;\r\n\t\tvar height = canvas && canvas.height;\r\n\t\tvar width
    = canvas && canvas.width;\r\n\r\n\t\tme.id = helpers$1.uid();\r\n\t\tme.ctx =
    context;\r\n\t\tme.canvas = canvas;\r\n\t\tme.config = config;\r\n\t\tme.width
    = width;\r\n\t\tme.height = height;\r\n\t\tme.aspectRatio = height ? width / height
    : null;\r\n\t\tme.options = config.options;\r\n\t\tme._bufferedRender = false;\r\n\t\tme._layers
    = [];\r\n\r\n\t\t/**\r\n\t\t * Provided for backward compatibility, Chart and
    Chart.Controller have been merged,\r\n\t\t * the \"instance\" still need to be
    defined since it might be called from plugins.\r\n\t\t * @prop Chart#chart\r\n\t\t
    * @deprecated since version 2.6.0\r\n\t\t * @todo remove at version 3\r\n\t\t
    * @private\r\n\t\t */\r\n\t\tme.chart = me;\r\n\t\tme.controller = me; // chart.chart.controller
    #inception\r\n\r\n\t\t// Add the chart instance to the global namespace\r\n\t\tChart.instances[me.id]
    = me;\r\n\r\n\t\t// Define alias to the config data: `chart.data === chart.config.data`\r\n\t\tObject.defineProperty(me,
    'data', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn me.config.data;\r\n\t\t\t},\r\n\t\t\tset:
    function(value) {\r\n\t\t\t\tme.config.data = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif
    (!context || !canvas) {\r\n\t\t\t// The given item is not a compatible context2d
    element, let's return before finalizing\r\n\t\t\t// the chart initialization but
    after setting basic chart / controller properties that\r\n\t\t\t// can help to
    figure out that the chart is not valid (e.g chart.canvas !== null);\r\n\t\t\t//
    https://github.com/chartjs/Chart.js/issues/2807\r\n\t\t\tconsole.error(\"Failed
    to create chart: can't acquire context from the given item\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme.initialize();\r\n\t\tme.update();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tinitialize: function() {\r\n\t\tvar me = this;\r\n\r\n\t\t//
    Before init plugin notification\r\n\t\tcore_plugins.notify(me, 'beforeInit');\r\n\r\n\t\thelpers$1.retinaScale(me,
    me.options.devicePixelRatio);\r\n\r\n\t\tme.bindEvents();\r\n\r\n\t\tif (me.options.responsive)
    {\r\n\t\t\t// Initial resize before chart draws (must be silent to preserve initial
    animations).\r\n\t\t\tme.resize(true);\r\n\t\t}\r\n\r\n\t\tme.initToolTip();\r\n\r\n\t\t//
    After init plugin notification\r\n\t\tcore_plugins.notify(me, 'afterInit');\r\n\r\n\t\treturn
    me;\r\n\t},\r\n\r\n\tclear: function() {\r\n\t\thelpers$1.canvas.clear(this);\r\n\t\treturn
    this;\r\n\t},\r\n\r\n\tstop: function() {\r\n\t\t// Stops any current animation
    loop occurring\r\n\t\tcore_animations.cancelAnimation(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tresize:
    function(silent) {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    canvas = me.canvas;\r\n\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio)
    || null;\r\n\r\n\t\t// the canvas render width and height will be casted to integers
    so make sure that\r\n\t\t// the canvas display style uses the same integer values
    to avoid blurring effect.\r\n\r\n\t\t// Set to 0 instead of canvas.size because
    the size defaults to 300x150 if the element is collapsed\r\n\t\tvar newWidth =
    Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\r\n\t\tvar newHeight
    = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\r\n\r\n\t\tif
    (me.width === newWidth && me.height === newHeight) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcanvas.width
    = me.width = newWidth;\r\n\t\tcanvas.height = me.height = newHeight;\r\n\t\tcanvas.style.width
    = newWidth + 'px';\r\n\t\tcanvas.style.height = newHeight + 'px';\r\n\r\n\t\thelpers$1.retinaScale(me,
    options.devicePixelRatio);\r\n\r\n\t\tif (!silent) {\r\n\t\t\t// Notify any plugins
    about the resize\r\n\t\t\tvar newSize = {width: newWidth, height: newHeight};\r\n\t\t\tcore_plugins.notify(me,
    'resize', [newSize]);\r\n\r\n\t\t\t// Notify of resize\r\n\t\t\tif (options.onResize)
    {\r\n\t\t\t\toptions.onResize(me, newSize);\r\n\t\t\t}\r\n\r\n\t\t\tme.stop();\r\n\t\t\tme.update({\r\n\t\t\t\tduration:
    options.responsiveAnimationDuration\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\tensureScalesHaveIDs:
    function() {\r\n\t\tvar options = this.options;\r\n\t\tvar scalesOptions = options.scales
    || {};\r\n\t\tvar scaleOptions = options.scale;\r\n\r\n\t\thelpers$1.each(scalesOptions.xAxes,
    function(xAxisOptions, index) {\r\n\t\t\tif (!xAxisOptions.id) {\r\n\t\t\t\txAxisOptions.id
    = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.each(scalesOptions.yAxes,
    function(yAxisOptions, index) {\r\n\t\t\tif (!yAxisOptions.id) {\r\n\t\t\t\tyAxisOptions.id
    = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif
    (scaleOptions) {\r\n\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Builds a map of scale ID to scale object for future lookup.\r\n\t */\r\n\tbuildOrUpdateScales:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    scales = me.scales || {};\r\n\t\tvar items = [];\r\n\t\tvar updated = Object.keys(scales).reduce(function(obj,
    id) {\r\n\t\t\tobj[id] = false;\r\n\t\t\treturn obj;\r\n\t\t}, {});\r\n\r\n\t\tif
    (options.scales) {\r\n\t\t\titems = items.concat(\r\n\t\t\t\t(options.scales.xAxes
    || []).map(function(xAxisOptions) {\r\n\t\t\t\t\treturn {options: xAxisOptions,
    dtype: 'category', dposition: 'bottom'};\r\n\t\t\t\t}),\r\n\t\t\t\t(options.scales.yAxes
    || []).map(function(yAxisOptions) {\r\n\t\t\t\t\treturn {options: yAxisOptions,
    dtype: 'linear', dposition: 'left'};\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif
    (options.scale) {\r\n\t\t\titems.push({\r\n\t\t\t\toptions: options.scale,\r\n\t\t\t\tdtype:
    'radialLinear',\r\n\t\t\t\tisDefault: true,\r\n\t\t\t\tdposition: 'chartArea'\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers$1.each(items,
    function(item) {\r\n\t\t\tvar scaleOptions = item.options;\r\n\t\t\tvar id = scaleOptions.id;\r\n\t\t\tvar
    scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);\r\n\r\n\t\t\tif (positionIsHorizontal(scaleOptions.position)
    !== positionIsHorizontal(item.dposition)) {\r\n\t\t\t\tscaleOptions.position =
    item.dposition;\r\n\t\t\t}\r\n\r\n\t\t\tupdated[id] = true;\r\n\t\t\tvar scale
    = null;\r\n\t\t\tif (id in scales && scales[id].type === scaleType) {\r\n\t\t\t\tscale
    = scales[id];\r\n\t\t\t\tscale.options = scaleOptions;\r\n\t\t\t\tscale.ctx =
    me.ctx;\r\n\t\t\t\tscale.chart = me;\r\n\t\t\t} else {\r\n\t\t\t\tvar scaleClass
    = core_scaleService.getScaleConstructor(scaleType);\r\n\t\t\t\tif (!scaleClass)
    {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tscale = new scaleClass({\r\n\t\t\t\t\tid:
    id,\r\n\t\t\t\t\ttype: scaleType,\r\n\t\t\t\t\toptions: scaleOptions,\r\n\t\t\t\t\tctx:
    me.ctx,\r\n\t\t\t\t\tchart: me\r\n\t\t\t\t});\r\n\t\t\t\tscales[scale.id] = scale;\r\n\t\t\t}\r\n\r\n\t\t\tscale.mergeTicksOptions();\r\n\r\n\t\t\t//
    TODO(SB): I think we should be able to remove this custom case (options.scale)\r\n\t\t\t//
    and consider it as a regular scale part of the \"scales\"\" map only! This would\r\n\t\t\t//
    make the logic easier and remove some useless? custom code.\r\n\t\t\tif (item.isDefault)
    {\r\n\t\t\t\tme.scale = scale;\r\n\t\t\t}\r\n\t\t});\r\n\t\t// clear up discarded
    scales\r\n\t\thelpers$1.each(updated, function(hasUpdated, id) {\r\n\t\t\tif (!hasUpdated)
    {\r\n\t\t\t\tdelete scales[id];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tme.scales = scales;\r\n\r\n\t\tcore_scaleService.addScalesToLayout(this);\r\n\t},\r\n\r\n\tbuildOrUpdateControllers:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar newControllers = [];\r\n\t\tvar
    datasets = me.data.datasets;\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i = 0, ilen =
    datasets.length; i < ilen; i++) {\r\n\t\t\tvar dataset = datasets[i];\r\n\t\t\tvar
    meta = me.getDatasetMeta(i);\r\n\t\t\tvar type = dataset.type || me.config.type;\r\n\r\n\t\t\tif
    (meta.type && meta.type !== type) {\r\n\t\t\t\tme.destroyDatasetMeta(i);\r\n\t\t\t\tmeta
    = me.getDatasetMeta(i);\r\n\t\t\t}\r\n\t\t\tmeta.type = type;\r\n\t\t\tmeta.order
    = dataset.order || 0;\r\n\t\t\tmeta.index = i;\r\n\r\n\t\t\tif (meta.controller)
    {\r\n\t\t\t\tmeta.controller.updateIndex(i);\r\n\t\t\t\tmeta.controller.linkScales();\r\n\t\t\t}
    else {\r\n\t\t\t\tvar ControllerClass = controllers[meta.type];\r\n\t\t\t\tif
    (ControllerClass === undefined) {\r\n\t\t\t\t\tthrow new Error('\"' + meta.type
    + '\" is not a chart type.');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmeta.controller = new
    ControllerClass(me, i);\r\n\t\t\t\tnewControllers.push(meta.controller);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    newControllers;\r\n\t},\r\n\r\n\t/**\r\n\t * Reset the elements of all datasets\r\n\t
    * @private\r\n\t */\r\n\tresetElements: function() {\r\n\t\tvar me = this;\r\n\t\thelpers$1.each(me.data.datasets,
    function(dataset, datasetIndex) {\r\n\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\r\n\t\t},
    me);\r\n\t},\r\n\r\n\t/**\r\n\t* Resets the chart back to it's state before the
    initial animation\r\n\t*/\r\n\treset: function() {\r\n\t\tthis.resetElements();\r\n\t\tthis.tooltip.initialize();\r\n\t},\r\n\r\n\tupdate:
    function(config) {\r\n\t\tvar me = this;\r\n\t\tvar i, ilen;\r\n\r\n\t\tif (!config
    || typeof config !== 'object') {\r\n\t\t\t// backwards compatibility\r\n\t\t\tconfig
    = {\r\n\t\t\t\tduration: config,\r\n\t\t\t\tlazy: arguments[1]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tupdateConfig(me);\r\n\r\n\t\t//
    plugins options references might have change, let's invalidate the cache\r\n\t\t//
    https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t\tcore_plugins._invalidate(me);\r\n\r\n\t\tif
    (core_plugins.notify(me, 'beforeUpdate') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//
    In case the entire data object changed\r\n\t\tme.tooltip._data = me.data;\r\n\r\n\t\t//
    Make sure dataset controllers are updated and new controllers are reset\r\n\t\tvar
    newControllers = me.buildOrUpdateControllers();\r\n\r\n\t\t// Make sure all dataset
    controllers have correct meta data counts\r\n\t\tfor (i = 0, ilen = me.data.datasets.length;
    i < ilen; i++) {\r\n\t\t\tme.getDatasetMeta(i).controller.buildOrUpdateElements();\r\n\t\t}\r\n\r\n\t\tme.updateLayout();\r\n\r\n\t\t//
    Can only reset the new controllers after the scales have been updated\r\n\t\tif
    (me.options.animation && me.options.animation.duration) {\r\n\t\t\thelpers$1.each(newControllers,
    function(controller) {\r\n\t\t\t\tcontroller.reset();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tme.updateDatasets();\r\n\r\n\t\t//
    Need to reset tooltip in case it is displayed with elements that are removed\r\n\t\t//
    after update.\r\n\t\tme.tooltip.initialize();\r\n\r\n\t\t// Last active contains
    items that were previously in the tooltip.\r\n\t\t// When we reset the tooltip,
    we need to clear it\r\n\t\tme.lastActive = [];\r\n\r\n\t\t// Do this before render
    so that any plugins that need final scale updates can use it\r\n\t\tcore_plugins.notify(me,
    'afterUpdate');\r\n\r\n\t\tme._layers.sort(compare2Level('z', '_idx'));\r\n\r\n\t\tif
    (me._bufferedRender) {\r\n\t\t\tme._bufferedRequest = {\r\n\t\t\t\tduration: config.duration,\r\n\t\t\t\teasing:
    config.easing,\r\n\t\t\t\tlazy: config.lazy\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tme.render(config);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\r\n\t
    * hook, in which case, plugins will not be called on `afterLayout`.\r\n\t * @private\r\n\t
    */\r\n\tupdateLayout: function() {\r\n\t\tvar me = this;\r\n\r\n\t\tif (core_plugins.notify(me,
    'beforeLayout') === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcore_layouts.update(this,
    this.width, this.height);\r\n\r\n\t\tme._layers = [];\r\n\t\thelpers$1.each(me.boxes,
    function(box) {\r\n\t\t\t// _configure is called twice, once in core.scale.update
    and once here.\r\n\t\t\t// Here the boxes are fully updated and at their final
    positions.\r\n\t\t\tif (box._configure) {\r\n\t\t\t\tbox._configure();\r\n\t\t\t}\r\n\t\t\tme._layers.push.apply(me._layers,
    box._layers());\r\n\t\t}, me);\r\n\r\n\t\tme._layers.forEach(function(item, index)
    {\r\n\t\t\titem._idx = index;\r\n\t\t});\r\n\r\n\t\t/**\r\n\t\t * Provided for
    backward compatibility, use `afterLayout` instead.\r\n\t\t * @method IPlugin#afterScaleUpdate\r\n\t\t
    * @deprecated since version 2.5.0\r\n\t\t * @todo remove at version 3\r\n\t\t
    * @private\r\n\t\t */\r\n\t\tcore_plugins.notify(me, 'afterScaleUpdate');\r\n\t\tcore_plugins.notify(me,
    'afterLayout');\r\n\t},\r\n\r\n\t/**\r\n\t * Updates all datasets unless a plugin
    returns `false` to the `beforeDatasetsUpdate`\r\n\t * hook, in which case, plugins
    will not be called on `afterDatasetsUpdate`.\r\n\t * @private\r\n\t */\r\n\tupdateDatasets:
    function() {\r\n\t\tvar me = this;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetsUpdate')
    === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, ilen = me.data.datasets.length;
    i < ilen; ++i) {\r\n\t\t\tme.updateDataset(i);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDatasetsUpdate');\r\n\t},\r\n\r\n\t/**\r\n\t * Updates dataset at index
    unless a plugin returns `false` to the `beforeDatasetUpdate`\r\n\t * hook, in
    which case, plugins will not be called on `afterDatasetUpdate`.\r\n\t * @private\r\n\t
    */\r\n\tupdateDataset: function(index) {\r\n\t\tvar me = this;\r\n\t\tvar meta
    = me.getDatasetMeta(index);\r\n\t\tvar args = {\r\n\t\t\tmeta: meta,\r\n\t\t\tindex:
    index\r\n\t\t};\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetUpdate',
    [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmeta.controller._update();\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDatasetUpdate', [args]);\r\n\t},\r\n\r\n\trender: function(config) {\r\n\t\tvar
    me = this;\r\n\r\n\t\tif (!config || typeof config !== 'object') {\r\n\t\t\t//
    backwards compatibility\r\n\t\t\tconfig = {\r\n\t\t\t\tduration: config,\r\n\t\t\t\tlazy:
    arguments[1]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar animationOptions = me.options.animation;\r\n\t\tvar
    duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);\r\n\t\tvar
    lazy = config.lazy;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeRender') ===
    false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar onComplete = function(animation)
    {\r\n\t\t\tcore_plugins.notify(me, 'afterRender');\r\n\t\t\thelpers$1.callback(animationOptions
    && animationOptions.onComplete, [animation], me);\r\n\t\t};\r\n\r\n\t\tif (animationOptions
    && duration) {\r\n\t\t\tvar animation = new core_animation({\r\n\t\t\t\tnumSteps:
    duration / 16.66, // 60 fps\r\n\t\t\t\teasing: config.easing || animationOptions.easing,\r\n\r\n\t\t\t\trender:
    function(chart, animationObject) {\r\n\t\t\t\t\tvar easingFunction = helpers$1.easing.effects[animationObject.easing];\r\n\t\t\t\t\tvar
    currentStep = animationObject.currentStep;\r\n\t\t\t\t\tvar stepDecimal = currentStep
    / animationObject.numSteps;\r\n\r\n\t\t\t\t\tchart.draw(easingFunction(stepDecimal),
    stepDecimal, currentStep);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tonAnimationProgress: animationOptions.onProgress,\r\n\t\t\t\tonAnimationComplete:
    onComplete\r\n\t\t\t});\r\n\r\n\t\t\tcore_animations.addAnimation(me, animation,
    duration, lazy);\r\n\t\t} else {\r\n\t\t\tme.draw();\r\n\r\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\r\n\t\t\tonComplete(new
    core_animation({numSteps: 0, chart: me}));\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\tdraw:
    function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar i, layers;\r\n\r\n\t\tme.clear();\r\n\r\n\t\tif
    (helpers$1.isNullOrUndef(easingValue)) {\r\n\t\t\teasingValue = 1;\r\n\t\t}\r\n\r\n\t\tme.transition(easingValue);\r\n\r\n\t\tif
    (me.width <= 0 || me.height <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (core_plugins.notify(me,
    'beforeDraw', [easingValue]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//
    Because of plugin hooks (before/afterDatasetsDraw), datasets can't\r\n\t\t// currently
    be part of layers. Instead, we draw\r\n\t\t// layers <= 0 before(default, backward
    compat), and the rest after\r\n\t\tlayers = me._layers;\r\n\t\tfor (i = 0; i <
    layers.length && layers[i].z <= 0; ++i) {\r\n\t\t\tlayers[i].draw(me.chartArea);\r\n\t\t}\r\n\r\n\t\tme.drawDatasets(easingValue);\r\n\r\n\t\t//
    Rest of layers\r\n\t\tfor (; i < layers.length; ++i) {\r\n\t\t\tlayers[i].draw(me.chartArea);\r\n\t\t}\r\n\r\n\t\tme._drawTooltip(easingValue);\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDraw', [easingValue]);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\ttransition:
    function(easingValue) {\r\n\t\tvar me = this;\r\n\r\n\t\tfor (var i = 0, ilen
    = (me.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\tif (me.isDatasetVisible(i))
    {\r\n\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.tooltip.transition(easingValue);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_getSortedDatasetMetas: function(filterVisible) {\r\n\t\tvar
    me = this;\r\n\t\tvar datasets = me.data.datasets || [];\r\n\t\tvar result = [];\r\n\t\tvar
    i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\r\n\t\t\tif
    (!filterVisible || me.isDatasetVisible(i)) {\r\n\t\t\t\tresult.push(me.getDatasetMeta(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.sort(compare2Level('order',
    'index'));\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_getSortedVisibleDatasetMetas: function() {\r\n\t\treturn this._getSortedDatasetMetas(true);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\r\n\t
    * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\r\n\t
    * @private\r\n\t */\r\n\tdrawDatasets: function(easingValue) {\r\n\t\tvar me =
    this;\r\n\t\tvar metasets, i;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeDatasetsDraw',
    [easingValue]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmetasets = me._getSortedVisibleDatasetMetas();\r\n\t\tfor
    (i = metasets.length - 1; i >= 0; --i) {\r\n\t\t\tme.drawDataset(metasets[i],
    easingValue);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'afterDatasetsDraw',
    [easingValue]);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws dataset at index unless a plugin
    returns `false` to the `beforeDatasetDraw`\r\n\t * hook, in which case, plugins
    will not be called on `afterDatasetDraw`.\r\n\t * @private\r\n\t */\r\n\tdrawDataset:
    function(meta, easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar args = {\r\n\t\t\tmeta:
    meta,\r\n\t\t\tindex: meta.index,\r\n\t\t\teasingValue: easingValue\r\n\t\t};\r\n\r\n\t\tif
    (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmeta.controller.draw(easingValue);\r\n\r\n\t\tcore_plugins.notify(me,
    'afterDatasetDraw', [args]);\r\n\t},\r\n\r\n\t/**\r\n\t * Draws tooltip unless
    a plugin returns `false` to the `beforeTooltipDraw`\r\n\t * hook, in which case,
    plugins will not be called on `afterTooltipDraw`.\r\n\t * @private\r\n\t */\r\n\t_drawTooltip:
    function(easingValue) {\r\n\t\tvar me = this;\r\n\t\tvar tooltip = me.tooltip;\r\n\t\tvar
    args = {\r\n\t\t\ttooltip: tooltip,\r\n\t\t\teasingValue: easingValue\r\n\t\t};\r\n\r\n\t\tif
    (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttooltip.draw();\r\n\r\n\t\tcore_plugins.notify(me,
    'afterTooltipDraw', [args]);\r\n\t},\r\n\r\n\t/**\r\n\t * Get the single element
    that was clicked on\r\n\t * @return An object containing the dataset index and
    element index of the matching element. Also contains the rectangle that was draw\r\n\t
    */\r\n\tgetElementAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.single(this,
    e);\r\n\t},\r\n\r\n\tgetElementsAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.label(this,
    e, {intersect: true});\r\n\t},\r\n\r\n\tgetElementsAtXAxis: function(e) {\r\n\t\treturn
    core_interaction.modes['x-axis'](this, e, {intersect: true});\r\n\t},\r\n\r\n\tgetElementsAtEventForMode:
    function(e, mode, options) {\r\n\t\tvar method = core_interaction.modes[mode];\r\n\t\tif
    (typeof method === 'function') {\r\n\t\t\treturn method(this, e, options);\r\n\t\t}\r\n\r\n\t\treturn
    [];\r\n\t},\r\n\r\n\tgetDatasetAtEvent: function(e) {\r\n\t\treturn core_interaction.modes.dataset(this,
    e, {intersect: true});\r\n\t},\r\n\r\n\tgetDatasetMeta: function(datasetIndex)
    {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.data.datasets[datasetIndex];\r\n\t\tif
    (!dataset._meta) {\r\n\t\t\tdataset._meta = {};\r\n\t\t}\r\n\r\n\t\tvar meta =
    dataset._meta[me.id];\r\n\t\tif (!meta) {\r\n\t\t\tmeta = dataset._meta[me.id]
    = {\r\n\t\t\t\ttype: null,\r\n\t\t\t\tdata: [],\r\n\t\t\t\tdataset: null,\r\n\t\t\t\tcontroller:
    null,\r\n\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\r\n\t\t\t\txAxisID:
    null,\r\n\t\t\t\tyAxisID: null,\r\n\t\t\t\torder: dataset.order || 0,\r\n\t\t\t\tindex:
    datasetIndex\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn meta;\r\n\t},\r\n\r\n\tgetVisibleDatasetCount:
    function() {\r\n\t\tvar count = 0;\r\n\t\tfor (var i = 0, ilen = this.data.datasets.length;
    i < ilen; ++i) {\r\n\t\t\tif (this.isDatasetVisible(i)) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn
    count;\r\n\t},\r\n\r\n\tisDatasetVisible: function(datasetIndex) {\r\n\t\tvar
    meta = this.getDatasetMeta(datasetIndex);\r\n\r\n\t\t// meta.hidden is a per chart
    dataset hidden flag override with 3 states: if true or false,\r\n\t\t// the dataset.hidden
    value is ignored, else if null, the dataset hidden state is returned.\r\n\t\treturn
    typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\r\n\t},\r\n\r\n\tgenerateLegend:
    function() {\r\n\t\treturn this.options.legendCallback(this);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tdestroyDatasetMeta: function(datasetIndex) {\r\n\t\tvar
    id = this.id;\r\n\t\tvar dataset = this.data.datasets[datasetIndex];\r\n\t\tvar
    meta = dataset._meta && dataset._meta[id];\r\n\r\n\t\tif (meta) {\r\n\t\t\tmeta.controller.destroy();\r\n\t\t\tdelete
    dataset._meta[id];\r\n\t\t}\r\n\t},\r\n\r\n\tdestroy: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar canvas = me.canvas;\r\n\t\tvar i, ilen;\r\n\r\n\t\tme.stop();\r\n\r\n\t\t//
    dataset controllers need to cleanup associated data\r\n\t\tfor (i = 0, ilen =
    me.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tme.destroyDatasetMeta(i);\r\n\t\t}\r\n\r\n\t\tif
    (canvas) {\r\n\t\t\tme.unbindEvents();\r\n\t\t\thelpers$1.canvas.clear(me);\r\n\t\t\tplatform.releaseContext(me.ctx);\r\n\t\t\tme.canvas
    = null;\r\n\t\t\tme.ctx = null;\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me, 'destroy');\r\n\r\n\t\tdelete
    Chart.instances[me.id];\r\n\t},\r\n\r\n\ttoBase64Image: function() {\r\n\t\treturn
    this.canvas.toDataURL.apply(this.canvas, arguments);\r\n\t},\r\n\r\n\tinitToolTip:
    function() {\r\n\t\tvar me = this;\r\n\t\tme.tooltip = new core_tooltip({\r\n\t\t\t_chart:
    me,\r\n\t\t\t_chartInstance: me, // deprecated, backward compatibility\r\n\t\t\t_data:
    me.data,\r\n\t\t\t_options: me.options.tooltips\r\n\t\t}, me);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tbindEvents: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    listeners = me._listeners = {};\r\n\t\tvar listener = function() {\r\n\t\t\tme.eventHandler.apply(me,
    arguments);\r\n\t\t};\r\n\r\n\t\thelpers$1.each(me.options.events, function(type)
    {\r\n\t\t\tplatform.addEventListener(me, type, listener);\r\n\t\t\tlisteners[type]
    = listener;\r\n\t\t});\r\n\r\n\t\t// Elements used to detect size change should
    not be injected for non responsive charts.\r\n\t\t// See https://github.com/chartjs/Chart.js/issues/2210\r\n\t\tif
    (me.options.responsive) {\r\n\t\t\tlistener = function() {\r\n\t\t\t\tme.resize();\r\n\t\t\t};\r\n\r\n\t\t\tplatform.addEventListener(me,
    'resize', listener);\r\n\t\t\tlisteners.resize = listener;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tunbindEvents: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    listeners = me._listeners;\r\n\t\tif (!listeners) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tdelete
    me._listeners;\r\n\t\thelpers$1.each(listeners, function(listener, type) {\r\n\t\t\tplatform.removeEventListener(me,
    type, listener);\r\n\t\t});\r\n\t},\r\n\r\n\tupdateHoverStyle: function(elements,
    mode, enabled) {\r\n\t\tvar prefix = enabled ? 'set' : 'remove';\r\n\t\tvar element,
    i, ilen;\r\n\r\n\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\r\n\t\t\telement
    = elements[i];\r\n\t\t\tif (element) {\r\n\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[prefix
    + 'HoverStyle'](element);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (mode === 'dataset')
    {\r\n\t\t\tthis.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix
    + 'DatasetHoverStyle']();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\teventHandler: function(e) {\r\n\t\tvar me = this;\r\n\t\tvar tooltip =
    me.tooltip;\r\n\r\n\t\tif (core_plugins.notify(me, 'beforeEvent', [e]) === false)
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Buffer any update calls so that renders
    do not occur\r\n\t\tme._bufferedRender = true;\r\n\t\tme._bufferedRequest = null;\r\n\r\n\t\tvar
    changed = me.handleEvent(e);\r\n\t\t// for smooth tooltip animations issue #4989\r\n\t\t//
    the tooltip should be the source of change\r\n\t\t// Animation check workaround:\r\n\t\t//
    tooltip._start will be null when tooltip isn't animating\r\n\t\tif (tooltip) {\r\n\t\t\tchanged
    = tooltip._start\r\n\t\t\t\t? tooltip.handleEvent(e)\r\n\t\t\t\t: changed | tooltip.handleEvent(e);\r\n\t\t}\r\n\r\n\t\tcore_plugins.notify(me,
    'afterEvent', [e]);\r\n\r\n\t\tvar bufferedRequest = me._bufferedRequest;\r\n\t\tif
    (bufferedRequest) {\r\n\t\t\t// If we have an update that was triggered, we need
    to do a normal render\r\n\t\t\tme.render(bufferedRequest);\r\n\t\t} else if (changed
    && !me.animating) {\r\n\t\t\t// If entering, leaving, or changing elements, animate
    the change via pivot\r\n\t\t\tme.stop();\r\n\r\n\t\t\t// We only need to render
    at this point. Updating will cause scales to be\r\n\t\t\t// recomputed generating
    flicker & using more memory than necessary.\r\n\t\t\tme.render({\r\n\t\t\t\tduration:
    me.options.hover.animationDuration,\r\n\t\t\t\tlazy: true\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tme._bufferedRender
    = false;\r\n\t\tme._bufferedRequest = null;\r\n\r\n\t\treturn me;\r\n\t},\r\n\r\n\t/**\r\n\t
    * Handle an event\r\n\t * @private\r\n\t * @param {IEvent} event the event to
    handle\r\n\t * @return {boolean} true if the chart needs to re-render\r\n\t */\r\n\thandleEvent:
    function(e) {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options || {};\r\n\t\tvar
    hoverOptions = options.hover;\r\n\t\tvar changed = false;\r\n\r\n\t\tme.lastActive
    = me.lastActive || [];\r\n\r\n\t\t// Find Active Elements for hover and tooltips\r\n\t\tif
    (e.type === 'mouseout') {\r\n\t\t\tme.active = [];\r\n\t\t} else {\r\n\t\t\tme.active
    = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\r\n\t\t}\r\n\r\n\t\t//
    Invoke onHover hook\r\n\t\t// Need to call with native event here to not break
    backwards compatibility\r\n\t\thelpers$1.callback(options.onHover || options.hover.onHover,
    [e.native, me.active], me);\r\n\r\n\t\tif (e.type === 'mouseup' || e.type ===
    'click') {\r\n\t\t\tif (options.onClick) {\r\n\t\t\t\t// Use e.native here for
    backwards compatibility\r\n\t\t\t\toptions.onClick.call(me, e.native, me.active);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//
    Remove styling for last active (even if it may still be active)\r\n\t\tif (me.lastActive.length)
    {\r\n\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\r\n\t\t}\r\n\r\n\t\t//
    Built in hover styling\r\n\t\tif (me.active.length && hoverOptions.mode) {\r\n\t\t\tme.updateHoverStyle(me.active,
    hoverOptions.mode, true);\r\n\t\t}\r\n\r\n\t\tchanged = !helpers$1.arrayEquals(me.active,
    me.lastActive);\r\n\r\n\t\t// Remember Last Actives\r\n\t\tme.lastActive = me.active;\r\n\r\n\t\treturn
    changed;\r\n\t}\r\n});\r\n\r\n/**\r\n * NOTE(SB) We actually don't use this container
    anymore but we need to keep it\r\n * for backward compatibility. Though, it can
    still be useful for plugins that\r\n * would need to work on multiple charts?!\r\n
    */\r\nChart.instances = {};\r\n\r\nvar core_controller = Chart;\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart instead.\r\n * @class Chart.Controller\r\n
    * @deprecated since version 2.6\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\nChart.Controller = Chart;\r\n\r\n/**\r\n * Provided for backward compatibility,
    not available anymore.\r\n * @namespace Chart\r\n * @deprecated since version
    2.8\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nChart.types = {};\r\n\r\n/**\r\n
    * Provided for backward compatibility, not available anymore.\r\n * @namespace
    Chart.helpers.configMerge\r\n * @deprecated since version 2.8.0\r\n * @todo remove
    at version 3\r\n * @private\r\n */\r\nhelpers$1.configMerge = mergeConfig;\r\n\r\n/**\r\n
    * Provided for backward compatibility, not available anymore.\r\n * @namespace
    Chart.helpers.scaleMerge\r\n * @deprecated since version 2.8.0\r\n * @todo remove
    at version 3\r\n * @private\r\n */\r\nhelpers$1.scaleMerge = mergeScaleConfig;\n\nvar
    core_helpers = function() {\r\n\r\n\t// -- Basic js utility methods\r\n\r\n\thelpers$1.where
    = function(collection, filterCallback) {\r\n\t\tif (helpers$1.isArray(collection)
    && Array.prototype.filter) {\r\n\t\t\treturn collection.filter(filterCallback);\r\n\t\t}\r\n\t\tvar
    filtered = [];\r\n\r\n\t\thelpers$1.each(collection, function(item) {\r\n\t\t\tif
    (filterCallback(item)) {\r\n\t\t\t\tfiltered.push(item);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn
    filtered;\r\n\t};\r\n\thelpers$1.findIndex = Array.prototype.findIndex ?\r\n\t\tfunction(array,
    callback, scope) {\r\n\t\t\treturn array.findIndex(callback, scope);\r\n\t\t}
    :\r\n\t\tfunction(array, callback, scope) {\r\n\t\t\tscope = scope === undefined
    ? array : scope;\r\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i)
    {\r\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\r\n\t\t\t\t\treturn
    i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\thelpers$1.findNextWhere
    = function(arrayToSearch, filterCallback, startIndex) {\r\n\t\t// Default to start
    of the array\r\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\r\n\t\t\tstartIndex
    = -1;\r\n\t\t}\r\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++)
    {\r\n\t\t\tvar currentItem = arrayToSearch[i];\r\n\t\t\tif (filterCallback(currentItem))
    {\r\n\t\t\t\treturn currentItem;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\thelpers$1.findPreviousWhere
    = function(arrayToSearch, filterCallback, startIndex) {\r\n\t\t// Default to end
    of the array\r\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\r\n\t\t\tstartIndex
    = arrayToSearch.length;\r\n\t\t}\r\n\t\tfor (var i = startIndex - 1; i >= 0; i--)
    {\r\n\t\t\tvar currentItem = arrayToSearch[i];\r\n\t\t\tif (filterCallback(currentItem))
    {\r\n\t\t\t\treturn currentItem;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// -- Math
    methods\r\n\thelpers$1.isNumber = function(n) {\r\n\t\treturn !isNaN(parseFloat(n))
    && isFinite(n);\r\n\t};\r\n\thelpers$1.almostEquals = function(x, y, epsilon)
    {\r\n\t\treturn Math.abs(x - y) < epsilon;\r\n\t};\r\n\thelpers$1.almostWhole
    = function(x, epsilon) {\r\n\t\tvar rounded = Math.round(x);\r\n\t\treturn ((rounded
    - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n\t};\r\n\thelpers$1.max = function(array)
    {\r\n\t\treturn array.reduce(function(max, value) {\r\n\t\t\tif (!isNaN(value))
    {\r\n\t\t\t\treturn Math.max(max, value);\r\n\t\t\t}\r\n\t\t\treturn max;\r\n\t\t},
    Number.NEGATIVE_INFINITY);\r\n\t};\r\n\thelpers$1.min = function(array) {\r\n\t\treturn
    array.reduce(function(min, value) {\r\n\t\t\tif (!isNaN(value)) {\r\n\t\t\t\treturn
    Math.min(min, value);\r\n\t\t\t}\r\n\t\t\treturn min;\r\n\t\t}, Number.POSITIVE_INFINITY);\r\n\t};\r\n\thelpers$1.sign
    = Math.sign ?\r\n\t\tfunction(x) {\r\n\t\t\treturn Math.sign(x);\r\n\t\t} :\r\n\t\tfunction(x)
    {\r\n\t\t\tx = +x; // convert to a number\r\n\t\t\tif (x === 0 || isNaN(x)) {\r\n\t\t\t\treturn
    x;\r\n\t\t\t}\r\n\t\t\treturn x > 0 ? 1 : -1;\r\n\t\t};\r\n\thelpers$1.toRadians
    = function(degrees) {\r\n\t\treturn degrees * (Math.PI / 180);\r\n\t};\r\n\thelpers$1.toDegrees
    = function(radians) {\r\n\t\treturn radians * (180 / Math.PI);\r\n\t};\r\n\r\n\t/**\r\n\t
    * Returns the number of decimal places\r\n\t * i.e. the number of digits after
    the decimal point, of the value of this Number.\r\n\t * @param {number} x - A
    number.\r\n\t * @returns {number} The number of decimal places.\r\n\t * @private\r\n\t
    */\r\n\thelpers$1._decimalPlaces = function(x) {\r\n\t\tif (!helpers$1.isFinite(x))
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar e = 1;\r\n\t\tvar p = 0;\r\n\t\twhile (Math.round(x
    * e) / e !== x) {\r\n\t\t\te *= 10;\r\n\t\t\tp++;\r\n\t\t}\r\n\t\treturn p;\r\n\t};\r\n\r\n\t//
    Gets the angle from vertical upright to the point about a centre.\r\n\thelpers$1.getAngleFromPoint
    = function(centrePoint, anglePoint) {\r\n\t\tvar distanceFromXCenter = anglePoint.x
    - centrePoint.x;\r\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n\t\tvar
    radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter
    + distanceFromYCenter * distanceFromYCenter);\r\n\r\n\t\tvar angle = Math.atan2(distanceFromYCenter,
    distanceFromXCenter);\r\n\r\n\t\tif (angle < (-0.5 * Math.PI)) {\r\n\t\t\tangle
    += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tangle: angle,\r\n\t\t\tdistance: radialDistanceFromCenter\r\n\t\t};\r\n\t};\r\n\thelpers$1.distanceBetweenPoints
    = function(pt1, pt2) {\r\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y
    - pt1.y, 2));\r\n\t};\r\n\r\n\t/**\r\n\t * Provided for backward compatibility,
    not available anymore\r\n\t * @function Chart.helpers.aliasPixel\r\n\t * @deprecated
    since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\thelpers$1.aliasPixel
    = function(pixelWidth) {\r\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\r\n\t};\r\n\r\n\t/**\r\n\t
    * Returns the aligned pixel value to avoid anti-aliasing blur\r\n\t * @param {Chart}
    chart - The chart instance.\r\n\t * @param {number} pixel - A pixel value.\r\n\t
    * @param {number} width - The width of the element.\r\n\t * @returns {number}
    The aligned pixel value.\r\n\t * @private\r\n\t */\r\n\thelpers$1._alignPixel
    = function(chart, pixel, width) {\r\n\t\tvar devicePixelRatio = chart.currentDevicePixelRatio;\r\n\t\tvar
    halfWidth = width / 2;\r\n\t\treturn Math.round((pixel - halfWidth) * devicePixelRatio)
    / devicePixelRatio + halfWidth;\r\n\t};\r\n\r\n\thelpers$1.splineCurve = function(firstPoint,
    middlePoint, afterPoint, t) {\r\n\t\t// Props to Rob Spencer at scaled innovation
    for his post on splining between points\r\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n\r\n\t\t//
    This function must also respect \"skipped\" points\r\n\r\n\t\tvar previous = firstPoint.skip
    ? middlePoint : firstPoint;\r\n\t\tvar current = middlePoint;\r\n\t\tvar next
    = afterPoint.skip ? middlePoint : afterPoint;\r\n\r\n\t\tvar d01 = Math.sqrt(Math.pow(current.x
    - previous.x, 2) + Math.pow(current.y - previous.y, 2));\r\n\t\tvar d12 = Math.sqrt(Math.pow(next.x
    - current.x, 2) + Math.pow(next.y - current.y, 2));\r\n\r\n\t\tvar s01 = d01 /
    (d01 + d12);\r\n\t\tvar s12 = d12 / (d01 + d12);\r\n\r\n\t\t// If all points are
    the same, s01 & s02 will be inf\r\n\t\ts01 = isNaN(s01) ? 0 : s01;\r\n\t\ts12
    = isNaN(s12) ? 0 : s12;\r\n\r\n\t\tvar fa = t * s01; // scaling factor for triangle
    Ta\r\n\t\tvar fb = t * s12;\r\n\r\n\t\treturn {\r\n\t\t\tprevious: {\r\n\t\t\t\tx:
    current.x - fa * (next.x - previous.x),\r\n\t\t\t\ty: current.y - fa * (next.y
    - previous.y)\r\n\t\t\t},\r\n\t\t\tnext: {\r\n\t\t\t\tx: current.x + fb * (next.x
    - previous.x),\r\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\thelpers$1.EPSILON
    = Number.EPSILON || 1e-14;\r\n\thelpers$1.splineCurveMonotone = function(points)
    {\r\n\t\t// This function calculates Bézier control points in a similar way than
    |splineCurve|,\r\n\t\t// but preserves monotonicity of the provided data and ensures
    no local extremums are added\r\n\t\t// between the dataset discrete points due
    to the interpolation.\r\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\r\n\r\n\t\tvar
    pointsWithTangents = (points || []).map(function(point) {\r\n\t\t\treturn {\r\n\t\t\t\tmodel:
    point._model,\r\n\t\t\t\tdeltaK: 0,\r\n\t\t\t\tmK: 0\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\t//
    Calculate slopes (deltaK) and initialize tangents (mK)\r\n\t\tvar pointsLen =
    pointsWithTangents.length;\r\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\r\n\t\tfor
    (i = 0; i < pointsLen; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tif
    (pointCurrent.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpointBefore
    = i > 0 ? pointsWithTangents[i - 1] : null;\r\n\t\t\tpointAfter = i < pointsLen
    - 1 ? pointsWithTangents[i + 1] : null;\r\n\t\t\tif (pointAfter && !pointAfter.model.skip)
    {\r\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\r\n\r\n\t\t\t\t//
    In the case of two points that appear at the same x pixel, slopeDeltaX is 0\r\n\t\t\t\tpointCurrent.deltaK
    = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX
    : 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\r\n\t\t\t\tpointCurrent.mK
    = pointCurrent.deltaK;\r\n\t\t\t} else if (!pointAfter || pointAfter.model.skip)
    {\r\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\r\n\t\t\t} else if (this.sign(pointBefore.deltaK)
    !== this.sign(pointCurrent.deltaK)) {\r\n\t\t\t\tpointCurrent.mK = 0;\r\n\t\t\t}
    else {\r\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK)
    / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Adjust tangents to ensure monotonic properties\r\n\t\tvar
    alphaK, betaK, tauK, squaredMagnitude;\r\n\t\tfor (i = 0; i < pointsLen - 1; ++i)
    {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tpointAfter = pointsWithTangents[i
    + 1];\r\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\r\n\t\t\t\tpointCurrent.mK
    = pointAfter.mK = 0;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\talphaK = pointCurrent.mK
    / pointCurrent.deltaK;\r\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\r\n\t\t\tsquaredMagnitude
    = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n\t\t\tif (squaredMagnitude <= 9)
    {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\r\n\t\t\tpointCurrent.mK
    = alphaK * tauK * pointCurrent.deltaK;\r\n\t\t\tpointAfter.mK = betaK * tauK *
    pointCurrent.deltaK;\r\n\t\t}\r\n\r\n\t\t// Compute control points\r\n\t\tvar
    deltaX;\r\n\t\tfor (i = 0; i < pointsLen; ++i) {\r\n\t\t\tpointCurrent = pointsWithTangents[i];\r\n\t\t\tif
    (pointCurrent.model.skip) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpointBefore
    = i > 0 ? pointsWithTangents[i - 1] : null;\r\n\t\t\tpointAfter = i < pointsLen
    - 1 ? pointsWithTangents[i + 1] : null;\r\n\t\t\tif (pointBefore && !pointBefore.model.skip)
    {\r\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\r\n\t\t\t\tpointCurrent.model.controlPointPreviousX
    = pointCurrent.model.x - deltaX;\r\n\t\t\t\tpointCurrent.model.controlPointPreviousY
    = pointCurrent.model.y - deltaX * pointCurrent.mK;\r\n\t\t\t}\r\n\t\t\tif (pointAfter
    && !pointAfter.model.skip) {\r\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x)
    / 3;\r\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x +
    deltaX;\r\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y
    + deltaX * pointCurrent.mK;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\thelpers$1.nextItem
    = function(collection, index, loop) {\r\n\t\tif (loop) {\r\n\t\t\treturn index
    >= collection.length - 1 ? collection[0] : collection[index + 1];\r\n\t\t}\r\n\t\treturn
    index >= collection.length - 1 ? collection[collection.length - 1] : collection[index
    + 1];\r\n\t};\r\n\thelpers$1.previousItem = function(collection, index, loop)
    {\r\n\t\tif (loop) {\r\n\t\t\treturn index <= 0 ? collection[collection.length
    - 1] : collection[index - 1];\r\n\t\t}\r\n\t\treturn index <= 0 ? collection[0]
    : collection[index - 1];\r\n\t};\r\n\t// Implementation of the nice number algorithm
    used in determining where axis labels will go\r\n\thelpers$1.niceNum = function(range,
    round) {\r\n\t\tvar exponent = Math.floor(helpers$1.log10(range));\r\n\t\tvar
    fraction = range / Math.pow(10, exponent);\r\n\t\tvar niceFraction;\r\n\r\n\t\tif
    (round) {\r\n\t\t\tif (fraction < 1.5) {\r\n\t\t\t\tniceFraction = 1;\r\n\t\t\t}
    else if (fraction < 3) {\r\n\t\t\t\tniceFraction = 2;\r\n\t\t\t} else if (fraction
    < 7) {\r\n\t\t\t\tniceFraction = 5;\r\n\t\t\t} else {\r\n\t\t\t\tniceFraction
    = 10;\r\n\t\t\t}\r\n\t\t} else if (fraction <= 1.0) {\r\n\t\t\tniceFraction =
    1;\r\n\t\t} else if (fraction <= 2) {\r\n\t\t\tniceFraction = 2;\r\n\t\t} else
    if (fraction <= 5) {\r\n\t\t\tniceFraction = 5;\r\n\t\t} else {\r\n\t\t\tniceFraction
    = 10;\r\n\t\t}\r\n\r\n\t\treturn niceFraction * Math.pow(10, exponent);\r\n\t};\r\n\t//
    Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\thelpers$1.requestAnimFrame
    = (function() {\r\n\t\tif (typeof window === 'undefined') {\r\n\t\t\treturn function(callback)
    {\r\n\t\t\t\tcallback();\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn window.requestAnimationFrame
    ||\r\n\t\t\twindow.webkitRequestAnimationFrame ||\r\n\t\t\twindow.mozRequestAnimationFrame
    ||\r\n\t\t\twindow.oRequestAnimationFrame ||\r\n\t\t\twindow.msRequestAnimationFrame
    ||\r\n\t\t\tfunction(callback) {\r\n\t\t\t\treturn window.setTimeout(callback,
    1000 / 60);\r\n\t\t\t};\r\n\t}());\r\n\t// -- DOM methods\r\n\thelpers$1.getRelativePosition
    = function(evt, chart) {\r\n\t\tvar mouseX, mouseY;\r\n\t\tvar e = evt.originalEvent
    || evt;\r\n\t\tvar canvas = evt.target || evt.srcElement;\r\n\t\tvar boundingRect
    = canvas.getBoundingClientRect();\r\n\r\n\t\tvar touches = e.touches;\r\n\t\tif
    (touches && touches.length > 0) {\r\n\t\t\tmouseX = touches[0].clientX;\r\n\t\t\tmouseY
    = touches[0].clientY;\r\n\r\n\t\t} else {\r\n\t\t\tmouseX = e.clientX;\r\n\t\t\tmouseY
    = e.clientY;\r\n\t\t}\r\n\r\n\t\t// Scale mouse coordinates into canvas coordinates\r\n\t\t//
    by following the pattern laid out by 'jerryj' in the comments of\r\n\t\t// https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\r\n\t\tvar
    paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\r\n\t\tvar
    paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\r\n\t\tvar
    paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\r\n\t\tvar
    paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\r\n\t\tvar
    width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\r\n\t\tvar
    height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\r\n\r\n\t\t//
    We divide by the current device pixel ratio, because the canvas is scaled up by
    that amount in each direction. However\r\n\t\t// the backend model is in unscaled
    coordinates. Since we are going to deal with our model coordinates, we go back
    here\r\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width)
    * canvas.width / chart.currentDevicePixelRatio);\r\n\t\tmouseY = Math.round((mouseY
    - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\r\n\r\n\t\treturn
    {\r\n\t\t\tx: mouseX,\r\n\t\t\ty: mouseY\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t// Private
    helper function to convert max-width/max-height values that may be percentages
    into a number\r\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\r\n\t\tvar
    valueInPixels;\r\n\t\tif (typeof styleValue === 'string') {\r\n\t\t\tvalueInPixels
    = parseInt(styleValue, 10);\r\n\r\n\t\t\tif (styleValue.indexOf('%') !== -1) {\r\n\t\t\t\t//
    percentage * size in dimension\r\n\t\t\t\tvalueInPixels = valueInPixels / 100
    * node.parentNode[parentProperty];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalueInPixels
    = styleValue;\r\n\t\t}\r\n\r\n\t\treturn valueInPixels;\r\n\t}\r\n\r\n\t/**\r\n\t
    * Returns if the given value contains an effective constraint.\r\n\t * @private\r\n\t
    */\r\n\tfunction isConstrainedValue(value) {\r\n\t\treturn value !== undefined
    && value !== null && value !== 'none';\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the
    max width or height of the given DOM node in a cross-browser compatible fashion\r\n\t
    * @param {HTMLElement} domNode - the node to check the constraint on\r\n\t * @param
    {string} maxStyle - the style that defines the maximum for the direction we are
    using ('max-width' / 'max-height')\r\n\t * @param {string} percentageProperty
    - property of parent to use when calculating width as a percentage\r\n\t * @see
    {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\r\n\t
    */\r\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty)
    {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers$1._getParentNode(domNode);\r\n\t\tvar
    constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer
    = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar
    hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity
    = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn
    Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty)
    : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode,
    percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r\n\t//
    returns Number or undefined if no constraint\r\n\thelpers$1.getConstraintWidth
    = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-width',
    'clientWidth');\r\n\t};\r\n\t// returns Number or undefined if no constraint\r\n\thelpers$1.getConstraintHeight
    = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-height',
    'clientHeight');\r\n\t};\r\n\t/**\r\n\t * @private\r\n \t */\r\n\thelpers$1._calculatePadding
    = function(container, padding, parentDimension) {\r\n\t\tpadding = helpers$1.getStyle(container,
    padding);\r\n\r\n\t\treturn padding.indexOf('%') > -1 ? parentDimension * parseInt(padding,
    10) / 100 : parseInt(padding, 10);\r\n\t};\r\n\t/**\r\n\t * @private\r\n\t */\r\n\thelpers$1._getParentNode
    = function(domNode) {\r\n\t\tvar parent = domNode.parentNode;\r\n\t\tif (parent
    && parent.toString() === '[object ShadowRoot]') {\r\n\t\t\tparent = parent.host;\r\n\t\t}\r\n\t\treturn
    parent;\r\n\t};\r\n\thelpers$1.getMaximumWidth = function(domNode) {\r\n\t\tvar
    container = helpers$1._getParentNode(domNode);\r\n\t\tif (!container) {\r\n\t\t\treturn
    domNode.clientWidth;\r\n\t\t}\r\n\r\n\t\tvar clientWidth = container.clientWidth;\r\n\t\tvar
    paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\r\n\t\tvar
    paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\r\n\r\n\t\tvar
    w = clientWidth - paddingLeft - paddingRight;\r\n\t\tvar cw = helpers$1.getConstraintWidth(domNode);\r\n\t\treturn
    isNaN(cw) ? w : Math.min(w, cw);\r\n\t};\r\n\thelpers$1.getMaximumHeight = function(domNode)
    {\r\n\t\tvar container = helpers$1._getParentNode(domNode);\r\n\t\tif (!container)
    {\r\n\t\t\treturn domNode.clientHeight;\r\n\t\t}\r\n\r\n\t\tvar clientHeight =
    container.clientHeight;\r\n\t\tvar paddingTop = helpers$1._calculatePadding(container,
    'padding-top', clientHeight);\r\n\t\tvar paddingBottom = helpers$1._calculatePadding(container,
    'padding-bottom', clientHeight);\r\n\r\n\t\tvar h = clientHeight - paddingTop
    - paddingBottom;\r\n\t\tvar ch = helpers$1.getConstraintHeight(domNode);\r\n\t\treturn
    isNaN(ch) ? h : Math.min(h, ch);\r\n\t};\r\n\thelpers$1.getStyle = function(el,
    property) {\r\n\t\treturn el.currentStyle ?\r\n\t\t\tel.currentStyle[property]
    :\r\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\r\n\t};\r\n\thelpers$1.retinaScale
    = function(chart, forceRatio) {\r\n\t\tvar pixelRatio = chart.currentDevicePixelRatio
    = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) ||
    1;\r\n\t\tif (pixelRatio === 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar canvas
    = chart.canvas;\r\n\t\tvar height = chart.height;\r\n\t\tvar width = chart.width;\r\n\r\n\t\tcanvas.height
    = height * pixelRatio;\r\n\t\tcanvas.width = width * pixelRatio;\r\n\t\tchart.ctx.scale(pixelRatio,
    pixelRatio);\r\n\r\n\t\t// If no style has been set on the canvas, the render
    size is used as display size,\r\n\t\t// making the chart visually bigger, so let's
    enforce it to the \"correct\" values.\r\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\r\n\t\tif
    (!canvas.style.height && !canvas.style.width) {\r\n\t\t\tcanvas.style.height =
    height + 'px';\r\n\t\t\tcanvas.style.width = width + 'px';\r\n\t\t}\r\n\t};\r\n\t//
    -- Canvas methods\r\n\thelpers$1.fontString = function(pixelSize, fontStyle, fontFamily)
    {\r\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n\t};\r\n\thelpers$1.longestText
    = function(ctx, font, arrayOfThings, cache) {\r\n\t\tcache = cache || {};\r\n\t\tvar
    data = cache.data = cache.data || {};\r\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect
    || [];\r\n\r\n\t\tif (cache.font !== font) {\r\n\t\t\tdata = cache.data = {};\r\n\t\t\tgc
    = cache.garbageCollect = [];\r\n\t\t\tcache.font = font;\r\n\t\t}\r\n\r\n\t\tctx.font
    = font;\r\n\t\tvar longest = 0;\r\n\t\tvar ilen = arrayOfThings.length;\r\n\t\tvar
    i, j, jlen, thing, nestedThing;\r\n\t\tfor (i = 0; i < ilen; i++) {\r\n\t\t\tthing
    = arrayOfThings[i];\r\n\r\n\t\t\t// Undefined strings and arrays should not be
    measured\r\n\t\t\tif (thing !== undefined && thing !== null && helpers$1.isArray(thing)
    !== true) {\r\n\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest,
    thing);\r\n\t\t\t} else if (helpers$1.isArray(thing)) {\r\n\t\t\t\t// if it is
    an array lets measure each element\r\n\t\t\t\t// to do maybe simplify this function
    a bit so we can do this more recursively?\r\n\t\t\t\tfor (j = 0, jlen = thing.length;
    j < jlen; j++) {\r\n\t\t\t\t\tnestedThing = thing[j];\r\n\t\t\t\t\t// Undefined
    strings and arrays should not be measured\r\n\t\t\t\t\tif (nestedThing !== undefined
    && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\r\n\t\t\t\t\t\tlongest
    = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar
    gcLen = gc.length / 2;\r\n\t\tif (gcLen > arrayOfThings.length) {\r\n\t\t\tfor
    (i = 0; i < gcLen; i++) {\r\n\t\t\t\tdelete data[gc[i]];\r\n\t\t\t}\r\n\t\t\tgc.splice(0,
    gcLen);\r\n\t\t}\r\n\t\treturn longest;\r\n\t};\r\n\thelpers$1.measureText = function(ctx,
    data, gc, longest, string) {\r\n\t\tvar textWidth = data[string];\r\n\t\tif (!textWidth)
    {\r\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\r\n\t\t\tgc.push(string);\r\n\t\t}\r\n\t\tif
    (textWidth > longest) {\r\n\t\t\tlongest = textWidth;\r\n\t\t}\r\n\t\treturn longest;\r\n\t};\r\n\r\n\t/**\r\n\t
    * @deprecated\r\n\t */\r\n\thelpers$1.numberOfLabelLines = function(arrayOfThings)
    {\r\n\t\tvar numberOfLines = 1;\r\n\t\thelpers$1.each(arrayOfThings, function(thing)
    {\r\n\t\t\tif (helpers$1.isArray(thing)) {\r\n\t\t\t\tif (thing.length > numberOfLines)
    {\r\n\t\t\t\t\tnumberOfLines = thing.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn
    numberOfLines;\r\n\t};\r\n\r\n\thelpers$1.color = !chartjsColor ?\r\n\t\tfunction(value)
    {\r\n\t\t\tconsole.error('Color.js not found!');\r\n\t\t\treturn value;\r\n\t\t}
    :\r\n\t\tfunction(value) {\r\n\t\t\t/* global CanvasGradient */\r\n\t\t\tif (value
    instanceof CanvasGradient) {\r\n\t\t\t\tvalue = core_defaults.global.defaultColor;\r\n\t\t\t}\r\n\r\n\t\t\treturn
    chartjsColor(value);\r\n\t\t};\r\n\r\n\thelpers$1.getHoverColor = function(colorValue)
    {\r\n\t\t/* global CanvasPattern */\r\n\t\treturn (colorValue instanceof CanvasPattern
    || colorValue instanceof CanvasGradient) ?\r\n\t\t\tcolorValue :\r\n\t\t\thelpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\r\n\t};\r\n};\n\nfunction
    abstract() {\r\n\tthrow new Error(\r\n\t\t'This method is not implemented: either
    no adapter can ' +\r\n\t\t'be found or an incomplete integration was provided.'\r\n\t);\r\n}\r\n\r\n/**\r\n
    * Date adapter (current used by the time scale)\r\n * @namespace Chart._adapters._date\r\n
    * @memberof Chart._adapters\r\n * @private\r\n */\r\n\r\n/**\r\n * Currently supported
    unit string values.\r\n * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\r\n
    * @memberof Chart._adapters._date\r\n * @name Unit\r\n */\r\n\r\n/**\r\n * @class\r\n
    */\r\nfunction DateAdapter(options) {\r\n\tthis.options = options || {};\r\n}\r\n\r\nhelpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */ {\r\n\t/**\r\n\t * Returns a map of time formats for
    the supported formatting units defined\r\n\t * in Unit as well as 'datetime' representing
    a detailed date/time string.\r\n\t * @returns {{string: string}}\r\n\t */\r\n\tformats:
    abstract,\r\n\r\n\t/**\r\n\t * Parses the given `value` and return the associated
    timestamp.\r\n\t * @param {any} value - the value to parse (usually comes from
    the data)\r\n\t * @param {string} [format] - the expected data format\r\n\t *
    @returns {(number|null)}\r\n\t * @function\r\n\t */\r\n\tparse: abstract,\r\n\r\n\t/**\r\n\t
    * Returns the formatted date in the specified `format` for a given `timestamp`.\r\n\t
    * @param {number} timestamp - the timestamp to format\r\n\t * @param {string}
    format - the date/time token\r\n\t * @return {string}\r\n\t * @function\r\n\t
    */\r\n\tformat: abstract,\r\n\r\n\t/**\r\n\t * Adds the specified `amount` of
    `unit` to the given `timestamp`.\r\n\t * @param {number} timestamp - the input
    timestamp\r\n\t * @param {number} amount - the amount to add\r\n\t * @param {Unit}
    unit - the unit as string\r\n\t * @return {number}\r\n\t * @function\r\n\t */\r\n\tadd:
    abstract,\r\n\r\n\t/**\r\n\t * Returns the number of `unit` between the given
    timestamps.\r\n\t * @param {number} max - the input timestamp (reference)\r\n\t
    * @param {number} min - the timestamp to substract\r\n\t * @param {Unit} unit
    - the unit as string\r\n\t * @return {number}\r\n\t * @function\r\n\t */\r\n\tdiff:
    abstract,\r\n\r\n\t/**\r\n\t * Returns start of `unit` for the given `timestamp`.\r\n\t
    * @param {number} timestamp - the input timestamp\r\n\t * @param {Unit} unit -
    the unit as string\r\n\t * @param {number} [weekday] - the ISO day of the week
    with 1 being Monday\r\n\t * and 7 being Sunday (only needed if param *unit* is
    `isoWeek`).\r\n\t * @function\r\n\t */\r\n\tstartOf: abstract,\r\n\r\n\t/**\r\n\t
    * Returns end of `unit` for the given `timestamp`.\r\n\t * @param {number} timestamp
    - the input timestamp\r\n\t * @param {Unit} unit - the unit as string\r\n\t *
    @function\r\n\t */\r\n\tendOf: abstract,\r\n\r\n\t// DEPRECATIONS\r\n\r\n\t/**\r\n\t
    * Provided for backward compatibility for scale.getValueForPixel(),\r\n\t * this
    method should be overridden only by the moment adapter.\r\n\t * @deprecated since
    version 2.8.0\r\n\t * @todo remove at version 3\r\n\t * @private\r\n\t */\r\n\t_create:
    function(value) {\r\n\t\treturn value;\r\n\t}\r\n});\r\n\r\nDateAdapter.override
    = function(members) {\r\n\thelpers$1.extend(DateAdapter.prototype, members);\r\n};\r\n\r\nvar
    _date = DateAdapter;\n\nvar core_adapters = {\n\t_date: _date\n};\n\n/**\r\n *
    Namespace to hold static tick generation functions\r\n * @namespace Chart.Ticks\r\n
    */\r\nvar core_ticks = {\r\n\t/**\r\n\t * Namespace to hold formatters for different
    types of ticks\r\n\t * @namespace Chart.Ticks.formatters\r\n\t */\r\n\tformatters:
    {\r\n\t\t/**\r\n\t\t * Formatter for value labels\r\n\t\t * @method Chart.Ticks.formatters.values\r\n\t\t
    * @param value the value to display\r\n\t\t * @return {string|string[]} the label
    to display\r\n\t\t */\r\n\t\tvalues: function(value) {\r\n\t\t\treturn helpers$1.isArray(value)
    ? value : '' + value;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Formatter for linear
    numeric ticks\r\n\t\t * @method Chart.Ticks.formatters.linear\r\n\t\t * @param
    tickValue {number} the value to be formatted\r\n\t\t * @param index {number} the
    position of the tickValue parameter in the ticks array\r\n\t\t * @param ticks
    {number[]} the list of ticks being converted\r\n\t\t * @return {string} string
    representation of the tickValue parameter\r\n\t\t */\r\n\t\tlinear: function(tickValue,
    index, ticks) {\r\n\t\t\t// If we have lots of ticks, don't use the ones\r\n\t\t\tvar
    delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\r\n\r\n\t\t\t//
    If we have a number like 2.5 as the delta, figure out how many decimal places
    we need\r\n\t\t\tif (Math.abs(delta) > 1) {\r\n\t\t\t\tif (tickValue !== Math.floor(tickValue))
    {\r\n\t\t\t\t\t// not an integer\r\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar
    logDelta = helpers$1.log10(Math.abs(delta));\r\n\t\t\tvar tickString = '';\r\n\r\n\t\t\tif
    (tickValue !== 0) {\r\n\t\t\t\tvar maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length
    - 1]));\r\n\t\t\t\tif (maxTick < 1e-4) { // all ticks are small numbers; use scientific
    notation\r\n\t\t\t\t\tvar logTick = helpers$1.log10(Math.abs(tickValue));\r\n\t\t\t\t\tvar
    numExponential = Math.floor(logTick) - Math.floor(logDelta);\r\n\t\t\t\t\tnumExponential
    = Math.max(Math.min(numExponential, 20), 0);\r\n\t\t\t\t\ttickString = tickValue.toExponential(numExponential);\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\r\n\t\t\t\t\tnumDecimal
    = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\r\n\t\t\t\t\ttickString
    = tickValue.toFixed(numDecimal);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttickString
    = '0'; // never show decimal places for 0\r\n\t\t\t}\r\n\r\n\t\t\treturn tickString;\r\n\t\t},\r\n\r\n\t\tlogarithmic:
    function(tickValue, index, ticks) {\r\n\t\t\tvar remain = tickValue / (Math.pow(10,
    Math.floor(helpers$1.log10(tickValue))));\r\n\r\n\t\t\tif (tickValue === 0) {\r\n\t\t\t\treturn
    '0';\r\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index
    === 0 || index === ticks.length - 1) {\r\n\t\t\t\treturn tickValue.toExponential();\r\n\t\t\t}\r\n\t\t\treturn
    '';\r\n\t\t}\r\n\t}\r\n};\n\nvar isArray = helpers$1.isArray;\r\nvar isNullOrUndef
    = helpers$1.isNullOrUndef;\r\nvar valueOrDefault$a = helpers$1.valueOrDefault;\r\nvar
    valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\r\n\r\ncore_defaults._set('scale',
    {\r\n\tdisplay: true,\r\n\tposition: 'left',\r\n\toffset: false,\r\n\r\n\t// grid
    line settings\r\n\tgridLines: {\r\n\t\tdisplay: true,\r\n\t\tcolor: 'rgba(0,0,0,0.1)',\r\n\t\tlineWidth:
    1,\r\n\t\tdrawBorder: true,\r\n\t\tdrawOnChartArea: true,\r\n\t\tdrawTicks: true,\r\n\t\ttickMarkLength:
    10,\r\n\t\tzeroLineWidth: 1,\r\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\r\n\t\tzeroLineBorderDash:
    [],\r\n\t\tzeroLineBorderDashOffset: 0.0,\r\n\t\toffsetGridLines: false,\r\n\t\tborderDash:
    [],\r\n\t\tborderDashOffset: 0.0\r\n\t},\r\n\r\n\t// scale label\r\n\tscaleLabel:
    {\r\n\t\t// display property\r\n\t\tdisplay: false,\r\n\r\n\t\t// actual label\r\n\t\tlabelString:
    '',\r\n\r\n\t\t// top/bottom padding\r\n\t\tpadding: {\r\n\t\t\ttop: 4,\r\n\t\t\tbottom:
    4\r\n\t\t}\r\n\t},\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\tbeginAtZero:
    false,\r\n\t\tminRotation: 0,\r\n\t\tmaxRotation: 50,\r\n\t\tmirror: false,\r\n\t\tpadding:
    0,\r\n\t\treverse: false,\r\n\t\tdisplay: true,\r\n\t\tautoSkip: true,\r\n\t\tautoSkipPadding:
    0,\r\n\t\tlabelOffset: 0,\r\n\t\t// We pass through arrays to be rendered as multiline
    labels, we convert Others to strings here.\r\n\t\tcallback: core_ticks.formatters.values,\r\n\t\tminor:
    {},\r\n\t\tmajor: {}\r\n\t}\r\n});\r\n\r\n/** Returns a new array containing numItems
    from arr */\r\nfunction sample(arr, numItems) {\r\n\tvar result = [];\r\n\tvar
    increment = arr.length / numItems;\r\n\tvar i = 0;\r\n\tvar len = arr.length;\r\n\r\n\tfor
    (; i < len; i += increment) {\r\n\t\tresult.push(arr[Math.floor(i)]);\r\n\t}\r\n\treturn
    result;\r\n}\r\n\r\nfunction getPixelForGridLine(scale, index, offsetGridLines)
    {\r\n\tvar length = scale.getTicks().length;\r\n\tvar validIndex = Math.min(index,
    length - 1);\r\n\tvar lineValue = scale.getPixelForTick(validIndex);\r\n\tvar
    start = scale._startPixel;\r\n\tvar end = scale._endPixel;\r\n\tvar epsilon =
    1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n\tvar offset;\r\n\r\n\tif
    (offsetGridLines) {\r\n\t\tif (length === 1) {\r\n\t\t\toffset = Math.max(lineValue
    - start, end - lineValue);\r\n\t\t} else if (index === 0) {\r\n\t\t\toffset =
    (scale.getPixelForTick(1) - lineValue) / 2;\r\n\t\t} else {\r\n\t\t\toffset =
    (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n\t\t}\r\n\t\tlineValue
    += validIndex < index ? offset : -offset;\r\n\r\n\t\t// Return undefined if the
    pixel is out of the range\r\n\t\tif (lineValue < start - epsilon || lineValue
    > end + epsilon) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\treturn lineValue;\r\n}\r\n\r\nfunction
    garbageCollect(caches, length) {\r\n\thelpers$1.each(caches, function(cache) {\r\n\t\tvar
    gc = cache.gc;\r\n\t\tvar gcLen = gc.length / 2;\r\n\t\tvar i;\r\n\t\tif (gcLen
    > length) {\r\n\t\t\tfor (i = 0; i < gcLen; ++i) {\r\n\t\t\t\tdelete cache.data[gc[i]];\r\n\t\t\t}\r\n\t\t\tgc.splice(0,
    gcLen);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Returns {width, height, offset}
    objects for the first, last, widest, highest tick\r\n * labels where offset indicates
    the anchor point offset from the top in pixels.\r\n */\r\nfunction computeLabelSizes(ctx,
    tickFonts, ticks, caches) {\r\n\tvar length = ticks.length;\r\n\tvar widths =
    [];\r\n\tvar heights = [];\r\n\tvar offsets = [];\r\n\tvar widestLabelSize = 0;\r\n\tvar
    highestLabelSize = 0;\r\n\tvar i, j, jlen, label, tickFont, fontString, cache,
    lineHeight, width, height, nestedLabel, widest, highest;\r\n\r\n\tfor (i = 0;
    i < length; ++i) {\r\n\t\tlabel = ticks[i].label;\r\n\t\ttickFont = ticks[i].major
    ? tickFonts.major : tickFonts.minor;\r\n\t\tctx.font = fontString = tickFont.string;\r\n\t\tcache
    = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n\t\tlineHeight
    = tickFont.lineHeight;\r\n\t\twidth = height = 0;\r\n\t\t// Undefined labels and
    arrays should not be measured\r\n\t\tif (!isNullOrUndef(label) && !isArray(label))
    {\r\n\t\t\twidth = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);\r\n\t\t\theight
    = lineHeight;\r\n\t\t} else if (isArray(label)) {\r\n\t\t\t// if it is an array
    let's measure each element\r\n\t\t\tfor (j = 0, jlen = label.length; j < jlen;
    ++j) {\r\n\t\t\t\tnestedLabel = label[j];\r\n\t\t\t\t// Undefined labels and arrays
    should not be measured\r\n\t\t\t\tif (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel))
    {\r\n\t\t\t\t\twidth = helpers$1.measureText(ctx, cache.data, cache.gc, width,
    nestedLabel);\r\n\t\t\t\t\theight += lineHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twidths.push(width);\r\n\t\theights.push(height);\r\n\t\toffsets.push(lineHeight
    / 2);\r\n\t\twidestLabelSize = Math.max(width, widestLabelSize);\r\n\t\thighestLabelSize
    = Math.max(height, highestLabelSize);\r\n\t}\r\n\tgarbageCollect(caches, length);\r\n\r\n\twidest
    = widths.indexOf(widestLabelSize);\r\n\thighest = heights.indexOf(highestLabelSize);\r\n\r\n\tfunction
    valueAt(idx) {\r\n\t\treturn {\r\n\t\t\twidth: widths[idx] || 0,\r\n\t\t\theight:
    heights[idx] || 0,\r\n\t\t\toffset: offsets[idx] || 0\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tfirst: valueAt(0),\r\n\t\tlast: valueAt(length - 1),\r\n\t\twidest: valueAt(widest),\r\n\t\thighest:
    valueAt(highest)\r\n\t};\r\n}\r\n\r\nfunction getTickMarkLength(options) {\r\n\treturn
    options.drawTicks ? options.tickMarkLength : 0;\r\n}\r\n\r\nfunction getScaleLabelHeight(options)
    {\r\n\tvar font, padding;\r\n\r\n\tif (!options.display) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfont
    = helpers$1.options._parseFont(options);\r\n\tpadding = helpers$1.options.toPadding(options.padding);\r\n\r\n\treturn
    font.lineHeight + padding.height;\r\n}\r\n\r\nfunction parseFontOptions(options,
    nestedOpts) {\r\n\treturn helpers$1.extend(helpers$1.options._parseFont({\r\n\t\tfontFamily:
    valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),\r\n\t\tfontSize:
    valueOrDefault$a(nestedOpts.fontSize, options.fontSize),\r\n\t\tfontStyle: valueOrDefault$a(nestedOpts.fontStyle,
    options.fontStyle),\r\n\t\tlineHeight: valueOrDefault$a(nestedOpts.lineHeight,
    options.lineHeight)\r\n\t}), {\r\n\t\tcolor: helpers$1.options.resolve([nestedOpts.fontColor,
    options.fontColor, core_defaults.global.defaultFontColor])\r\n\t});\r\n}\r\n\r\nfunction
    parseTickFontOptions(options) {\r\n\tvar minor = parseFontOptions(options, options.minor);\r\n\tvar
    major = options.major.enabled ? parseFontOptions(options, options.major) : minor;\r\n\r\n\treturn
    {minor: minor, major: major};\r\n}\r\n\r\nfunction nonSkipped(ticksToFilter) {\r\n\tvar
    filtered = [];\r\n\tvar item, index, len;\r\n\tfor (index = 0, len = ticksToFilter.length;
    index < len; ++index) {\r\n\t\titem = ticksToFilter[index];\r\n\t\tif (typeof
    item._index !== 'undefined') {\r\n\t\t\tfiltered.push(item);\r\n\t\t}\r\n\t}\r\n\treturn
    filtered;\r\n}\r\n\r\nfunction getEvenSpacing(arr) {\r\n\tvar len = arr.length;\r\n\tvar
    i, diff;\r\n\r\n\tif (len < 2) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor (diff
    = arr[0], i = 1; i < len; ++i) {\r\n\t\tif (arr[i] - arr[i - 1] !== diff) {\r\n\t\t\treturn
    false;\r\n\t\t}\r\n\t}\r\n\treturn diff;\r\n}\r\n\r\nfunction calculateSpacing(majorIndices,
    ticks, axisLength, ticksLimit) {\r\n\tvar evenMajorSpacing = getEvenSpacing(majorIndices);\r\n\tvar
    spacing = (ticks.length - 1) / ticksLimit;\r\n\tvar factors, factor, i, ilen;\r\n\r\n\t//
    If the major ticks are evenly spaced apart, place the minor ticks\r\n\t// so that
    they divide the major ticks into even chunks\r\n\tif (!evenMajorSpacing) {\r\n\t\treturn
    Math.max(spacing, 1);\r\n\t}\r\n\r\n\tfactors = helpers$1.math._factorize(evenMajorSpacing);\r\n\tfor
    (i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n\t\tfactor = factors[i];\r\n\t\tif
    (factor > spacing) {\r\n\t\t\treturn factor;\r\n\t\t}\r\n\t}\r\n\treturn Math.max(spacing,
    1);\r\n}\r\n\r\nfunction getMajorIndices(ticks) {\r\n\tvar result = [];\r\n\tvar
    i, ilen;\r\n\tfor (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n\t\tif (ticks[i].major)
    {\r\n\t\t\tresult.push(i);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction
    skipMajors(ticks, majorIndices, spacing) {\r\n\tvar count = 0;\r\n\tvar next =
    majorIndices[0];\r\n\tvar i, tick;\r\n\r\n\tspacing = Math.ceil(spacing);\r\n\tfor
    (i = 0; i < ticks.length; i++) {\r\n\t\ttick = ticks[i];\r\n\t\tif (i === next)
    {\r\n\t\t\ttick._index = i;\r\n\t\t\tcount++;\r\n\t\t\tnext = majorIndices[count
    * spacing];\r\n\t\t} else {\r\n\t\t\tdelete tick.label;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction
    skip(ticks, spacing, majorStart, majorEnd) {\r\n\tvar start = valueOrDefault$a(majorStart,
    0);\r\n\tvar end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);\r\n\tvar
    count = 0;\r\n\tvar length, i, tick, next;\r\n\r\n\tspacing = Math.ceil(spacing);\r\n\tif
    (majorEnd) {\r\n\t\tlength = majorEnd - majorStart;\r\n\t\tspacing = length /
    Math.floor(length / spacing);\r\n\t}\r\n\r\n\tnext = start;\r\n\r\n\twhile (next
    < 0) {\r\n\t\tcount++;\r\n\t\tnext = Math.round(start + count * spacing);\r\n\t}\r\n\r\n\tfor
    (i = Math.max(start, 0); i < end; i++) {\r\n\t\ttick = ticks[i];\r\n\t\tif (i
    === next) {\r\n\t\t\ttick._index = i;\r\n\t\t\tcount++;\r\n\t\t\tnext = Math.round(start
    + count * spacing);\r\n\t\t} else {\r\n\t\t\tdelete tick.label;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvar
    Scale = core_element.extend({\r\n\r\n\tzeroLineIndex: 0,\r\n\r\n\t/**\r\n\t *
    Get the padding needed for the scale\r\n\t * @method getPadding\r\n\t * @private\r\n\t
    * @returns {Padding} the necessary padding\r\n\t */\r\n\tgetPadding: function()
    {\r\n\t\tvar me = this;\r\n\t\treturn {\r\n\t\t\tleft: me.paddingLeft || 0,\r\n\t\t\ttop:
    me.paddingTop || 0,\r\n\t\t\tright: me.paddingRight || 0,\r\n\t\t\tbottom: me.paddingBottom
    || 0\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the scale tick objects ({label,
    major})\r\n\t * @since 2.7\r\n\t */\r\n\tgetTicks: function() {\r\n\t\treturn
    this._ticks;\r\n\t},\r\n\r\n\t/**\r\n\t* @private\r\n\t*/\r\n\t_getLabels: function()
    {\r\n\t\tvar data = this.chart.data;\r\n\t\treturn this.options.labels || (this.isHorizontal()
    ? data.xLabels : data.yLabels) || data.labels || [];\r\n\t},\r\n\r\n\t// These
    methods are ordered by lifecyle. Utilities then follow.\r\n\t// Any function defined
    here is inherited by all scale types.\r\n\t// Any function can be extended by
    the scale type\r\n\r\n\t/**\r\n\t * Provided for backward compatibility, not available
    anymore\r\n\t * @function Chart.Scale.mergeTicksOptions\r\n\t * @deprecated since
    version 2.8.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\tmergeTicksOptions:
    function() {\r\n\t\t// noop\r\n\t},\r\n\r\n\tbeforeUpdate: function() {\r\n\t\thelpers$1.callback(this.options.beforeUpdate,
    [this]);\r\n\t},\r\n\r\n\t/**\r\n\t * @param {number} maxWidth - the max width
    in pixels\r\n\t * @param {number} maxHeight - the max height in pixels\r\n\t *
    @param {object} margins - the space between the edge of the other scales and edge
    of the chart\r\n\t *   This space comes from two sources:\r\n\t *     - padding
    - space that's required to show the labels at the edges of the scale\r\n\t *     -
    thickness of scales or legends in another orientation\r\n\t */\r\n\tupdate: function(maxWidth,
    maxHeight, margins) {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    sampleSize = tickOpts.sampleSize;\r\n\t\tvar i, ilen, labels, ticks, samplingEnabled;\r\n\r\n\t\t//
    Update Lifecycle - Probably don't want to ever extend or overwrite this function
    ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth
    = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = helpers$1.extend({\r\n\t\t\tleft:
    0,\r\n\t\t\tright: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tbottom: 0\r\n\t\t}, margins);\r\n\r\n\t\tme._ticks
    = null;\r\n\t\tme.ticks = null;\r\n\t\tme._labelSizes = null;\r\n\t\tme._maxLabelLines
    = 0;\r\n\t\tme.longestLabelWidth = 0;\r\n\t\tme.longestTextCache = me.longestTextCache
    || {};\r\n\t\tme._gridLineItems = null;\r\n\t\tme._labelItems = null;\r\n\r\n\t\t//
    Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\r\n\t\t//
    Data min/max\r\n\t\tme.beforeDataLimits();\r\n\t\tme.determineDataLimits();\r\n\t\tme.afterDataLimits();\r\n\r\n\t\t//
    Ticks - `this.ticks` is now DEPRECATED!\r\n\t\t// Internal ticks are now stored
    as objects in the PRIVATE `this._ticks` member\r\n\t\t// and must not be accessed
    directly from outside this class. `this.ticks` being\r\n\t\t// around for long
    time and not marked as private, we can't change its structure\r\n\t\t// without
    unexpected breaking changes. If you need to access the scale ticks,\r\n\t\t//
    use scale.getTicks() instead.\r\n\r\n\t\tme.beforeBuildTicks();\r\n\r\n\t\t//
    New implementations should return an array of objects but for BACKWARD COMPAT,\r\n\t\t//
    we still support no return (`this.ticks` internally set by calling this method).\r\n\t\tticks
    = me.buildTicks() || [];\r\n\r\n\t\t// Allow modification of ticks in callback.\r\n\t\tticks
    = me.afterBuildTicks(ticks) || ticks;\r\n\r\n\t\t// Ensure ticks contains ticks
    in new tick format\r\n\t\tif ((!ticks || !ticks.length) && me.ticks) {\r\n\t\t\tticks
    = [];\r\n\t\t\tfor (i = 0, ilen = me.ticks.length; i < ilen; ++i) {\r\n\t\t\t\tticks.push({\r\n\t\t\t\t\tvalue:
    me.ticks[i],\r\n\t\t\t\t\tmajor: false\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme._ticks
    = ticks;\r\n\r\n\t\t// Compute tick rotation and fit using a sampled subset of
    labels\r\n\t\t// We generally don't need to compute the size of every single label
    for determining scale size\r\n\t\tsamplingEnabled = sampleSize < ticks.length;\r\n\t\tlabels
    = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);\r\n\r\n\t\t//
    _configure is called twice, once here, once from core.controller.updateLayout.\r\n\t\t//
    Here we haven't been positioned yet, but dimensions are correct.\r\n\t\t// Variables
    set in _configure are needed for calculateTickRotation, and\r\n\t\t// it's ok
    that coordinates are not correct there, only dimensions matter.\r\n\t\tme._configure();\r\n\r\n\t\t//
    Tick Rotation\r\n\t\tme.beforeCalculateTickRotation();\r\n\t\tme.calculateTickRotation();\r\n\t\tme.afterCalculateTickRotation();\r\n\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\r\n\t\t//
    Auto-skip\r\n\t\tme._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source
    === 'auto') ? me._autoSkip(ticks) : ticks;\r\n\r\n\t\tif (samplingEnabled) {\r\n\t\t\t//
    Generate labels using all non-skipped ticks\r\n\t\t\tlabels = me._convertTicksToLabels(me._ticksToDraw);\r\n\t\t}\r\n\r\n\t\tme.ticks
    = labels;   // BACKWARD COMPATIBILITY\r\n\r\n\t\t// IMPORTANT: after this point,
    we consider that `this.ticks` will NEVER change!\r\n\r\n\t\tme.afterUpdate();\r\n\r\n\t\t//
    TODO(v3): remove minSize as a public property and return value from all layout
    boxes. It is unused\r\n\t\t// make maxWidth and maxHeight private\r\n\t\treturn
    me.minSize;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_configure: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar reversePixels = me.options.ticks.reverse;\r\n\t\tvar
    startPixel, endPixel;\r\n\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\tstartPixel
    = me.left;\r\n\t\t\tendPixel = me.right;\r\n\t\t} else {\r\n\t\t\tstartPixel =
    me.top;\r\n\t\t\tendPixel = me.bottom;\r\n\t\t\t// by default vertical scales
    are from bottom to top, so pixels are reversed\r\n\t\t\treversePixels = !reversePixels;\r\n\t\t}\r\n\t\tme._startPixel
    = startPixel;\r\n\t\tme._endPixel = endPixel;\r\n\t\tme._reversePixels = reversePixels;\r\n\t\tme._length
    = endPixel - startPixel;\r\n\t},\r\n\r\n\tafterUpdate: function() {\r\n\t\thelpers$1.callback(this.options.afterUpdate,
    [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions: function() {\r\n\t\thelpers$1.callback(this.options.beforeSetDimensions,
    [this]);\r\n\t},\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t//
    Set the unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal())
    {\r\n\t\t\t// Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left
    = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom
    = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop
    = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\t},\r\n\tafterSetDimensions:
    function() {\r\n\t\thelpers$1.callback(this.options.afterSetDimensions, [this]);\r\n\t},\r\n\r\n\t//
    Data limits\r\n\tbeforeDataLimits: function() {\r\n\t\thelpers$1.callback(this.options.beforeDataLimits,
    [this]);\r\n\t},\r\n\tdetermineDataLimits: helpers$1.noop,\r\n\tafterDataLimits:
    function() {\r\n\t\thelpers$1.callback(this.options.afterDataLimits, [this]);\r\n\t},\r\n\r\n\t//\r\n\tbeforeBuildTicks:
    function() {\r\n\t\thelpers$1.callback(this.options.beforeBuildTicks, [this]);\r\n\t},\r\n\tbuildTicks:
    helpers$1.noop,\r\n\tafterBuildTicks: function(ticks) {\r\n\t\tvar me = this;\r\n\t\t//
    ticks is empty for old axis implementations here\r\n\t\tif (isArray(ticks) &&
    ticks.length) {\r\n\t\t\treturn helpers$1.callback(me.options.afterBuildTicks,
    [me, ticks]);\r\n\t\t}\r\n\t\t// Support old implementations (that modified `this.ticks`
    directly in buildTicks)\r\n\t\tme.ticks = helpers$1.callback(me.options.afterBuildTicks,
    [me, me.ticks]) || me.ticks;\r\n\t\treturn ticks;\r\n\t},\r\n\r\n\tbeforeTickToLabelConversion:
    function() {\r\n\t\thelpers$1.callback(this.options.beforeTickToLabelConversion,
    [this]);\r\n\t},\r\n\tconvertTicksToLabels: function() {\r\n\t\tvar me = this;\r\n\t\t//
    Convert ticks to strings\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tme.ticks
    = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\r\n\t},\r\n\tafterTickToLabelConversion:
    function() {\r\n\t\thelpers$1.callback(this.options.afterTickToLabelConversion,
    [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeCalculateTickRotation: function()
    {\r\n\t\thelpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\r\n\t},\r\n\tcalculateTickRotation:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    tickOpts = options.ticks;\r\n\t\tvar numTicks = me.getTicks().length;\r\n\t\tvar
    minRotation = tickOpts.minRotation || 0;\r\n\t\tvar maxRotation = tickOpts.maxRotation;\r\n\t\tvar
    labelRotation = minRotation;\r\n\t\tvar labelSizes, maxLabelWidth, maxLabelHeight,
    maxWidth, tickWidth, maxHeight, maxLabelDiagonal;\r\n\r\n\t\tif (!me._isVisible()
    || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal())
    {\r\n\t\t\tme.labelRotation = minRotation;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlabelSizes
    = me._getLabelSizes();\r\n\t\tmaxLabelWidth = labelSizes.widest.width;\r\n\t\tmaxLabelHeight
    = labelSizes.highest.height - labelSizes.highest.offset;\r\n\r\n\t\t// Estimate
    the width of each grid based on the canvas width, the maximum\r\n\t\t// label
    width and the number of tick intervals\r\n\t\tmaxWidth = Math.min(me.maxWidth,
    me.chart.width - maxLabelWidth);\r\n\t\ttickWidth = options.offset ? me.maxWidth
    / numTicks : maxWidth / (numTicks - 1);\r\n\r\n\t\t// Allow 3 pixels x2 padding
    either side for label readability\r\n\t\tif (maxLabelWidth + 6 > tickWidth) {\r\n\t\t\ttickWidth
    = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n\t\t\tmaxHeight = me.maxHeight
    - getTickMarkLength(options.gridLines)\r\n\t\t\t\t- tickOpts.padding - getScaleLabelHeight(options.scaleLabel);\r\n\t\t\tmaxLabelDiagonal
    = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n\t\t\tlabelRotation
    = helpers$1.toDegrees(Math.min(\r\n\t\t\t\tMath.asin(Math.min((labelSizes.highest.height
    + 6) / tickWidth, 1)),\r\n\t\t\t\tMath.asin(Math.min(maxHeight / maxLabelDiagonal,
    1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)\r\n\t\t\t));\r\n\t\t\tlabelRotation
    = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n\t\t}\r\n\r\n\t\tme.labelRotation
    = labelRotation;\r\n\t},\r\n\tafterCalculateTickRotation: function() {\r\n\t\thelpers$1.callback(this.options.afterCalculateTickRotation,
    [this]);\r\n\t},\r\n\r\n\t//\r\n\r\n\tbeforeFit: function() {\r\n\t\thelpers$1.callback(this.options.beforeFit,
    [this]);\r\n\t},\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\t// Reset\r\n\t\tvar
    minSize = me.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\t\tvar
    scaleLabelOpts = opts.scaleLabel;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar
    display = me._isVisible();\r\n\t\tvar isBottom = opts.position === 'bottom';\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\r\n\t\t// Width\r\n\t\tif (isHorizontal)
    {\r\n\t\t\tminSize.width = me.maxWidth;\r\n\t\t} else if (display) {\r\n\t\t\tminSize.width
    = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\r\n\t\t}\r\n\r\n\t\t//
    height\r\n\t\tif (!isHorizontal) {\r\n\t\t\tminSize.height = me.maxHeight; //
    fill all the height\r\n\t\t} else if (display) {\r\n\t\t\tminSize.height = getTickMarkLength(gridLineOpts)
    + getScaleLabelHeight(scaleLabelOpts);\r\n\t\t}\r\n\r\n\t\t// Don't bother fitting
    the ticks if we are not showing the labels\r\n\t\tif (tickOpts.display && display)
    {\r\n\t\t\tvar tickFonts = parseTickFontOptions(tickOpts);\r\n\t\t\tvar labelSizes
    = me._getLabelSizes();\r\n\t\t\tvar firstLabelSize = labelSizes.first;\r\n\t\t\tvar
    lastLabelSize = labelSizes.last;\r\n\t\t\tvar widestLabelSize = labelSizes.widest;\r\n\t\t\tvar
    highestLabelSize = labelSizes.highest;\r\n\t\t\tvar lineSpace = tickFonts.minor.lineHeight
    * 0.4;\r\n\t\t\tvar tickPadding = tickOpts.padding;\r\n\r\n\t\t\tif (isHorizontal)
    {\r\n\t\t\t\t// A horizontal axis is more constrained by the height.\r\n\t\t\t\tvar
    isRotated = me.labelRotation !== 0;\r\n\t\t\t\tvar angleRadians = helpers$1.toRadians(me.labelRotation);\r\n\t\t\t\tvar
    cosRotation = Math.cos(angleRadians);\r\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\tvar
    labelHeight = sinRotation * widestLabelSize.width\r\n\t\t\t\t\t+ cosRotation *
    (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0))\r\n\t\t\t\t\t+
    (isRotated ? 0 : lineSpace); // padding\r\n\r\n\t\t\t\tminSize.height = Math.min(me.maxHeight,
    minSize.height + labelHeight + tickPadding);\r\n\r\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0)
    - me.left;\r\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(me.getTicks().length
    - 1);\r\n\t\t\t\tvar paddingLeft, paddingRight;\r\n\r\n\t\t\t\t// Ensure that
    our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n\t\t\t\t//
    which means that the right padding is dominated by the font height\r\n\t\t\t\tif
    (isRotated) {\r\n\t\t\t\t\tpaddingLeft = isBottom ?\r\n\t\t\t\t\t\tcosRotation
    * firstLabelSize.width + sinRotation * firstLabelSize.offset :\r\n\t\t\t\t\t\tsinRotation
    * (firstLabelSize.height - firstLabelSize.offset);\r\n\t\t\t\t\tpaddingRight =
    isBottom ?\r\n\t\t\t\t\t\tsinRotation * (lastLabelSize.height - lastLabelSize.offset)
    :\r\n\t\t\t\t\t\tcosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;\r\n\t\t\t\t}
    else {\r\n\t\t\t\t\tpaddingLeft = firstLabelSize.width / 2;\r\n\t\t\t\t\tpaddingRight
    = lastLabelSize.width / 2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Adjust padding taking
    into account changes in offsets\r\n\t\t\t\t// and add 3 px to move away from canvas
    edges\r\n\t\t\t\tme.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width
    / (me.width - offsetLeft), 0) + 3;\r\n\t\t\t\tme.paddingRight = Math.max((paddingRight
    - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;\r\n\t\t\t} else
    {\r\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\r\n\t\t\t\t//
    dominant factor here, so get that length first and account for padding\r\n\t\t\t\tvar
    labelWidth = tickOpts.mirror ? 0 :\r\n\t\t\t\t\t// use lineSpace for consistency
    with horizontal axis\r\n\t\t\t\t\t// tickPadding is not implemented for horizontal\r\n\t\t\t\t\twidestLabelSize.width
    + tickPadding + lineSpace;\r\n\r\n\t\t\t\tminSize.width = Math.min(me.maxWidth,
    minSize.width + labelWidth);\r\n\r\n\t\t\t\tme.paddingTop = firstLabelSize.height
    / 2;\r\n\t\t\t\tme.paddingBottom = lastLabelSize.height / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.handleMargins();\r\n\r\n\t\tif
    (isHorizontal) {\r\n\t\t\tme.width = me._length = chart.width - me.margins.left
    - me.margins.right;\r\n\t\t\tme.height = minSize.height;\r\n\t\t} else {\r\n\t\t\tme.width
    = minSize.width;\r\n\t\t\tme.height = me._length = chart.height - me.margins.top
    - me.margins.bottom;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Handle margins and
    padding interactions\r\n\t * @private\r\n\t */\r\n\thandleMargins: function()
    {\r\n\t\tvar me = this;\r\n\t\tif (me.margins) {\r\n\t\t\tme.margins.left = Math.max(me.paddingLeft,
    me.margins.left);\r\n\t\t\tme.margins.top = Math.max(me.paddingTop, me.margins.top);\r\n\t\t\tme.margins.right
    = Math.max(me.paddingRight, me.margins.right);\r\n\t\t\tme.margins.bottom = Math.max(me.paddingBottom,
    me.margins.bottom);\r\n\t\t}\r\n\t},\r\n\r\n\tafterFit: function() {\r\n\t\thelpers$1.callback(this.options.afterFit,
    [this]);\r\n\t},\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\tvar
    pos = this.options.position;\r\n\t\treturn pos === 'top' || pos === 'bottom';\r\n\t},\r\n\tisFullWidth:
    function() {\r\n\t\treturn this.options.fullWidth;\r\n\t},\r\n\r\n\t// Get the
    correct value. NaN bad inputs, If the value type is object get the x or y based
    on whether we are horizontal or not\r\n\tgetRightValue: function(rawValue) {\r\n\t\t//
    Null and undefined values first\r\n\t\tif (isNullOrUndef(rawValue)) {\r\n\t\t\treturn
    NaN;\r\n\t\t}\r\n\t\t// isNaN(object) returns true, so make sure NaN is checking
    for a number; Discard Infinite values\r\n\t\tif ((typeof rawValue === 'number'
    || rawValue instanceof Number) && !isFinite(rawValue)) {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\r\n\t\t//
    If it is in fact an object, dive in one more level\r\n\t\tif (rawValue) {\r\n\t\t\tif
    (this.isHorizontal()) {\r\n\t\t\t\tif (rawValue.x !== undefined) {\r\n\t\t\t\t\treturn
    this.getRightValue(rawValue.x);\r\n\t\t\t\t}\r\n\t\t\t} else if (rawValue.y !==
    undefined) {\r\n\t\t\t\treturn this.getRightValue(rawValue.y);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//
    Value is good, return it\r\n\t\treturn rawValue;\r\n\t},\r\n\r\n\t_convertTicksToLabels:
    function(ticks) {\r\n\t\tvar me = this;\r\n\t\tvar labels, i, ilen;\r\n\r\n\t\tme.ticks
    = ticks.map(function(tick) {\r\n\t\t\treturn tick.value;\r\n\t\t});\r\n\r\n\t\tme.beforeTickToLabelConversion();\r\n\r\n\t\t//
    New implementations should return the formatted tick labels but for BACKWARD\r\n\t\t//
    COMPAT, we still support no return (`this.ticks` internally changed by calling\r\n\t\t//
    this method and supposed to contain only string values).\r\n\t\tlabels = me.convertTicksToLabels(ticks)
    || me.ticks;\r\n\r\n\t\tme.afterTickToLabelConversion();\r\n\r\n\t\t// BACKWARD
    COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\r\n\t\tfor
    (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\tticks[i].label = labels[i];\r\n\t\t}\r\n\r\n\t\treturn
    labels;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLabelSizes: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar labelSizes = me._labelSizes;\r\n\r\n\t\tif
    (!labelSizes) {\r\n\t\t\tme._labelSizes = labelSizes = computeLabelSizes(me.ctx,
    parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);\r\n\t\t\tme.longestLabelWidth
    = labelSizes.widest.width;\r\n\t\t}\r\n\r\n\t\treturn labelSizes;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_parseValue: function(value) {\r\n\t\tvar start, end,
    min, max;\r\n\r\n\t\tif (isArray(value)) {\r\n\t\t\tstart = +this.getRightValue(value[0]);\r\n\t\t\tend
    = +this.getRightValue(value[1]);\r\n\t\t\tmin = Math.min(start, end);\r\n\t\t\tmax
    = Math.max(start, end);\r\n\t\t} else {\r\n\t\t\tvalue = +this.getRightValue(value);\r\n\t\t\tstart
    = undefined;\r\n\t\t\tend = value;\r\n\t\t\tmin = value;\r\n\t\t\tmax = value;\r\n\t\t}\r\n\r\n\t\treturn
    {\r\n\t\t\tmin: min,\r\n\t\t\tmax: max,\r\n\t\t\tstart: start,\r\n\t\t\tend: end\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t*
    @private\r\n\t*/\r\n\t_getScaleLabel: function(rawValue) {\r\n\t\tvar v = this._parseValue(rawValue);\r\n\t\tif
    (v.start !== undefined) {\r\n\t\t\treturn '[' + v.start + ', ' + v.end + ']';\r\n\t\t}\r\n\r\n\t\treturn
    +this.getRightValue(rawValue);\r\n\t},\r\n\r\n\t/**\r\n\t * Used to get the value
    to display in the tooltip for the data at the given index\r\n\t * @param index\r\n\t
    * @param datasetIndex\r\n\t */\r\n\tgetLabelForIndex: helpers$1.noop,\r\n\r\n\t/**\r\n\t
    * Returns the location of the given data point. Value can either be an index or
    a numerical value\r\n\t * The coordinate (0, 0) is at the upper-left corner of
    the canvas\r\n\t * @param value\r\n\t * @param index\r\n\t * @param datasetIndex\r\n\t
    */\r\n\tgetPixelForValue: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Used to get the
    data value from a given pixel. This is the inverse of getPixelForValue\r\n\t *
    The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param
    pixel\r\n\t */\r\n\tgetValueForPixel: helpers$1.noop,\r\n\r\n\t/**\r\n\t * Returns
    the location of the tick at the given index\r\n\t * The coordinate (0, 0) is at
    the upper-left corner of the canvas\r\n\t */\r\n\tgetPixelForTick: function(index)
    {\r\n\t\tvar me = this;\r\n\t\tvar offset = me.options.offset;\r\n\t\tvar numTicks
    = me._ticks.length;\r\n\t\tvar tickWidth = 1 / Math.max(numTicks - (offset ? 0
    : 1), 1);\r\n\r\n\t\treturn index < 0 || index > numTicks - 1\r\n\t\t\t? null\r\n\t\t\t:
    me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));\r\n\t},\r\n\r\n\t/**\r\n\t
    * Utility for getting the pixel location of a percentage of scale\r\n\t * The
    coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t */\r\n\tgetPixelForDecimal:
    function(decimal) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (me._reversePixels) {\r\n\t\t\tdecimal
    = 1 - decimal;\r\n\t\t}\r\n\r\n\t\treturn me._startPixel + decimal * me._length;\r\n\t},\r\n\r\n\tgetDecimalForPixel:
    function(pixel) {\r\n\t\tvar decimal = (pixel - this._startPixel) / this._length;\r\n\t\treturn
    this._reversePixels ? 1 - decimal : decimal;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns
    the pixel for the minimum chart value\r\n\t * The coordinate (0, 0) is at the
    upper-left corner of the canvas\r\n\t */\r\n\tgetBasePixel: function() {\r\n\t\treturn
    this.getPixelForValue(this.getBaseValue());\r\n\t},\r\n\r\n\tgetBaseValue: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\r\n\t\treturn
    me.beginAtZero ? 0 :\r\n\t\t\tmin < 0 && max < 0 ? max :\r\n\t\t\tmin > 0 && max
    > 0 ? min :\r\n\t\t\t0;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a subset of ticks
    to be plotted to avoid overlapping labels.\r\n\t * @private\r\n\t */\r\n\t_autoSkip:
    function(ticks) {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    axisLength = me._length;\r\n\t\tvar ticksLimit = tickOpts.maxTicksLimit || axisLength
    / me._tickSize() + 1;\r\n\t\tvar majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks)
    : [];\r\n\t\tvar numMajorIndices = majorIndices.length;\r\n\t\tvar first = majorIndices[0];\r\n\t\tvar
    last = majorIndices[numMajorIndices - 1];\r\n\t\tvar i, ilen, spacing, avgMajorSpacing;\r\n\r\n\t\t//
    If there are too many major ticks to display them all\r\n\t\tif (numMajorIndices
    > ticksLimit) {\r\n\t\t\tskipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);\r\n\t\t\treturn
    nonSkipped(ticks);\r\n\t\t}\r\n\r\n\t\tspacing = calculateSpacing(majorIndices,
    ticks, axisLength, ticksLimit);\r\n\r\n\t\tif (numMajorIndices > 0) {\r\n\t\t\tfor
    (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n\t\t\t\tskip(ticks, spacing,
    majorIndices[i], majorIndices[i + 1]);\r\n\t\t\t}\r\n\t\t\tavgMajorSpacing = numMajorIndices
    > 1 ? (last - first) / (numMajorIndices - 1) : null;\r\n\t\t\tskip(ticks, spacing,
    helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n\t\t\tskip(ticks,
    spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last
    + avgMajorSpacing);\r\n\t\t\treturn nonSkipped(ticks);\r\n\t\t}\r\n\t\tskip(ticks,
    spacing);\r\n\t\treturn nonSkipped(ticks);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_tickSize: function() {\r\n\t\tvar me = this;\r\n\t\tvar optionTicks =
    me.options.ticks;\r\n\r\n\t\t// Calculate space needed by label in axis direction.\r\n\t\tvar
    rot = helpers$1.toRadians(me.labelRotation);\r\n\t\tvar cos = Math.abs(Math.cos(rot));\r\n\t\tvar
    sin = Math.abs(Math.sin(rot));\r\n\r\n\t\tvar labelSizes = me._getLabelSizes();\r\n\t\tvar
    padding = optionTicks.autoSkipPadding || 0;\r\n\t\tvar w = labelSizes ? labelSizes.widest.width
    + padding : 0;\r\n\t\tvar h = labelSizes ? labelSizes.highest.height + padding
    : 0;\r\n\r\n\t\t// Calculate space needed for 1 tick in axis direction.\r\n\t\treturn
    me.isHorizontal()\r\n\t\t\t? h * cos > w * sin ? w / cos : h / sin\r\n\t\t\t:
    h * sin < w * cos ? h / cos : w / sin;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_isVisible: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    display = me.options.display;\r\n\t\tvar i, ilen, meta;\r\n\r\n\t\tif (display
    !== 'auto') {\r\n\t\t\treturn !!display;\r\n\t\t}\r\n\r\n\t\t// When 'auto', the
    scale is visible if at least one associated dataset is visible.\r\n\t\tfor (i
    = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n\t\t\tif (chart.isDatasetVisible(i))
    {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tif (meta.xAxisID === me.id
    || meta.yAxisID === me.id) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    false;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_computeGridLineItems:
    function(chartArea) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    options = me.options;\r\n\t\tvar gridLines = options.gridLines;\r\n\t\tvar position
    = options.position;\r\n\t\tvar offsetGridLines = gridLines.offsetGridLines;\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\tvar ticks = me._ticksToDraw;\r\n\t\tvar
    ticksLength = ticks.length + (offsetGridLines ? 1 : 0);\r\n\r\n\t\tvar tl = getTickMarkLength(gridLines);\r\n\t\tvar
    items = [];\r\n\t\tvar axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth,
    0, 0) : 0;\r\n\t\tvar axisHalfWidth = axisWidth / 2;\r\n\t\tvar alignPixel = helpers$1._alignPixel;\r\n\t\tvar
    alignBorderValue = function(pixel) {\r\n\t\t\treturn alignPixel(chart, pixel,
    axisWidth);\r\n\t\t};\r\n\t\tvar borderValue, i, tick, lineValue, alignedLineValue;\r\n\t\tvar
    tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;\r\n\r\n\t\tif
    (position === 'top') {\r\n\t\t\tborderValue = alignBorderValue(me.bottom);\r\n\t\t\tty1
    = me.bottom - tl;\r\n\t\t\tty2 = borderValue - axisHalfWidth;\r\n\t\t\ty1 = alignBorderValue(chartArea.top)
    + axisHalfWidth;\r\n\t\t\ty2 = chartArea.bottom;\r\n\t\t} else if (position ===
    'bottom') {\r\n\t\t\tborderValue = alignBorderValue(me.top);\r\n\t\t\ty1 = chartArea.top;\r\n\t\t\ty2
    = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n\t\t\tty1 = borderValue
    + axisHalfWidth;\r\n\t\t\tty2 = me.top + tl;\r\n\t\t} else if (position === 'left')
    {\r\n\t\t\tborderValue = alignBorderValue(me.right);\r\n\t\t\ttx1 = me.right -
    tl;\r\n\t\t\ttx2 = borderValue - axisHalfWidth;\r\n\t\t\tx1 = alignBorderValue(chartArea.left)
    + axisHalfWidth;\r\n\t\t\tx2 = chartArea.right;\r\n\t\t} else {\r\n\t\t\tborderValue
    = alignBorderValue(me.left);\r\n\t\t\tx1 = chartArea.left;\r\n\t\t\tx2 = alignBorderValue(chartArea.right)
    - axisHalfWidth;\r\n\t\t\ttx1 = borderValue + axisHalfWidth;\r\n\t\t\ttx2 = me.left
    + tl;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < ticksLength; ++i) {\r\n\t\t\ttick =
    ticks[i] || {};\r\n\r\n\t\t\t// autoskipper skipped this tick (#4635)\r\n\t\t\tif
    (isNullOrUndef(tick.label) && i < ticks.length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (i === me.zeroLineIndex && options.offset === offsetGridLines) {\r\n\t\t\t\t//
    Draw the first index specially\r\n\t\t\t\tlineWidth = gridLines.zeroLineWidth;\r\n\t\t\t\tlineColor
    = gridLines.zeroLineColor;\r\n\t\t\t\tborderDash = gridLines.zeroLineBorderDash
    || [];\r\n\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\r\n\t\t\t}
    else {\r\n\t\t\t\tlineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);\r\n\t\t\t\tlineColor
    = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');\r\n\t\t\t\tborderDash
    = gridLines.borderDash || [];\r\n\t\t\t\tborderDashOffset = gridLines.borderDashOffset
    || 0.0;\r\n\t\t\t}\r\n\r\n\t\t\tlineValue = getPixelForGridLine(me, tick._index
    || i, offsetGridLines);\r\n\r\n\t\t\t// Skip if the pixel is out of the range\r\n\t\t\tif
    (lineValue === undefined) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\talignedLineValue
    = alignPixel(chart, lineValue, lineWidth);\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\ttx1
    = tx2 = x1 = x2 = alignedLineValue;\r\n\t\t\t} else {\r\n\t\t\t\tty1 = ty2 = y1
    = y2 = alignedLineValue;\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\ttx1:
    tx1,\r\n\t\t\t\tty1: ty1,\r\n\t\t\t\ttx2: tx2,\r\n\t\t\t\tty2: ty2,\r\n\t\t\t\tx1:
    x1,\r\n\t\t\t\ty1: y1,\r\n\t\t\t\tx2: x2,\r\n\t\t\t\ty2: y2,\r\n\t\t\t\twidth:
    lineWidth,\r\n\t\t\t\tcolor: lineColor,\r\n\t\t\t\tborderDash: borderDash,\r\n\t\t\t\tborderDashOffset:
    borderDashOffset,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\titems.ticksLength = ticksLength;\r\n\t\titems.borderValue
    = borderValue;\r\n\r\n\t\treturn items;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_computeLabelItems: function() {\r\n\t\tvar me = this;\r\n\t\tvar options
    = me.options;\r\n\t\tvar optionTicks = options.ticks;\r\n\t\tvar position = options.position;\r\n\t\tvar
    isMirrored = optionTicks.mirror;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tvar
    ticks = me._ticksToDraw;\r\n\t\tvar fonts = parseTickFontOptions(optionTicks);\r\n\t\tvar
    tickPadding = optionTicks.padding;\r\n\t\tvar tl = getTickMarkLength(options.gridLines);\r\n\t\tvar
    rotation = -helpers$1.toRadians(me.labelRotation);\r\n\t\tvar items = [];\r\n\t\tvar
    i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n\r\n\t\tif
    (position === 'top') {\r\n\t\t\ty = me.bottom - tl - tickPadding;\r\n\t\t\ttextAlign
    = !rotation ? 'center' : 'left';\r\n\t\t} else if (position === 'bottom') {\r\n\t\t\ty
    = me.top + tl + tickPadding;\r\n\t\t\ttextAlign = !rotation ? 'center' : 'right';\r\n\t\t}
    else if (position === 'left') {\r\n\t\t\tx = me.right - (isMirrored ? 0 : tl)
    - tickPadding;\r\n\t\t\ttextAlign = isMirrored ? 'left' : 'right';\r\n\t\t} else
    {\r\n\t\t\tx = me.left + (isMirrored ? 0 : tl) + tickPadding;\r\n\t\t\ttextAlign
    = isMirrored ? 'right' : 'left';\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = ticks.length;
    i < ilen; ++i) {\r\n\t\t\ttick = ticks[i];\r\n\t\t\tlabel = tick.label;\r\n\r\n\t\t\t//
    autoskipper skipped this tick (#4635)\r\n\t\t\tif (isNullOrUndef(label)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tpixel
    = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;\r\n\t\t\tfont
    = tick.major ? fonts.major : fonts.minor;\r\n\t\t\tlineHeight = font.lineHeight;\r\n\t\t\tlineCount
    = isArray(label) ? label.length : 1;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tx
    = pixel;\r\n\t\t\t\ttextOffset = position === 'top'\r\n\t\t\t\t\t? ((!rotation
    ? 0.5 : 1) - lineCount) * lineHeight\r\n\t\t\t\t\t: (!rotation ? 0.5 : 0) * lineHeight;\r\n\t\t\t}
    else {\r\n\t\t\t\ty = pixel;\r\n\t\t\t\ttextOffset = (1 - lineCount) * lineHeight
    / 2;\r\n\t\t\t}\r\n\r\n\t\t\titems.push({\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y,\r\n\t\t\t\trotation:
    rotation,\r\n\t\t\t\tlabel: label,\r\n\t\t\t\tfont: font,\r\n\t\t\t\ttextOffset:
    textOffset,\r\n\t\t\t\ttextAlign: textAlign\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn
    items;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_drawGrid: function(chartArea)
    {\r\n\t\tvar me = this;\r\n\t\tvar gridLines = me.options.gridLines;\r\n\r\n\t\tif
    (!gridLines.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar
    chart = me.chart;\r\n\t\tvar alignPixel = helpers$1._alignPixel;\r\n\t\tvar axisWidth
    = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\r\n\t\tvar
    items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\r\n\t\tvar
    width, color, i, ilen, item;\r\n\r\n\t\tfor (i = 0, ilen = items.length; i < ilen;
    ++i) {\r\n\t\t\titem = items[i];\r\n\t\t\twidth = item.width;\r\n\t\t\tcolor =
    item.color;\r\n\r\n\t\t\tif (width && color) {\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.lineWidth
    = width;\r\n\t\t\t\tctx.strokeStyle = color;\r\n\t\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t\tctx.setLineDash(item.borderDash);\r\n\t\t\t\t\tctx.lineDashOffset
    = item.borderDashOffset;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.beginPath();\r\n\r\n\t\t\t\tif
    (gridLines.drawTicks) {\r\n\t\t\t\t\tctx.moveTo(item.tx1, item.ty1);\r\n\t\t\t\t\tctx.lineTo(item.tx2,
    item.ty2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (gridLines.drawOnChartArea) {\r\n\t\t\t\t\tctx.moveTo(item.x1,
    item.y1);\r\n\t\t\t\t\tctx.lineTo(item.x2, item.y2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.stroke();\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (axisWidth) {\r\n\t\t\t// Draw the line at the edge of the axis\r\n\t\t\tvar firstLineWidth
    = axisWidth;\r\n\t\t\tvar lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth,
    items.ticksLength - 1, 1);\r\n\t\t\tvar borderValue = items.borderValue;\r\n\t\t\tvar
    x1, x2, y1, y2;\r\n\r\n\t\t\tif (me.isHorizontal()) {\r\n\t\t\t\tx1 = alignPixel(chart,
    me.left, firstLineWidth) - firstLineWidth / 2;\r\n\t\t\t\tx2 = alignPixel(chart,
    me.right, lastLineWidth) + lastLineWidth / 2;\r\n\t\t\t\ty1 = y2 = borderValue;\r\n\t\t\t}
    else {\r\n\t\t\t\ty1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth
    / 2;\r\n\t\t\t\ty2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth
    / 2;\r\n\t\t\t\tx1 = x2 = borderValue;\r\n\t\t\t}\r\n\r\n\t\t\tctx.lineWidth =
    axisWidth;\r\n\t\t\tctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.moveTo(x1,
    y1);\r\n\t\t\tctx.lineTo(x2, y2);\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    optionTicks = me.options.ticks;\r\n\r\n\t\tif (!optionTicks.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar items = me._labelItems || (me._labelItems = me._computeLabelItems());\r\n\t\tvar
    i, j, ilen, jlen, item, tickFont, label, y;\r\n\r\n\t\tfor (i = 0, ilen = items.length;
    i < ilen; ++i) {\r\n\t\t\titem = items[i];\r\n\t\t\ttickFont = item.font;\r\n\r\n\t\t\t//
    Make sure we draw text in the correct color and font\r\n\t\t\tctx.save();\r\n\t\t\tctx.translate(item.x,
    item.y);\r\n\t\t\tctx.rotate(item.rotation);\r\n\t\t\tctx.font = tickFont.string;\r\n\t\t\tctx.fillStyle
    = tickFont.color;\r\n\t\t\tctx.textBaseline = 'middle';\r\n\t\t\tctx.textAlign
    = item.textAlign;\r\n\r\n\t\t\tlabel = item.label;\r\n\t\t\ty = item.textOffset;\r\n\t\t\tif
    (isArray(label)) {\r\n\t\t\t\tfor (j = 0, jlen = label.length; j < jlen; ++j)
    {\r\n\t\t\t\t\t// We just make sure the multiline element is a string here..\r\n\t\t\t\t\tctx.fillText(''
    + label[j], 0, y);\r\n\t\t\t\t\ty += tickFont.lineHeight;\r\n\t\t\t\t}\r\n\t\t\t}
    else {\r\n\t\t\t\tctx.fillText(label, 0, y);\r\n\t\t\t}\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar options = me.options;\r\n\t\tvar scaleLabel = options.scaleLabel;\r\n\r\n\t\tif
    (!scaleLabel.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar scaleLabelFontColor
    = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);\r\n\t\tvar
    scaleLabelFont = helpers$1.options._parseFont(scaleLabel);\r\n\t\tvar scaleLabelPadding
    = helpers$1.options.toPadding(scaleLabel.padding);\r\n\t\tvar halfLineHeight =
    scaleLabelFont.lineHeight / 2;\r\n\t\tvar position = options.position;\r\n\t\tvar
    rotation = 0;\r\n\t\tvar scaleLabelX, scaleLabelY;\r\n\r\n\t\tif (me.isHorizontal())
    {\r\n\t\t\tscaleLabelX = me.left + me.width / 2; // midpoint of the width\r\n\t\t\tscaleLabelY
    = position === 'bottom'\r\n\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\r\n\t\t\t\t:
    me.top + halfLineHeight + scaleLabelPadding.top;\r\n\t\t} else {\r\n\t\t\tvar
    isLeft = position === 'left';\r\n\t\t\tscaleLabelX = isLeft\r\n\t\t\t\t? me.left
    + halfLineHeight + scaleLabelPadding.top\r\n\t\t\t\t: me.right - halfLineHeight
    - scaleLabelPadding.top;\r\n\t\t\tscaleLabelY = me.top + me.height / 2;\r\n\t\t\trotation
    = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(scaleLabelX,
    scaleLabelY);\r\n\t\tctx.rotate(rotation);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline
    = 'middle';\r\n\t\tctx.fillStyle = scaleLabelFontColor; // render in correct colour\r\n\t\tctx.font
    = scaleLabelFont.string;\r\n\t\tctx.fillText(scaleLabel.labelString, 0, 0);\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tdraw:
    function(chartArea) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (!me._isVisible()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme._drawGrid(chartArea);\r\n\t\tme._drawTitle();\r\n\t\tme._drawLabels();\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_layers: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    opts = me.options;\r\n\t\tvar tz = opts.ticks && opts.ticks.z || 0;\r\n\t\tvar
    gz = opts.gridLines && opts.gridLines.z || 0;\r\n\r\n\t\tif (!me._isVisible()
    || tz === gz || me.draw !== me._draw) {\r\n\t\t\t// backward compatibility: draw
    has been overridden by custom scale\r\n\t\t\treturn [{\r\n\t\t\t\tz: tz,\r\n\t\t\t\tdraw:
    function() {\r\n\t\t\t\t\tme.draw.apply(me, arguments);\r\n\t\t\t\t}\r\n\t\t\t}];\r\n\t\t}\r\n\r\n\t\treturn
    [{\r\n\t\t\tz: gz,\r\n\t\t\tdraw: function() {\r\n\t\t\t\tme._drawGrid.apply(me,
    arguments);\r\n\t\t\t\tme._drawTitle.apply(me, arguments);\r\n\t\t\t}\r\n\t\t},
    {\r\n\t\t\tz: tz,\r\n\t\t\tdraw: function() {\r\n\t\t\t\tme._drawLabels.apply(me,
    arguments);\r\n\t\t\t}\r\n\t\t}];\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\t_getMatchingVisibleMetas: function(type) {\r\n\t\tvar me = this;\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\treturn me.chart._getSortedVisibleDatasetMetas()\r\n\t\t\t.filter(function(meta)
    {\r\n\t\t\t\treturn (!type || meta.type === type)\r\n\t\t\t\t\t&& (isHorizontal
    ? meta.xAxisID === me.id : meta.yAxisID === me.id);\r\n\t\t\t});\r\n\t}\r\n});\r\n\r\nScale.prototype._draw
    = Scale.prototype.draw;\r\n\r\nvar core_scale = Scale;\n\nvar isNullOrUndef$1
    = helpers$1.isNullOrUndef;\r\n\r\nvar defaultConfig = {\r\n\tposition: 'bottom'\r\n};\r\n\r\nvar
    scale_category = core_scale.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar labels = me._getLabels();\r\n\t\tvar ticksOpts = me.options.ticks;\r\n\t\tvar
    min = ticksOpts.min;\r\n\t\tvar max = ticksOpts.max;\r\n\t\tvar minIndex = 0;\r\n\t\tvar
    maxIndex = labels.length - 1;\r\n\t\tvar findIndex;\r\n\r\n\t\tif (min !== undefined)
    {\r\n\t\t\t// user specified min value\r\n\t\t\tfindIndex = labels.indexOf(min);\r\n\t\t\tif
    (findIndex >= 0) {\r\n\t\t\t\tminIndex = findIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (max !== undefined) {\r\n\t\t\t// user specified max value\r\n\t\t\tfindIndex
    = labels.indexOf(max);\r\n\t\t\tif (findIndex >= 0) {\r\n\t\t\t\tmaxIndex = findIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.minIndex
    = minIndex;\r\n\t\tme.maxIndex = maxIndex;\r\n\t\tme.min = labels[minIndex];\r\n\t\tme.max
    = labels[maxIndex];\r\n\t},\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me =
    this;\r\n\t\tvar labels = me._getLabels();\r\n\t\tvar minIndex = me.minIndex;\r\n\t\tvar
    maxIndex = me.maxIndex;\r\n\r\n\t\t// If we are viewing some subset of labels,
    slice the original array\r\n\t\tme.ticks = (minIndex === 0 && maxIndex === labels.length
    - 1) ? labels : labels.slice(minIndex, maxIndex + 1);\r\n\t},\r\n\r\n\tgetLabelForIndex:
    function(index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\r\n\t\tif
    (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\r\n\t\t\treturn
    me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\r\n\t\t}\r\n\r\n\t\treturn
    me._getLabels()[index];\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me
    = this;\r\n\t\tvar offset = me.options.offset;\r\n\t\tvar ticks = me.ticks;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif
    (!me.isHorizontal()) {\r\n\t\t\t// For backward compatibility, vertical category
    scale reverse is inverted.\r\n\t\t\tme._reversePixels = !me._reversePixels;\r\n\t\t}\r\n\r\n\t\tif
    (!ticks) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tme._startValue = me.minIndex -
    (offset ? 0.5 : 0);\r\n\t\tme._valueRange = Math.max(ticks.length - (offset ?
    0 : 1), 1);\r\n\t},\r\n\r\n\t// Used to get data value locations.  Value can either
    be an index or a numerical value\r\n\tgetPixelForValue: function(value, index,
    datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar valueCategory, labels, idx;\r\n\r\n\t\tif
    (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {\r\n\t\t\tvalue =
    me.chart.data.datasets[datasetIndex].data[index];\r\n\t\t}\r\n\r\n\t\t// If value
    is a data object, then index is the index in the data array,\r\n\t\t// not the
    index of the scale. We need to change that.\r\n\t\tif (!isNullOrUndef$1(value))
    {\r\n\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\r\n\t\t}\r\n\t\tif
    (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\r\n\t\t\tlabels
    = me._getLabels();\r\n\t\t\tvalue = helpers$1.valueOrDefault(valueCategory, value);\r\n\t\t\tidx
    = labels.indexOf(value);\r\n\t\t\tindex = idx !== -1 ? idx : index;\r\n\t\t\tif
    (isNaN(index)) {\r\n\t\t\t\tindex = value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn me.getPixelForDecimal((index
    - me._startValue) / me._valueRange);\r\n\t},\r\n\r\n\tgetPixelForTick: function(index)
    {\r\n\t\tvar ticks = this.ticks;\r\n\t\treturn index < 0 || index > ticks.length
    - 1\r\n\t\t\t? null\r\n\t\t\t: this.getPixelForValue(ticks[index], index + this.minIndex);\r\n\t},\r\n\r\n\tgetValueForPixel:
    function(pixel) {\r\n\t\tvar me = this;\r\n\t\tvar value = Math.round(me._startValue
    + me.getDecimalForPixel(pixel) * me._valueRange);\r\n\t\treturn Math.min(Math.max(value,
    0), me.ticks.length - 1);\r\n\t},\r\n\r\n\tgetBasePixel: function() {\r\n\t\treturn
    this.bottom;\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options, registered
    in src/index.js\r\nvar _defaults = defaultConfig;\nscale_category._defaults =
    _defaults;\n\nvar noop = helpers$1.noop;\r\nvar isNullOrUndef$2 = helpers$1.isNullOrUndef;\r\n\r\n/**\r\n
    * Generate a set of linear ticks\r\n * @param generationOptions the options used
    to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns
    {number[]} array of tick values\r\n */\r\nfunction generateTicks(generationOptions,
    dataRange) {\r\n\tvar ticks = [];\r\n\t// To get a \"nice\" value for the tick
    spacing, we will use the appropriately named\r\n\t// \"nice number\" algorithm.
    See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\r\n\t//
    for details.\r\n\r\n\tvar MIN_SPACING = 1e-14;\r\n\tvar stepSize = generationOptions.stepSize;\r\n\tvar
    unit = stepSize || 1;\r\n\tvar maxNumSpaces = generationOptions.maxTicks - 1;\r\n\tvar
    min = generationOptions.min;\r\n\tvar max = generationOptions.max;\r\n\tvar precision
    = generationOptions.precision;\r\n\tvar rmin = dataRange.min;\r\n\tvar rmax =
    dataRange.max;\r\n\tvar spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces
    / unit) * unit;\r\n\tvar factor, niceMin, niceMax, numSpaces;\r\n\r\n\t// Beyond
    MIN_SPACING floating point numbers being to lose precision\r\n\t// such that we
    can't do the math necessary to generate ticks\r\n\tif (spacing < MIN_SPACING &&
    isNullOrUndef$2(min) && isNullOrUndef$2(max)) {\r\n\t\treturn [rmin, rmax];\r\n\t}\r\n\r\n\tnumSpaces
    = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n\tif (numSpaces >
    maxNumSpaces) {\r\n\t\t// If the calculated num of spaces exceeds maxNumSpaces,
    recalculate it\r\n\t\tspacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces
    / unit) * unit;\r\n\t}\r\n\r\n\tif (stepSize || isNullOrUndef$2(precision)) {\r\n\t\t//
    If a precision is not specified, calculate factor based on spacing\r\n\t\tfactor
    = Math.pow(10, helpers$1._decimalPlaces(spacing));\r\n\t} else {\r\n\t\t// If
    the user specified a precision, round to that number of decimal places\r\n\t\tfactor
    = Math.pow(10, precision);\r\n\t\tspacing = Math.ceil(spacing * factor) / factor;\r\n\t}\r\n\r\n\tniceMin
    = Math.floor(rmin / spacing) * spacing;\r\n\tniceMax = Math.ceil(rmax / spacing)
    * spacing;\r\n\r\n\t// If min, max and stepSize is set and they make an evenly
    spaced scale use it.\r\n\tif (stepSize) {\r\n\t\t// If very close to our whole
    number, use it.\r\n\t\tif (!isNullOrUndef$2(min) && helpers$1.almostWhole(min
    / spacing, spacing / 1000)) {\r\n\t\t\tniceMin = min;\r\n\t\t}\r\n\t\tif (!isNullOrUndef$2(max)
    && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\r\n\t\t\tniceMax =
    max;\r\n\t\t}\r\n\t}\r\n\r\n\tnumSpaces = (niceMax - niceMin) / spacing;\r\n\t//
    If very close to our rounded value, use it.\r\n\tif (helpers$1.almostEquals(numSpaces,
    Math.round(numSpaces), spacing / 1000)) {\r\n\t\tnumSpaces = Math.round(numSpaces);\r\n\t}
    else {\r\n\t\tnumSpaces = Math.ceil(numSpaces);\r\n\t}\r\n\r\n\tniceMin = Math.round(niceMin
    * factor) / factor;\r\n\tniceMax = Math.round(niceMax * factor) / factor;\r\n\tticks.push(isNullOrUndef$2(min)
    ? niceMin : min);\r\n\tfor (var j = 1; j < numSpaces; ++j) {\r\n\t\tticks.push(Math.round((niceMin
    + j * spacing) * factor) / factor);\r\n\t}\r\n\tticks.push(isNullOrUndef$2(max)
    ? niceMax : max);\r\n\r\n\treturn ticks;\r\n}\r\n\r\nvar scale_linearbase = core_scale.extend({\r\n\tgetRightValue:
    function(value) {\r\n\t\tif (typeof value === 'string') {\r\n\t\t\treturn +value;\r\n\t\t}\r\n\t\treturn
    core_scale.prototype.getRightValue.call(this, value);\r\n\t},\r\n\r\n\thandleTickRangeOptions:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts
    = opts.ticks;\r\n\r\n\t\t// If we are forcing it to begin at 0, but 0 will already
    be rendered on the chart,\r\n\t\t// do nothing since that would make the chart
    weird. If the user really wants a weird chart\r\n\t\t// axis, they can manually
    override it\r\n\t\tif (tickOpts.beginAtZero) {\r\n\t\t\tvar minSign = helpers$1.sign(me.min);\r\n\t\t\tvar
    maxSign = helpers$1.sign(me.max);\r\n\r\n\t\t\tif (minSign < 0 && maxSign < 0)
    {\r\n\t\t\t\t// move the top up to 0\r\n\t\t\t\tme.max = 0;\r\n\t\t\t} else if
    (minSign > 0 && maxSign > 0) {\r\n\t\t\t\t// move the bottom down to 0\r\n\t\t\t\tme.min
    = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar setMin = tickOpts.min !== undefined ||
    tickOpts.suggestedMin !== undefined;\r\n\t\tvar setMax = tickOpts.max !== undefined
    || tickOpts.suggestedMax !== undefined;\r\n\r\n\t\tif (tickOpts.min !== undefined)
    {\r\n\t\t\tme.min = tickOpts.min;\r\n\t\t} else if (tickOpts.suggestedMin !==
    undefined) {\r\n\t\t\tif (me.min === null) {\r\n\t\t\t\tme.min = tickOpts.suggestedMin;\r\n\t\t\t}
    else {\r\n\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (tickOpts.max !== undefined) {\r\n\t\t\tme.max = tickOpts.max;\r\n\t\t} else if
    (tickOpts.suggestedMax !== undefined) {\r\n\t\t\tif (me.max === null) {\r\n\t\t\t\tme.max
    = tickOpts.suggestedMax;\r\n\t\t\t} else {\r\n\t\t\t\tme.max = Math.max(me.max,
    tickOpts.suggestedMax);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (setMin !== setMax)
    {\r\n\t\t\t// We set the min or the max but not both.\r\n\t\t\t// So ensure that
    our range is good\r\n\t\t\t// Inverted or 0 length range can happen when\r\n\t\t\t//
    ticks.min is set, and no datasets are visible\r\n\t\t\tif (me.min >= me.max) {\r\n\t\t\t\tif
    (setMin) {\r\n\t\t\t\t\tme.max = me.min + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tme.min
    = me.max - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.min === me.max)
    {\r\n\t\t\tme.max++;\r\n\r\n\t\t\tif (!tickOpts.beginAtZero) {\r\n\t\t\t\tme.min--;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetTickLimit:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    stepSize = tickOpts.stepSize;\r\n\t\tvar maxTicksLimit = tickOpts.maxTicksLimit;\r\n\t\tvar
    maxTicks;\r\n\r\n\t\tif (stepSize) {\r\n\t\t\tmaxTicks = Math.ceil(me.max / stepSize)
    - Math.floor(me.min / stepSize) + 1;\r\n\t\t} else {\r\n\t\t\tmaxTicks = me._computeTickLimit();\r\n\t\t\tmaxTicksLimit
    = maxTicksLimit || 11;\r\n\t\t}\r\n\r\n\t\tif (maxTicksLimit) {\r\n\t\t\tmaxTicks
    = Math.min(maxTicksLimit, maxTicks);\r\n\t\t}\r\n\r\n\t\treturn maxTicks;\r\n\t},\r\n\r\n\t_computeTickLimit:
    function() {\r\n\t\treturn Number.POSITIVE_INFINITY;\r\n\t},\r\n\r\n\thandleDirectionalChanges:
    noop,\r\n\r\n\tbuildTicks: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts
    = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\t// Figure out what
    the max number of ticks we can support it is based on the size of\r\n\t\t// the
    axis area. For now, we say that the minimum tick spacing in pixels must be 40\r\n\t\t//
    We also limit the maximum number of ticks to 11 which gives a nice 10 squares
    on\r\n\t\t// the graph. Make sure we always have at least 2 ticks\r\n\t\tvar maxTicks
    = me.getTickLimit();\r\n\t\tmaxTicks = Math.max(2, maxTicks);\r\n\r\n\t\tvar numericGeneratorOptions
    = {\r\n\t\t\tmaxTicks: maxTicks,\r\n\t\t\tmin: tickOpts.min,\r\n\t\t\tmax: tickOpts.max,\r\n\t\t\tprecision:
    tickOpts.precision,\r\n\t\t\tstepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize,
    tickOpts.stepSize)\r\n\t\t};\r\n\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions,
    me);\r\n\r\n\t\tme.handleDirectionalChanges();\r\n\r\n\t\t// At this point, we
    need to update our max and min given the tick values since we have expanded the\r\n\t\t//
    range of the scale\r\n\t\tme.max = helpers$1.max(ticks);\r\n\t\tme.min = helpers$1.min(ticks);\r\n\r\n\t\tif
    (tickOpts.reverse) {\r\n\t\t\tticks.reverse();\r\n\r\n\t\t\tme.start = me.max;\r\n\t\t\tme.end
    = me.min;\r\n\t\t} else {\r\n\t\t\tme.start = me.min;\r\n\t\t\tme.end = me.max;\r\n\t\t}\r\n\t},\r\n\r\n\tconvertTicksToLabels:
    function() {\r\n\t\tvar me = this;\r\n\t\tme.ticksAsNumbers = me.ticks.slice();\r\n\t\tme.zeroLineIndex
    = me.ticks.indexOf(0);\r\n\r\n\t\tcore_scale.prototype.convertTicksToLabels.call(me);\r\n\t},\r\n\r\n\t_configure:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar ticks = me.getTicks();\r\n\t\tvar
    start = me.min;\r\n\t\tvar end = me.max;\r\n\t\tvar offset;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif
    (me.options.offset && ticks.length) {\r\n\t\t\toffset = (end - start) / Math.max(ticks.length
    - 1, 1) / 2;\r\n\t\t\tstart -= offset;\r\n\t\t\tend += offset;\r\n\t\t}\r\n\t\tme._startValue
    = start;\r\n\t\tme._endValue = end;\r\n\t\tme._valueRange = end - start;\r\n\t}\r\n});\n\nvar
    defaultConfig$1 = {\r\n\tposition: 'left',\r\n\tticks: {\r\n\t\tcallback: core_ticks.formatters.linear\r\n\t}\r\n};\r\n\r\nvar
    DEFAULT_MIN = 0;\r\nvar DEFAULT_MAX = 1;\r\n\r\nfunction getOrCreateStack(stacks,
    stacked, meta) {\r\n\tvar key = [\r\n\t\tmeta.type,\r\n\t\t// we have a separate
    stack for stack=undefined datasets when the opts.stacked is undefined\r\n\t\tstacked
    === undefined && meta.stack === undefined ? meta.index : '',\r\n\t\tmeta.stack\r\n\t].join('.');\r\n\r\n\tif
    (stacks[key] === undefined) {\r\n\t\tstacks[key] = {\r\n\t\t\tpos: [],\r\n\t\t\tneg:
    []\r\n\t\t};\r\n\t}\r\n\r\n\treturn stacks[key];\r\n}\r\n\r\nfunction stackData(scale,
    stacks, meta, data) {\r\n\tvar opts = scale.options;\r\n\tvar stacked = opts.stacked;\r\n\tvar
    stack = getOrCreateStack(stacks, stacked, meta);\r\n\tvar pos = stack.pos;\r\n\tvar
    neg = stack.neg;\r\n\tvar ilen = data.length;\r\n\tvar i, value;\r\n\r\n\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\tvalue = scale._parseValue(data[i]);\r\n\t\tif
    (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tpos[i]
    = pos[i] || 0;\r\n\t\tneg[i] = neg[i] || 0;\r\n\r\n\t\tif (opts.relativePoints)
    {\r\n\t\t\tpos[i] = 100;\r\n\t\t} else if (value.min < 0 || value.max < 0) {\r\n\t\t\tneg[i]
    += value.min;\r\n\t\t} else {\r\n\t\t\tpos[i] += value.max;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction
    updateMinMax(scale, meta, data) {\r\n\tvar ilen = data.length;\r\n\tvar i, value;\r\n\r\n\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\tvalue = scale._parseValue(data[i]);\r\n\t\tif
    (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tscale.min
    = Math.min(scale.min, value.min);\r\n\t\tscale.max = Math.max(scale.max, value.max);\r\n\t}\r\n}\r\n\r\nvar
    scale_linear = scale_linearbase.extend({\r\n\tdetermineDataLimits: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasets = chart.data.datasets;\r\n\t\tvar metasets = me._getMatchingVisibleMetas();\r\n\t\tvar
    hasStacks = opts.stacked;\r\n\t\tvar stacks = {};\r\n\t\tvar ilen = metasets.length;\r\n\t\tvar
    i, meta, data, values;\r\n\r\n\t\tme.min = Number.POSITIVE_INFINITY;\r\n\t\tme.max
    = Number.NEGATIVE_INFINITY;\r\n\r\n\t\tif (hasStacks === undefined) {\r\n\t\t\tfor
    (i = 0; !hasStacks && i < ilen; ++i) {\r\n\t\t\t\tmeta = metasets[i];\r\n\t\t\t\thasStacks
    = meta.stack !== undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < ilen;
    ++i) {\r\n\t\t\tmeta = metasets[i];\r\n\t\t\tdata = datasets[meta.index].data;\r\n\t\t\tif
    (hasStacks) {\r\n\t\t\t\tstackData(me, stacks, meta, data);\r\n\t\t\t} else {\r\n\t\t\t\tupdateMinMax(me,
    meta, data);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers$1.each(stacks, function(stackValues)
    {\r\n\t\t\tvalues = stackValues.pos.concat(stackValues.neg);\r\n\t\t\tme.min =
    Math.min(me.min, helpers$1.min(values));\r\n\t\t\tme.max = Math.max(me.max, helpers$1.max(values));\r\n\t\t});\r\n\r\n\t\tme.min
    = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\r\n\t\tme.max
    = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\r\n\r\n\t\t//
    Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\r\n\t\tme.handleTickRangeOptions();\r\n\t},\r\n\r\n\t//
    Returns the maximum number of ticks based on the scale dimension\r\n\t_computeTickLimit:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickFont;\r\n\r\n\t\tif (me.isHorizontal())
    {\r\n\t\t\treturn Math.ceil(me.width / 40);\r\n\t\t}\r\n\t\ttickFont = helpers$1.options._parseFont(me.options.ticks);\r\n\t\treturn
    Math.ceil(me.height / tickFont.lineHeight);\r\n\t},\r\n\r\n\t// Called after the
    ticks are built. We need\r\n\thandleDirectionalChanges: function() {\r\n\t\tif
    (!this.isHorizontal()) {\r\n\t\t\t// We are in a vertical orientation. The top
    value is the highest. So reverse the array\r\n\t\t\tthis.ticks.reverse();\r\n\t\t}\r\n\t},\r\n\r\n\tgetLabelForIndex:
    function(index, datasetIndex) {\r\n\t\treturn this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\t//
    Utils\r\n\tgetPixelForValue: function(value) {\r\n\t\tvar me = this;\r\n\t\treturn
    me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);\r\n\t},\r\n\r\n\tgetValueForPixel:
    function(pixel) {\r\n\t\treturn this._startValue + this.getDecimalForPixel(pixel)
    * this._valueRange;\r\n\t},\r\n\r\n\tgetPixelForTick: function(index) {\r\n\t\tvar
    ticks = this.ticksAsNumbers;\r\n\t\tif (index < 0 || index > ticks.length - 1)
    {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this.getPixelForValue(ticks[index]);\r\n\t}\r\n});\r\n\r\n//
    INTERNAL: static default options, registered in src/index.js\r\nvar _defaults$1
    = defaultConfig$1;\nscale_linear._defaults = _defaults$1;\n\nvar valueOrDefault$b
    = helpers$1.valueOrDefault;\r\nvar log10 = helpers$1.math.log10;\r\n\r\n/**\r\n
    * Generate a set of logarithmic ticks\r\n * @param generationOptions the options
    used to generate the ticks\r\n * @param dataRange the range of the data\r\n *
    @returns {number[]} array of tick values\r\n */\r\nfunction generateTicks$1(generationOptions,
    dataRange) {\r\n\tvar ticks = [];\r\n\r\n\tvar tickVal = valueOrDefault$b(generationOptions.min,
    Math.pow(10, Math.floor(log10(dataRange.min))));\r\n\r\n\tvar endExp = Math.floor(log10(dataRange.max));\r\n\tvar
    endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\r\n\tvar exp,
    significand;\r\n\r\n\tif (tickVal === 0) {\r\n\t\texp = Math.floor(log10(dataRange.minNotZero));\r\n\t\tsignificand
    = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\r\n\r\n\t\tticks.push(tickVal);\r\n\t\ttickVal
    = significand * Math.pow(10, exp);\r\n\t} else {\r\n\t\texp = Math.floor(log10(tickVal));\r\n\t\tsignificand
    = Math.floor(tickVal / Math.pow(10, exp));\r\n\t}\r\n\tvar precision = exp < 0
    ? Math.pow(10, Math.abs(exp)) : 1;\r\n\r\n\tdo {\r\n\t\tticks.push(tickVal);\r\n\r\n\t\t++significand;\r\n\t\tif
    (significand === 10) {\r\n\t\t\tsignificand = 1;\r\n\t\t\t++exp;\r\n\t\t\tprecision
    = exp >= 0 ? 1 : precision;\r\n\t\t}\r\n\r\n\t\ttickVal = Math.round(significand
    * Math.pow(10, exp) * precision) / precision;\r\n\t} while (exp < endExp || (exp
    === endExp && significand < endSignificand));\r\n\r\n\tvar lastTick = valueOrDefault$b(generationOptions.max,
    tickVal);\r\n\tticks.push(lastTick);\r\n\r\n\treturn ticks;\r\n}\r\n\r\nvar defaultConfig$2
    = {\r\n\tposition: 'left',\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\tcallback:
    core_ticks.formatters.logarithmic\r\n\t}\r\n};\r\n\r\n// TODO(v3): change this
    to positiveOrDefault\r\nfunction nonNegativeOrDefault(value, defaultValue) {\r\n\treturn
    helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\r\n}\r\n\r\nvar
    scale_logarithmic = core_scale.extend({\r\n\tdetermineDataLimits: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar chart = me.chart;\r\n\t\tvar
    datasets = chart.data.datasets;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\t\tfunction
    IDMatches(meta) {\r\n\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID
    === me.id;\r\n\t\t}\r\n\t\tvar datasetIndex, meta, value, data, i, ilen;\r\n\r\n\t\t//
    Calculate Range\r\n\t\tme.min = Number.POSITIVE_INFINITY;\r\n\t\tme.max = Number.NEGATIVE_INFINITY;\r\n\t\tme.minNotZero
    = Number.POSITIVE_INFINITY;\r\n\r\n\t\tvar hasStacks = opts.stacked;\r\n\t\tif
    (hasStacks === undefined) {\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length;
    datasetIndex++) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tif
    (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\r\n\t\t\t\t\tmeta.stack
    !== undefined) {\r\n\t\t\t\t\thasStacks = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif
    (opts.stacked || hasStacks) {\r\n\t\t\tvar valuesPerStack = {};\r\n\r\n\t\t\tfor
    (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\r\n\t\t\t\tmeta
    = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tvar key = [\r\n\t\t\t\t\tmeta.type,\r\n\t\t\t\t\t//
    we have a separate stack for stack=undefined datasets when the opts.stacked is
    undefined\r\n\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined)
    ? datasetIndex : ''),\r\n\t\t\t\t\tmeta.stack\r\n\t\t\t\t].join('.');\r\n\r\n\t\t\t\tif
    (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\tif (valuesPerStack[key]
    === undefined) {\r\n\t\t\t\t\t\tvaluesPerStack[key] = [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata
    = datasets[datasetIndex].data;\r\n\t\t\t\t\tfor (i = 0, ilen = data.length; i
    < ilen; i++) {\r\n\t\t\t\t\t\tvar values = valuesPerStack[key];\r\n\t\t\t\t\t\tvalue
    = me._parseValue(data[i]);\r\n\t\t\t\t\t\t// invalid, hidden and negative values
    are ignored\r\n\t\t\t\t\t\tif (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden
    || value.min < 0 || value.max < 0) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[i]
    = values[i] || 0;\r\n\t\t\t\t\t\tvalues[i] += value.max;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\thelpers$1.each(valuesPerStack,
    function(valuesForType) {\r\n\t\t\t\tif (valuesForType.length > 0) {\r\n\t\t\t\t\tvar
    minVal = helpers$1.min(valuesForType);\r\n\t\t\t\t\tvar maxVal = helpers$1.max(valuesForType);\r\n\t\t\t\t\tme.min
    = Math.min(me.min, minVal);\r\n\t\t\t\t\tme.max = Math.max(me.max, maxVal);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}
    else {\r\n\t\t\tfor (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++)
    {\r\n\t\t\t\tmeta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)
    && IDMatches(meta)) {\r\n\t\t\t\t\tdata = datasets[datasetIndex].data;\r\n\t\t\t\t\tfor
    (i = 0, ilen = data.length; i < ilen; i++) {\r\n\t\t\t\t\t\tvalue = me._parseValue(data[i]);\r\n\t\t\t\t\t\t//
    invalid, hidden and negative values are ignored\r\n\t\t\t\t\t\tif (isNaN(value.min)
    || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0)
    {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tme.min = Math.min(value.min,
    me.min);\r\n\t\t\t\t\t\tme.max = Math.max(value.max, me.max);\r\n\r\n\t\t\t\t\t\tif
    (value.min !== 0) {\r\n\t\t\t\t\t\t\tme.minNotZero = Math.min(value.min, me.minNotZero);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.min
    = helpers$1.isFinite(me.min) ? me.min : null;\r\n\t\tme.max = helpers$1.isFinite(me.max)
    ? me.max : null;\r\n\t\tme.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero
    : null;\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max\r\n\t\tthis.handleTickRangeOptions();\r\n\t},\r\n\r\n\thandleTickRangeOptions:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    DEFAULT_MIN = 1;\r\n\t\tvar DEFAULT_MAX = 10;\r\n\r\n\t\tme.min = nonNegativeOrDefault(tickOpts.min,
    me.min);\r\n\t\tme.max = nonNegativeOrDefault(tickOpts.max, me.max);\r\n\r\n\t\tif
    (me.min === me.max) {\r\n\t\t\tif (me.min !== 0 && me.min !== null) {\r\n\t\t\t\tme.min
    = Math.pow(10, Math.floor(log10(me.min)) - 1);\r\n\t\t\t\tme.max = Math.pow(10,
    Math.floor(log10(me.max)) + 1);\r\n\t\t\t} else {\r\n\t\t\t\tme.min = DEFAULT_MIN;\r\n\t\t\t\tme.max
    = DEFAULT_MAX;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (me.min === null) {\r\n\t\t\tme.min
    = Math.pow(10, Math.floor(log10(me.max)) - 1);\r\n\t\t}\r\n\t\tif (me.max ===
    null) {\r\n\t\t\tme.max = me.min !== 0\r\n\t\t\t\t? Math.pow(10, Math.floor(log10(me.min))
    + 1)\r\n\t\t\t\t: DEFAULT_MAX;\r\n\t\t}\r\n\t\tif (me.minNotZero === null) {\r\n\t\t\tif
    (me.min > 0) {\r\n\t\t\t\tme.minNotZero = me.min;\r\n\t\t\t} else if (me.max <
    1) {\r\n\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(log10(me.max)));\r\n\t\t\t}
    else {\r\n\t\t\t\tme.minNotZero = DEFAULT_MIN;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tbuildTicks:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar
    reverse = !me.isHorizontal();\r\n\r\n\t\tvar generationOptions = {\r\n\t\t\tmin:
    nonNegativeOrDefault(tickOpts.min),\r\n\t\t\tmax: nonNegativeOrDefault(tickOpts.max)\r\n\t\t};\r\n\t\tvar
    ticks = me.ticks = generateTicks$1(generationOptions, me);\r\n\r\n\t\t// At this
    point, we need to update our max and min given the tick values since we have expanded
    the\r\n\t\t// range of the scale\r\n\t\tme.max = helpers$1.max(ticks);\r\n\t\tme.min
    = helpers$1.min(ticks);\r\n\r\n\t\tif (tickOpts.reverse) {\r\n\t\t\treverse =
    !reverse;\r\n\t\t\tme.start = me.max;\r\n\t\t\tme.end = me.min;\r\n\t\t} else
    {\r\n\t\t\tme.start = me.min;\r\n\t\t\tme.end = me.max;\r\n\t\t}\r\n\t\tif (reverse)
    {\r\n\t\t\tticks.reverse();\r\n\t\t}\r\n\t},\r\n\r\n\tconvertTicksToLabels: function()
    {\r\n\t\tthis.tickValues = this.ticks.slice();\r\n\r\n\t\tcore_scale.prototype.convertTicksToLabels.call(this);\r\n\t},\r\n\r\n\t//
    Get the correct tooltip label\r\n\tgetLabelForIndex: function(index, datasetIndex)
    {\r\n\t\treturn this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\tgetPixelForTick:
    function(index) {\r\n\t\tvar ticks = this.tickValues;\r\n\t\tif (index < 0 ||
    index > ticks.length - 1) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this.getPixelForValue(ticks[index]);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Returns the value of the first tick.\r\n\t * @param {number} value - The minimum
    not zero value.\r\n\t * @return {number} The first tick value.\r\n\t * @private\r\n\t
    */\r\n\t_getFirstTickValue: function(value) {\r\n\t\tvar exp = Math.floor(log10(value));\r\n\t\tvar
    significand = Math.floor(value / Math.pow(10, exp));\r\n\r\n\t\treturn significand
    * Math.pow(10, exp);\r\n\t},\r\n\r\n\t_configure: function() {\r\n\t\tvar me =
    this;\r\n\t\tvar start = me.min;\r\n\t\tvar offset = 0;\r\n\r\n\t\tcore_scale.prototype._configure.call(me);\r\n\r\n\t\tif
    (start === 0) {\r\n\t\t\tstart = me._getFirstTickValue(me.minNotZero);\r\n\t\t\toffset
    = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize)
    / me._length;\r\n\t\t}\r\n\r\n\t\tme._startValue = log10(start);\r\n\t\tme._valueOffset
    = offset;\r\n\t\tme._valueRange = (log10(me.max) - log10(start)) / (1 - offset);\r\n\t},\r\n\r\n\tgetPixelForValue:
    function(value) {\r\n\t\tvar me = this;\r\n\t\tvar decimal = 0;\r\n\r\n\t\tvalue
    = +me.getRightValue(value);\r\n\r\n\t\tif (value > me.min && value > 0) {\r\n\t\t\tdecimal
    = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;\r\n\t\t}\r\n\t\treturn
    me.getPixelForDecimal(decimal);\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel)
    {\r\n\t\tvar me = this;\r\n\t\tvar decimal = me.getDecimalForPixel(pixel);\r\n\t\treturn
    decimal === 0 && me.min === 0\r\n\t\t\t? 0\r\n\t\t\t: Math.pow(10, me._startValue
    + (decimal - me._valueOffset) * me._valueRange);\r\n\t}\r\n});\r\n\r\n// INTERNAL:
    static default options, registered in src/index.js\r\nvar _defaults$2 = defaultConfig$2;\nscale_logarithmic._defaults
    = _defaults$2;\n\nvar valueOrDefault$c = helpers$1.valueOrDefault;\r\nvar valueAtIndexOrDefault$1
    = helpers$1.valueAtIndexOrDefault;\r\nvar resolve$4 = helpers$1.options.resolve;\r\n\r\nvar
    defaultConfig$3 = {\r\n\tdisplay: true,\r\n\r\n\t// Boolean - Whether to animate
    scaling the chart from the centre\r\n\tanimate: true,\r\n\tposition: 'chartArea',\r\n\r\n\tangleLines:
    {\r\n\t\tdisplay: true,\r\n\t\tcolor: 'rgba(0,0,0,0.1)',\r\n\t\tlineWidth: 1,\r\n\t\tborderDash:
    [],\r\n\t\tborderDashOffset: 0.0\r\n\t},\r\n\r\n\tgridLines: {\r\n\t\tcircular:
    false\r\n\t},\r\n\r\n\t// label settings\r\n\tticks: {\r\n\t\t// Boolean - Show
    a backdrop to the scale label\r\n\t\tshowLabelBackdrop: true,\r\n\r\n\t\t// String
    - The colour of the label backdrop\r\n\t\tbackdropColor: 'rgba(255,255,255,0.75)',\r\n\r\n\t\t//
    Number - The backdrop padding above & below the label in pixels\r\n\t\tbackdropPaddingY:
    2,\r\n\r\n\t\t// Number - The backdrop padding to the side of the label in pixels\r\n\t\tbackdropPaddingX:
    2,\r\n\r\n\t\tcallback: core_ticks.formatters.linear\r\n\t},\r\n\r\n\tpointLabels:
    {\r\n\t\t// Boolean - if true, show point labels\r\n\t\tdisplay: true,\r\n\r\n\t\t//
    Number - Point label font size in pixels\r\n\t\tfontSize: 10,\r\n\r\n\t\t// Function
    - Used to convert point labels\r\n\t\tcallback: function(label) {\r\n\t\t\treturn
    label;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n\tvar
    tickOpts = opts.ticks;\r\n\r\n\tif (tickOpts.display && opts.display) {\r\n\t\treturn
    valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY
    * 2;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nfunction measureLabelSize(ctx, lineHeight,
    label) {\r\n\tif (helpers$1.isArray(label)) {\r\n\t\treturn {\r\n\t\t\tw: helpers$1.longestText(ctx,
    ctx.font, label),\r\n\t\t\th: label.length * lineHeight\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tw: ctx.measureText(label).width,\r\n\t\th: lineHeight\r\n\t};\r\n}\r\n\r\nfunction
    determineLimits(angle, pos, size, min, max) {\r\n\tif (angle === min || angle
    === max) {\r\n\t\treturn {\r\n\t\t\tstart: pos - (size / 2),\r\n\t\t\tend: pos
    + (size / 2)\r\n\t\t};\r\n\t} else if (angle < min || angle > max) {\r\n\t\treturn
    {\r\n\t\t\tstart: pos - size,\r\n\t\t\tend: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn
    {\r\n\t\tstart: pos,\r\n\t\tend: pos + size\r\n\t};\r\n}\r\n\r\n/**\r\n * Helper
    function to fit a radial linear scale with point labels\r\n */\r\nfunction fitWithPointLabels(scale)
    {\r\n\r\n\t// Right, this is really confusing and there is a lot of maths going
    on here\r\n\t// The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t//\r\n\t//
    Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t//\r\n\t//
    Solution:\r\n\t//\r\n\t// We assume the radius of the polygon is half the size
    of the canvas at first\r\n\t// at each index we check if the text overlaps.\r\n\t//\r\n\t//
    Where it does, we store that angle and that index.\r\n\t//\r\n\t// After finding
    the largest index and angle we calculate how much we need to remove\r\n\t// from
    the shape radius to move the point inwards by that x.\r\n\t//\r\n\t// We average
    the left and right distances to get the maximum shape radius that can fit in the
    box\r\n\t// along with labels.\r\n\t//\r\n\t// Once we have that, we can find
    the centre point for the chart, by taking the x text protrusion\r\n\t// on each
    side, removing that from the size, halving it and adding the left x protrusion
    width.\r\n\t//\r\n\t// This will mean we have a shape fitted to the canvas, as
    large as it can be with the labels\r\n\t// and position it in the most space efficient
    manner\r\n\t//\r\n\t// https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\r\n\tvar
    plFont = helpers$1.options._parseFont(scale.options.pointLabels);\r\n\r\n\t//
    Get maximum radius of the polygon. Either half the height (minus the text width)
    or half the width.\r\n\t// Use this to calculate the offset + change. - Make sure
    L/R protrusion is at least 0 to stop issues with centre points\r\n\tvar furthestLimits
    = {\r\n\t\tl: 0,\r\n\t\tr: scale.width,\r\n\t\tt: 0,\r\n\t\tb: scale.height -
    scale.paddingTop\r\n\t};\r\n\tvar furthestAngles = {};\r\n\tvar i, textSize, pointPosition;\r\n\r\n\tscale.ctx.font
    = plFont.string;\r\n\tscale._pointLabelSizes = [];\r\n\r\n\tvar valueCount = scale.chart.data.labels.length;\r\n\tfor
    (i = 0; i < valueCount; i++) {\r\n\t\tpointPosition = scale.getPointPosition(i,
    scale.drawingArea + 5);\r\n\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight,
    scale.pointLabels[i]);\r\n\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t//
    Add quarter circle to make degree 0 mean top of circle\r\n\t\tvar angleRadians
    = scale.getIndexAngle(i);\r\n\t\tvar angle = helpers$1.toDegrees(angleRadians)
    % 360;\r\n\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w,
    0, 180);\r\n\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h,
    90, 270);\r\n\r\n\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\tfurthestLimits.l
    = hLimits.start;\r\n\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t}\r\n\r\n\t\tif
    (hLimits.end > furthestLimits.r) {\r\n\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\tfurthestAngles.r
    = angleRadians;\r\n\t\t}\r\n\r\n\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\tfurthestLimits.t
    = vLimits.start;\r\n\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t}\r\n\r\n\t\tif
    (vLimits.end > furthestLimits.b) {\r\n\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\tfurthestAngles.b
    = angleRadians;\r\n\t\t}\r\n\t}\r\n\r\n\tscale.setReductions(scale.drawingArea,
    furthestLimits, furthestAngles);\r\n}\r\n\r\nfunction getTextAlignForAngle(angle)
    {\r\n\tif (angle === 0 || angle === 180) {\r\n\t\treturn 'center';\r\n\t} else
    if (angle < 180) {\r\n\t\treturn 'left';\r\n\t}\r\n\r\n\treturn 'right';\r\n}\r\n\r\nfunction
    fillText(ctx, text, position, lineHeight) {\r\n\tvar y = position.y + lineHeight
    / 2;\r\n\tvar i, ilen;\r\n\r\n\tif (helpers$1.isArray(text)) {\r\n\t\tfor (i =
    0, ilen = text.length; i < ilen; ++i) {\r\n\t\t\tctx.fillText(text[i], position.x,
    y);\r\n\t\t\ty += lineHeight;\r\n\t\t}\r\n\t} else {\r\n\t\tctx.fillText(text,
    position.x, y);\r\n\t}\r\n}\r\n\r\nfunction adjustPointPositionForLabelHeight(angle,
    textSize, position) {\r\n\tif (angle === 90 || angle === 270) {\r\n\t\tposition.y
    -= (textSize.h / 2);\r\n\t} else if (angle > 270 || angle < 90) {\r\n\t\tposition.y
    -= textSize.h;\r\n\t}\r\n}\r\n\r\nfunction drawPointLabels(scale) {\r\n\tvar ctx
    = scale.ctx;\r\n\tvar opts = scale.options;\r\n\tvar pointLabelOpts = opts.pointLabels;\r\n\tvar
    tickBackdropHeight = getTickBackdropHeight(opts);\r\n\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse
    ? scale.min : scale.max);\r\n\tvar plFont = helpers$1.options._parseFont(pointLabelOpts);\r\n\r\n\tctx.save();\r\n\r\n\tctx.font
    = plFont.string;\r\n\tctx.textBaseline = 'middle';\r\n\r\n\tfor (var i = scale.chart.data.labels.length
    - 1; i >= 0; i--) {\r\n\t\t// Extra pixels out for some label spacing\r\n\t\tvar
    extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\tvar pointLabelPosition
    = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t// Keep this
    in loop since we may support array properties here\r\n\t\tvar pointLabelFontColor
    = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\r\n\t\tctx.fillStyle
    = pointLabelFontColor;\r\n\r\n\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\tvar
    angle = helpers$1.toDegrees(angleRadians);\r\n\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\tadjustPointPositionForLabelHeight(angle,
    scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\tfillText(ctx, scale.pointLabels[i],
    pointLabelPosition, plFont.lineHeight);\r\n\t}\r\n\tctx.restore();\r\n}\r\n\r\nfunction
    drawRadiusLine(scale, gridLineOpts, radius, index) {\r\n\tvar ctx = scale.ctx;\r\n\tvar
    circular = gridLineOpts.circular;\r\n\tvar valueCount = scale.chart.data.labels.length;\r\n\tvar
    lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\r\n\tvar lineWidth
    = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\r\n\tvar pointPosition;\r\n\r\n\tif
    ((!circular && !valueCount) || !lineColor || !lineWidth) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tctx.save();\r\n\tctx.strokeStyle
    = lineColor;\r\n\tctx.lineWidth = lineWidth;\r\n\tif (ctx.setLineDash) {\r\n\t\tctx.setLineDash(gridLineOpts.borderDash
    || []);\r\n\t\tctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tif
    (circular) {\r\n\t\t// Draw circular arcs between the points\r\n\t\tctx.arc(scale.xCenter,
    scale.yCenter, radius, 0, Math.PI * 2);\r\n\t} else {\r\n\t\t// Draw straight
    lines connecting each index\r\n\t\tpointPosition = scale.getPointPosition(0, radius);\r\n\t\tctx.moveTo(pointPosition.x,
    pointPosition.y);\r\n\r\n\t\tfor (var i = 1; i < valueCount; i++) {\r\n\t\t\tpointPosition
    = scale.getPointPosition(i, radius);\r\n\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\r\n\t\t}\r\n\t}\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n\tctx.restore();\r\n}\r\n\r\nfunction
    numberOrZero(param) {\r\n\treturn helpers$1.isNumber(param) ? param : 0;\r\n}\r\n\r\nvar
    scale_radialLinear = scale_linearbase.extend({\r\n\tsetDimensions: function()
    {\r\n\t\tvar me = this;\r\n\r\n\t\t// Set the unconstrained dimension before label
    rotation\r\n\t\tme.width = me.maxWidth;\r\n\t\tme.height = me.maxHeight;\r\n\t\tme.paddingTop
    = getTickBackdropHeight(me.options) / 2;\r\n\t\tme.xCenter = Math.floor(me.width
    / 2);\r\n\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\r\n\t\tme.drawingArea
    = Math.min(me.height - me.paddingTop, me.width) / 2;\r\n\t},\r\n\r\n\tdetermineDataLimits:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar min
    = Number.POSITIVE_INFINITY;\r\n\t\tvar max = Number.NEGATIVE_INFINITY;\r\n\r\n\t\thelpers$1.each(chart.data.datasets,
    function(dataset, datasetIndex) {\r\n\t\t\tif (chart.isDatasetVisible(datasetIndex))
    {\r\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\r\n\t\t\t\thelpers$1.each(dataset.data,
    function(rawValue, index) {\r\n\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\tif
    (isNaN(value) || meta.data[index].hidden) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmin
    = Math.min(value, min);\r\n\t\t\t\t\tmax = Math.max(value, max);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tme.min
    = (min === Number.POSITIVE_INFINITY ? 0 : min);\r\n\t\tme.max = (max === Number.NEGATIVE_INFINITY
    ? 0 : max);\r\n\r\n\t\t// Common base implementation to handle ticks.min, ticks.max,
    ticks.beginAtZero\r\n\t\tme.handleTickRangeOptions();\r\n\t},\r\n\r\n\t// Returns
    the maximum number of ticks based on the scale dimension\r\n\t_computeTickLimit:
    function() {\r\n\t\treturn Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n\t},\r\n\r\n\tconvertTicksToLabels:
    function() {\r\n\t\tvar me = this;\r\n\r\n\t\tscale_linearbase.prototype.convertTicksToLabels.call(me);\r\n\r\n\t\t//
    Point labels\r\n\t\tme.pointLabels = me.chart.data.labels.map(function() {\r\n\t\t\tvar
    label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);\r\n\t\t\treturn
    label || label === 0 ? label : '';\r\n\t\t});\r\n\t},\r\n\r\n\tgetLabelForIndex:
    function(index, datasetIndex) {\r\n\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\r\n\t},\r\n\r\n\tfit:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\r\n\t\tif
    (opts.display && opts.pointLabels.display) {\r\n\t\t\tfitWithPointLabels(me);\r\n\t\t}
    else {\r\n\t\t\tme.setCenterPoint(0, 0, 0, 0);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * Set radius reductions and determine new radius and center point\r\n\t * @private\r\n\t
    */\r\n\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles)
    {\r\n\t\tvar me = this;\r\n\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\tvar
    radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\tvar
    radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\tvar
    radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop),
    0) / Math.cos(furthestAngles.b);\r\n\r\n\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\tradiusReductionRight
    = numberOrZero(radiusReductionRight);\r\n\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\tradiusReductionBottom
    = numberOrZero(radiusReductionBottom);\r\n\r\n\t\tme.drawingArea = Math.min(\r\n\t\t\tMath.floor(largestPossibleRadius
    - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\tMath.floor(largestPossibleRadius
    - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\tme.setCenterPoint(radiusReductionLeft,
    radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t},\r\n\r\n\tsetCenterPoint:
    function(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n\t\tvar
    me = this;\r\n\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\r\n\t\tvar
    maxLeft = leftMovement + me.drawingArea;\r\n\t\tvar maxTop = topMovement + me.drawingArea;\r\n\t\tvar
    maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\r\n\r\n\t\tme.xCenter
    = Math.floor(((maxLeft + maxRight) / 2) + me.left);\r\n\t\tme.yCenter = Math.floor(((maxTop
    + maxBottom) / 2) + me.top + me.paddingTop);\r\n\t},\r\n\r\n\tgetIndexAngle: function(index)
    {\r\n\t\tvar chart = this.chart;\r\n\t\tvar angleMultiplier = 360 / chart.data.labels.length;\r\n\t\tvar
    options = chart.options || {};\r\n\t\tvar startAngle = options.startAngle || 0;\r\n\r\n\t\t//
    Start from the top instead of right, so remove a quarter of the circle\r\n\t\tvar
    angle = (index * angleMultiplier + startAngle) % 360;\r\n\r\n\t\treturn (angle
    < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;\r\n\t},\r\n\r\n\tgetDistanceFromCenterForValue:
    function(value) {\r\n\t\tvar me = this;\r\n\r\n\t\tif (helpers$1.isNullOrUndef(value))
    {\r\n\t\t\treturn NaN;\r\n\t\t}\r\n\r\n\t\t// Take into account half font size
    + the yPadding of the top value\r\n\t\tvar scalingFactor = me.drawingArea / (me.max
    - me.min);\r\n\t\tif (me.options.ticks.reverse) {\r\n\t\t\treturn (me.max - value)
    * scalingFactor;\r\n\t\t}\r\n\t\treturn (value - me.min) * scalingFactor;\r\n\t},\r\n\r\n\tgetPointPosition:
    function(index, distanceFromCenter) {\r\n\t\tvar me = this;\r\n\t\tvar thisAngle
    = me.getIndexAngle(index) - (Math.PI / 2);\r\n\t\treturn {\r\n\t\t\tx: Math.cos(thisAngle)
    * distanceFromCenter + me.xCenter,\r\n\t\t\ty: Math.sin(thisAngle) * distanceFromCenter
    + me.yCenter\r\n\t\t};\r\n\t},\r\n\r\n\tgetPointPositionForValue: function(index,
    value) {\r\n\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n\t},\r\n\r\n\tgetBasePosition:
    function(index) {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max
    = me.max;\r\n\r\n\t\treturn me.getPointPositionForValue(index || 0,\r\n\t\t\tme.beginAtZero
    ? 0 :\r\n\t\t\tmin < 0 && max < 0 ? max :\r\n\t\t\tmin > 0 && max > 0 ? min :\r\n\t\t\t0);\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawGrid: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar
    angleLineOpts = opts.angleLines;\r\n\t\tvar lineWidth = valueOrDefault$c(angleLineOpts.lineWidth,
    gridLineOpts.lineWidth);\r\n\t\tvar lineColor = valueOrDefault$c(angleLineOpts.color,
    gridLineOpts.color);\r\n\t\tvar i, offset, position;\r\n\r\n\t\tif (opts.pointLabels.display)
    {\r\n\t\t\tdrawPointLabels(me);\r\n\t\t}\r\n\r\n\t\tif (gridLineOpts.display)
    {\r\n\t\t\thelpers$1.each(me.ticks, function(label, index) {\r\n\t\t\t\tif (index
    !== 0) {\r\n\t\t\t\t\toffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\t\t\t\t\tdrawRadiusLine(me,
    gridLineOpts, offset, index);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif
    (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\tctx.save();\r\n\t\t\tctx.lineWidth
    = lineWidth;\r\n\t\t\tctx.strokeStyle = lineColor;\r\n\t\t\tif (ctx.setLineDash)
    {\r\n\t\t\t\tctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash,
    []]));\r\n\t\t\t\tctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset,
    gridLineOpts.borderDashOffset, 0.0]);\r\n\t\t\t}\r\n\r\n\t\t\tfor (i = me.chart.data.labels.length
    - 1; i >= 0; i--) {\r\n\t\t\t\toffset = me.getDistanceFromCenterForValue(opts.ticks.reverse
    ? me.min : me.max);\r\n\t\t\t\tposition = me.getPointPosition(i, offset);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(me.xCenter,
    me.yCenter);\r\n\t\t\t\tctx.lineTo(position.x, position.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\t_drawLabels: function() {\r\n\t\tvar me = this;\r\n\t\tvar
    ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\tif
    (!tickOpts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar startAngle = me.getIndexAngle(0);\r\n\t\tvar
    tickFont = helpers$1.options._parseFont(tickOpts);\r\n\t\tvar tickFontColor =
    valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);\r\n\t\tvar
    offset, width;\r\n\r\n\t\tctx.save();\r\n\t\tctx.font = tickFont.string;\r\n\t\tctx.translate(me.xCenter,
    me.yCenter);\r\n\t\tctx.rotate(startAngle);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\thelpers$1.each(me.ticks, function(label, index) {\r\n\t\t\tif
    (index === 0 && !tickOpts.reverse) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\toffset
    = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\r\n\t\t\tif
    (tickOpts.showLabelBackdrop) {\r\n\t\t\t\twidth = ctx.measureText(label).width;\r\n\t\t\t\tctx.fillStyle
    = tickOpts.backdropColor;\r\n\r\n\t\t\t\tctx.fillRect(\r\n\t\t\t\t\t-width / 2
    - tickOpts.backdropPaddingX,\r\n\t\t\t\t\t-offset - tickFont.size / 2 - tickOpts.backdropPaddingY,\r\n\t\t\t\t\twidth
    + tickOpts.backdropPaddingX * 2,\r\n\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY
    * 2\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tctx.fillStyle = tickFontColor;\r\n\t\t\tctx.fillText(label,
    0, -offset);\r\n\t\t});\r\n\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\t/**\r\n\t *
    @private\r\n\t */\r\n\t_drawTitle: helpers$1.noop\r\n});\r\n\r\n// INTERNAL: static
    default options, registered in src/index.js\r\nvar _defaults$3 = defaultConfig$3;\nscale_radialLinear._defaults
    = _defaults$3;\n\nvar deprecated$1 = helpers$1._deprecated;\r\nvar resolve$5 =
    helpers$1.options.resolve;\r\nvar valueOrDefault$d = helpers$1.valueOrDefault;\r\n\r\n//
    Integer constants are from the ES6 spec.\r\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER
    || -9007199254740991;\r\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\r\n\r\nvar
    INTERVALS = {\r\n\tmillisecond: {\r\n\t\tcommon: true,\r\n\t\tsize: 1,\r\n\t\tsteps:
    1000\r\n\t},\r\n\tsecond: {\r\n\t\tcommon: true,\r\n\t\tsize: 1000,\r\n\t\tsteps:
    60\r\n\t},\r\n\tminute: {\r\n\t\tcommon: true,\r\n\t\tsize: 60000,\r\n\t\tsteps:
    60\r\n\t},\r\n\thour: {\r\n\t\tcommon: true,\r\n\t\tsize: 3600000,\r\n\t\tsteps:
    24\r\n\t},\r\n\tday: {\r\n\t\tcommon: true,\r\n\t\tsize: 86400000,\r\n\t\tsteps:
    30\r\n\t},\r\n\tweek: {\r\n\t\tcommon: false,\r\n\t\tsize: 604800000,\r\n\t\tsteps:
    4\r\n\t},\r\n\tmonth: {\r\n\t\tcommon: true,\r\n\t\tsize: 2.628e9,\r\n\t\tsteps:
    12\r\n\t},\r\n\tquarter: {\r\n\t\tcommon: false,\r\n\t\tsize: 7.884e9,\r\n\t\tsteps:
    4\r\n\t},\r\n\tyear: {\r\n\t\tcommon: true,\r\n\t\tsize: 3.154e10\r\n\t}\r\n};\r\n\r\nvar
    UNITS = Object.keys(INTERVALS);\r\n\r\nfunction sorter(a, b) {\r\n\treturn a -
    b;\r\n}\r\n\r\nfunction arrayUnique(items) {\r\n\tvar hash = {};\r\n\tvar out
    = [];\r\n\tvar i, ilen, item;\r\n\r\n\tfor (i = 0, ilen = items.length; i < ilen;
    ++i) {\r\n\t\titem = items[i];\r\n\t\tif (!hash[item]) {\r\n\t\t\thash[item] =
    true;\r\n\t\t\tout.push(item);\r\n\t\t}\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\nfunction
    getMin(options) {\r\n\treturn helpers$1.valueOrDefault(options.time.min, options.ticks.min);\r\n}\r\n\r\nfunction
    getMax(options) {\r\n\treturn helpers$1.valueOrDefault(options.time.max, options.ticks.max);\r\n}\r\n\r\n/**\r\n
    * Returns an array of {time, pos} objects used to interpolate a specific `time`
    or position\r\n * (`pos`) on the scale, by searching entries before and after
    the requested value. `pos` is\r\n * a decimal between 0 and 1: 0 being the start
    of the scale (left or top) and 1 the other\r\n * extremity (left + width or top
    + height). Note that it would be more optimized to directly\r\n * store pre-computed
    pixels, but the scale dimensions are not guaranteed at the time we need\r\n *
    to create the lookup table. The table ALWAYS contains at least two items: min
    and max.\r\n *\r\n * @param {number[]} timestamps - timestamps sorted from lowest
    to highest.\r\n * @param {string} distribution - If 'linear', timestamps will
    be spread linearly along the min\r\n * and max range, so basically, the table
    will contains only two items: {min, 0} and {max, 1}.\r\n * If 'series', timestamps
    will be positioned at the same distance from each other. In this\r\n * case, only
    timestamps that break the time linearity are registered, meaning that in the\r\n
    * best case, all timestamps are linear, the table contains only min and max.\r\n
    */\r\nfunction buildLookupTable(timestamps, min, max, distribution) {\r\n\tif
    (distribution === 'linear' || !timestamps.length) {\r\n\t\treturn [\r\n\t\t\t{time:
    min, pos: 0},\r\n\t\t\t{time: max, pos: 1}\r\n\t\t];\r\n\t}\r\n\r\n\tvar table
    = [];\r\n\tvar items = [min];\r\n\tvar i, ilen, prev, curr, next;\r\n\r\n\tfor
    (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\tcurr = timestamps[i];\r\n\t\tif
    (curr > min && curr < max) {\r\n\t\t\titems.push(curr);\r\n\t\t}\r\n\t}\r\n\r\n\titems.push(max);\r\n\r\n\tfor
    (i = 0, ilen = items.length; i < ilen; ++i) {\r\n\t\tnext = items[i + 1];\r\n\t\tprev
    = items[i - 1];\r\n\t\tcurr = items[i];\r\n\r\n\t\t// only add points that breaks
    the scale linearity\r\n\t\tif (prev === undefined || next === undefined || Math.round((next
    + prev) / 2) !== curr) {\r\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    table;\r\n}\r\n\r\n// @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\r\nfunction
    lookup(table, key, value) {\r\n\tvar lo = 0;\r\n\tvar hi = table.length - 1;\r\n\tvar
    mid, i0, i1;\r\n\r\n\twhile (lo >= 0 && lo <= hi) {\r\n\t\tmid = (lo + hi) >>
    1;\r\n\t\ti0 = table[mid - 1] || null;\r\n\t\ti1 = table[mid];\r\n\r\n\t\tif (!i0)
    {\r\n\t\t\t// given value is outside table (before first item)\r\n\t\t\treturn
    {lo: null, hi: i1};\r\n\t\t} else if (i1[key] < value) {\r\n\t\t\tlo = mid + 1;\r\n\t\t}
    else if (i0[key] > value) {\r\n\t\t\thi = mid - 1;\r\n\t\t} else {\r\n\t\t\treturn
    {lo: i0, hi: i1};\r\n\t\t}\r\n\t}\r\n\r\n\t// given value is outside table (after
    last item)\r\n\treturn {lo: i1, hi: null};\r\n}\r\n\r\n/**\r\n * Linearly interpolates
    the given source `value` using the table items `skey` values and\r\n * returns
    the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n
    * returns the position for a timestamp equal to 42. If value is out of bounds,
    values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n
    */\r\nfunction interpolate$1(table, skey, sval, tkey) {\r\n\tvar range = lookup(table,
    skey, sval);\r\n\r\n\t// Note: the lookup table ALWAYS contains at least 2 items
    (min and max)\r\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length
    - 2] : range.lo;\r\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length
    - 1] : range.hi;\r\n\r\n\tvar span = next[skey] - prev[skey];\r\n\tvar ratio =
    span ? (sval - prev[skey]) / span : 0;\r\n\tvar offset = (next[tkey] - prev[tkey])
    * ratio;\r\n\r\n\treturn prev[tkey] + offset;\r\n}\r\n\r\nfunction toTimestamp(scale,
    input) {\r\n\tvar adapter = scale._adapter;\r\n\tvar options = scale.options.time;\r\n\tvar
    parser = options.parser;\r\n\tvar format = parser || options.format;\r\n\tvar
    value = input;\r\n\r\n\tif (typeof parser === 'function') {\r\n\t\tvalue = parser(value);\r\n\t}\r\n\r\n\t//
    Only parse if its not a timestamp already\r\n\tif (!helpers$1.isFinite(value))
    {\r\n\t\tvalue = typeof format === 'string'\r\n\t\t\t? adapter.parse(value, format)\r\n\t\t\t:
    adapter.parse(value);\r\n\t}\r\n\r\n\tif (value !== null) {\r\n\t\treturn +value;\r\n\t}\r\n\r\n\t//
    Labels are in an incompatible format and no `parser` has been provided.\r\n\t//
    The user might still use the deprecated `format` option for parsing.\r\n\tif (!parser
    && typeof format === 'function') {\r\n\t\tvalue = format(input);\r\n\r\n\t\t//
    `format` could return something else than a timestamp, if so, parse it\r\n\t\tif
    (!helpers$1.isFinite(value)) {\r\n\t\t\tvalue = adapter.parse(value);\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    value;\r\n}\r\n\r\nfunction parse(scale, input) {\r\n\tif (helpers$1.isNullOrUndef(input))
    {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar options = scale.options.time;\r\n\tvar
    value = toTimestamp(scale, scale.getRightValue(input));\r\n\tif (value === null)
    {\r\n\t\treturn value;\r\n\t}\r\n\r\n\tif (options.round) {\r\n\t\tvalue = +scale._adapter.startOf(value,
    options.round);\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Figures out
    what unit results in an appropriate number of auto-generated ticks\r\n */\r\nfunction
    determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n\tvar ilen = UNITS.length;\r\n\tvar
    i, interval, factor;\r\n\r\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i)
    {\r\n\t\tinterval = INTERVALS[UNITS[i]];\r\n\t\tfactor = interval.steps ? interval.steps
    : MAX_INTEGER;\r\n\r\n\t\tif (interval.common && Math.ceil((max - min) / (factor
    * interval.size)) <= capacity) {\r\n\t\t\treturn UNITS[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    UNITS[ilen - 1];\r\n}\r\n\r\n/**\r\n * Figures out what unit to format a set of
    ticks with\r\n */\r\nfunction determineUnitForFormatting(scale, numTicks, minUnit,
    min, max) {\r\n\tvar i, unit;\r\n\r\n\tfor (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit);
    i--) {\r\n\t\tunit = UNITS[i];\r\n\t\tif (INTERVALS[unit].common && scale._adapter.diff(max,
    min, unit) >= numTicks - 1) {\r\n\t\t\treturn unit;\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\n\r\nfunction determineMajorUnit(unit)
    {\r\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i)
    {\r\n\t\tif (INTERVALS[UNITS[i]].common) {\r\n\t\t\treturn UNITS[i];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n
    * Generates a maximum of `capacity` timestamps between min and max, rounded to
    the\r\n * `minor` unit using the given scale time `options`.\r\n * Important:
    this method can return ticks outside the min and max range, it's the\r\n * responsibility
    of the calling code to clamp values if needed.\r\n */\r\nfunction generate(scale,
    min, max, capacity) {\r\n\tvar adapter = scale._adapter;\r\n\tvar options = scale.options;\r\n\tvar
    timeOpts = options.time;\r\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit,
    min, max, capacity);\r\n\tvar stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize,
    1]);\r\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n\tvar
    first = min;\r\n\tvar ticks = [];\r\n\tvar time;\r\n\r\n\t// For 'week' unit,
    handle the first day of week option\r\n\tif (weekday) {\r\n\t\tfirst = +adapter.startOf(first,
    'isoWeek', weekday);\r\n\t}\r\n\r\n\t// Align first ticks on unit\r\n\tfirst =
    +adapter.startOf(first, weekday ? 'day' : minor);\r\n\r\n\t// Prevent browser
    from freezing in case user options request millions of milliseconds\r\n\tif (adapter.diff(max,
    min, minor) > 100000 * stepSize) {\r\n\t\tthrow min + ' and ' + max + ' are too
    far apart with stepSize of ' + stepSize + ' ' + minor;\r\n\t}\r\n\r\n\tfor (time
    = first; time < max; time = +adapter.add(time, stepSize, minor)) {\r\n\t\tticks.push(time);\r\n\t}\r\n\r\n\tif
    (time === max || options.bounds === 'ticks') {\r\n\t\tticks.push(time);\r\n\t}\r\n\r\n\treturn
    ticks;\r\n}\r\n\r\n/**\r\n * Returns the start and end offsets from edges in the
    form of {start, end}\r\n * where each value is a relative width to the scale and
    ranges between 0 and 1.\r\n * They add extra margins on the both sides by scaling
    down the original scale.\r\n * Offsets are added when the `offset` option is true.\r\n
    */\r\nfunction computeOffsets(table, ticks, min, max, options) {\r\n\tvar start
    = 0;\r\n\tvar end = 0;\r\n\tvar first, last;\r\n\r\n\tif (options.offset && ticks.length)
    {\r\n\t\tfirst = interpolate$1(table, 'time', ticks[0], 'pos');\r\n\t\tif (ticks.length
    === 1) {\r\n\t\t\tstart = 1 - first;\r\n\t\t} else {\r\n\t\t\tstart = (interpolate$1(table,
    'time', ticks[1], 'pos') - first) / 2;\r\n\t\t}\r\n\t\tlast = interpolate$1(table,
    'time', ticks[ticks.length - 1], 'pos');\r\n\t\tif (ticks.length === 1) {\r\n\t\t\tend
    = last;\r\n\t\t} else {\r\n\t\t\tend = (last - interpolate$1(table, 'time', ticks[ticks.length
    - 2], 'pos')) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn {start: start, end: end, factor:
    1 / (start + 1 + end)};\r\n}\r\n\r\nfunction setMajorTicks(scale, ticks, map,
    majorUnit) {\r\n\tvar adapter = scale._adapter;\r\n\tvar first = +adapter.startOf(ticks[0].value,
    majorUnit);\r\n\tvar last = ticks[ticks.length - 1].value;\r\n\tvar major, index;\r\n\r\n\tfor
    (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n\t\tindex
    = map[major];\r\n\t\tif (index >= 0) {\r\n\t\t\tticks[index].major = true;\r\n\t\t}\r\n\t}\r\n\treturn
    ticks;\r\n}\r\n\r\nfunction ticksFromTimestamps(scale, values, majorUnit) {\r\n\tvar
    ticks = [];\r\n\tvar map = {};\r\n\tvar ilen = values.length;\r\n\tvar i, value;\r\n\r\n\tfor
    (i = 0; i < ilen; ++i) {\r\n\t\tvalue = values[i];\r\n\t\tmap[value] = i;\r\n\r\n\t\tticks.push({\r\n\t\t\tvalue:
    value,\r\n\t\t\tmajor: false\r\n\t\t});\r\n\t}\r\n\r\n\t// We set the major ticks
    separately from the above loop because calling startOf for every tick\r\n\t//
    is expensive when there is a large number of ticks\r\n\treturn (ilen === 0 ||
    !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\n\r\nvar
    defaultConfig$4 = {\r\n\tposition: 'bottom',\r\n\r\n\t/**\r\n\t * Data distribution
    along the scale:\r\n\t * - 'linear': data are spread according to their time (distances
    can vary),\r\n\t * - 'series': data are spread at the same distance from each
    other.\r\n\t * @see https://github.com/chartjs/Chart.js/pull/4507\r\n\t * @since
    2.7.0\r\n\t */\r\n\tdistribution: 'linear',\r\n\r\n\t/**\r\n\t * Scale boundary
    strategy (bypassed by min/max time options)\r\n\t * - `data`: make sure data are
    fully visible, ticks outside are removed\r\n\t * - `ticks`: make sure ticks are
    fully visible, data outside are truncated\r\n\t * @see https://github.com/chartjs/Chart.js/pull/4556\r\n\t
    * @since 2.7.0\r\n\t */\r\n\tbounds: 'data',\r\n\r\n\tadapters: {},\r\n\ttime:
    {\r\n\t\tparser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/
    or a custom callback that converts its argument to a moment\r\n\t\tunit: false,
    // false == automatic or override with week, month, year, etc.\r\n\t\tround: false,
    // none, or override with week, month, year, etc.\r\n\t\tdisplayFormat: false,
    // DEPRECATED\r\n\t\tisoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\r\n\t\tminUnit:
    'millisecond',\r\n\t\tdisplayFormats: {}\r\n\t},\r\n\tticks: {\r\n\t\tautoSkip:
    false,\r\n\r\n\t\t/**\r\n\t\t * Ticks generation input values:\r\n\t\t * - 'auto':
    generates \"optimal\" ticks based on scale size and time options.\r\n\t\t * -
    'data': generates ticks from data (including labels from data {t|x|y} objects).\r\n\t\t
    * - 'labels': generates ticks from user given `data.labels` values ONLY.\r\n\t\t
    * @see https://github.com/chartjs/Chart.js/pull/4507\r\n\t\t * @since 2.7.0\r\n\t\t
    */\r\n\t\tsource: 'auto',\r\n\r\n\t\tmajor: {\r\n\t\t\tenabled: false\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar
    scale_time = core_scale.extend({\r\n\tinitialize: function() {\r\n\t\tthis.mergeTicksOptions();\r\n\t\tcore_scale.prototype.initialize.call(this);\r\n\t},\r\n\r\n\tupdate:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar options = me.options;\r\n\t\tvar
    time = options.time || (options.time = {});\r\n\t\tvar adapter = me._adapter =
    new core_adapters._date(options.adapters.date);\r\n\r\n\t\t// DEPRECATIONS: output
    a message only one time per update\r\n\t\tdeprecated$1('time scale', time.format,
    'time.format', 'time.parser');\r\n\t\tdeprecated$1('time scale', time.min, 'time.min',
    'ticks.min');\r\n\t\tdeprecated$1('time scale', time.max, 'time.max', 'ticks.max');\r\n\r\n\t\t//
    Backward compatibility: before introducing adapter, `displayFormats` was\r\n\t\t//
    supposed to contain *all* unit/string pairs but this can't be resolved\r\n\t\t//
    when loading the scale (adapters are loaded afterward), so let's populate\r\n\t\t//
    missing formats on update\r\n\t\thelpers$1.mergeIf(time.displayFormats, adapter.formats());\r\n\r\n\t\treturn
    core_scale.prototype.update.apply(me, arguments);\r\n\t},\r\n\r\n\t/**\r\n\t *
    Allows data to be referenced via 't' attribute\r\n\t */\r\n\tgetRightValue: function(rawValue)
    {\r\n\t\tif (rawValue && rawValue.t !== undefined) {\r\n\t\t\trawValue = rawValue.t;\r\n\t\t}\r\n\t\treturn
    core_scale.prototype.getRightValue.call(this, rawValue);\r\n\t},\r\n\r\n\tdetermineDataLimits:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar adapter
    = me._adapter;\r\n\t\tvar options = me.options;\r\n\t\tvar unit = options.time.unit
    || 'day';\r\n\t\tvar min = MAX_INTEGER;\r\n\t\tvar max = MIN_INTEGER;\r\n\t\tvar
    timestamps = [];\r\n\t\tvar datasets = [];\r\n\t\tvar labels = [];\r\n\t\tvar
    i, j, ilen, jlen, data, timestamp, labelsAdded;\r\n\t\tvar dataLabels = me._getLabels();\r\n\r\n\t\tfor
    (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\tlabels.push(parse(me,
    dataLabels[i]));\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = (chart.data.datasets ||
    []).length; i < ilen; ++i) {\r\n\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\tdata
    = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t// Let's consider that all data
    have the same format.\r\n\t\t\t\tif (helpers$1.isObject(data[0])) {\r\n\t\t\t\t\tdatasets[i]
    = [];\r\n\r\n\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\ttimestamp
    = parse(me, data[j]);\r\n\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\tdatasets[i][j]
    = timestamp;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\tif
    (!labelsAdded) {\r\n\t\t\t\t\t\ttimestamps = timestamps.concat(labels);\r\n\t\t\t\t\t\tlabelsAdded
    = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tdatasets[i] =
    [];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (labels.length) {\r\n\t\t\tmin = Math.min(min,
    labels[0]);\r\n\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t}\r\n\r\n\t\tif
    (timestamps.length) {\r\n\t\t\ttimestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter)
    : timestamps.sort(sorter);\r\n\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\tmax
    = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t}\r\n\r\n\t\tmin =
    parse(me, getMin(options)) || min;\r\n\t\tmax = parse(me, getMax(options)) ||
    max;\r\n\r\n\t\t// In case there is no valid min/max, set limits based on unit
    time option\r\n\t\tmin = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit)
    : min;\r\n\t\tmax = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1
    : max;\r\n\r\n\t\t// Make sure that max is strictly higher than min (required
    by the lookup table)\r\n\t\tme.min = Math.min(min, max);\r\n\t\tme.max = Math.max(min
    + 1, max);\r\n\r\n\t\t// PRIVATE\r\n\t\tme._table = [];\r\n\t\tme._timestamps
    = {\r\n\t\t\tdata: timestamps,\r\n\t\t\tdatasets: datasets,\r\n\t\t\tlabels: labels\r\n\t\t};\r\n\t},\r\n\r\n\tbuildTicks:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar min = me.min;\r\n\t\tvar max = me.max;\r\n\t\tvar
    options = me.options;\r\n\t\tvar tickOpts = options.ticks;\r\n\t\tvar timeOpts
    = options.time;\r\n\t\tvar timestamps = me._timestamps;\r\n\t\tvar ticks = [];\r\n\t\tvar
    capacity = me.getLabelCapacity(min);\r\n\t\tvar source = tickOpts.source;\r\n\t\tvar
    distribution = options.distribution;\r\n\t\tvar i, ilen, timestamp;\r\n\r\n\t\tif
    (source === 'data' || (source === 'auto' && distribution === 'series')) {\r\n\t\t\ttimestamps
    = timestamps.data;\r\n\t\t} else if (source === 'labels') {\r\n\t\t\ttimestamps
    = timestamps.labels;\r\n\t\t} else {\r\n\t\t\ttimestamps = generate(me, min, max,
    capacity);\r\n\t\t}\r\n\r\n\t\tif (options.bounds === 'ticks' && timestamps.length)
    {\r\n\t\t\tmin = timestamps[0];\r\n\t\t\tmax = timestamps[timestamps.length -
    1];\r\n\t\t}\r\n\r\n\t\t// Enforce limits with user min/max options\r\n\t\tmin
    = parse(me, getMin(options)) || min;\r\n\t\tmax = parse(me, getMax(options)) ||
    max;\r\n\r\n\t\t// Remove ticks outside the min/max range\r\n\t\tfor (i = 0, ilen
    = timestamps.length; i < ilen; ++i) {\r\n\t\t\ttimestamp = timestamps[i];\r\n\t\t\tif
    (timestamp >= min && timestamp <= max) {\r\n\t\t\t\tticks.push(timestamp);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.min
    = min;\r\n\t\tme.max = max;\r\n\r\n\t\t// PRIVATE\r\n\t\t// determineUnitForFormatting
    relies on the number of ticks so we don't use it when\r\n\t\t// autoSkip is enabled
    because we don't yet know what the final number of ticks will be\r\n\t\tme._unit
    = timeOpts.unit || (tickOpts.autoSkip\r\n\t\t\t? determineUnitForAutoTicks(timeOpts.minUnit,
    me.min, me.max, capacity)\r\n\t\t\t: determineUnitForFormatting(me, ticks.length,
    timeOpts.minUnit, me.min, me.max));\r\n\t\tme._majorUnit = !tickOpts.major.enabled
    || me._unit === 'year' ? undefined\r\n\t\t\t: determineMajorUnit(me._unit);\r\n\t\tme._table
    = buildLookupTable(me._timestamps.data, min, max, distribution);\r\n\t\tme._offsets
    = computeOffsets(me._table, ticks, min, max, options);\r\n\r\n\t\tif (tickOpts.reverse)
    {\r\n\t\t\tticks.reverse();\r\n\t\t}\r\n\r\n\t\treturn ticksFromTimestamps(me,
    ticks, me._majorUnit);\r\n\t},\r\n\r\n\tgetLabelForIndex: function(index, datasetIndex)
    {\r\n\t\tvar me = this;\r\n\t\tvar adapter = me._adapter;\r\n\t\tvar data = me.chart.data;\r\n\t\tvar
    timeOpts = me.options.time;\r\n\t\tvar label = data.labels && index < data.labels.length
    ? data.labels[index] : '';\r\n\t\tvar value = data.datasets[datasetIndex].data[index];\r\n\r\n\t\tif
    (helpers$1.isObject(value)) {\r\n\t\t\tlabel = me.getRightValue(value);\r\n\t\t}\r\n\t\tif
    (timeOpts.tooltipFormat) {\r\n\t\t\treturn adapter.format(toTimestamp(me, label),
    timeOpts.tooltipFormat);\r\n\t\t}\r\n\t\tif (typeof label === 'string') {\r\n\t\t\treturn
    label;\r\n\t\t}\r\n\t\treturn adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\r\n\t},\r\n\r\n\t/**\r\n\t
    * Function to format an individual tick mark\r\n\t * @private\r\n\t */\r\n\ttickFormatFunction:
    function(time, index, ticks, format) {\r\n\t\tvar me = this;\r\n\t\tvar adapter
    = me._adapter;\r\n\t\tvar options = me.options;\r\n\t\tvar formats = options.time.displayFormats;\r\n\t\tvar
    minorFormat = formats[me._unit];\r\n\t\tvar majorUnit = me._majorUnit;\r\n\t\tvar
    majorFormat = formats[majorUnit];\r\n\t\tvar tick = ticks[index];\r\n\t\tvar tickOpts
    = options.ticks;\r\n\t\tvar major = majorUnit && majorFormat && tick && tick.major;\r\n\t\tvar
    label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\r\n\t\tvar
    nestedTickOpts = major ? tickOpts.major : tickOpts.minor;\r\n\t\tvar formatter
    = resolve$5([\r\n\t\t\tnestedTickOpts.callback,\r\n\t\t\tnestedTickOpts.userCallback,\r\n\t\t\ttickOpts.callback,\r\n\t\t\ttickOpts.userCallback\r\n\t\t]);\r\n\r\n\t\treturn
    formatter ? formatter(label, index, ticks) : label;\r\n\t},\r\n\r\n\tconvertTicksToLabels:
    function(ticks) {\r\n\t\tvar labels = [];\r\n\t\tvar i, ilen;\r\n\r\n\t\tfor (i
    = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\t\tlabels.push(this.tickFormatFunction(ticks[i].value,
    i, ticks));\r\n\t\t}\r\n\r\n\t\treturn labels;\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t
    */\r\n\tgetPixelForOffset: function(time) {\r\n\t\tvar me = this;\r\n\t\tvar offsets
    = me._offsets;\r\n\t\tvar pos = interpolate$1(me._table, 'time', time, 'pos');\r\n\t\treturn
    me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n\t},\r\n\r\n\tgetPixelForValue:
    function(value, index, datasetIndex) {\r\n\t\tvar me = this;\r\n\t\tvar time =
    null;\r\n\r\n\t\tif (index !== undefined && datasetIndex !== undefined) {\r\n\t\t\ttime
    = me._timestamps.datasets[datasetIndex][index];\r\n\t\t}\r\n\r\n\t\tif (time ===
    null) {\r\n\t\t\ttime = parse(me, value);\r\n\t\t}\r\n\r\n\t\tif (time !== null)
    {\r\n\t\t\treturn me.getPixelForOffset(time);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPixelForTick:
    function(index) {\r\n\t\tvar ticks = this.getTicks();\r\n\t\treturn index >= 0
    && index < ticks.length ?\r\n\t\t\tthis.getPixelForOffset(ticks[index].value)
    :\r\n\t\t\tnull;\r\n\t},\r\n\r\n\tgetValueForPixel: function(pixel) {\r\n\t\tvar
    me = this;\r\n\t\tvar offsets = me._offsets;\r\n\t\tvar pos = me.getDecimalForPixel(pixel)
    / offsets.factor - offsets.end;\r\n\t\tvar time = interpolate$1(me._table, 'pos',
    pos, 'time');\r\n\r\n\t\t// DEPRECATION, we should return time directly\r\n\t\treturn
    me._adapter._create(time);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLabelSize:
    function(label) {\r\n\t\tvar me = this;\r\n\t\tvar ticksOpts = me.options.ticks;\r\n\t\tvar
    tickLabelWidth = me.ctx.measureText(label).width;\r\n\t\tvar angle = helpers$1.toRadians(me.isHorizontal()
    ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n\t\tvar cosRotation = Math.cos(angle);\r\n\t\tvar
    sinRotation = Math.sin(angle);\r\n\t\tvar tickFontSize = valueOrDefault$d(ticksOpts.fontSize,
    core_defaults.global.defaultFontSize);\r\n\r\n\t\treturn {\r\n\t\t\tw: (tickLabelWidth
    * cosRotation) + (tickFontSize * sinRotation),\r\n\t\t\th: (tickLabelWidth * sinRotation)
    + (tickFontSize * cosRotation)\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Crude approximation
    of what the label width might be\r\n\t * @private\r\n\t */\r\n\tgetLabelWidth:
    function(label) {\r\n\t\treturn this._getLabelSize(label).w;\r\n\t},\r\n\r\n\t/**\r\n\t
    * @private\r\n\t */\r\n\tgetLabelCapacity: function(exampleTime) {\r\n\t\tvar
    me = this;\r\n\t\tvar timeOpts = me.options.time;\r\n\t\tvar displayFormats =
    timeOpts.displayFormats;\r\n\r\n\t\t// pick the longest format (milliseconds)
    for guestimation\r\n\t\tvar format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n\t\tvar
    exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime],
    me._majorUnit), format);\r\n\t\tvar size = me._getLabelSize(exampleLabel);\r\n\t\tvar
    capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);\r\n\r\n\t\tif
    (me.options.offset) {\r\n\t\t\tcapacity--;\r\n\t\t}\r\n\r\n\t\treturn capacity
    > 0 ? capacity : 1;\r\n\t}\r\n});\r\n\r\n// INTERNAL: static default options,
    registered in src/index.js\r\nvar _defaults$4 = defaultConfig$4;\nscale_time._defaults
    = _defaults$4;\n\nvar scales = {\r\n\tcategory: scale_category,\r\n\tlinear: scale_linear,\r\n\tlogarithmic:
    scale_logarithmic,\r\n\tradialLinear: scale_radialLinear,\r\n\ttime: scale_time\r\n};\n\nvar
    FORMATS = {\r\n\tdatetime: 'MMM D, YYYY, h:mm:ss a',\r\n\tmillisecond: 'h:mm:ss.SSS
    a',\r\n\tsecond: 'h:mm:ss a',\r\n\tminute: 'h:mm a',\r\n\thour: 'hA',\r\n\tday:
    'MMM D',\r\n\tweek: 'll',\r\n\tmonth: 'MMM YYYY',\r\n\tquarter: '[Q]Q - YYYY',\r\n\tyear:
    'YYYY'\r\n};\r\n\r\ncore_adapters._date.override(typeof moment === 'function'
    ? {\r\n\t_id: 'moment', // DEBUG ONLY\r\n\r\n\tformats: function() {\r\n\t\treturn
    FORMATS;\r\n\t},\r\n\r\n\tparse: function(value, format) {\r\n\t\tif (typeof value
    === 'string' && typeof format === 'string') {\r\n\t\t\tvalue = moment(value, format);\r\n\t\t}
    else if (!(value instanceof moment)) {\r\n\t\t\tvalue = moment(value);\r\n\t\t}\r\n\t\treturn
    value.isValid() ? value.valueOf() : null;\r\n\t},\r\n\r\n\tformat: function(time,
    format) {\r\n\t\treturn moment(time).format(format);\r\n\t},\r\n\r\n\tadd: function(time,
    amount, unit) {\r\n\t\treturn moment(time).add(amount, unit).valueOf();\r\n\t},\r\n\r\n\tdiff:
    function(max, min, unit) {\r\n\t\treturn moment(max).diff(moment(min), unit);\r\n\t},\r\n\r\n\tstartOf:
    function(time, unit, weekday) {\r\n\t\ttime = moment(time);\r\n\t\tif (unit ===
    'isoWeek') {\r\n\t\t\treturn time.isoWeekday(weekday).valueOf();\r\n\t\t}\r\n\t\treturn
    time.startOf(unit).valueOf();\r\n\t},\r\n\r\n\tendOf: function(time, unit) {\r\n\t\treturn
    moment(time).endOf(unit).valueOf();\r\n\t},\r\n\r\n\t// DEPRECATIONS\r\n\r\n\t/**\r\n\t
    * Provided for backward compatibility with scale.getValueForPixel().\r\n\t * @deprecated
    since version 2.8.0\r\n\t * @todo remove at version 3\r\n\t * @private\r\n\t */\r\n\t_create:
    function(time) {\r\n\t\treturn moment(time);\r\n\t},\r\n} : {});\n\ncore_defaults._set('global',
    {\r\n\tplugins: {\r\n\t\tfiller: {\r\n\t\t\tpropagate: true\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar
    mappers = {\r\n\tdataset: function(source) {\r\n\t\tvar index = source.fill;\r\n\t\tvar
    chart = source.chart;\r\n\t\tvar meta = chart.getDatasetMeta(index);\r\n\t\tvar
    visible = meta && chart.isDatasetVisible(index);\r\n\t\tvar points = (visible
    && meta.dataset._children) || [];\r\n\t\tvar length = points.length || 0;\r\n\r\n\t\treturn
    !length ? null : function(point, i) {\r\n\t\t\treturn (i < length && points[i]._view)
    || null;\r\n\t\t};\r\n\t},\r\n\r\n\tboundary: function(source) {\r\n\t\tvar boundary
    = source.boundary;\r\n\t\tvar x = boundary ? boundary.x : null;\r\n\t\tvar y =
    boundary ? boundary.y : null;\r\n\r\n\t\tif (helpers$1.isArray(boundary)) {\r\n\t\t\treturn
    function(point, i) {\r\n\t\t\t\treturn boundary[i];\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn
    function(point) {\r\n\t\t\treturn {\r\n\t\t\t\tx: x === null ? point.x : x,\r\n\t\t\t\ty:
    y === null ? point.y : y,\r\n\t\t\t};\r\n\t\t};\r\n\t}\r\n};\r\n\r\n// @todo if
    (fill[0] === '#')\r\nfunction decodeFill(el, index, count) {\r\n\tvar model =
    el._model || {};\r\n\tvar fill = model.fill;\r\n\tvar target;\r\n\r\n\tif (fill
    === undefined) {\r\n\t\tfill = !!model.backgroundColor;\r\n\t}\r\n\r\n\tif (fill
    === false || fill === null) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (fill ===
    true) {\r\n\t\treturn 'origin';\r\n\t}\r\n\r\n\ttarget = parseFloat(fill, 10);\r\n\tif
    (isFinite(target) && Math.floor(target) === target) {\r\n\t\tif (fill[0] === '-'
    || fill[0] === '+') {\r\n\t\t\ttarget = index + target;\r\n\t\t}\r\n\r\n\t\tif
    (target === index || target < 0 || target >= count) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn
    target;\r\n\t}\r\n\r\n\tswitch (fill) {\r\n\t// compatibility\r\n\tcase 'bottom':\r\n\t\treturn
    'start';\r\n\tcase 'top':\r\n\t\treturn 'end';\r\n\tcase 'zero':\r\n\t\treturn
    'origin';\r\n\t// supported boundaries\r\n\tcase 'origin':\r\n\tcase 'start':\r\n\tcase
    'end':\r\n\t\treturn fill;\r\n\t// invalid fill values\r\n\tdefault:\r\n\t\treturn
    false;\r\n\t}\r\n}\r\n\r\nfunction computeLinearBoundary(source) {\r\n\tvar model
    = source.el._model || {};\r\n\tvar scale = source.el._scale || {};\r\n\tvar fill
    = source.fill;\r\n\tvar target = null;\r\n\tvar horizontal;\r\n\r\n\tif (isFinite(fill))
    {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Backward compatibility: until v3, we
    still need to support boundary values set on\r\n\t// the model (scaleTop, scaleBottom
    and scaleZero) because some external plugins and\r\n\t// controllers might still
    use it (e.g. the Smith chart).\r\n\r\n\tif (fill === 'start') {\r\n\t\ttarget
    = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\r\n\t} else
    if (fill === 'end') {\r\n\t\ttarget = model.scaleTop === undefined ? scale.top
    : model.scaleTop;\r\n\t} else if (model.scaleZero !== undefined) {\r\n\t\ttarget
    = model.scaleZero;\r\n\t} else if (scale.getBasePixel) {\r\n\t\ttarget = scale.getBasePixel();\r\n\t}\r\n\r\n\tif
    (target !== undefined && target !== null) {\r\n\t\tif (target.x !== undefined
    && target.y !== undefined) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\tif (helpers$1.isFinite(target))
    {\r\n\t\t\thorizontal = scale.isHorizontal();\r\n\t\t\treturn {\r\n\t\t\t\tx:
    horizontal ? target : null,\r\n\t\t\t\ty: horizontal ? null : target\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\treturn
    null;\r\n}\r\n\r\nfunction computeCircularBoundary(source) {\r\n\tvar scale =
    source.el._scale;\r\n\tvar options = scale.options;\r\n\tvar length = scale.chart.data.labels.length;\r\n\tvar
    fill = source.fill;\r\n\tvar target = [];\r\n\tvar start, end, center, i, point;\r\n\r\n\tif
    (!length) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstart = options.ticks.reverse
    ? scale.max : scale.min;\r\n\tend = options.ticks.reverse ? scale.min : scale.max;\r\n\tcenter
    = scale.getPointPositionForValue(0, start);\r\n\tfor (i = 0; i < length; ++i)
    {\r\n\t\tpoint = fill === 'start' || fill === 'end'\r\n\t\t\t? scale.getPointPositionForValue(i,
    fill === 'start' ? start : end)\r\n\t\t\t: scale.getBasePosition(i);\r\n\t\tif
    (options.gridLines.circular) {\r\n\t\t\tpoint.cx = center.x;\r\n\t\t\tpoint.cy
    = center.y;\r\n\t\t\tpoint.angle = scale.getIndexAngle(i) - Math.PI / 2;\r\n\t\t}\r\n\t\ttarget.push(point);\r\n\t}\r\n\treturn
    target;\r\n}\r\n\r\nfunction computeBoundary(source) {\r\n\tvar scale = source.el._scale
    || {};\r\n\r\n\tif (scale.getPointPositionForValue) {\r\n\t\treturn computeCircularBoundary(source);\r\n\t}\r\n\treturn
    computeLinearBoundary(source);\r\n}\r\n\r\nfunction resolveTarget(sources, index,
    propagate) {\r\n\tvar source = sources[index];\r\n\tvar fill = source.fill;\r\n\tvar
    visited = [index];\r\n\tvar target;\r\n\r\n\tif (!propagate) {\r\n\t\treturn fill;\r\n\t}\r\n\r\n\twhile
    (fill !== false && visited.indexOf(fill) === -1) {\r\n\t\tif (!isFinite(fill))
    {\r\n\t\t\treturn fill;\r\n\t\t}\r\n\r\n\t\ttarget = sources[fill];\r\n\t\tif
    (!target) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (target.visible) {\r\n\t\t\treturn
    fill;\r\n\t\t}\r\n\r\n\t\tvisited.push(fill);\r\n\t\tfill = target.fill;\r\n\t}\r\n\r\n\treturn
    false;\r\n}\r\n\r\nfunction createMapper(source) {\r\n\tvar fill = source.fill;\r\n\tvar
    type = 'dataset';\r\n\r\n\tif (fill === false) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tif
    (!isFinite(fill)) {\r\n\t\ttype = 'boundary';\r\n\t}\r\n\r\n\treturn mappers[type](source);\r\n}\r\n\r\nfunction
    isDrawable(point) {\r\n\treturn point && !point.skip;\r\n}\r\n\r\nfunction drawArea(ctx,
    curve0, curve1, len0, len1) {\r\n\tvar i, cx, cy, r;\r\n\r\n\tif (!len0 || !len1)
    {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// building first area curve (normal)\r\n\tctx.moveTo(curve0[0].x,
    curve0[0].y);\r\n\tfor (i = 1; i < len0; ++i) {\r\n\t\thelpers$1.canvas.lineTo(ctx,
    curve0[i - 1], curve0[i]);\r\n\t}\r\n\r\n\tif (curve1[0].angle !== undefined)
    {\r\n\t\tcx = curve1[0].cx;\r\n\t\tcy = curve1[0].cy;\r\n\t\tr = Math.sqrt(Math.pow(curve1[0].x
    - cx, 2) + Math.pow(curve1[0].y - cy, 2));\r\n\t\tfor (i = len1 - 1; i > 0; --i)
    {\r\n\t\t\tctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\t//
    joining the two area curves\r\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 -
    1].y);\r\n\r\n\t// building opposite area curve (reverse)\r\n\tfor (i = len1 -
    1; i > 0; --i) {\r\n\t\thelpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1],
    true);\r\n\t}\r\n}\r\n\r\nfunction doFill(ctx, points, mapper, view, color, loop)
    {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0
    = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i,
    ilen, index, p0, p1, d0, d1, loopOffset;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor
    (i = 0, ilen = count; i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1
    = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif
    (loop && loopOffset === undefined && d0) {\r\n\t\t\tloopOffset = i + 1;\r\n\t\t\tilen
    = count + loopOffset;\r\n\t\t}\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1
    = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx,
    curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1
    = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif
    (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx,
    curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r\n\r\nvar
    plugin_filler = {\r\n\tid: 'filler',\r\n\r\n\tafterDatasetsUpdate: function(chart,
    options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate
    = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor
    (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel
    = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el
    instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill:
    decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler
    = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count;
    ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill
    = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper
    = createMapper(source);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeDatasetsDraw: function(chart)
    {\r\n\t\tvar metasets = chart._getSortedVisibleDatasetMetas();\r\n\t\tvar ctx
    = chart.ctx;\r\n\t\tvar meta, i, el, view, points, mapper, color;\r\n\r\n\t\tfor
    (i = metasets.length - 1; i >= 0; --i) {\r\n\t\t\tmeta = metasets[i].$filler;\r\n\r\n\t\t\tif
    (!meta || !meta.visible) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tel = meta.el;\r\n\t\t\tview
    = el._view;\r\n\t\t\tpoints = el._children || [];\r\n\t\t\tmapper = meta.mapper;\r\n\t\t\tcolor
    = view.backgroundColor || core_defaults.global.defaultColor;\r\n\r\n\t\t\tif (mapper
    && color && points.length) {\r\n\t\t\t\thelpers$1.canvas.clipArea(ctx, chart.chartArea);\r\n\t\t\t\tdoFill(ctx,
    points, mapper, view, color, el._loop);\r\n\t\t\t\thelpers$1.canvas.unclipArea(ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\n\nvar
    getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;\r\nvar noop$1 = helpers$1.noop;\r\nvar
    valueOrDefault$e = helpers$1.valueOrDefault;\r\n\r\ncore_defaults._set('global',
    {\r\n\tlegend: {\r\n\t\tdisplay: true,\r\n\t\tposition: 'top',\r\n\t\talign: 'center',\r\n\t\tfullWidth:
    true,\r\n\t\treverse: false,\r\n\t\tweight: 1000,\r\n\r\n\t\t// a callback that
    will handle\r\n\t\tonClick: function(e, legendItem) {\r\n\t\t\tvar index = legendItem.datasetIndex;\r\n\t\t\tvar
    ci = this.chart;\r\n\t\t\tvar meta = ci.getDatasetMeta(index);\r\n\r\n\t\t\t//
    See controller.isDatasetVisible comment\r\n\t\t\tmeta.hidden = meta.hidden ===
    null ? !ci.data.datasets[index].hidden : null;\r\n\r\n\t\t\t// We hid a dataset
    ... rerender the chart\r\n\t\t\tci.update();\r\n\t\t},\r\n\r\n\t\tonHover: null,\r\n\t\tonLeave:
    null,\r\n\r\n\t\tlabels: {\r\n\t\t\tboxWidth: 40,\r\n\t\t\tpadding: 10,\r\n\t\t\t//
    Generates labels shown in the legend\r\n\t\t\t// Valid properties to return:\r\n\t\t\t//
    text : text to display\r\n\t\t\t// fillStyle : fill of coloured box\r\n\t\t\t//
    strokeStyle: stroke of coloured box\r\n\t\t\t// hidden : if this legend item refers
    to a hidden item\r\n\t\t\t// lineCap : cap style for line\r\n\t\t\t// lineDash\r\n\t\t\t//
    lineDashOffset :\r\n\t\t\t// lineJoin :\r\n\t\t\t// lineWidth :\r\n\t\t\tgenerateLabels:
    function(chart) {\r\n\t\t\t\tvar datasets = chart.data.datasets;\r\n\t\t\t\tvar
    options = chart.options.legend || {};\r\n\t\t\t\tvar usePointStyle = options.labels
    && options.labels.usePointStyle;\r\n\r\n\t\t\t\treturn chart._getSortedDatasetMetas().map(function(meta)
    {\r\n\t\t\t\t\tvar style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n\r\n\t\t\t\t\treturn
    {\r\n\t\t\t\t\t\ttext: datasets[meta.index].label,\r\n\t\t\t\t\t\tfillStyle: style.backgroundColor,\r\n\t\t\t\t\t\thidden:
    !chart.isDatasetVisible(meta.index),\r\n\t\t\t\t\t\tlineCap: style.borderCapStyle,\r\n\t\t\t\t\t\tlineDash:
    style.borderDash,\r\n\t\t\t\t\t\tlineDashOffset: style.borderDashOffset,\r\n\t\t\t\t\t\tlineJoin:
    style.borderJoinStyle,\r\n\t\t\t\t\t\tlineWidth: style.borderWidth,\r\n\t\t\t\t\t\tstrokeStyle:
    style.borderColor,\r\n\t\t\t\t\t\tpointStyle: style.pointStyle,\r\n\t\t\t\t\t\trotation:
    style.rotation,\r\n\r\n\t\t\t\t\t\t// Below is extra data used for toggling the
    datasets\r\n\t\t\t\t\t\tdatasetIndex: meta.index\r\n\t\t\t\t\t};\r\n\t\t\t\t},
    this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tlegendCallback: function(chart) {\r\n\t\tvar
    list = document.createElement('ul');\r\n\t\tvar datasets = chart.data.datasets;\r\n\t\tvar
    i, ilen, listItem, listItemSpan;\r\n\r\n\t\tlist.setAttribute('class', chart.id
    + '-legend');\r\n\r\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n\t\t\tlistItem
    = list.appendChild(document.createElement('li'));\r\n\t\t\tlistItemSpan = listItem.appendChild(document.createElement('span'));\r\n\t\t\tlistItemSpan.style.backgroundColor
    = datasets[i].backgroundColor;\r\n\t\t\tif (datasets[i].label) {\r\n\t\t\t\tlistItem.appendChild(document.createTextNode(datasets[i].label));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    list.outerHTML;\r\n\t}\r\n});\r\n\r\n/**\r\n * Helper function to get the box
    width based on the usePointStyle option\r\n * @param {object} labelopts - the
    label options on the legend\r\n * @param {number} fontSize - the label font size\r\n
    * @return {number} width of the color box area\r\n */\r\nfunction getBoxWidth(labelOpts,
    fontSize) {\r\n\treturn labelOpts.usePointStyle && labelOpts.boxWidth > fontSize
    ?\r\n\t\tfontSize :\r\n\t\tlabelOpts.boxWidth;\r\n}\r\n\r\n/**\r\n * IMPORTANT:
    this class is exposed publicly as Chart.Legend, backward compatibility required!\r\n
    */\r\nvar Legend = core_element.extend({\r\n\r\n\tinitialize: function(config)
    {\r\n\t\tvar me = this;\r\n\t\thelpers$1.extend(me, config);\r\n\r\n\t\t// Contains
    hit boxes for each dataset (in dataset order)\r\n\t\tme.legendHitBoxes = [];\r\n\r\n\t\t/**\r\n
    \t\t * @private\r\n \t\t */\r\n\t\tme._hoveredItem = null;\r\n\r\n\t\t// Are we
    in doughnut mode which has a different data type\r\n\t\tme.doughnutMode = false;\r\n\t},\r\n\r\n\t//
    These methods are ordered by lifecycle. Utilities then follow.\r\n\t// Any function
    defined here is inherited by all legend types.\r\n\t// Any function can be extended
    by the legend type\r\n\r\n\tbeforeUpdate: noop$1,\r\n\tupdate: function(maxWidth,
    maxHeight, margins) {\r\n\t\tvar me = this;\r\n\r\n\t\t// Update Lifecycle - Probably
    don't want to ever extend or overwrite this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t//
    Absorb the master measurements\r\n\t\tme.maxWidth = maxWidth;\r\n\t\tme.maxHeight
    = maxHeight;\r\n\t\tme.margins = margins;\r\n\r\n\t\t// Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\t\t//
    Labels\r\n\t\tme.beforeBuildLabels();\r\n\t\tme.buildLabels();\r\n\t\tme.afterBuildLabels();\r\n\r\n\t\t//
    Fit\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\t\t//\r\n\t\tme.afterUpdate();\r\n\r\n\t\treturn
    me.minSize;\r\n\t},\r\n\tafterUpdate: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions:
    noop$1,\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the
    unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left
    = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom
    = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop
    = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\r\n\t\t// Reset
    minSize\r\n\t\tme.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\t},\r\n\tafterSetDimensions:
    noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeBuildLabels: noop$1,\r\n\tbuildLabels: function()
    {\r\n\t\tvar me = this;\r\n\t\tvar labelOpts = me.options.labels || {};\r\n\t\tvar
    legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) ||
    [];\r\n\r\n\t\tif (labelOpts.filter) {\r\n\t\t\tlegendItems = legendItems.filter(function(item)
    {\r\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif
    (me.options.reverse) {\r\n\t\t\tlegendItems.reverse();\r\n\t\t}\r\n\r\n\t\tme.legendItems
    = legendItems;\r\n\t},\r\n\tafterBuildLabels: noop$1,\r\n\r\n\t//\r\n\r\n\tbeforeFit:
    noop$1,\r\n\tfit: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar
    labelOpts = opts.labels;\r\n\t\tvar display = opts.display;\r\n\r\n\t\tvar ctx
    = me.ctx;\r\n\r\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\r\n\t\tvar
    fontSize = labelFont.size;\r\n\r\n\t\t// Reset hit boxes\r\n\t\tvar hitboxes =
    me.legendHitBoxes = [];\r\n\r\n\t\tvar minSize = me.minSize;\r\n\t\tvar isHorizontal
    = me.isHorizontal();\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.width = me.maxWidth;
    // fill all the width\r\n\t\t\tminSize.height = display ? 10 : 0;\r\n\t\t} else
    {\r\n\t\t\tminSize.width = display ? 10 : 0;\r\n\t\t\tminSize.height = me.maxHeight;
    // fill all the height\r\n\t\t}\r\n\r\n\t\t// Increase sizes here\r\n\t\tif (!display)
    {\r\n\t\t\tme.width = minSize.width = me.height = minSize.height = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tctx.font
    = labelFont.string;\r\n\r\n\t\tif (isHorizontal) {\r\n\t\t\t// Labels\r\n\r\n\t\t\t//
    Width of each line of legend boxes. Labels wrap onto multiple lines when there
    are too many to fit on one\r\n\t\t\tvar lineWidths = me.lineWidths = [0];\r\n\t\t\tvar
    totalHeight = 0;\r\n\r\n\t\t\tctx.textAlign = 'left';\r\n\t\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\t\thelpers$1.each(me.legendItems, function(legendItem, i)
    {\r\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\tvar width
    = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\tif
    (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding
    > minSize.width) {\r\n\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\r\n\t\t\t\t\tlineWidths[lineWidths.length
    - (i > 0 ? 0 : 1)] = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store the hitbox width
    and height here. Final position will be updated in `draw`\r\n\t\t\t\thitboxes[i]
    = {\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\twidth: width,\r\n\t\t\t\t\theight:
    fontSize\r\n\t\t\t\t};\r\n\r\n\t\t\t\tlineWidths[lineWidths.length - 1] += width
    + labelOpts.padding;\r\n\t\t\t});\r\n\r\n\t\t\tminSize.height += totalHeight;\r\n\r\n\t\t}
    else {\r\n\t\t\tvar vPadding = labelOpts.padding;\r\n\t\t\tvar columnWidths =
    me.columnWidths = [];\r\n\t\t\tvar columnHeights = me.columnHeights = [];\r\n\t\t\tvar
    totalWidth = labelOpts.padding;\r\n\t\t\tvar currentColWidth = 0;\r\n\t\t\tvar
    currentColHeight = 0;\r\n\r\n\t\t\thelpers$1.each(me.legendItems, function(legendItem,
    i) {\r\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\tvar
    itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\t//
    If too tall, go to new column\r\n\t\t\t\tif (i > 0 && currentColHeight + fontSize
    + 2 * vPadding > minSize.height) {\r\n\t\t\t\t\ttotalWidth += currentColWidth
    + labelOpts.padding;\r\n\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous
    column width\r\n\t\t\t\t\tcolumnHeights.push(currentColHeight);\r\n\t\t\t\t\tcurrentColWidth
    = 0;\r\n\t\t\t\t\tcurrentColHeight = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get max
    width\r\n\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\r\n\t\t\t\tcurrentColHeight
    += fontSize + vPadding;\r\n\r\n\t\t\t\t// Store the hitbox width and height here.
    Final position will be updated in `draw`\r\n\t\t\t\thitboxes[i] = {\r\n\t\t\t\t\tleft:
    0,\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\twidth: itemWidth,\r\n\t\t\t\t\theight: fontSize\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\ttotalWidth
    += currentColWidth;\r\n\t\t\tcolumnWidths.push(currentColWidth);\r\n\t\t\tcolumnHeights.push(currentColHeight);\r\n\t\t\tminSize.width
    += totalWidth;\r\n\t\t}\r\n\r\n\t\tme.width = minSize.width;\r\n\t\tme.height
    = minSize.height;\r\n\t},\r\n\tafterFit: noop$1,\r\n\r\n\t// Shared Methods\r\n\tisHorizontal:
    function() {\r\n\t\treturn this.options.position === 'top' || this.options.position
    === 'bottom';\r\n\t},\r\n\r\n\t// Actually draw the legend on the canvas\r\n\tdraw:
    function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar labelOpts
    = opts.labels;\r\n\t\tvar globalDefaults = core_defaults.global;\r\n\t\tvar defaultColor
    = globalDefaults.defaultColor;\r\n\t\tvar lineDefault = globalDefaults.elements.line;\r\n\t\tvar
    legendHeight = me.height;\r\n\t\tvar columnHeights = me.columnHeights;\r\n\t\tvar
    legendWidth = me.width;\r\n\t\tvar lineWidths = me.lineWidths;\r\n\r\n\t\tif (!opts.display)
    {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar rtlHelper = getRtlHelper$1(opts.rtl,
    me.left, me.minSize.width);\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar fontColor = valueOrDefault$e(labelOpts.fontColor,
    globalDefaults.defaultFontColor);\r\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\r\n\t\tvar
    fontSize = labelFont.size;\r\n\t\tvar cursor;\r\n\r\n\t\t// Canvas setup\r\n\t\tctx.textAlign
    = rtlHelper.textAlign('left');\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.lineWidth
    = 0.5;\r\n\t\tctx.strokeStyle = fontColor; // for strikethrough effect\r\n\t\tctx.fillStyle
    = fontColor; // render in correct colour\r\n\t\tctx.font = labelFont.string;\r\n\r\n\t\tvar
    boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\tvar hitboxes = me.legendHitBoxes;\r\n\r\n\t\t//
    current position\r\n\t\tvar drawLegendBox = function(x, y, legendItem) {\r\n\t\t\tif
    (isNaN(boxWidth) || boxWidth <= 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t//
    Set the ctx for the box\r\n\t\t\tctx.save();\r\n\r\n\t\t\tvar lineWidth = valueOrDefault$e(legendItem.lineWidth,
    lineDefault.borderWidth);\r\n\t\t\tctx.fillStyle = valueOrDefault$e(legendItem.fillStyle,
    defaultColor);\r\n\t\t\tctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);\r\n\t\t\tctx.lineDashOffset
    = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);\r\n\t\t\tctx.lineJoin
    = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);\r\n\t\t\tctx.lineWidth
    = lineWidth;\r\n\t\t\tctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle,
    defaultColor);\r\n\r\n\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t// IE 9 and 10 do
    not support line dash\r\n\t\t\t\tctx.setLineDash(valueOrDefault$e(legendItem.lineDash,
    lineDefault.borderDash));\r\n\t\t\t}\r\n\r\n\t\t\tif (labelOpts && labelOpts.usePointStyle)
    {\r\n\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\r\n\t\t\t\t//
    x and y to be center of figure (instead of top left)\r\n\t\t\t\tvar radius = boxWidth
    * Math.SQRT2 / 2;\r\n\t\t\t\tvar centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n\t\t\t\tvar
    centerY = y + fontSize / 2;\r\n\r\n\t\t\t\t// Draw pointStyle as legend symbol\r\n\t\t\t\thelpers$1.canvas.drawPoint(ctx,
    legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);\r\n\t\t\t}
    else {\r\n\t\t\t\t// Draw box as legend symbol\r\n\t\t\t\tctx.fillRect(rtlHelper.leftForLtr(x,
    boxWidth), y, boxWidth, fontSize);\r\n\t\t\t\tif (lineWidth !== 0) {\r\n\t\t\t\t\tctx.strokeRect(rtlHelper.leftForLtr(x,
    boxWidth), y, boxWidth, fontSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t};\r\n\r\n\t\tvar
    fillText = function(x, y, legendItem, textWidth) {\r\n\t\t\tvar halfFontSize =
    fontSize / 2;\r\n\t\t\tvar xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);\r\n\t\t\tvar
    yMiddle = y + halfFontSize;\r\n\r\n\t\t\tctx.fillText(legendItem.text, xLeft,
    yMiddle);\r\n\r\n\t\t\tif (legendItem.hidden) {\r\n\t\t\t\t// Strikethrough the
    text if hidden\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.lineWidth = 2;\r\n\t\t\t\tctx.moveTo(xLeft,
    yMiddle);\r\n\t\t\t\tctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar
    alignmentOffset = function(dimension, blockSize) {\r\n\t\t\tswitch (opts.align)
    {\r\n\t\t\tcase 'start':\r\n\t\t\t\treturn labelOpts.padding;\r\n\t\t\tcase 'end':\r\n\t\t\t\treturn
    dimension - blockSize;\r\n\t\t\tdefault: // center\r\n\t\t\t\treturn (dimension
    - blockSize + labelOpts.padding) / 2;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Horizontal\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\tif (isHorizontal) {\r\n\t\t\tcursor =
    {\r\n\t\t\t\tx: me.left + alignmentOffset(legendWidth, lineWidths[0]),\r\n\t\t\t\ty:
    me.top + labelOpts.padding,\r\n\t\t\t\tline: 0\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tcursor
    = {\r\n\t\t\t\tx: me.left + labelOpts.padding,\r\n\t\t\t\ty: me.top + alignmentOffset(legendHeight,
    columnHeights[0]),\r\n\t\t\t\tline: 0\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\thelpers$1.rtl.overrideTextDirection(me.ctx,
    opts.textDirection);\r\n\r\n\t\tvar itemHeight = fontSize + labelOpts.padding;\r\n\t\thelpers$1.each(me.legendItems,
    function(legendItem, i) {\r\n\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\r\n\t\t\tvar
    width = boxWidth + (fontSize / 2) + textWidth;\r\n\t\t\tvar x = cursor.x;\r\n\t\t\tvar
    y = cursor.y;\r\n\r\n\t\t\trtlHelper.setWidth(me.minSize.width);\r\n\r\n\t\t\t//
    Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\r\n\t\t\t//
    instead of me.right and me.bottom because me.width and me.height\r\n\t\t\t// may
    have been changed since me.minSize was calculated\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tif
    (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\r\n\t\t\t\t\ty
    = cursor.y += itemHeight;\r\n\t\t\t\t\tcursor.line++;\r\n\t\t\t\t\tx = cursor.x
    = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\r\n\t\t\t\t}\r\n\t\t\t}
    else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\r\n\t\t\t\tx
    = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n\t\t\t\tcursor.line++;\r\n\t\t\t\ty
    = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\r\n\t\t\t}\r\n\r\n\t\t\tvar
    realX = rtlHelper.x(x);\r\n\r\n\t\t\tdrawLegendBox(realX, y, legendItem);\r\n\r\n\t\t\thitboxes[i].left
    = rtlHelper.leftForLtr(realX, hitboxes[i].width);\r\n\t\t\thitboxes[i].top = y;\r\n\r\n\t\t\t//
    Fill the actual label\r\n\t\t\tfillText(realX, y, legendItem, textWidth);\r\n\r\n\t\t\tif
    (isHorizontal) {\r\n\t\t\t\tcursor.x += width + labelOpts.padding;\r\n\t\t\t}
    else {\r\n\t\t\t\tcursor.y += itemHeight;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers$1.rtl.restoreTextDirection(me.ctx,
    opts.textDirection);\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\t_getLegendItemAt:
    function(x, y) {\r\n\t\tvar me = this;\r\n\t\tvar i, hitBox, lh;\r\n\r\n\t\tif
    (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\r\n\t\t\t//
    See if we are touching one of the dataset boxes\r\n\t\t\tlh = me.legendHitBoxes;\r\n\t\t\tfor
    (i = 0; i < lh.length; ++i) {\r\n\t\t\t\thitBox = lh[i];\r\n\r\n\t\t\t\tif (x
    >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top
    + hitBox.height) {\r\n\t\t\t\t\t// Touching an element\r\n\t\t\t\t\treturn me.legendItems[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn
    null;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle an event\r\n\t * @private\r\n\t * @param
    {IEvent} event - The event to handle\r\n\t */\r\n\thandleEvent: function(e) {\r\n\t\tvar
    me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar type = e.type === 'mouseup'
    ? 'click' : e.type;\r\n\t\tvar hoveredItem;\r\n\r\n\t\tif (type === 'mousemove')
    {\r\n\t\t\tif (!opts.onHover && !opts.onLeave) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}
    else if (type === 'click') {\r\n\t\t\tif (!opts.onClick) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}
    else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chart event already has relative
    position in it\r\n\t\thoveredItem = me._getLegendItemAt(e.x, e.y);\r\n\r\n\t\tif
    (type === 'click') {\r\n\t\t\tif (hoveredItem && opts.onClick) {\r\n\t\t\t\t//
    use e.native for backwards compatibility\r\n\t\t\t\topts.onClick.call(me, e.native,
    hoveredItem);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (opts.onLeave && hoveredItem
    !== me._hoveredItem) {\r\n\t\t\t\tif (me._hoveredItem) {\r\n\t\t\t\t\topts.onLeave.call(me,
    e.native, me._hoveredItem);\r\n\t\t\t\t}\r\n\t\t\t\tme._hoveredItem = hoveredItem;\r\n\t\t\t}\r\n\r\n\t\t\tif
    (opts.onHover && hoveredItem) {\r\n\t\t\t\t// use e.native for backwards compatibility\r\n\t\t\t\topts.onHover.call(me,
    e.native, hoveredItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction createNewLegendAndAttach(chart,
    legendOpts) {\r\n\tvar legend = new Legend({\r\n\t\tctx: chart.ctx,\r\n\t\toptions:
    legendOpts,\r\n\t\tchart: chart\r\n\t});\r\n\r\n\tcore_layouts.configure(chart,
    legend, legendOpts);\r\n\tcore_layouts.addBox(chart, legend);\r\n\tchart.legend
    = legend;\r\n}\r\n\r\nvar plugin_legend = {\r\n\tid: 'legend',\r\n\r\n\t/**\r\n\t
    * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\r\n\t
    * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part
    of\r\n\t * the plugin, which one will be re-exposed in the chart.js file.\r\n\t
    * https://github.com/chartjs/Chart.js/pull/2640\r\n\t * @private\r\n\t */\r\n\t_element:
    Legend,\r\n\r\n\tbeforeInit: function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\r\n\t\tif
    (legendOpts) {\r\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeUpdate:
    function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\t\tvar legend
    = chart.legend;\r\n\r\n\t\tif (legendOpts) {\r\n\t\t\thelpers$1.mergeIf(legendOpts,
    core_defaults.global.legend);\r\n\r\n\t\t\tif (legend) {\r\n\t\t\t\tcore_layouts.configure(chart,
    legend, legendOpts);\r\n\t\t\t\tlegend.options = legendOpts;\r\n\t\t\t} else {\r\n\t\t\t\tcreateNewLegendAndAttach(chart,
    legendOpts);\r\n\t\t\t}\r\n\t\t} else if (legend) {\r\n\t\t\tcore_layouts.removeBox(chart,
    legend);\r\n\t\t\tdelete chart.legend;\r\n\t\t}\r\n\t},\r\n\r\n\tafterEvent: function(chart,
    e) {\r\n\t\tvar legend = chart.legend;\r\n\t\tif (legend) {\r\n\t\t\tlegend.handleEvent(e);\r\n\t\t}\r\n\t}\r\n};\n\nvar
    noop$2 = helpers$1.noop;\r\n\r\ncore_defaults._set('global', {\r\n\ttitle: {\r\n\t\tdisplay:
    false,\r\n\t\tfontStyle: 'bold',\r\n\t\tfullWidth: true,\r\n\t\tpadding: 10,\r\n\t\tposition:
    'top',\r\n\t\ttext: '',\r\n\t\tweight: 2000         // by default greater than
    legend (1000) to be above\r\n\t}\r\n});\r\n\r\n/**\r\n * IMPORTANT: this class
    is exposed publicly as Chart.Legend, backward compatibility required!\r\n */\r\nvar
    Title = core_element.extend({\r\n\tinitialize: function(config) {\r\n\t\tvar me
    = this;\r\n\t\thelpers$1.extend(me, config);\r\n\r\n\t\t// Contains hit boxes
    for each dataset (in dataset order)\r\n\t\tme.legendHitBoxes = [];\r\n\t},\r\n\r\n\t//
    These methods are ordered by lifecycle. Utilities then follow.\r\n\r\n\tbeforeUpdate:
    noop$2,\r\n\tupdate: function(maxWidth, maxHeight, margins) {\r\n\t\tvar me =
    this;\r\n\r\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite
    this function ;)\r\n\t\tme.beforeUpdate();\r\n\r\n\t\t// Absorb the master measurements\r\n\t\tme.maxWidth
    = maxWidth;\r\n\t\tme.maxHeight = maxHeight;\r\n\t\tme.margins = margins;\r\n\r\n\t\t//
    Dimensions\r\n\t\tme.beforeSetDimensions();\r\n\t\tme.setDimensions();\r\n\t\tme.afterSetDimensions();\r\n\t\t//
    Labels\r\n\t\tme.beforeBuildLabels();\r\n\t\tme.buildLabels();\r\n\t\tme.afterBuildLabels();\r\n\r\n\t\t//
    Fit\r\n\t\tme.beforeFit();\r\n\t\tme.fit();\r\n\t\tme.afterFit();\r\n\t\t//\r\n\t\tme.afterUpdate();\r\n\r\n\t\treturn
    me.minSize;\r\n\r\n\t},\r\n\tafterUpdate: noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeSetDimensions:
    noop$2,\r\n\tsetDimensions: function() {\r\n\t\tvar me = this;\r\n\t\t// Set the
    unconstrained dimension before label rotation\r\n\t\tif (me.isHorizontal()) {\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.left
    = 0;\r\n\t\t\tme.right = me.width;\r\n\t\t} else {\r\n\t\t\tme.height = me.maxHeight;\r\n\r\n\t\t\t//
    Reset position before calculating rotation\r\n\t\t\tme.top = 0;\r\n\t\t\tme.bottom
    = me.height;\r\n\t\t}\r\n\r\n\t\t// Reset padding\r\n\t\tme.paddingLeft = 0;\r\n\t\tme.paddingTop
    = 0;\r\n\t\tme.paddingRight = 0;\r\n\t\tme.paddingBottom = 0;\r\n\r\n\t\t// Reset
    minSize\r\n\t\tme.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\t},\r\n\tafterSetDimensions:
    noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeBuildLabels: noop$2,\r\n\tbuildLabels: noop$2,\r\n\tafterBuildLabels:
    noop$2,\r\n\r\n\t//\r\n\r\n\tbeforeFit: noop$2,\r\n\tfit: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar minSize = me.minSize = {};\r\n\t\tvar
    isHorizontal = me.isHorizontal();\r\n\t\tvar lineCount, textSize;\r\n\r\n\t\tif
    (!opts.display) {\r\n\t\t\tme.width = minSize.width = me.height = minSize.height
    = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlineCount = helpers$1.isArray(opts.text)
    ? opts.text.length : 1;\r\n\t\ttextSize = lineCount * helpers$1.options._parseFont(opts).lineHeight
    + opts.padding * 2;\r\n\r\n\t\tme.width = minSize.width = isHorizontal ? me.maxWidth
    : textSize;\r\n\t\tme.height = minSize.height = isHorizontal ? textSize : me.maxHeight;\r\n\t},\r\n\tafterFit:
    noop$2,\r\n\r\n\t// Shared Methods\r\n\tisHorizontal: function() {\r\n\t\tvar
    pos = this.options.position;\r\n\t\treturn pos === 'top' || pos === 'bottom';\r\n\t},\r\n\r\n\t//
    Actually draw the title block on the canvas\r\n\tdraw: function() {\r\n\t\tvar
    me = this;\r\n\t\tvar ctx = me.ctx;\r\n\t\tvar opts = me.options;\r\n\r\n\t\tif
    (!opts.display) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar fontOpts = helpers$1.options._parseFont(opts);\r\n\t\tvar
    lineHeight = fontOpts.lineHeight;\r\n\t\tvar offset = lineHeight / 2 + opts.padding;\r\n\t\tvar
    rotation = 0;\r\n\t\tvar top = me.top;\r\n\t\tvar left = me.left;\r\n\t\tvar bottom
    = me.bottom;\r\n\t\tvar right = me.right;\r\n\t\tvar maxWidth, titleX, titleY;\r\n\r\n\t\tctx.fillStyle
    = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
    // render in correct colour\r\n\t\tctx.font = fontOpts.string;\r\n\r\n\t\t// Horizontal\r\n\t\tif
    (me.isHorizontal()) {\r\n\t\t\ttitleX = left + ((right - left) / 2); // midpoint
    of the width\r\n\t\t\ttitleY = top + offset;\r\n\t\t\tmaxWidth = right - left;\r\n\t\t}
    else {\r\n\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\r\n\t\t\ttitleY
    = top + ((bottom - top) / 2);\r\n\t\t\tmaxWidth = bottom - top;\r\n\t\t\trotation
    = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(titleX,
    titleY);\r\n\t\tctx.rotate(rotation);\r\n\t\tctx.textAlign = 'center';\r\n\t\tctx.textBaseline
    = 'middle';\r\n\r\n\t\tvar text = opts.text;\r\n\t\tif (helpers$1.isArray(text))
    {\r\n\t\t\tvar y = 0;\r\n\t\t\tfor (var i = 0; i < text.length; ++i) {\r\n\t\t\t\tctx.fillText(text[i],
    0, y, maxWidth);\r\n\t\t\t\ty += lineHeight;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tctx.fillText(text,
    0, 0, maxWidth);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n});\r\n\r\nfunction
    createNewTitleBlockAndAttach(chart, titleOpts) {\r\n\tvar title = new Title({\r\n\t\tctx:
    chart.ctx,\r\n\t\toptions: titleOpts,\r\n\t\tchart: chart\r\n\t});\r\n\r\n\tcore_layouts.configure(chart,
    title, titleOpts);\r\n\tcore_layouts.addBox(chart, title);\r\n\tchart.titleBlock
    = title;\r\n}\r\n\r\nvar plugin_title = {\r\n\tid: 'title',\r\n\r\n\t/**\r\n\t
    * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\r\n\t
    * Chart.Title obsolete. To avoid a breaking change, we export the Title as part
    of\r\n\t * the plugin, which one will be re-exposed in the chart.js file.\r\n\t
    * https://github.com/chartjs/Chart.js/pull/2640\r\n\t * @private\r\n\t */\r\n\t_element:
    Title,\r\n\r\n\tbeforeInit: function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\r\n\t\tif
    (titleOpts) {\r\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t}\r\n\t},\r\n\r\n\tbeforeUpdate:
    function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\t\tvar titleBlock
    = chart.titleBlock;\r\n\r\n\t\tif (titleOpts) {\r\n\t\t\thelpers$1.mergeIf(titleOpts,
    core_defaults.global.title);\r\n\r\n\t\t\tif (titleBlock) {\r\n\t\t\t\tcore_layouts.configure(chart,
    titleBlock, titleOpts);\r\n\t\t\t\ttitleBlock.options = titleOpts;\r\n\t\t\t}
    else {\r\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t\t}\r\n\t\t}
    else if (titleBlock) {\r\n\t\t\tcore_layouts.removeBox(chart, titleBlock);\r\n\t\t\tdelete
    chart.titleBlock;\r\n\t\t}\r\n\t}\r\n};\n\nvar plugins = {};\r\nvar filler = plugin_filler;\r\nvar
    legend = plugin_legend;\r\nvar title = plugin_title;\nplugins.filler = filler;\nplugins.legend
    = legend;\nplugins.title = title;\n\n/**\r\n * @namespace Chart\r\n */\r\n\r\n\r\ncore_controller.helpers
    = helpers$1;\r\n\r\n// @todo dispatch these helpers into appropriated helpers/helpers.*
    file and write unit tests!\r\ncore_helpers();\r\n\r\ncore_controller._adapters
    = core_adapters;\r\ncore_controller.Animation = core_animation;\r\ncore_controller.animationService
    = core_animations;\r\ncore_controller.controllers = controllers;\r\ncore_controller.DatasetController
    = core_datasetController;\r\ncore_controller.defaults = core_defaults;\r\ncore_controller.Element
    = core_element;\r\ncore_controller.elements = elements;\r\ncore_controller.Interaction
    = core_interaction;\r\ncore_controller.layouts = core_layouts;\r\ncore_controller.platform
    = platform;\r\ncore_controller.plugins = core_plugins;\r\ncore_controller.Scale
    = core_scale;\r\ncore_controller.scaleService = core_scaleService;\r\ncore_controller.Ticks
    = core_ticks;\r\ncore_controller.Tooltip = core_tooltip;\r\n\r\n// Register built-in
    scales\r\n\r\ncore_controller.helpers.each(scales, function(scale, type) {\r\n\tcore_controller.scaleService.registerScaleType(type,
    scale, scale._defaults);\r\n});\r\n\r\n// Load to register built-in adapters (as
    side effects)\r\n\r\n\r\n// Loading built-in plugins\r\n\r\nfor (var k in plugins)
    {\r\n\tif (plugins.hasOwnProperty(k)) {\r\n\t\tcore_controller.plugins.register(plugins[k]);\r\n\t}\r\n}\r\n\r\ncore_controller.platform.initialize();\r\n\r\nvar
    src = core_controller;\r\nif (typeof window !== 'undefined') {\r\n\twindow.Chart
    = core_controller;\r\n}\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward
    compatibility, not available anymore\r\n * @namespace Chart.Chart\r\n * @deprecated
    since version 2.8.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Chart
    = core_controller;\r\n\r\n/**\r\n * Provided for backward compatibility, not available
    anymore\r\n * @namespace Chart.Legend\r\n * @deprecated since version 2.1.5\r\n
    * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Legend =
    plugins.legend._element;\r\n\r\n/**\r\n * Provided for backward compatibility,
    not available anymore\r\n * @namespace Chart.Title\r\n * @deprecated since version
    2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.Title
    = plugins.title._element;\r\n\r\n/**\r\n * Provided for backward compatibility,
    use Chart.plugins instead\r\n * @namespace Chart.pluginService\r\n * @deprecated
    since version 2.1.5\r\n * @todo remove at version 3\r\n * @private\r\n */\r\ncore_controller.pluginService
    = core_controller.plugins;\r\n\r\n/**\r\n * Provided for backward compatibility,
    inheriting from Chart.PlugingBase has no\r\n * effect, instead simply create/register
    plugins via plain JavaScript objects.\r\n * @interface Chart.PluginBase\r\n *
    @deprecated since version 2.5.0\r\n * @todo remove at version 3\r\n * @private\r\n
    */\r\ncore_controller.PluginBase = core_controller.Element.extend({});\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.helpers.canvas instead.\r\n *
    @namespace Chart.canvasHelpers\r\n * @deprecated since version 2.6.0\r\n * @todo
    remove at version 3\r\n * @private\r\n */\r\ncore_controller.canvasHelpers = core_controller.helpers.canvas;\r\n\r\n/**\r\n
    * Provided for backward compatibility, use Chart.layouts instead.\r\n * @namespace
    Chart.layoutService\r\n * @deprecated since version 2.7.3\r\n * @todo remove at
    version 3\r\n * @private\r\n */\r\ncore_controller.layoutService = core_controller.layouts;\r\n\r\n/**\r\n
    * Provided for backward compatibility, not available anymore.\r\n * @namespace
    Chart.LinearScaleBase\r\n * @deprecated since version 2.8\r\n * @todo remove at
    version 3\r\n * @private\r\n */\r\ncore_controller.LinearScaleBase = scale_linearbase;\r\n\r\n/**\r\n
    * Provided for backward compatibility, instead we should create a new Chart\r\n
    * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\r\n
    * @deprecated since version 2.8.0\r\n * @todo remove at version 3\r\n */\r\ncore_controller.helpers.each(\r\n\t[\r\n\t\t'Bar',\r\n\t\t'Bubble',\r\n\t\t'Doughnut',\r\n\t\t'Line',\r\n\t\t'PolarArea',\r\n\t\t'Radar',\r\n\t\t'Scatter'\r\n\t],\r\n\tfunction(klass)
    {\r\n\t\tcore_controller[klass] = function(ctx, cfg) {\r\n\t\t\treturn new core_controller(ctx,
    core_controller.helpers.merge(cfg || {}, {\r\n\t\t\t\ttype: klass.charAt(0).toLowerCase()
    + klass.slice(1)\r\n\t\t\t}));\r\n\t\t};\r\n\t}\r\n);\n\nreturn src;\n\n})));\n"
  admin-Public-Admin-plugins-chart.js-Chart.min.css: '@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation
    1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}'
  admin-Public-Admin-plugins-chart.js-Chart.min.js: |
    /*!
     * Chart.js v2.9.4
     * https://www.chartjs.org
     * (c) 2020 Chart.js Contributors
     * Released under the MIT License
     */
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(function(){try{return require("moment")}catch(t){}}()):"function"==typeof define&&define.amd?define(["require"],(function(t){return e(function(){try{return t("moment")}catch(t){}}())})):(t=t||self).Chart=e(t.moment)}(this,(function(t){"use strict";t=t&&t.hasOwnProperty("default")?t.default:t;var e={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},n=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(t){var n={};for(var i in e)e.hasOwnProperty(i)&&(n[e[i]]=i);var a=t.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var r in a)if(a.hasOwnProperty(r)){if(!("channels"in a[r]))throw new Error("missing channels property: "+r);if(!("labels"in a[r]))throw new Error("missing channel labels property: "+r);if(a[r].labels.length!==a[r].channels)throw new Error("channel and label counts mismatch: "+r);var o=a[r].channels,s=a[r].labels;delete a[r].channels,delete a[r].labels,Object.defineProperty(a[r],"channels",{value:o}),Object.defineProperty(a[r],"labels",{value:s})}a.rgb.hsl=function(t){var e,n,i=t[0]/255,a=t[1]/255,r=t[2]/255,o=Math.min(i,a,r),s=Math.max(i,a,r),l=s-o;return s===o?e=0:i===s?e=(a-r)/l:a===s?e=2+(r-i)/l:r===s&&(e=4+(i-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),n=(o+s)/2,[e,100*(s===o?0:n<=.5?l/(s+o):l/(2-s-o)),100*n]},a.rgb.hsv=function(t){var e,n,i,a,r,o=t[0]/255,s=t[1]/255,l=t[2]/255,u=Math.max(o,s,l),d=u-Math.min(o,s,l),h=function(t){return(u-t)/6/d+.5};return 0===d?a=r=0:(r=d/u,e=h(o),n=h(s),i=h(l),o===u?a=i-n:s===u?a=1/3+e-i:l===u&&(a=2/3+n-e),a<0?a+=1:a>1&&(a-=1)),[360*a,100*r,100*u]},a.rgb.hwb=function(t){var e=t[0],n=t[1],i=t[2];return[a.rgb.hsl(t)[0],100*(1/255*Math.min(e,Math.min(n,i))),100*(i=1-1/255*Math.max(e,Math.max(n,i)))]},a.rgb.cmyk=function(t){var e,n=t[0]/255,i=t[1]/255,a=t[2]/255;return[100*((1-n-(e=Math.min(1-n,1-i,1-a)))/(1-e)||0),100*((1-i-e)/(1-e)||0),100*((1-a-e)/(1-e)||0),100*e]},a.rgb.keyword=function(t){var i=n[t];if(i)return i;var a,r,o,s=1/0;for(var l in e)if(e.hasOwnProperty(l)){var u=e[l],d=(r=t,o=u,Math.pow(r[0]-o[0],2)+Math.pow(r[1]-o[1],2)+Math.pow(r[2]-o[2],2));d<s&&(s=d,a=l)}return a},a.keyword.rgb=function(t){return e[t]},a.rgb.xyz=function(t){var e=t[0]/255,n=t[1]/255,i=t[2]/255;return[100*(.4124*(e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)+.1805*(i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92)),100*(.2126*e+.7152*n+.0722*i),100*(.0193*e+.1192*n+.9505*i)]},a.rgb.lab=function(t){var e=a.rgb.xyz(t),n=e[0],i=e[1],r=e[2];return i/=100,r/=108.883,n=(n/=95.047)>.008856?Math.pow(n,1/3):7.787*n+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(n-i),200*(i-(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116))]},a.hsl.rgb=function(t){var e,n,i,a,r,o=t[0]/360,s=t[1]/100,l=t[2]/100;if(0===s)return[r=255*l,r,r];e=2*l-(n=l<.5?l*(1+s):l+s-l*s),a=[0,0,0];for(var u=0;u<3;u++)(i=o+1/3*-(u-1))<0&&i++,i>1&&i--,r=6*i<1?e+6*(n-e)*i:2*i<1?n:3*i<2?e+(n-e)*(2/3-i)*6:e,a[u]=255*r;return a},a.hsl.hsv=function(t){var e=t[0],n=t[1]/100,i=t[2]/100,a=n,r=Math.max(i,.01);return n*=(i*=2)<=1?i:2-i,a*=r<=1?r:2-r,[e,100*(0===i?2*a/(r+a):2*n/(i+n)),100*((i+n)/2)]},a.hsv.rgb=function(t){var e=t[0]/60,n=t[1]/100,i=t[2]/100,a=Math.floor(e)%6,r=e-Math.floor(e),o=255*i*(1-n),s=255*i*(1-n*r),l=255*i*(1-n*(1-r));switch(i*=255,a){case 0:return[i,l,o];case 1:return[s,i,o];case 2:return[o,i,l];case 3:return[o,s,i];case 4:return[l,o,i];case 5:return[i,o,s]}},a.hsv.hsl=function(t){var e,n,i,a=t[0],r=t[1]/100,o=t[2]/100,s=Math.max(o,.01);return i=(2-r)*o,n=r*s,[a,100*(n=(n/=(e=(2-r)*s)<=1?e:2-e)||0),100*(i/=2)]},a.hwb.rgb=function(t){var e,n,i,a,r,o,s,l=t[0]/360,u=t[1]/100,d=t[2]/100,h=u+d;switch(h>1&&(u/=h,d/=h),i=6*l-(e=Math.floor(6*l)),0!=(1&e)&&(i=1-i),a=u+i*((n=1-d)-u),e){default:case 6:case 0:r=n,o=a,s=u;break;case 1:r=a,o=n,s=u;break;case 2:r=u,o=n,s=a;break;case 3:r=u,o=a,s=n;break;case 4:r=a,o=u,s=n;break;case 5:r=n,o=u,s=a}return[255*r,255*o,255*s]},a.cmyk.rgb=function(t){var e=t[0]/100,n=t[1]/100,i=t[2]/100,a=t[3]/100;return[255*(1-Math.min(1,e*(1-a)+a)),255*(1-Math.min(1,n*(1-a)+a)),255*(1-Math.min(1,i*(1-a)+a))]},a.xyz.rgb=function(t){var e,n,i,a=t[0]/100,r=t[1]/100,o=t[2]/100;return n=-.9689*a+1.8758*r+.0415*o,i=.0557*a+-.204*r+1.057*o,e=(e=3.2406*a+-1.5372*r+-.4986*o)>.0031308?1.055*Math.pow(e,1/2.4)-.055:12.92*e,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:12.92*i,[255*(e=Math.min(Math.max(0,e),1)),255*(n=Math.min(Math.max(0,n),1)),255*(i=Math.min(Math.max(0,i),1))]},a.xyz.lab=function(t){var e=t[0],n=t[1],i=t[2];return n/=100,i/=108.883,e=(e/=95.047)>.008856?Math.pow(e,1/3):7.787*e+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(e-n),200*(n-(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116))]},a.lab.xyz=function(t){var e,n,i,a=t[0];e=t[1]/500+(n=(a+16)/116),i=n-t[2]/200;var r=Math.pow(n,3),o=Math.pow(e,3),s=Math.pow(i,3);return n=r>.008856?r:(n-16/116)/7.787,e=o>.008856?o:(e-16/116)/7.787,i=s>.008856?s:(i-16/116)/7.787,[e*=95.047,n*=100,i*=108.883]},a.lab.lch=function(t){var e,n=t[0],i=t[1],a=t[2];return(e=360*Math.atan2(a,i)/2/Math.PI)<0&&(e+=360),[n,Math.sqrt(i*i+a*a),e]},a.lch.lab=function(t){var e,n=t[0],i=t[1];return e=t[2]/360*2*Math.PI,[n,i*Math.cos(e),i*Math.sin(e)]},a.rgb.ansi16=function(t){var e=t[0],n=t[1],i=t[2],r=1 in arguments?arguments[1]:a.rgb.hsv(t)[2];if(0===(r=Math.round(r/50)))return 30;var o=30+(Math.round(i/255)<<2|Math.round(n/255)<<1|Math.round(e/255));return 2===r&&(o+=60),o},a.hsv.ansi16=function(t){return a.rgb.ansi16(a.hsv.rgb(t),t[2])},a.rgb.ansi256=function(t){var e=t[0],n=t[1],i=t[2];return e===n&&n===i?e<8?16:e>248?231:Math.round((e-8)/247*24)+232:16+36*Math.round(e/255*5)+6*Math.round(n/255*5)+Math.round(i/255*5)},a.ansi16.rgb=function(t){var e=t%10;if(0===e||7===e)return t>50&&(e+=3.5),[e=e/10.5*255,e,e];var n=.5*(1+~~(t>50));return[(1&e)*n*255,(e>>1&1)*n*255,(e>>2&1)*n*255]},a.ansi256.rgb=function(t){if(t>=232){var e=10*(t-232)+8;return[e,e,e]}var n;return t-=16,[Math.floor(t/36)/5*255,Math.floor((n=t%36)/6)/5*255,n%6/5*255]},a.rgb.hex=function(t){var e=(((255&Math.round(t[0]))<<16)+((255&Math.round(t[1]))<<8)+(255&Math.round(t[2]))).toString(16).toUpperCase();return"000000".substring(e.length)+e},a.hex.rgb=function(t){var e=t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!e)return[0,0,0];var n=e[0];3===e[0].length&&(n=n.split("").map((function(t){return t+t})).join(""));var i=parseInt(n,16);return[i>>16&255,i>>8&255,255&i]},a.rgb.hcg=function(t){var e,n=t[0]/255,i=t[1]/255,a=t[2]/255,r=Math.max(Math.max(n,i),a),o=Math.min(Math.min(n,i),a),s=r-o;return e=s<=0?0:r===n?(i-a)/s%6:r===i?2+(a-n)/s:4+(n-i)/s+4,e/=6,[360*(e%=1),100*s,100*(s<1?o/(1-s):0)]},a.hsl.hcg=function(t){var e=t[1]/100,n=t[2]/100,i=1,a=0;return(i=n<.5?2*e*n:2*e*(1-n))<1&&(a=(n-.5*i)/(1-i)),[t[0],100*i,100*a]},a.hsv.hcg=function(t){var e=t[1]/100,n=t[2]/100,i=e*n,a=0;return i<1&&(a=(n-i)/(1-i)),[t[0],100*i,100*a]},a.hcg.rgb=function(t){var e=t[0]/360,n=t[1]/100,i=t[2]/100;if(0===n)return[255*i,255*i,255*i];var a,r=[0,0,0],o=e%1*6,s=o%1,l=1-s;switch(Math.floor(o)){case 0:r[0]=1,r[1]=s,r[2]=0;break;case 1:r[0]=l,r[1]=1,r[2]=0;break;case 2:r[0]=0,r[1]=1,r[2]=s;break;case 3:r[0]=0,r[1]=l,r[2]=1;break;case 4:r[0]=s,r[1]=0,r[2]=1;break;default:r[0]=1,r[1]=0,r[2]=l}return a=(1-n)*i,[255*(n*r[0]+a),255*(n*r[1]+a),255*(n*r[2]+a)]},a.hcg.hsv=function(t){var e=t[1]/100,n=e+t[2]/100*(1-e),i=0;return n>0&&(i=e/n),[t[0],100*i,100*n]},a.hcg.hsl=function(t){var e=t[1]/100,n=t[2]/100*(1-e)+.5*e,i=0;return n>0&&n<.5?i=e/(2*n):n>=.5&&n<1&&(i=e/(2*(1-n))),[t[0],100*i,100*n]},a.hcg.hwb=function(t){var e=t[1]/100,n=e+t[2]/100*(1-e);return[t[0],100*(n-e),100*(1-n)]},a.hwb.hcg=function(t){var e=t[1]/100,n=1-t[2]/100,i=n-e,a=0;return i<1&&(a=(n-i)/(1-i)),[t[0],100*i,100*a]},a.apple.rgb=function(t){return[t[0]/65535*255,t[1]/65535*255,t[2]/65535*255]},a.rgb.apple=function(t){return[t[0]/255*65535,t[1]/255*65535,t[2]/255*65535]},a.gray.rgb=function(t){return[t[0]/100*255,t[0]/100*255,t[0]/100*255]},a.gray.hsl=a.gray.hsv=function(t){return[0,0,t[0]]},a.gray.hwb=function(t){return[0,100,t[0]]},a.gray.cmyk=function(t){return[0,0,0,t[0]]},a.gray.lab=function(t){return[t[0],0,0]},a.gray.hex=function(t){var e=255&Math.round(t[0]/100*255),n=((e<<16)+(e<<8)+e).toString(16).toUpperCase();return"000000".substring(n.length)+n},a.rgb.gray=function(t){return[(t[0]+t[1]+t[2])/3/255*100]}}));n.rgb,n.hsl,n.hsv,n.hwb,n.cmyk,n.xyz,n.lab,n.lch,n.hex,n.keyword,n.ansi16,n.ansi256,n.hcg,n.apple,n.gray;function i(t){var e=function(){for(var t={},e=Object.keys(n),i=e.length,a=0;a<i;a++)t[e[a]]={distance:-1,parent:null};return t}(),i=[t];for(e[t].distance=0;i.length;)for(var a=i.pop(),r=Object.keys(n[a]),o=r.length,s=0;s<o;s++){var l=r[s],u=e[l];-1===u.distance&&(u.distance=e[a].distance+1,u.parent=a,i.unshift(l))}return e}function a(t,e){return function(n){return e(t(n))}}function r(t,e){for(var i=[e[t].parent,t],r=n[e[t].parent][t],o=e[t].parent;e[o].parent;)i.unshift(e[o].parent),r=a(n[e[o].parent][o],r),o=e[o].parent;return r.conversion=i,r}var o={};Object.keys(n).forEach((function(t){o[t]={},Object.defineProperty(o[t],"channels",{value:n[t].channels}),Object.defineProperty(o[t],"labels",{value:n[t].labels});var e=function(t){for(var e=i(t),n={},a=Object.keys(e),o=a.length,s=0;s<o;s++){var l=a[s];null!==e[l].parent&&(n[l]=r(l,e))}return n}(t);Object.keys(e).forEach((function(n){var i=e[n];o[t][n]=function(t){var e=function(e){if(null==e)return e;arguments.length>1&&(e=Array.prototype.slice.call(arguments));var n=t(e);if("object"==typeof n)for(var i=n.length,a=0;a<i;a++)n[a]=Math.round(n[a]);return n};return"conversion"in t&&(e.conversion=t.conversion),e}(i),o[t][n].raw=function(t){var e=function(e){return null==e?e:(arguments.length>1&&(e=Array.prototype.slice.call(arguments)),t(e))};return"conversion"in t&&(e.conversion=t.conversion),e}(i)}))}));var s=o,l={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},u={getRgba:d,getHsla:h,getRgb:function(t){var e=d(t);return e&&e.slice(0,3)},getHsl:function(t){var e=h(t);return e&&e.slice(0,3)},getHwb:c,getAlpha:function(t){var e=d(t);if(e)return e[3];if(e=h(t))return e[3];if(e=c(t))return e[3]},hexString:function(t,e){e=void 0!==e&&3===t.length?e:t[3];return"#"+v(t[0])+v(t[1])+v(t[2])+(e>=0&&e<1?v(Math.round(255*e)):"")},rgbString:function(t,e){if(e<1||t[3]&&t[3]<1)return f(t,e);return"rgb("+t[0]+", "+t[1]+", "+t[2]+")"},rgbaString:f,percentString:function(t,e){if(e<1||t[3]&&t[3]<1)return g(t,e);var n=Math.round(t[0]/255*100),i=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgb("+n+"%, "+i+"%, "+a+"%)"},percentaString:g,hslString:function(t,e){if(e<1||t[3]&&t[3]<1)return p(t,e);return"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"},hslaString:p,hwbString:function(t,e){void 0===e&&(e=void 0!==t[3]?t[3]:1);return"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"},keyword:function(t){return b[t.slice(0,3)]}};function d(t){if(t){var e=[0,0,0],n=1,i=t.match(/^#([a-fA-F0-9]{3,4})$/i),a="";if(i){a=(i=i[1])[3];for(var r=0;r<e.length;r++)e[r]=parseInt(i[r]+i[r],16);a&&(n=Math.round(parseInt(a+a,16)/255*100)/100)}else if(i=t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)){a=i[2],i=i[1];for(r=0;r<e.length;r++)e[r]=parseInt(i.slice(2*r,2*r+2),16);a&&(n=Math.round(parseInt(a,16)/255*100)/100)}else if(i=t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(r=0;r<e.length;r++)e[r]=parseInt(i[r+1]);n=parseFloat(i[4])}else if(i=t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(r=0;r<e.length;r++)e[r]=Math.round(2.55*parseFloat(i[r+1]));n=parseFloat(i[4])}else if(i=t.match(/(\w+)/)){if("transparent"==i[1])return[0,0,0,0];if(!(e=l[i[1]]))return}for(r=0;r<e.length;r++)e[r]=m(e[r],0,255);return n=n||0==n?m(n,0,1):1,e[3]=n,e}}function h(t){if(t){var e=t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var n=parseFloat(e[4]);return[m(parseInt(e[1]),0,360),m(parseFloat(e[2]),0,100),m(parseFloat(e[3]),0,100),m(isNaN(n)?1:n,0,1)]}}}function c(t){if(t){var e=t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var n=parseFloat(e[4]);return[m(parseInt(e[1]),0,360),m(parseFloat(e[2]),0,100),m(parseFloat(e[3]),0,100),m(isNaN(n)?1:n,0,1)]}}}function f(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function g(t,e){return"rgba("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%, "+(e||t[3]||1)+")"}function p(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}function m(t,e,n){return Math.min(Math.max(e,t),n)}function v(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}var b={};for(var x in l)b[l[x]]=x;var y=function(t){return t instanceof y?t:this instanceof y?(this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1},void("string"==typeof t?(e=u.getRgba(t))?this.setValues("rgb",e):(e=u.getHsla(t))?this.setValues("hsl",e):(e=u.getHwb(t))&&this.setValues("hwb",e):"object"==typeof t&&(void 0!==(e=t).r||void 0!==e.red?this.setValues("rgb",e):void 0!==e.l||void 0!==e.lightness?this.setValues("hsl",e):void 0!==e.v||void 0!==e.value?this.setValues("hsv",e):void 0!==e.w||void 0!==e.whiteness?this.setValues("hwb",e):void 0===e.c&&void 0===e.cyan||this.setValues("cmyk",e)))):new y(t);var e};y.prototype={isValid:function(){return this.valid},rgb:function(){return this.setSpace("rgb",arguments)},hsl:function(){return this.setSpace("hsl",arguments)},hsv:function(){return this.setSpace("hsv",arguments)},hwb:function(){return this.setSpace("hwb",arguments)},cmyk:function(){return this.setSpace("cmyk",arguments)},rgbArray:function(){return this.values.rgb},hslArray:function(){return this.values.hsl},hsvArray:function(){return this.values.hsv},hwbArray:function(){var t=this.values;return 1!==t.alpha?t.hwb.concat([t.alpha]):t.hwb},cmykArray:function(){return this.values.cmyk},rgbaArray:function(){var t=this.values;return t.rgb.concat([t.alpha])},hslaArray:function(){var t=this.values;return t.hsl.concat([t.alpha])},alpha:function(t){return void 0===t?this.values.alpha:(this.setValues("alpha",t),this)},red:function(t){return this.setChannel("rgb",0,t)},green:function(t){return this.setChannel("rgb",1,t)},blue:function(t){return this.setChannel("rgb",2,t)},hue:function(t){return t&&(t=(t%=360)<0?360+t:t),this.setChannel("hsl",0,t)},saturation:function(t){return this.setChannel("hsl",1,t)},lightness:function(t){return this.setChannel("hsl",2,t)},saturationv:function(t){return this.setChannel("hsv",1,t)},whiteness:function(t){return this.setChannel("hwb",1,t)},blackness:function(t){return this.setChannel("hwb",2,t)},value:function(t){return this.setChannel("hsv",2,t)},cyan:function(t){return this.setChannel("cmyk",0,t)},magenta:function(t){return this.setChannel("cmyk",1,t)},yellow:function(t){return this.setChannel("cmyk",2,t)},black:function(t){return this.setChannel("cmyk",3,t)},hexString:function(){return u.hexString(this.values.rgb)},rgbString:function(){return u.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function(){return u.rgbaString(this.values.rgb,this.values.alpha)},percentString:function(){return u.percentString(this.values.rgb,this.values.alpha)},hslString:function(){return u.hslString(this.values.hsl,this.values.alpha)},hslaString:function(){return u.hslaString(this.values.hsl,this.values.alpha)},hwbString:function(){return u.hwbString(this.values.hwb,this.values.alpha)},keyword:function(){return u.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function(){var t=this.values.rgb;return t[0]<<16|t[1]<<8|t[2]},luminosity:function(){for(var t=this.values.rgb,e=[],n=0;n<t.length;n++){var i=t[n]/255;e[n]=i<=.03928?i/12.92:Math.pow((i+.055)/1.055,2.4)}return.2126*e[0]+.7152*e[1]+.0722*e[2]},contrast:function(t){var e=this.luminosity(),n=t.luminosity();return e>n?(e+.05)/(n+.05):(n+.05)/(e+.05)},level:function(t){var e=this.contrast(t);return e>=7.1?"AAA":e>=4.5?"AA":""},dark:function(){var t=this.values.rgb;return(299*t[0]+587*t[1]+114*t[2])/1e3<128},light:function(){return!this.dark()},negate:function(){for(var t=[],e=0;e<3;e++)t[e]=255-this.values.rgb[e];return this.setValues("rgb",t),this},lighten:function(t){var e=this.values.hsl;return e[2]+=e[2]*t,this.setValues("hsl",e),this},darken:function(t){var e=this.values.hsl;return e[2]-=e[2]*t,this.setValues("hsl",e),this},saturate:function(t){var e=this.values.hsl;return e[1]+=e[1]*t,this.setValues("hsl",e),this},desaturate:function(t){var e=this.values.hsl;return e[1]-=e[1]*t,this.setValues("hsl",e),this},whiten:function(t){var e=this.values.hwb;return e[1]+=e[1]*t,this.setValues("hwb",e),this},blacken:function(t){var e=this.values.hwb;return e[2]+=e[2]*t,this.setValues("hwb",e),this},greyscale:function(){var t=this.values.rgb,e=.3*t[0]+.59*t[1]+.11*t[2];return this.setValues("rgb",[e,e,e]),this},clearer:function(t){var e=this.values.alpha;return this.setValues("alpha",e-e*t),this},opaquer:function(t){var e=this.values.alpha;return this.setValues("alpha",e+e*t),this},rotate:function(t){var e=this.values.hsl,n=(e[0]+t)%360;return e[0]=n<0?360+n:n,this.setValues("hsl",e),this},mix:function(t,e){var n=t,i=void 0===e?.5:e,a=2*i-1,r=this.alpha()-n.alpha(),o=((a*r==-1?a:(a+r)/(1+a*r))+1)/2,s=1-o;return this.rgb(o*this.red()+s*n.red(),o*this.green()+s*n.green(),o*this.blue()+s*n.blue()).alpha(this.alpha()*i+n.alpha()*(1-i))},toJSON:function(){return this.rgb()},clone:function(){var t,e,n=new y,i=this.values,a=n.values;for(var r in i)i.hasOwnProperty(r)&&(t=i[r],"[object Array]"===(e={}.toString.call(t))?a[r]=t.slice(0):"[object Number]"===e?a[r]=t:console.error("unexpected color value:",t));return n}},y.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},y.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},y.prototype.getValues=function(t){for(var e=this.values,n={},i=0;i<t.length;i++)n[t.charAt(i)]=e[t][i];return 1!==e.alpha&&(n.a=e.alpha),n},y.prototype.setValues=function(t,e){var n,i,a=this.values,r=this.spaces,o=this.maxes,l=1;if(this.valid=!0,"alpha"===t)l=e;else if(e.length)a[t]=e.slice(0,t.length),l=e[t.length];else if(void 0!==e[t.charAt(0)]){for(n=0;n<t.length;n++)a[t][n]=e[t.charAt(n)];l=e.a}else if(void 0!==e[r[t][0]]){var u=r[t];for(n=0;n<t.length;n++)a[t][n]=e[u[n]];l=e.alpha}if(a.alpha=Math.max(0,Math.min(1,void 0===l?a.alpha:l)),"alpha"===t)return!1;for(n=0;n<t.length;n++)i=Math.max(0,Math.min(o[t][n],a[t][n])),a[t][n]=Math.round(i);for(var d in r)d!==t&&(a[d]=s[t][d](a[t]));return!0},y.prototype.setSpace=function(t,e){var n=e[0];return void 0===n?this.getValues(t):("number"==typeof n&&(n=Array.prototype.slice.call(e)),this.setValues(t,n),this)},y.prototype.setChannel=function(t,e,n){var i=this.values[t];return void 0===n?i[e]:n===i[e]?this:(i[e]=n,this.setValues(t,i),this)},"undefined"!=typeof window&&(window.Color=y);var _=y;function k(t){return-1===["__proto__","prototype","constructor"].indexOf(t)}var w,M={noop:function(){},uid:(w=0,function(){return w++}),isNullOrUndef:function(t){return null==t},isArray:function(t){if(Array.isArray&&Array.isArray(t))return!0;var e=Object.prototype.toString.call(t);return"[object"===e.substr(0,7)&&"Array]"===e.substr(-6)},isObject:function(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)},isFinite:function(t){return("number"==typeof t||t instanceof Number)&&isFinite(t)},valueOrDefault:function(t,e){return void 0===t?e:t},valueAtIndexOrDefault:function(t,e,n){return M.valueOrDefault(M.isArray(t)?t[e]:t,n)},callback:function(t,e,n){if(t&&"function"==typeof t.call)return t.apply(n,e)},each:function(t,e,n,i){var a,r,o;if(M.isArray(t))if(r=t.length,i)for(a=r-1;a>=0;a--)e.call(n,t[a],a);else for(a=0;a<r;a++)e.call(n,t[a],a);else if(M.isObject(t))for(r=(o=Object.keys(t)).length,a=0;a<r;a++)e.call(n,t[o[a]],o[a])},arrayEquals:function(t,e){var n,i,a,r;if(!t||!e||t.length!==e.length)return!1;for(n=0,i=t.length;n<i;++n)if(a=t[n],r=e[n],a instanceof Array&&r instanceof Array){if(!M.arrayEquals(a,r))return!1}else if(a!==r)return!1;return!0},clone:function(t){if(M.isArray(t))return t.map(M.clone);if(M.isObject(t)){for(var e=Object.create(t),n=Object.keys(t),i=n.length,a=0;a<i;++a)e[n[a]]=M.clone(t[n[a]]);return e}return t},_merger:function(t,e,n,i){if(k(t)){var a=e[t],r=n[t];M.isObject(a)&&M.isObject(r)?M.merge(a,r,i):e[t]=M.clone(r)}},_mergerIf:function(t,e,n){if(k(t)){var i=e[t],a=n[t];M.isObject(i)&&M.isObject(a)?M.mergeIf(i,a):e.hasOwnProperty(t)||(e[t]=M.clone(a))}},merge:function(t,e,n){var i,a,r,o,s,l=M.isArray(e)?e:[e],u=l.length;if(!M.isObject(t))return t;for(i=(n=n||{}).merger||M._merger,a=0;a<u;++a)if(e=l[a],M.isObject(e))for(s=0,o=(r=Object.keys(e)).length;s<o;++s)i(r[s],t,e,n);return t},mergeIf:function(t,e){return M.merge(t,e,{merger:M._mergerIf})},extend:Object.assign||function(t){return M.merge(t,[].slice.call(arguments,1),{merger:function(t,e,n){e[t]=n[t]}})},inherits:function(t){var e=this,n=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return e.apply(this,arguments)},i=function(){this.constructor=n};return i.prototype=e.prototype,n.prototype=new i,n.extend=M.inherits,t&&M.extend(n.prototype,t),n.__super__=e.prototype,n},_deprecated:function(t,e,n,i){void 0!==e&&console.warn(t+': "'+n+'" is deprecated. Please use "'+i+'" instead')}},S=M;M.callCallback=M.callback,M.indexOf=function(t,e,n){return Array.prototype.indexOf.call(t,e,n)},M.getValueOrDefault=M.valueOrDefault,M.getValueAtIndexOrDefault=M.valueAtIndexOrDefault;var C={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return(t-=1)*t*t+1},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-((t-=1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return(t-=1)*t*t*t*t+1},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return 1-Math.cos(t*(Math.PI/2))},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:1-Math.pow(2,-10*t)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},easeInCirc:function(t){return t>=1?t:-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-(t-=1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:1===t?1:(n||(n=.3),i<1?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),-i*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/n))},easeOutElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:1===t?1:(n||(n=.3),i<1?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),i*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/n)+1)},easeInOutElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:2==(t/=.5)?1:(n||(n=.45),i<1?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),t<1?i*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/n)*-.5:i*Math.pow(2,-10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/n)*.5+1)},easeInBack:function(t){var e=1.70158;return t*t*((e+1)*t-e)},easeOutBack:function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:function(t){return 1-C.easeOutBounce(1-t)},easeOutBounce:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInOutBounce:function(t){return t<.5?.5*C.easeInBounce(2*t):.5*C.easeOutBounce(2*t-1)+.5}},P={effects:C};S.easingEffects=C;var A=Math.PI,D=A/180,T=2*A,I=A/2,F=A/4,O=2*A/3,L={clear:function(t){t.ctx.clearRect(0,0,t.width,t.height)},roundedRect:function(t,e,n,i,a,r){if(r){var o=Math.min(r,a/2,i/2),s=e+o,l=n+o,u=e+i-o,d=n+a-o;t.moveTo(e,l),s<u&&l<d?(t.arc(s,l,o,-A,-I),t.arc(u,l,o,-I,0),t.arc(u,d,o,0,I),t.arc(s,d,o,I,A)):s<u?(t.moveTo(s,n),t.arc(u,l,o,-I,I),t.arc(s,l,o,I,A+I)):l<d?(t.arc(s,l,o,-A,0),t.arc(s,d,o,0,A)):t.arc(s,l,o,-A,A),t.closePath(),t.moveTo(e,n)}else t.rect(e,n,i,a)},drawPoint:function(t,e,n,i,a,r){var o,s,l,u,d,h=(r||0)*D;if(e&&"object"==typeof e&&("[object HTMLImageElement]"===(o=e.toString())||"[object HTMLCanvasElement]"===o))return t.save(),t.translate(i,a),t.rotate(h),t.drawImage(e,-e.width/2,-e.height/2,e.width,e.height),void t.restore();if(!(isNaN(n)||n<=0)){switch(t.beginPath(),e){default:t.arc(i,a,n,0,T),t.closePath();break;case"triangle":t.moveTo(i+Math.sin(h)*n,a-Math.cos(h)*n),h+=O,t.lineTo(i+Math.sin(h)*n,a-Math.cos(h)*n),h+=O,t.lineTo(i+Math.sin(h)*n,a-Math.cos(h)*n),t.closePath();break;case"rectRounded":u=n-(d=.516*n),s=Math.cos(h+F)*u,l=Math.sin(h+F)*u,t.arc(i-s,a-l,d,h-A,h-I),t.arc(i+l,a-s,d,h-I,h),t.arc(i+s,a+l,d,h,h+I),t.arc(i-l,a+s,d,h+I,h+A),t.closePath();break;case"rect":if(!r){u=Math.SQRT1_2*n,t.rect(i-u,a-u,2*u,2*u);break}h+=F;case"rectRot":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+l,a-s),t.lineTo(i+s,a+l),t.lineTo(i-l,a+s),t.closePath();break;case"crossRot":h+=F;case"cross":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l),t.moveTo(i+l,a-s),t.lineTo(i-l,a+s);break;case"star":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l),t.moveTo(i+l,a-s),t.lineTo(i-l,a+s),h+=F,s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l),t.moveTo(i+l,a-s),t.lineTo(i-l,a+s);break;case"line":s=Math.cos(h)*n,l=Math.sin(h)*n,t.moveTo(i-s,a-l),t.lineTo(i+s,a+l);break;case"dash":t.moveTo(i,a),t.lineTo(i+Math.cos(h)*n,a+Math.sin(h)*n)}t.fill(),t.stroke()}},_isPointInArea:function(t,e){return t.x>e.left-1e-6&&t.x<e.right+1e-6&&t.y>e.top-1e-6&&t.y<e.bottom+1e-6},clipArea:function(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()},unclipArea:function(t){t.restore()},lineTo:function(t,e,n,i){var a=n.steppedLine;if(a){if("middle"===a){var r=(e.x+n.x)/2;t.lineTo(r,i?n.y:e.y),t.lineTo(r,i?e.y:n.y)}else"after"===a&&!i||"after"!==a&&i?t.lineTo(e.x,n.y):t.lineTo(n.x,e.y);t.lineTo(n.x,n.y)}else n.tension?t.bezierCurveTo(i?e.controlPointPreviousX:e.controlPointNextX,i?e.controlPointPreviousY:e.controlPointNextY,i?n.controlPointNextX:n.controlPointPreviousX,i?n.controlPointNextY:n.controlPointPreviousY,n.x,n.y):t.lineTo(n.x,n.y)}},R=L;S.clear=L.clear,S.drawRoundedRectangle=function(t){t.beginPath(),L.roundedRect.apply(L,arguments)};var z={_set:function(t,e){return S.merge(this[t]||(this[t]={}),e)}};z._set("global",{defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",defaultLineHeight:1.2,showLines:!0});var N=z,B=S.valueOrDefault;var E={toLineHeight:function(t,e){var n=(""+t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);if(!n||"normal"===n[1])return 1.2*e;switch(t=+n[2],n[3]){case"px":return t;case"%":t/=100}return e*t},toPadding:function(t){var e,n,i,a;return S.isObject(t)?(e=+t.top||0,n=+t.right||0,i=+t.bottom||0,a=+t.left||0):e=n=i=a=+t||0,{top:e,right:n,bottom:i,left:a,height:e+i,width:a+n}},_parseFont:function(t){var e=N.global,n=B(t.fontSize,e.defaultFontSize),i={family:B(t.fontFamily,e.defaultFontFamily),lineHeight:S.options.toLineHeight(B(t.lineHeight,e.defaultLineHeight),n),size:n,style:B(t.fontStyle,e.defaultFontStyle),weight:null,string:""};return i.string=function(t){return!t||S.isNullOrUndef(t.size)||S.isNullOrUndef(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}(i),i},resolve:function(t,e,n,i){var a,r,o,s=!0;for(a=0,r=t.length;a<r;++a)if(void 0!==(o=t[a])&&(void 0!==e&&"function"==typeof o&&(o=o(e),s=!1),void 0!==n&&S.isArray(o)&&(o=o[n],s=!1),void 0!==o))return i&&!s&&(i.cacheable=!1),o}},W={_factorize:function(t){var e,n=[],i=Math.sqrt(t);for(e=1;e<i;e++)t%e==0&&(n.push(e),n.push(t/e));return i===(0|i)&&n.push(i),n.sort((function(t,e){return t-e})).pop(),n},log10:Math.log10||function(t){var e=Math.log(t)*Math.LOG10E,n=Math.round(e);return t===Math.pow(10,n)?n:e}},V=W;S.log10=W.log10;var H=S,j=P,q=R,U=E,Y=V,G={getRtlAdapter:function(t,e,n){return t?function(t,e){return{x:function(n){return t+t+e-n},setWidth:function(t){e=t},textAlign:function(t){return"center"===t?t:"right"===t?"left":"right"},xPlus:function(t,e){return t-e},leftForLtr:function(t,e){return t-e}}}(e,n):{x:function(t){return t},setWidth:function(t){},textAlign:function(t){return t},xPlus:function(t,e){return t+e},leftForLtr:function(t,e){return t}}},overrideTextDirection:function(t,e){var n,i;"ltr"!==e&&"rtl"!==e||(i=[(n=t.canvas.style).getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",e,"important"),t.prevTextDirection=i)},restoreTextDirection:function(t){var e=t.prevTextDirection;void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}};H.easing=j,H.canvas=q,H.options=U,H.math=Y,H.rtl=G;var X=function(t){H.extend(this,t),this.initialize.apply(this,arguments)};H.extend(X.prototype,{_type:void 0,initialize:function(){this.hidden=!1},pivot:function(){var t=this;return t._view||(t._view=H.extend({},t._model)),t._start={},t},transition:function(t){var e=this,n=e._model,i=e._start,a=e._view;return n&&1!==t?(a||(a=e._view={}),i||(i=e._start={}),function(t,e,n,i){var a,r,o,s,l,u,d,h,c,f=Object.keys(n);for(a=0,r=f.length;a<r;++a)if(u=n[o=f[a]],e.hasOwnProperty(o)||(e[o]=u),(s=e[o])!==u&&"_"!==o[0]){if(t.hasOwnProperty(o)||(t[o]=s),(d=typeof u)===typeof(l=t[o]))if("string"===d){if((h=_(l)).valid&&(c=_(u)).valid){e[o]=c.mix(h,i).rgbString();continue}}else if(H.isFinite(l)&&H.isFinite(u)){e[o]=l+(u-l)*i;continue}e[o]=u}}(i,a,n,t),e):(e._view=H.extend({},n),e._start=null,e)},tooltipPosition:function(){return{x:this._model.x,y:this._model.y}},hasValue:function(){return H.isNumber(this._model.x)&&H.isNumber(this._model.y)}}),X.extend=H.inherits;var K=X,Z=K.extend({chart:null,currentStep:0,numSteps:60,easing:"",render:null,onAnimationProgress:null,onAnimationComplete:null}),$=Z;Object.defineProperty(Z.prototype,"animationObject",{get:function(){return this}}),Object.defineProperty(Z.prototype,"chartInstance",{get:function(){return this.chart},set:function(t){this.chart=t}}),N._set("global",{animation:{duration:1e3,easing:"easeOutQuart",onProgress:H.noop,onComplete:H.noop}});var J={animations:[],request:null,addAnimation:function(t,e,n,i){var a,r,o=this.animations;for(e.chart=t,e.startTime=Date.now(),e.duration=n,i||(t.animating=!0),a=0,r=o.length;a<r;++a)if(o[a].chart===t)return void(o[a]=e);o.push(e),1===o.length&&this.requestAnimationFrame()},cancelAnimation:function(t){var e=H.findIndex(this.animations,(function(e){return e.chart===t}));-1!==e&&(this.animations.splice(e,1),t.animating=!1)},requestAnimationFrame:function(){var t=this;null===t.request&&(t.request=H.requestAnimFrame.call(window,(function(){t.request=null,t.startDigest()})))},startDigest:function(){this.advance(),this.animations.length>0&&this.requestAnimationFrame()},advance:function(){for(var t,e,n,i,a=this.animations,r=0;r<a.length;)e=(t=a[r]).chart,n=t.numSteps,i=Math.floor((Date.now()-t.startTime)/t.duration*n)+1,t.currentStep=Math.min(i,n),H.callback(t.render,[e,t],e),H.callback(t.onAnimationProgress,[t],e),t.currentStep>=n?(H.callback(t.onAnimationComplete,[t],e),e.animating=!1,a.splice(r,1)):++r}},Q=H.options.resolve,tt=["push","pop","shift","splice","unshift"];function et(t,e){var n=t._chartjs;if(n){var i=n.listeners,a=i.indexOf(e);-1!==a&&i.splice(a,1),i.length>0||(tt.forEach((function(e){delete t[e]})),delete t._chartjs)}}var nt=function(t,e){this.initialize(t,e)};H.extend(nt.prototype,{datasetElementType:null,dataElementType:null,_datasetElementOptions:["backgroundColor","borderCapStyle","borderColor","borderDash","borderDashOffset","borderJoinStyle","borderWidth"],_dataElementOptions:["backgroundColor","borderColor","borderWidth","pointStyle"],initialize:function(t,e){var n=this;n.chart=t,n.index=e,n.linkScales(),n.addElements(),n._type=n.getMeta().type},updateIndex:function(t){this.index=t},linkScales:function(){var t=this.getMeta(),e=this.chart,n=e.scales,i=this.getDataset(),a=e.options.scales;null!==t.xAxisID&&t.xAxisID in n&&!i.xAxisID||(t.xAxisID=i.xAxisID||a.xAxes[0].id),null!==t.yAxisID&&t.yAxisID in n&&!i.yAxisID||(t.yAxisID=i.yAxisID||a.yAxes[0].id)},getDataset:function(){return this.chart.data.datasets[this.index]},getMeta:function(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function(t){return this.chart.scales[t]},_getValueScaleId:function(){return this.getMeta().yAxisID},_getIndexScaleId:function(){return this.getMeta().xAxisID},_getValueScale:function(){return this.getScaleForId(this._getValueScaleId())},_getIndexScale:function(){return this.getScaleForId(this._getIndexScaleId())},reset:function(){this._update(!0)},destroy:function(){this._data&&et(this._data,this)},createMetaDataset:function(){var t=this.datasetElementType;return t&&new t({_chart:this.chart,_datasetIndex:this.index})},createMetaData:function(t){var e=this.dataElementType;return e&&new e({_chart:this.chart,_datasetIndex:this.index,_index:t})},addElements:function(){var t,e,n=this.getMeta(),i=this.getDataset().data||[],a=n.data;for(t=0,e=i.length;t<e;++t)a[t]=a[t]||this.createMetaData(t);n.dataset=n.dataset||this.createMetaDataset()},addElementAndReset:function(t){var e=this.createMetaData(t);this.getMeta().data.splice(t,0,e),this.updateElement(e,t,!0)},buildOrUpdateElements:function(){var t,e,n=this,i=n.getDataset(),a=i.data||(i.data=[]);n._data!==a&&(n._data&&et(n._data,n),a&&Object.isExtensible(a)&&(e=n,(t=a)._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),tt.forEach((function(e){var n="onData"+e.charAt(0).toUpperCase()+e.slice(1),i=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:function(){var e=Array.prototype.slice.call(arguments),a=i.apply(this,e);return H.each(t._chartjs.listeners,(function(t){"function"==typeof t[n]&&t[n].apply(t,e)})),a}})})))),n._data=a),n.resyncElements()},_configure:function(){this._config=H.merge(Object.create(null),[this.chart.options.datasets[this._type],this.getDataset()],{merger:function(t,e,n){"_meta"!==t&&"data"!==t&&H._merger(t,e,n)}})},_update:function(t){this._configure(),this._cachedDataOpts=null,this.update(t)},update:H.noop,transition:function(t){for(var e=this.getMeta(),n=e.data||[],i=n.length,a=0;a<i;++a)n[a].transition(t);e.dataset&&e.dataset.transition(t)},draw:function(){var t=this.getMeta(),e=t.data||[],n=e.length,i=0;for(t.dataset&&t.dataset.draw();i<n;++i)e[i].draw()},getStyle:function(t){var e,n=this.getMeta(),i=n.dataset;return this._configure(),i&&void 0===t?e=this._resolveDatasetElementOptions(i||{}):(t=t||0,e=this._resolveDataElementOptions(n.data[t]||{},t)),!1!==e.fill&&null!==e.fill||(e.backgroundColor=e.borderColor),e},_resolveDatasetElementOptions:function(t,e){var n,i,a,r,o=this,s=o.chart,l=o._config,u=t.custom||{},d=s.options.elements[o.datasetElementType.prototype._type]||{},h=o._datasetElementOptions,c={},f={chart:s,dataset:o.getDataset(),datasetIndex:o.index,hover:e};for(n=0,i=h.length;n<i;++n)a=h[n],r=e?"hover"+a.charAt(0).toUpperCase()+a.slice(1):a,c[a]=Q([u[r],l[r],d[r]],f);return c},_resolveDataElementOptions:function(t,e){var n=this,i=t&&t.custom,a=n._cachedDataOpts;if(a&&!i)return a;var r,o,s,l,u=n.chart,d=n._config,h=u.options.elements[n.dataElementType.prototype._type]||{},c=n._dataElementOptions,f={},g={chart:u,dataIndex:e,dataset:n.getDataset(),datasetIndex:n.index},p={cacheable:!i};if(i=i||{},H.isArray(c))for(o=0,s=c.length;o<s;++o)f[l=c[o]]=Q([i[l],d[l],h[l]],g,e,p);else for(o=0,s=(r=Object.keys(c)).length;o<s;++o)f[l=r[o]]=Q([i[l],d[c[l]],d[l],h[l]],g,e,p);return p.cacheable&&(n._cachedDataOpts=Object.freeze(f)),f},removeHoverStyle:function(t){H.merge(t._model,t.$previousStyle||{}),delete t.$previousStyle},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],n=t._index,i=t.custom||{},a=t._model,r=H.getHoverColor;t.$previousStyle={backgroundColor:a.backgroundColor,borderColor:a.borderColor,borderWidth:a.borderWidth},a.backgroundColor=Q([i.hoverBackgroundColor,e.hoverBackgroundColor,r(a.backgroundColor)],void 0,n),a.borderColor=Q([i.hoverBorderColor,e.hoverBorderColor,r(a.borderColor)],void 0,n),a.borderWidth=Q([i.hoverBorderWidth,e.hoverBorderWidth,a.borderWidth],void 0,n)},_removeDatasetHoverStyle:function(){var t=this.getMeta().dataset;t&&this.removeHoverStyle(t)},_setDatasetHoverStyle:function(){var t,e,n,i,a,r,o=this.getMeta().dataset,s={};if(o){for(r=o._model,a=this._resolveDatasetElementOptions(o,!0),t=0,e=(i=Object.keys(a)).length;t<e;++t)s[n=i[t]]=r[n],r[n]=a[n];o.$previousStyle=s}},resyncElements:function(){var t=this.getMeta(),e=this.getDataset().data,n=t.data.length,i=e.length;i<n?t.data.splice(i,n-i):i>n&&this.insertElements(n,i-n)},insertElements:function(t,e){for(var n=0;n<e;++n)this.addElementAndReset(t+n)},onDataPush:function(){var t=arguments.length;this.insertElements(this.getDataset().data.length-t,t)},onDataPop:function(){this.getMeta().data.pop()},onDataShift:function(){this.getMeta().data.shift()},onDataSplice:function(t,e){this.getMeta().data.splice(t,e),this.insertElements(t,arguments.length-2)},onDataUnshift:function(){this.insertElements(0,arguments.length)}}),nt.extend=H.inherits;var it=nt,at=2*Math.PI;function rt(t,e){var n=e.startAngle,i=e.endAngle,a=e.pixelMargin,r=a/e.outerRadius,o=e.x,s=e.y;t.beginPath(),t.arc(o,s,e.outerRadius,n-r,i+r),e.innerRadius>a?(r=a/e.innerRadius,t.arc(o,s,e.innerRadius-a,i+r,n-r,!0)):t.arc(o,s,a,i+Math.PI/2,n-Math.PI/2),t.closePath(),t.clip()}function ot(t,e,n){var i="inner"===e.borderAlign;i?(t.lineWidth=2*e.borderWidth,t.lineJoin="round"):(t.lineWidth=e.borderWidth,t.lineJoin="bevel"),n.fullCircles&&function(t,e,n,i){var a,r=n.endAngle;for(i&&(n.endAngle=n.startAngle+at,rt(t,n),n.endAngle=r,n.endAngle===n.startAngle&&n.fullCircles&&(n.endAngle+=at,n.fullCircles--)),t.beginPath(),t.arc(n.x,n.y,n.innerRadius,n.startAngle+at,n.startAngle,!0),a=0;a<n.fullCircles;++a)t.stroke();for(t.beginPath(),t.arc(n.x,n.y,e.outerRadius,n.startAngle,n.startAngle+at),a=0;a<n.fullCircles;++a)t.stroke()}(t,e,n,i),i&&rt(t,n),t.beginPath(),t.arc(n.x,n.y,e.outerRadius,n.startAngle,n.endAngle),t.arc(n.x,n.y,n.innerRadius,n.endAngle,n.startAngle,!0),t.closePath(),t.stroke()}N._set("global",{elements:{arc:{backgroundColor:N.global.defaultColor,borderColor:"#fff",borderWidth:2,borderAlign:"center"}}});var st=K.extend({_type:"arc",inLabelRange:function(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hoverRadius,2)},inRange:function(t,e){var n=this._view;if(n){for(var i=H.getAngleFromPoint(n,{x:t,y:e}),a=i.angle,r=i.distance,o=n.startAngle,s=n.endAngle;s<o;)s+=at;for(;a>s;)a-=at;for(;a<o;)a+=at;var l=a>=o&&a<=s,u=r>=n.innerRadius&&r<=n.outerRadius;return l&&u}return!1},getCenterPoint:function(){var t=this._view,e=(t.startAngle+t.endAngle)/2,n=(t.innerRadius+t.outerRadius)/2;return{x:t.x+Math.cos(e)*n,y:t.y+Math.sin(e)*n}},getArea:function(){var t=this._view;return Math.PI*((t.endAngle-t.startAngle)/(2*Math.PI))*(Math.pow(t.outerRadius,2)-Math.pow(t.innerRadius,2))},tooltipPosition:function(){var t=this._view,e=t.startAngle+(t.endAngle-t.startAngle)/2,n=(t.outerRadius-t.innerRadius)/2+t.innerRadius;return{x:t.x+Math.cos(e)*n,y:t.y+Math.sin(e)*n}},draw:function(){var t,e=this._chart.ctx,n=this._view,i="inner"===n.borderAlign?.33:0,a={x:n.x,y:n.y,innerRadius:n.innerRadius,outerRadius:Math.max(n.outerRadius-i,0),pixelMargin:i,startAngle:n.startAngle,endAngle:n.endAngle,fullCircles:Math.floor(n.circumference/at)};if(e.save(),e.fillStyle=n.backgroundColor,e.strokeStyle=n.borderColor,a.fullCircles){for(a.endAngle=a.startAngle+at,e.beginPath(),e.arc(a.x,a.y,a.outerRadius,a.startAngle,a.endAngle),e.arc(a.x,a.y,a.innerRadius,a.endAngle,a.startAngle,!0),e.closePath(),t=0;t<a.fullCircles;++t)e.fill();a.endAngle=a.startAngle+n.circumference%at}e.beginPath(),e.arc(a.x,a.y,a.outerRadius,a.startAngle,a.endAngle),e.arc(a.x,a.y,a.innerRadius,a.endAngle,a.startAngle,!0),e.closePath(),e.fill(),n.borderWidth&&ot(e,n,a),e.restore()}}),lt=H.valueOrDefault,ut=N.global.defaultColor;N._set("global",{elements:{line:{tension:.4,backgroundColor:ut,borderWidth:3,borderColor:ut,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0}}});var dt=K.extend({_type:"line",draw:function(){var t,e,n,i=this,a=i._view,r=i._chart.ctx,o=a.spanGaps,s=i._children.slice(),l=N.global,u=l.elements.line,d=-1,h=i._loop;if(s.length){if(i._loop){for(t=0;t<s.length;++t)if(e=H.previousItem(s,t),!s[t]._view.skip&&e._view.skip){s=s.slice(t).concat(s.slice(0,t)),h=o;break}h&&s.push(s[0])}for(r.save(),r.lineCap=a.borderCapStyle||u.borderCapStyle,r.setLineDash&&r.setLineDash(a.borderDash||u.borderDash),r.lineDashOffset=lt(a.borderDashOffset,u.borderDashOffset),r.lineJoin=a.borderJoinStyle||u.borderJoinStyle,r.lineWidth=lt(a.borderWidth,u.borderWidth),r.strokeStyle=a.borderColor||l.defaultColor,r.beginPath(),(n=s[0]._view).skip||(r.moveTo(n.x,n.y),d=0),t=1;t<s.length;++t)n=s[t]._view,e=-1===d?H.previousItem(s,t):s[d],n.skip||(d!==t-1&&!o||-1===d?r.moveTo(n.x,n.y):H.canvas.lineTo(r,e._view,n),d=t);h&&r.closePath(),r.stroke(),r.restore()}}}),ht=H.valueOrDefault,ct=N.global.defaultColor;function ft(t){var e=this._view;return!!e&&Math.abs(t-e.x)<e.radius+e.hitRadius}N._set("global",{elements:{point:{radius:3,pointStyle:"circle",backgroundColor:ct,borderColor:ct,borderWidth:1,hitRadius:1,hoverRadius:4,hoverBorderWidth:1}}});var gt=K.extend({_type:"point",inRange:function(t,e){var n=this._view;return!!n&&Math.pow(t-n.x,2)+Math.pow(e-n.y,2)<Math.pow(n.hitRadius+n.radius,2)},inLabelRange:ft,inXRange:ft,inYRange:function(t){var e=this._view;return!!e&&Math.abs(t-e.y)<e.radius+e.hitRadius},getCenterPoint:function(){var t=this._view;return{x:t.x,y:t.y}},getArea:function(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y,padding:t.radius+t.borderWidth}},draw:function(t){var e=this._view,n=this._chart.ctx,i=e.pointStyle,a=e.rotation,r=e.radius,o=e.x,s=e.y,l=N.global,u=l.defaultColor;e.skip||(void 0===t||H.canvas._isPointInArea(e,t))&&(n.strokeStyle=e.borderColor||u,n.lineWidth=ht(e.borderWidth,l.elements.point.borderWidth),n.fillStyle=e.backgroundColor||u,H.canvas.drawPoint(n,i,r,o,s,a))}}),pt=N.global.defaultColor;function mt(t){return t&&void 0!==t.width}function vt(t){var e,n,i,a,r;return mt(t)?(r=t.width/2,e=t.x-r,n=t.x+r,i=Math.min(t.y,t.base),a=Math.max(t.y,t.base)):(r=t.height/2,e=Math.min(t.x,t.base),n=Math.max(t.x,t.base),i=t.y-r,a=t.y+r),{left:e,top:i,right:n,bottom:a}}function bt(t,e,n){return t===e?n:t===n?e:t}function xt(t,e,n){var i,a,r,o,s=t.borderWidth,l=function(t){var e=t.borderSkipped,n={};return e?(t.horizontal?t.base>t.x&&(e=bt(e,"left","right")):t.base<t.y&&(e=bt(e,"bottom","top")),n[e]=!0,n):n}(t);return H.isObject(s)?(i=+s.top||0,a=+s.right||0,r=+s.bottom||0,o=+s.left||0):i=a=r=o=+s||0,{t:l.top||i<0?0:i>n?n:i,r:l.right||a<0?0:a>e?e:a,b:l.bottom||r<0?0:r>n?n:r,l:l.left||o<0?0:o>e?e:o}}function yt(t,e,n){var i=null===e,a=null===n,r=!(!t||i&&a)&&vt(t);return r&&(i||e>=r.left&&e<=r.right)&&(a||n>=r.top&&n<=r.bottom)}N._set("global",{elements:{rectangle:{backgroundColor:pt,borderColor:pt,borderSkipped:"bottom",borderWidth:0}}});var _t=K.extend({_type:"rectangle",draw:function(){var t=this._chart.ctx,e=this._view,n=function(t){var e=vt(t),n=e.right-e.left,i=e.bottom-e.top,a=xt(t,n/2,i/2);return{outer:{x:e.left,y:e.top,w:n,h:i},inner:{x:e.left+a.l,y:e.top+a.t,w:n-a.l-a.r,h:i-a.t-a.b}}}(e),i=n.outer,a=n.inner;t.fillStyle=e.backgroundColor,t.fillRect(i.x,i.y,i.w,i.h),i.w===a.w&&i.h===a.h||(t.save(),t.beginPath(),t.rect(i.x,i.y,i.w,i.h),t.clip(),t.fillStyle=e.borderColor,t.rect(a.x,a.y,a.w,a.h),t.fill("evenodd"),t.restore())},height:function(){var t=this._view;return t.base-t.y},inRange:function(t,e){return yt(this._view,t,e)},inLabelRange:function(t,e){var n=this._view;return mt(n)?yt(n,t,null):yt(n,null,e)},inXRange:function(t){return yt(this._view,t,null)},inYRange:function(t){return yt(this._view,null,t)},getCenterPoint:function(){var t,e,n=this._view;return mt(n)?(t=n.x,e=(n.y+n.base)/2):(t=(n.x+n.base)/2,e=n.y),{x:t,y:e}},getArea:function(){var t=this._view;return mt(t)?t.width*Math.abs(t.y-t.base):t.height*Math.abs(t.x-t.base)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y}}}),kt={},wt=st,Mt=dt,St=gt,Ct=_t;kt.Arc=wt,kt.Line=Mt,kt.Point=St,kt.Rectangle=Ct;var Pt=H._deprecated,At=H.valueOrDefault;function Dt(t,e,n){var i,a,r=n.barThickness,o=e.stackCount,s=e.pixels[t],l=H.isNullOrUndef(r)?function(t,e){var n,i,a,r,o=t._length;for(a=1,r=e.length;a<r;++a)o=Math.min(o,Math.abs(e[a]-e[a-1]));for(a=0,r=t.getTicks().length;a<r;++a)i=t.getPixelForTick(a),o=a>0?Math.min(o,Math.abs(i-n)):o,n=i;return o}(e.scale,e.pixels):-1;return H.isNullOrUndef(r)?(i=l*n.categoryPercentage,a=n.barPercentage):(i=r*o,a=1),{chunk:i/o,ratio:a,start:s-i/2}}N._set("bar",{hover:{mode:"label"},scales:{xAxes:[{type:"category",offset:!0,gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}}),N._set("global",{datasets:{bar:{categoryPercentage:.8,barPercentage:.9}}});var Tt=it.extend({dataElementType:kt.Rectangle,_dataElementOptions:["backgroundColor","borderColor","borderSkipped","borderWidth","barPercentage","barThickness","categoryPercentage","maxBarThickness","minBarLength"],initialize:function(){var t,e,n=this;it.prototype.initialize.apply(n,arguments),(t=n.getMeta()).stack=n.getDataset().stack,t.bar=!0,e=n._getIndexScale().options,Pt("bar chart",e.barPercentage,"scales.[x/y]Axes.barPercentage","dataset.barPercentage"),Pt("bar chart",e.barThickness,"scales.[x/y]Axes.barThickness","dataset.barThickness"),Pt("bar chart",e.categoryPercentage,"scales.[x/y]Axes.categoryPercentage","dataset.categoryPercentage"),Pt("bar chart",n._getValueScale().options.minBarLength,"scales.[x/y]Axes.minBarLength","dataset.minBarLength"),Pt("bar chart",e.maxBarThickness,"scales.[x/y]Axes.maxBarThickness","dataset.maxBarThickness")},update:function(t){var e,n,i=this.getMeta().data;for(this._ruler=this.getRuler(),e=0,n=i.length;e<n;++e)this.updateElement(i[e],e,t)},updateElement:function(t,e,n){var i=this,a=i.getMeta(),r=i.getDataset(),o=i._resolveDataElementOptions(t,e);t._xScale=i.getScaleForId(a.xAxisID),t._yScale=i.getScaleForId(a.yAxisID),t._datasetIndex=i.index,t._index=e,t._model={backgroundColor:o.backgroundColor,borderColor:o.borderColor,borderSkipped:o.borderSkipped,borderWidth:o.borderWidth,datasetLabel:r.label,label:i.chart.data.labels[e]},H.isArray(r.data[e])&&(t._model.borderSkipped=null),i._updateElementGeometry(t,e,n,o),t.pivot()},_updateElementGeometry:function(t,e,n,i){var a=this,r=t._model,o=a._getValueScale(),s=o.getBasePixel(),l=o.isHorizontal(),u=a._ruler||a.getRuler(),d=a.calculateBarValuePixels(a.index,e,i),h=a.calculateBarIndexPixels(a.index,e,u,i);r.horizontal=l,r.base=n?s:d.base,r.x=l?n?s:d.head:h.center,r.y=l?h.center:n?s:d.head,r.height=l?h.size:void 0,r.width=l?void 0:h.size},_getStacks:function(t){var e,n,i=this._getIndexScale(),a=i._getMatchingVisibleMetas(this._type),r=i.options.stacked,o=a.length,s=[];for(e=0;e<o&&(n=a[e],(!1===r||-1===s.indexOf(n.stack)||void 0===r&&void 0===n.stack)&&s.push(n.stack),n.index!==t);++e);return s},getStackCount:function(){return this._getStacks().length},getStackIndex:function(t,e){var n=this._getStacks(t),i=void 0!==e?n.indexOf(e):-1;return-1===i?n.length-1:i},getRuler:function(){var t,e,n=this._getIndexScale(),i=[];for(t=0,e=this.getMeta().data.length;t<e;++t)i.push(n.getPixelForValue(null,t,this.index));return{pixels:i,start:n._startPixel,end:n._endPixel,stackCount:this.getStackCount(),scale:n}},calculateBarValuePixels:function(t,e,n){var i,a,r,o,s,l,u,d=this.chart,h=this._getValueScale(),c=h.isHorizontal(),f=d.data.datasets,g=h._getMatchingVisibleMetas(this._type),p=h._parseValue(f[t].data[e]),m=n.minBarLength,v=h.options.stacked,b=this.getMeta().stack,x=void 0===p.start?0:p.max>=0&&p.min>=0?p.min:p.max,y=void 0===p.start?p.end:p.max>=0&&p.min>=0?p.max-p.min:p.min-p.max,_=g.length;if(v||void 0===v&&void 0!==b)for(i=0;i<_&&(a=g[i]).index!==t;++i)a.stack===b&&(r=void 0===(u=h._parseValue(f[a.index].data[e])).start?u.end:u.min>=0&&u.max>=0?u.max:u.min,(p.min<0&&r<0||p.max>=0&&r>0)&&(x+=r));return o=h.getPixelForValue(x),l=(s=h.getPixelForValue(x+y))-o,void 0!==m&&Math.abs(l)<m&&(l=m,s=y>=0&&!c||y<0&&c?o-m:o+m),{size:l,base:o,head:s,center:s+l/2}},calculateBarIndexPixels:function(t,e,n,i){var a="flex"===i.barThickness?function(t,e,n){var i,a=e.pixels,r=a[t],o=t>0?a[t-1]:null,s=t<a.length-1?a[t+1]:null,l=n.categoryPercentage;return null===o&&(o=r-(null===s?e.end-e.start:s-r)),null===s&&(s=r+r-o),i=r-(r-Math.min(o,s))/2*l,{chunk:Math.abs(s-o)/2*l/e.stackCount,ratio:n.barPercentage,start:i}}(e,n,i):Dt(e,n,i),r=this.getStackIndex(t,this.getMeta().stack),o=a.start+a.chunk*r+a.chunk/2,s=Math.min(At(i.maxBarThickness,1/0),a.chunk*a.ratio);return{base:o-s/2,head:o+s/2,center:o,size:s}},draw:function(){var t=this.chart,e=this._getValueScale(),n=this.getMeta().data,i=this.getDataset(),a=n.length,r=0;for(H.canvas.clipArea(t.ctx,t.chartArea);r<a;++r){var o=e._parseValue(i.data[r]);isNaN(o.min)||isNaN(o.max)||n[r].draw()}H.canvas.unclipArea(t.ctx)},_resolveDataElementOptions:function(){var t=this,e=H.extend({},it.prototype._resolveDataElementOptions.apply(t,arguments)),n=t._getIndexScale().options,i=t._getValueScale().options;return e.barPercentage=At(n.barPercentage,e.barPercentage),e.barThickness=At(n.barThickness,e.barThickness),e.categoryPercentage=At(n.categoryPercentage,e.categoryPercentage),e.maxBarThickness=At(n.maxBarThickness,e.maxBarThickness),e.minBarLength=At(i.minBarLength,e.minBarLength),e}}),It=H.valueOrDefault,Ft=H.options.resolve;N._set("bubble",{hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function(){return""},label:function(t,e){var n=e.datasets[t.datasetIndex].label||"",i=e.datasets[t.datasetIndex].data[t.index];return n+": ("+t.xLabel+", "+t.yLabel+", "+i.r+")"}}}});var Ot=it.extend({dataElementType:kt.Point,_dataElementOptions:["backgroundColor","borderColor","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","pointStyle","rotation"],update:function(t){var e=this,n=e.getMeta().data;H.each(n,(function(n,i){e.updateElement(n,i,t)}))},updateElement:function(t,e,n){var i=this,a=i.getMeta(),r=t.custom||{},o=i.getScaleForId(a.xAxisID),s=i.getScaleForId(a.yAxisID),l=i._resolveDataElementOptions(t,e),u=i.getDataset().data[e],d=i.index,h=n?o.getPixelForDecimal(.5):o.getPixelForValue("object"==typeof u?u:NaN,e,d),c=n?s.getBasePixel():s.getPixelForValue(u,e,d);t._xScale=o,t._yScale=s,t._options=l,t._datasetIndex=d,t._index=e,t._model={backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,hitRadius:l.hitRadius,pointStyle:l.pointStyle,rotation:l.rotation,radius:n?0:l.radius,skip:r.skip||isNaN(h)||isNaN(c),x:h,y:c},t.pivot()},setHoverStyle:function(t){var e=t._model,n=t._options,i=H.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=It(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=It(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=It(n.hoverBorderWidth,n.borderWidth),e.radius=n.radius+n.hoverRadius},_resolveDataElementOptions:function(t,e){var n=this,i=n.chart,a=n.getDataset(),r=t.custom||{},o=a.data[e]||{},s=it.prototype._resolveDataElementOptions.apply(n,arguments),l={chart:i,dataIndex:e,dataset:a,datasetIndex:n.index};return n._cachedDataOpts===s&&(s=H.extend({},s)),s.radius=Ft([r.radius,o.r,n._config.radius,i.options.elements.point.radius],l,e),s}}),Lt=H.valueOrDefault,Rt=Math.PI,zt=2*Rt,Nt=Rt/2;N._set("doughnut",{animation:{animateRotate:!0,animateScale:!1},hover:{mode:"single"},legendCallback:function(t){var e,n,i,a=document.createElement("ul"),r=t.data,o=r.datasets,s=r.labels;if(a.setAttribute("class",t.id+"-legend"),o.length)for(e=0,n=o[0].data.length;e<n;++e)(i=a.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor=o[0].backgroundColor[e],s[e]&&i.appendChild(document.createTextNode(s[e]));return a.outerHTML},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map((function(n,i){var a=t.getDatasetMeta(0),r=a.controller.getStyle(i);return{text:n,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,lineWidth:r.borderWidth,hidden:isNaN(e.datasets[0].data[i])||a.data[i].hidden,index:i}})):[]}},onClick:function(t,e){var n,i,a,r=e.index,o=this.chart;for(n=0,i=(o.data.datasets||[]).length;n<i;++n)(a=o.getDatasetMeta(n)).data[r]&&(a.data[r].hidden=!a.data[r].hidden);o.update()}},cutoutPercentage:50,rotation:-Nt,circumference:zt,tooltips:{callbacks:{title:function(){return""},label:function(t,e){var n=e.labels[t.index],i=": "+e.datasets[t.datasetIndex].data[t.index];return H.isArray(n)?(n=n.slice())[0]+=i:n+=i,n}}}});var Bt=it.extend({dataElementType:kt.Arc,linkScales:H.noop,_dataElementOptions:["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"],getRingIndex:function(t){for(var e=0,n=0;n<t;++n)this.chart.isDatasetVisible(n)&&++e;return e},update:function(t){var e,n,i,a,r=this,o=r.chart,s=o.chartArea,l=o.options,u=1,d=1,h=0,c=0,f=r.getMeta(),g=f.data,p=l.cutoutPercentage/100||0,m=l.circumference,v=r._getRingWeight(r.index);if(m<zt){var b=l.rotation%zt,x=(b+=b>=Rt?-zt:b<-Rt?zt:0)+m,y=Math.cos(b),_=Math.sin(b),k=Math.cos(x),w=Math.sin(x),M=b<=0&&x>=0||x>=zt,S=b<=Nt&&x>=Nt||x>=zt+Nt,C=b<=-Nt&&x>=-Nt||x>=Rt+Nt,P=b===-Rt||x>=Rt?-1:Math.min(y,y*p,k,k*p),A=C?-1:Math.min(_,_*p,w,w*p),D=M?1:Math.max(y,y*p,k,k*p),T=S?1:Math.max(_,_*p,w,w*p);u=(D-P)/2,d=(T-A)/2,h=-(D+P)/2,c=-(T+A)/2}for(i=0,a=g.length;i<a;++i)g[i]._options=r._resolveDataElementOptions(g[i],i);for(o.borderWidth=r.getMaxBorderWidth(),e=(s.right-s.left-o.borderWidth)/u,n=(s.bottom-s.top-o.borderWidth)/d,o.outerRadius=Math.max(Math.min(e,n)/2,0),o.innerRadius=Math.max(o.outerRadius*p,0),o.radiusLength=(o.outerRadius-o.innerRadius)/(r._getVisibleDatasetWeightTotal()||1),o.offsetX=h*o.outerRadius,o.offsetY=c*o.outerRadius,f.total=r.calculateTotal(),r.outerRadius=o.outerRadius-o.radiusLength*r._getRingWeightOffset(r.index),r.innerRadius=Math.max(r.outerRadius-o.radiusLength*v,0),i=0,a=g.length;i<a;++i)r.updateElement(g[i],i,t)},updateElement:function(t,e,n){var i=this,a=i.chart,r=a.chartArea,o=a.options,s=o.animation,l=(r.left+r.right)/2,u=(r.top+r.bottom)/2,d=o.rotation,h=o.rotation,c=i.getDataset(),f=n&&s.animateRotate?0:t.hidden?0:i.calculateCircumference(c.data[e])*(o.circumference/zt),g=n&&s.animateScale?0:i.innerRadius,p=n&&s.animateScale?0:i.outerRadius,m=t._options||{};H.extend(t,{_datasetIndex:i.index,_index:e,_model:{backgroundColor:m.backgroundColor,borderColor:m.borderColor,borderWidth:m.borderWidth,borderAlign:m.borderAlign,x:l+a.offsetX,y:u+a.offsetY,startAngle:d,endAngle:h,circumference:f,outerRadius:p,innerRadius:g,label:H.valueAtIndexOrDefault(c.label,e,a.data.labels[e])}});var v=t._model;n&&s.animateRotate||(v.startAngle=0===e?o.rotation:i.getMeta().data[e-1]._model.endAngle,v.endAngle=v.startAngle+v.circumference),t.pivot()},calculateTotal:function(){var t,e=this.getDataset(),n=this.getMeta(),i=0;return H.each(n.data,(function(n,a){t=e.data[a],isNaN(t)||n.hidden||(i+=Math.abs(t))})),i},calculateCircumference:function(t){var e=this.getMeta().total;return e>0&&!isNaN(t)?zt*(Math.abs(t)/e):0},getMaxBorderWidth:function(t){var e,n,i,a,r,o,s,l,u=0,d=this.chart;if(!t)for(e=0,n=d.data.datasets.length;e<n;++e)if(d.isDatasetVisible(e)){t=(i=d.getDatasetMeta(e)).data,e!==this.index&&(r=i.controller);break}if(!t)return 0;for(e=0,n=t.length;e<n;++e)a=t[e],r?(r._configure(),o=r._resolveDataElementOptions(a,e)):o=a._options,"inner"!==o.borderAlign&&(s=o.borderWidth,u=(l=o.hoverBorderWidth)>(u=s>u?s:u)?l:u);return u},setHoverStyle:function(t){var e=t._model,n=t._options,i=H.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=Lt(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Lt(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Lt(n.hoverBorderWidth,n.borderWidth)},_getRingWeightOffset:function(t){for(var e=0,n=0;n<t;++n)this.chart.isDatasetVisible(n)&&(e+=this._getRingWeight(n));return e},_getRingWeight:function(t){return Math.max(Lt(this.chart.data.datasets[t].weight,1),0)},_getVisibleDatasetWeightTotal:function(){return this._getRingWeightOffset(this.chart.data.datasets.length)}});N._set("horizontalBar",{hover:{mode:"index",axis:"y"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{type:"category",position:"left",offset:!0,gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{mode:"index",axis:"y"}}),N._set("global",{datasets:{horizontalBar:{categoryPercentage:.8,barPercentage:.9}}});var Et=Tt.extend({_getValueScaleId:function(){return this.getMeta().xAxisID},_getIndexScaleId:function(){return this.getMeta().yAxisID}}),Wt=H.valueOrDefault,Vt=H.options.resolve,Ht=H.canvas._isPointInArea;function jt(t,e){var n=t&&t.options.ticks||{},i=n.reverse,a=void 0===n.min?e:0,r=void 0===n.max?e:0;return{start:i?r:a,end:i?a:r}}function qt(t,e,n){var i=n/2,a=jt(t,i),r=jt(e,i);return{top:r.end,right:a.end,bottom:r.start,left:a.start}}function Ut(t){var e,n,i,a;return H.isObject(t)?(e=t.top,n=t.right,i=t.bottom,a=t.left):e=n=i=a=t,{top:e,right:n,bottom:i,left:a}}N._set("line",{showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}});var Yt=it.extend({datasetElementType:kt.Line,dataElementType:kt.Point,_datasetElementOptions:["backgroundColor","borderCapStyle","borderColor","borderDash","borderDashOffset","borderJoinStyle","borderWidth","cubicInterpolationMode","fill"],_dataElementOptions:{backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},update:function(t){var e,n,i=this,a=i.getMeta(),r=a.dataset,o=a.data||[],s=i.chart.options,l=i._config,u=i._showLine=Wt(l.showLine,s.showLines);for(i._xScale=i.getScaleForId(a.xAxisID),i._yScale=i.getScaleForId(a.yAxisID),u&&(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),r._scale=i._yScale,r._datasetIndex=i.index,r._children=o,r._model=i._resolveDatasetElementOptions(r),r.pivot()),e=0,n=o.length;e<n;++e)i.updateElement(o[e],e,t);for(u&&0!==r._model.tension&&i.updateBezierControlPoints(),e=0,n=o.length;e<n;++e)o[e].pivot()},updateElement:function(t,e,n){var i,a,r=this,o=r.getMeta(),s=t.custom||{},l=r.getDataset(),u=r.index,d=l.data[e],h=r._xScale,c=r._yScale,f=o.dataset._model,g=r._resolveDataElementOptions(t,e);i=h.getPixelForValue("object"==typeof d?d:NaN,e,u),a=n?c.getBasePixel():r.calculatePointY(d,e,u),t._xScale=h,t._yScale=c,t._options=g,t._datasetIndex=u,t._index=e,t._model={x:i,y:a,skip:s.skip||isNaN(i)||isNaN(a),radius:g.radius,pointStyle:g.pointStyle,rotation:g.rotation,backgroundColor:g.backgroundColor,borderColor:g.borderColor,borderWidth:g.borderWidth,tension:Wt(s.tension,f?f.tension:0),steppedLine:!!f&&f.steppedLine,hitRadius:g.hitRadius}},_resolveDatasetElementOptions:function(t){var e=this,n=e._config,i=t.custom||{},a=e.chart.options,r=a.elements.line,o=it.prototype._resolveDatasetElementOptions.apply(e,arguments);return o.spanGaps=Wt(n.spanGaps,a.spanGaps),o.tension=Wt(n.lineTension,r.tension),o.steppedLine=Vt([i.steppedLine,n.steppedLine,r.stepped]),o.clip=Ut(Wt(n.clip,qt(e._xScale,e._yScale,o.borderWidth))),o},calculatePointY:function(t,e,n){var i,a,r,o,s,l,u,d=this.chart,h=this._yScale,c=0,f=0;if(h.options.stacked){for(s=+h.getRightValue(t),u=(l=d._getSortedVisibleDatasetMetas()).length,i=0;i<u&&(r=l[i]).index!==n;++i)a=d.data.datasets[r.index],"line"===r.type&&r.yAxisID===h.id&&((o=+h.getRightValue(a.data[e]))<0?f+=o||0:c+=o||0);return s<0?h.getPixelForValue(f+s):h.getPixelForValue(c+s)}return h.getPixelForValue(t)},updateBezierControlPoints:function(){var t,e,n,i,a=this.chart,r=this.getMeta(),o=r.dataset._model,s=a.chartArea,l=r.data||[];function u(t,e,n){return Math.max(Math.min(t,n),e)}if(o.spanGaps&&(l=l.filter((function(t){return!t._model.skip}))),"monotone"===o.cubicInterpolationMode)H.splineCurveMonotone(l);else for(t=0,e=l.length;t<e;++t)n=l[t]._model,i=H.splineCurve(H.previousItem(l,t)._model,n,H.nextItem(l,t)._model,o.tension),n.controlPointPreviousX=i.previous.x,n.controlPointPreviousY=i.previous.y,n.controlPointNextX=i.next.x,n.controlPointNextY=i.next.y;if(a.options.elements.line.capBezierPoints)for(t=0,e=l.length;t<e;++t)n=l[t]._model,Ht(n,s)&&(t>0&&Ht(l[t-1]._model,s)&&(n.controlPointPreviousX=u(n.controlPointPreviousX,s.left,s.right),n.controlPointPreviousY=u(n.controlPointPreviousY,s.top,s.bottom)),t<l.length-1&&Ht(l[t+1]._model,s)&&(n.controlPointNextX=u(n.controlPointNextX,s.left,s.right),n.controlPointNextY=u(n.controlPointNextY,s.top,s.bottom)))},draw:function(){var t,e=this.chart,n=this.getMeta(),i=n.data||[],a=e.chartArea,r=e.canvas,o=0,s=i.length;for(this._showLine&&(t=n.dataset._model.clip,H.canvas.clipArea(e.ctx,{left:!1===t.left?0:a.left-t.left,right:!1===t.right?r.width:a.right+t.right,top:!1===t.top?0:a.top-t.top,bottom:!1===t.bottom?r.height:a.bottom+t.bottom}),n.dataset.draw(),H.canvas.unclipArea(e.ctx));o<s;++o)i[o].draw(a)},setHoverStyle:function(t){var e=t._model,n=t._options,i=H.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Wt(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Wt(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Wt(n.hoverBorderWidth,n.borderWidth),e.radius=Wt(n.hoverRadius,n.radius)}}),Gt=H.options.resolve;N._set("polarArea",{scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,legendCallback:function(t){var e,n,i,a=document.createElement("ul"),r=t.data,o=r.datasets,s=r.labels;if(a.setAttribute("class",t.id+"-legend"),o.length)for(e=0,n=o[0].data.length;e<n;++e)(i=a.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor=o[0].backgroundColor[e],s[e]&&i.appendChild(document.createTextNode(s[e]));return a.outerHTML},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map((function(n,i){var a=t.getDatasetMeta(0),r=a.controller.getStyle(i);return{text:n,fillStyle:r.backgroundColor,strokeStyle:r.borderColor,lineWidth:r.borderWidth,hidden:isNaN(e.datasets[0].data[i])||a.data[i].hidden,index:i}})):[]}},onClick:function(t,e){var n,i,a,r=e.index,o=this.chart;for(n=0,i=(o.data.datasets||[]).length;n<i;++n)(a=o.getDatasetMeta(n)).data[r].hidden=!a.data[r].hidden;o.update()}},tooltips:{callbacks:{title:function(){return""},label:function(t,e){return e.labels[t.index]+": "+t.yLabel}}}});var Xt=it.extend({dataElementType:kt.Arc,linkScales:H.noop,_dataElementOptions:["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"],_getIndexScaleId:function(){return this.chart.scale.id},_getValueScaleId:function(){return this.chart.scale.id},update:function(t){var e,n,i,a=this,r=a.getDataset(),o=a.getMeta(),s=a.chart.options.startAngle||0,l=a._starts=[],u=a._angles=[],d=o.data;for(a._updateRadius(),o.count=a.countVisibleElements(),e=0,n=r.data.length;e<n;e++)l[e]=s,i=a._computeAngle(e),u[e]=i,s+=i;for(e=0,n=d.length;e<n;++e)d[e]._options=a._resolveDataElementOptions(d[e],e),a.updateElement(d[e],e,t)},_updateRadius:function(){var t=this,e=t.chart,n=e.chartArea,i=e.options,a=Math.min(n.right-n.left,n.bottom-n.top);e.outerRadius=Math.max(a/2,0),e.innerRadius=Math.max(i.cutoutPercentage?e.outerRadius/100*i.cutoutPercentage:1,0),e.radiusLength=(e.outerRadius-e.innerRadius)/e.getVisibleDatasetCount(),t.outerRadius=e.outerRadius-e.radiusLength*t.index,t.innerRadius=t.outerRadius-e.radiusLength},updateElement:function(t,e,n){var i=this,a=i.chart,r=i.getDataset(),o=a.options,s=o.animation,l=a.scale,u=a.data.labels,d=l.xCenter,h=l.yCenter,c=o.startAngle,f=t.hidden?0:l.getDistanceFromCenterForValue(r.data[e]),g=i._starts[e],p=g+(t.hidden?0:i._angles[e]),m=s.animateScale?0:l.getDistanceFromCenterForValue(r.data[e]),v=t._options||{};H.extend(t,{_datasetIndex:i.index,_index:e,_scale:l,_model:{backgroundColor:v.backgroundColor,borderColor:v.borderColor,borderWidth:v.borderWidth,borderAlign:v.borderAlign,x:d,y:h,innerRadius:0,outerRadius:n?m:f,startAngle:n&&s.animateRotate?c:g,endAngle:n&&s.animateRotate?c:p,label:H.valueAtIndexOrDefault(u,e,u[e])}}),t.pivot()},countVisibleElements:function(){var t=this.getDataset(),e=this.getMeta(),n=0;return H.each(e.data,(function(e,i){isNaN(t.data[i])||e.hidden||n++})),n},setHoverStyle:function(t){var e=t._model,n=t._options,i=H.getHoverColor,a=H.valueOrDefault;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=a(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=a(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=a(n.hoverBorderWidth,n.borderWidth)},_computeAngle:function(t){var e=this,n=this.getMeta().count,i=e.getDataset(),a=e.getMeta();if(isNaN(i.data[t])||a.data[t].hidden)return 0;var r={chart:e.chart,dataIndex:t,dataset:i,datasetIndex:e.index};return Gt([e.chart.options.elements.arc.angle,2*Math.PI/n],r,t)}});N._set("pie",H.clone(N.doughnut)),N._set("pie",{cutoutPercentage:0});var Kt=Bt,Zt=H.valueOrDefault;N._set("radar",{spanGaps:!1,scale:{type:"radialLinear"},elements:{line:{fill:"start",tension:0}}});var $t=it.extend({datasetElementType:kt.Line,dataElementType:kt.Point,linkScales:H.noop,_datasetElementOptions:["backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill"],_dataElementOptions:{backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},_getIndexScaleId:function(){return this.chart.scale.id},_getValueScaleId:function(){return this.chart.scale.id},update:function(t){var e,n,i=this,a=i.getMeta(),r=a.dataset,o=a.data||[],s=i.chart.scale,l=i._config;for(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),r._scale=s,r._datasetIndex=i.index,r._children=o,r._loop=!0,r._model=i._resolveDatasetElementOptions(r),r.pivot(),e=0,n=o.length;e<n;++e)i.updateElement(o[e],e,t);for(i.updateBezierControlPoints(),e=0,n=o.length;e<n;++e)o[e].pivot()},updateElement:function(t,e,n){var i=this,a=t.custom||{},r=i.getDataset(),o=i.chart.scale,s=o.getPointPositionForValue(e,r.data[e]),l=i._resolveDataElementOptions(t,e),u=i.getMeta().dataset._model,d=n?o.xCenter:s.x,h=n?o.yCenter:s.y;t._scale=o,t._options=l,t._datasetIndex=i.index,t._index=e,t._model={x:d,y:h,skip:a.skip||isNaN(d)||isNaN(h),radius:l.radius,pointStyle:l.pointStyle,rotation:l.rotation,backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,tension:Zt(a.tension,u?u.tension:0),hitRadius:l.hitRadius}},_resolveDatasetElementOptions:function(){var t=this,e=t._config,n=t.chart.options,i=it.prototype._resolveDatasetElementOptions.apply(t,arguments);return i.spanGaps=Zt(e.spanGaps,n.spanGaps),i.tension=Zt(e.lineTension,n.elements.line.tension),i},updateBezierControlPoints:function(){var t,e,n,i,a=this.getMeta(),r=this.chart.chartArea,o=a.data||[];function s(t,e,n){return Math.max(Math.min(t,n),e)}for(a.dataset._model.spanGaps&&(o=o.filter((function(t){return!t._model.skip}))),t=0,e=o.length;t<e;++t)n=o[t]._model,i=H.splineCurve(H.previousItem(o,t,!0)._model,n,H.nextItem(o,t,!0)._model,n.tension),n.controlPointPreviousX=s(i.previous.x,r.left,r.right),n.controlPointPreviousY=s(i.previous.y,r.top,r.bottom),n.controlPointNextX=s(i.next.x,r.left,r.right),n.controlPointNextY=s(i.next.y,r.top,r.bottom)},setHoverStyle:function(t){var e=t._model,n=t._options,i=H.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Zt(n.hoverBackgroundColor,i(n.backgroundColor)),e.borderColor=Zt(n.hoverBorderColor,i(n.borderColor)),e.borderWidth=Zt(n.hoverBorderWidth,n.borderWidth),e.radius=Zt(n.hoverRadius,n.radius)}});N._set("scatter",{hover:{mode:"single"},scales:{xAxes:[{id:"x-axis-1",type:"linear",position:"bottom"}],yAxes:[{id:"y-axis-1",type:"linear",position:"left"}]},tooltips:{callbacks:{title:function(){return""},label:function(t){return"("+t.xLabel+", "+t.yLabel+")"}}}}),N._set("global",{datasets:{scatter:{showLine:!1}}});var Jt={bar:Tt,bubble:Ot,doughnut:Bt,horizontalBar:Et,line:Yt,polarArea:Xt,pie:Kt,radar:$t,scatter:Yt};function Qt(t,e){return t.native?{x:t.x,y:t.y}:H.getRelativePosition(t,e)}function te(t,e){var n,i,a,r,o,s,l=t._getSortedVisibleDatasetMetas();for(i=0,r=l.length;i<r;++i)for(a=0,o=(n=l[i].data).length;a<o;++a)(s=n[a])._view.skip||e(s)}function ee(t,e){var n=[];return te(t,(function(t){t.inRange(e.x,e.y)&&n.push(t)})),n}function ne(t,e,n,i){var a=Number.POSITIVE_INFINITY,r=[];return te(t,(function(t){if(!n||t.inRange(e.x,e.y)){var o=t.getCenterPoint(),s=i(e,o);s<a?(r=[t],a=s):s===a&&r.push(t)}})),r}function ie(t){var e=-1!==t.indexOf("x"),n=-1!==t.indexOf("y");return function(t,i){var a=e?Math.abs(t.x-i.x):0,r=n?Math.abs(t.y-i.y):0;return Math.sqrt(Math.pow(a,2)+Math.pow(r,2))}}function ae(t,e,n){var i=Qt(e,t);n.axis=n.axis||"x";var a=ie(n.axis),r=n.intersect?ee(t,i):ne(t,i,!1,a),o=[];return r.length?(t._getSortedVisibleDatasetMetas().forEach((function(t){var e=t.data[r[0]._index];e&&!e._view.skip&&o.push(e)})),o):[]}var re={modes:{single:function(t,e){var n=Qt(e,t),i=[];return te(t,(function(t){if(t.inRange(n.x,n.y))return i.push(t),i})),i.slice(0,1)},label:ae,index:ae,dataset:function(t,e,n){var i=Qt(e,t);n.axis=n.axis||"xy";var a=ie(n.axis),r=n.intersect?ee(t,i):ne(t,i,!1,a);return r.length>0&&(r=t.getDatasetMeta(r[0]._datasetIndex).data),r},"x-axis":function(t,e){return ae(t,e,{intersect:!1})},point:function(t,e){return ee(t,Qt(e,t))},nearest:function(t,e,n){var i=Qt(e,t);n.axis=n.axis||"xy";var a=ie(n.axis);return ne(t,i,n.intersect,a)},x:function(t,e,n){var i=Qt(e,t),a=[],r=!1;return te(t,(function(t){t.inXRange(i.x)&&a.push(t),t.inRange(i.x,i.y)&&(r=!0)})),n.intersect&&!r&&(a=[]),a},y:function(t,e,n){var i=Qt(e,t),a=[],r=!1;return te(t,(function(t){t.inYRange(i.y)&&a.push(t),t.inRange(i.x,i.y)&&(r=!0)})),n.intersect&&!r&&(a=[]),a}}},oe=H.extend;function se(t,e){return H.where(t,(function(t){return t.pos===e}))}function le(t,e){return t.sort((function(t,n){var i=e?n:t,a=e?t:n;return i.weight===a.weight?i.index-a.index:i.weight-a.weight}))}function ue(t,e,n,i){return Math.max(t[n],e[n])+Math.max(t[i],e[i])}function de(t,e,n){var i,a,r=n.box,o=t.maxPadding;if(n.size&&(t[n.pos]-=n.size),n.size=n.horizontal?r.height:r.width,t[n.pos]+=n.size,r.getPadding){var s=r.getPadding();o.top=Math.max(o.top,s.top),o.left=Math.max(o.left,s.left),o.bottom=Math.max(o.bottom,s.bottom),o.right=Math.max(o.right,s.right)}if(i=e.outerWidth-ue(o,t,"left","right"),a=e.outerHeight-ue(o,t,"top","bottom"),i!==t.w||a!==t.h){t.w=i,t.h=a;var l=n.horizontal?[i,t.w]:[a,t.h];return!(l[0]===l[1]||isNaN(l[0])&&isNaN(l[1]))}}function he(t,e){var n=e.maxPadding;function i(t){var i={left:0,top:0,right:0,bottom:0};return t.forEach((function(t){i[t]=Math.max(e[t],n[t])})),i}return i(t?["left","right"]:["top","bottom"])}function ce(t,e,n){var i,a,r,o,s,l,u=[];for(i=0,a=t.length;i<a;++i)(o=(r=t[i]).box).update(r.width||e.w,r.height||e.h,he(r.horizontal,e)),de(e,n,r)&&(l=!0,u.length&&(s=!0)),o.fullWidth||u.push(r);return s&&ce(u,e,n)||l}function fe(t,e,n){var i,a,r,o,s=n.padding,l=e.x,u=e.y;for(i=0,a=t.length;i<a;++i)o=(r=t[i]).box,r.horizontal?(o.left=o.fullWidth?s.left:e.left,o.right=o.fullWidth?n.outerWidth-s.right:e.left+e.w,o.top=u,o.bottom=u+o.height,o.width=o.right-o.left,u=o.bottom):(o.left=l,o.right=l+o.width,o.top=e.top,o.bottom=e.top+e.h,o.height=o.bottom-o.top,l=o.right);e.x=l,e.y=u}N._set("global",{layout:{padding:{top:0,right:0,bottom:0,left:0}}});var ge,pe={defaults:{},addBox:function(t,e){t.boxes||(t.boxes=[]),e.fullWidth=e.fullWidth||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw:function(){e.draw.apply(e,arguments)}}]},t.boxes.push(e)},removeBox:function(t,e){var n=t.boxes?t.boxes.indexOf(e):-1;-1!==n&&t.boxes.splice(n,1)},configure:function(t,e,n){for(var i,a=["fullWidth","position","weight"],r=a.length,o=0;o<r;++o)i=a[o],n.hasOwnProperty(i)&&(e[i]=n[i])},update:function(t,e,n){if(t){var i=t.options.layout||{},a=H.options.toPadding(i.padding),r=e-a.width,o=n-a.height,s=function(t){var e=function(t){var e,n,i,a=[];for(e=0,n=(t||[]).length;e<n;++e)i=t[e],a.push({index:e,box:i,pos:i.position,horizontal:i.isHorizontal(),weight:i.weight});return a}(t),n=le(se(e,"left"),!0),i=le(se(e,"right")),a=le(se(e,"top"),!0),r=le(se(e,"bottom"));return{leftAndTop:n.concat(a),rightAndBottom:i.concat(r),chartArea:se(e,"chartArea"),vertical:n.concat(i),horizontal:a.concat(r)}}(t.boxes),l=s.vertical,u=s.horizontal,d=Object.freeze({outerWidth:e,outerHeight:n,padding:a,availableWidth:r,vBoxMaxWidth:r/2/l.length,hBoxMaxHeight:o/2}),h=oe({maxPadding:oe({},a),w:r,h:o,x:a.left,y:a.top},a);!function(t,e){var n,i,a;for(n=0,i=t.length;n<i;++n)(a=t[n]).width=a.horizontal?a.box.fullWidth&&e.availableWidth:e.vBoxMaxWidth,a.height=a.horizontal&&e.hBoxMaxHeight}(l.concat(u),d),ce(l,h,d),ce(u,h,d)&&ce(l,h,d),function(t){var e=t.maxPadding;function n(n){var i=Math.max(e[n]-t[n],0);return t[n]+=i,i}t.y+=n("top"),t.x+=n("left"),n("right"),n("bottom")}(h),fe(s.leftAndTop,h,d),h.x+=h.w,h.y+=h.h,fe(s.rightAndBottom,h,d),t.chartArea={left:h.left,top:h.top,right:h.left+h.w,bottom:h.top+h.h},H.each(s.chartArea,(function(e){var n=e.box;oe(n,t.chartArea),n.update(h.w,h.h)}))}}},me=(ge=Object.freeze({__proto__:null,default:"@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}"}))&&ge.default||ge,ve="$chartjs",be="chartjs-size-monitor",xe="chartjs-render-monitor",ye="chartjs-render-animation",_e=["animationstart","webkitAnimationStart"],ke={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};function we(t,e){var n=H.getStyle(t,e),i=n&&n.match(/^(\d+)(\.\d+)?px$/);return i?Number(i[1]):void 0}var Me=!!function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("e",null,e)}catch(t){}return t}()&&{passive:!0};function Se(t,e,n){t.addEventListener(e,n,Me)}function Ce(t,e,n){t.removeEventListener(e,n,Me)}function Pe(t,e,n,i,a){return{type:t,chart:e,native:a||null,x:void 0!==n?n:null,y:void 0!==i?i:null}}function Ae(t){var e=document.createElement("div");return e.className=t||"",e}function De(t,e,n){var i,a,r,o,s=t[ve]||(t[ve]={}),l=s.resizer=function(t){var e=Ae(be),n=Ae(be+"-expand"),i=Ae(be+"-shrink");n.appendChild(Ae()),i.appendChild(Ae()),e.appendChild(n),e.appendChild(i),e._reset=function(){n.scrollLeft=1e6,n.scrollTop=1e6,i.scrollLeft=1e6,i.scrollTop=1e6};var a=function(){e._reset(),t()};return Se(n,"scroll",a.bind(n,"expand")),Se(i,"scroll",a.bind(i,"shrink")),e}((i=function(){if(s.resizer){var i=n.options.maintainAspectRatio&&t.parentNode,a=i?i.clientWidth:0;e(Pe("resize",n)),i&&i.clientWidth<a&&n.canvas&&e(Pe("resize",n))}},r=!1,o=[],function(){o=Array.prototype.slice.call(arguments),a=a||this,r||(r=!0,H.requestAnimFrame.call(window,(function(){r=!1,i.apply(a,o)})))}));!function(t,e){var n=t[ve]||(t[ve]={}),i=n.renderProxy=function(t){t.animationName===ye&&e()};H.each(_e,(function(e){Se(t,e,i)})),n.reflow=!!t.offsetParent,t.classList.add(xe)}(t,(function(){if(s.resizer){var e=t.parentNode;e&&e!==l.parentNode&&e.insertBefore(l,e.firstChild),l._reset()}}))}function Te(t){var e=t[ve]||{},n=e.resizer;delete e.resizer,function(t){var e=t[ve]||{},n=e.renderProxy;n&&(H.each(_e,(function(e){Ce(t,e,n)})),delete e.renderProxy),t.classList.remove(xe)}(t),n&&n.parentNode&&n.parentNode.removeChild(n)}var Ie={disableCSSInjection:!1,_enabled:"undefined"!=typeof window&&"undefined"!=typeof document,_ensureLoaded:function(t){if(!this.disableCSSInjection){var e=t.getRootNode?t.getRootNode():document;!function(t,e){var n=t[ve]||(t[ve]={});if(!n.containsStyles){n.containsStyles=!0,e="/* Chart.js */\n"+e;var i=document.createElement("style");i.setAttribute("type","text/css"),i.appendChild(document.createTextNode(e)),t.appendChild(i)}}(e.host?e:document.head,me)}},acquireContext:function(t,e){"string"==typeof t?t=document.getElementById(t):t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas);var n=t&&t.getContext&&t.getContext("2d");return n&&n.canvas===t?(this._ensureLoaded(t),function(t,e){var n=t.style,i=t.getAttribute("height"),a=t.getAttribute("width");if(t[ve]={initial:{height:i,width:a,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",null===a||""===a){var r=we(t,"width");void 0!==r&&(t.width=r)}if(null===i||""===i)if(""===t.style.height)t.height=t.width/(e.options.aspectRatio||2);else{var o=we(t,"height");void 0!==r&&(t.height=o)}}(t,e),n):null},releaseContext:function(t){var e=t.canvas;if(e[ve]){var n=e[ve].initial;["height","width"].forEach((function(t){var i=n[t];H.isNullOrUndef(i)?e.removeAttribute(t):e.setAttribute(t,i)})),H.each(n.style||{},(function(t,n){e.style[n]=t})),e.width=e.width,delete e[ve]}},addEventListener:function(t,e,n){var i=t.canvas;if("resize"!==e){var a=n[ve]||(n[ve]={});Se(i,e,(a.proxies||(a.proxies={}))[t.id+"_"+e]=function(e){n(function(t,e){var n=ke[t.type]||t.type,i=H.getRelativePosition(t,e);return Pe(n,e,i.x,i.y,t)}(e,t))})}else De(i,n,t)},removeEventListener:function(t,e,n){var i=t.canvas;if("resize"!==e){var a=((n[ve]||{}).proxies||{})[t.id+"_"+e];a&&Ce(i,e,a)}else Te(i)}};H.addEvent=Se,H.removeEvent=Ce;var Fe=Ie._enabled?Ie:{acquireContext:function(t){return t&&t.canvas&&(t=t.canvas),t&&t.getContext("2d")||null}},Oe=H.extend({initialize:function(){},acquireContext:function(){},releaseContext:function(){},addEventListener:function(){},removeEventListener:function(){}},Fe);N._set("global",{plugins:{}});var Le={_plugins:[],_cacheId:0,register:function(t){var e=this._plugins;[].concat(t).forEach((function(t){-1===e.indexOf(t)&&e.push(t)})),this._cacheId++},unregister:function(t){var e=this._plugins;[].concat(t).forEach((function(t){var n=e.indexOf(t);-1!==n&&e.splice(n,1)})),this._cacheId++},clear:function(){this._plugins=[],this._cacheId++},count:function(){return this._plugins.length},getAll:function(){return this._plugins},notify:function(t,e,n){var i,a,r,o,s,l=this.descriptors(t),u=l.length;for(i=0;i<u;++i)if("function"==typeof(s=(r=(a=l[i]).plugin)[e])&&((o=[t].concat(n||[])).push(a.options),!1===s.apply(r,o)))return!1;return!0},descriptors:function(t){var e=t.$plugins||(t.$plugins={});if(e.id===this._cacheId)return e.descriptors;var n=[],i=[],a=t&&t.config||{},r=a.options&&a.options.plugins||{};return this._plugins.concat(a.plugins||[]).forEach((function(t){if(-1===n.indexOf(t)){var e=t.id,a=r[e];!1!==a&&(!0===a&&(a=H.clone(N.global.plugins[e])),n.push(t),i.push({plugin:t,options:a||{}}))}})),e.descriptors=i,e.id=this._cacheId,i},_invalidate:function(t){delete t.$plugins}},Re={constructors:{},defaults:{},registerScaleType:function(t,e,n){this.constructors[t]=e,this.defaults[t]=H.clone(n)},getScaleConstructor:function(t){return this.constructors.hasOwnProperty(t)?this.constructors[t]:void 0},getScaleDefaults:function(t){return this.defaults.hasOwnProperty(t)?H.merge(Object.create(null),[N.scale,this.defaults[t]]):{}},updateScaleDefaults:function(t,e){this.defaults.hasOwnProperty(t)&&(this.defaults[t]=H.extend(this.defaults[t],e))},addScalesToLayout:function(t){H.each(t.scales,(function(e){e.fullWidth=e.options.fullWidth,e.position=e.options.position,e.weight=e.options.weight,pe.addBox(t,e)}))}},ze=H.valueOrDefault,Ne=H.rtl.getRtlAdapter;N._set("global",{tooltips:{enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{beforeTitle:H.noop,title:function(t,e){var n="",i=e.labels,a=i?i.length:0;if(t.length>0){var r=t[0];r.label?n=r.label:r.xLabel?n=r.xLabel:a>0&&r.index<a&&(n=i[r.index])}return n},afterTitle:H.noop,beforeBody:H.noop,beforeLabel:H.noop,label:function(t,e){var n=e.datasets[t.datasetIndex].label||"";return n&&(n+=": "),H.isNullOrUndef(t.value)?n+=t.yLabel:n+=t.value,n},labelColor:function(t,e){var n=e.getDatasetMeta(t.datasetIndex).data[t.index]._view;return{borderColor:n.borderColor,backgroundColor:n.backgroundColor}},labelTextColor:function(){return this._options.bodyFontColor},afterLabel:H.noop,afterBody:H.noop,beforeFooter:H.noop,footer:H.noop,afterFooter:H.noop}}});var Be={average:function(t){if(!t.length)return!1;var e,n,i=0,a=0,r=0;for(e=0,n=t.length;e<n;++e){var o=t[e];if(o&&o.hasValue()){var s=o.tooltipPosition();i+=s.x,a+=s.y,++r}}return{x:i/r,y:a/r}},nearest:function(t,e){var n,i,a,r=e.x,o=e.y,s=Number.POSITIVE_INFINITY;for(n=0,i=t.length;n<i;++n){var l=t[n];if(l&&l.hasValue()){var u=l.getCenterPoint(),d=H.distanceBetweenPoints(e,u);d<s&&(s=d,a=l)}}if(a){var h=a.tooltipPosition();r=h.x,o=h.y}return{x:r,y:o}}};function Ee(t,e){return e&&(H.isArray(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function We(t){return("string"==typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function Ve(t){var e=N.global;return{xPadding:t.xPadding,yPadding:t.yPadding,xAlign:t.xAlign,yAlign:t.yAlign,rtl:t.rtl,textDirection:t.textDirection,bodyFontColor:t.bodyFontColor,_bodyFontFamily:ze(t.bodyFontFamily,e.defaultFontFamily),_bodyFontStyle:ze(t.bodyFontStyle,e.defaultFontStyle),_bodyAlign:t.bodyAlign,bodyFontSize:ze(t.bodyFontSize,e.defaultFontSize),bodySpacing:t.bodySpacing,titleFontColor:t.titleFontColor,_titleFontFamily:ze(t.titleFontFamily,e.defaultFontFamily),_titleFontStyle:ze(t.titleFontStyle,e.defaultFontStyle),titleFontSize:ze(t.titleFontSize,e.defaultFontSize),_titleAlign:t.titleAlign,titleSpacing:t.titleSpacing,titleMarginBottom:t.titleMarginBottom,footerFontColor:t.footerFontColor,_footerFontFamily:ze(t.footerFontFamily,e.defaultFontFamily),_footerFontStyle:ze(t.footerFontStyle,e.defaultFontStyle),footerFontSize:ze(t.footerFontSize,e.defaultFontSize),_footerAlign:t.footerAlign,footerSpacing:t.footerSpacing,footerMarginTop:t.footerMarginTop,caretSize:t.caretSize,cornerRadius:t.cornerRadius,backgroundColor:t.backgroundColor,opacity:0,legendColorBackground:t.multiKeyBackground,displayColors:t.displayColors,borderColor:t.borderColor,borderWidth:t.borderWidth}}function He(t,e){return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-t.xPadding:t.x+t.xPadding}function je(t){return Ee([],We(t))}var qe=K.extend({initialize:function(){this._model=Ve(this._options),this._lastActive=[]},getTitle:function(){var t=this,e=t._options,n=e.callbacks,i=n.beforeTitle.apply(t,arguments),a=n.title.apply(t,arguments),r=n.afterTitle.apply(t,arguments),o=[];return o=Ee(o,We(i)),o=Ee(o,We(a)),o=Ee(o,We(r))},getBeforeBody:function(){return je(this._options.callbacks.beforeBody.apply(this,arguments))},getBody:function(t,e){var n=this,i=n._options.callbacks,a=[];return H.each(t,(function(t){var r={before:[],lines:[],after:[]};Ee(r.before,We(i.beforeLabel.call(n,t,e))),Ee(r.lines,i.label.call(n,t,e)),Ee(r.after,We(i.afterLabel.call(n,t,e))),a.push(r)})),a},getAfterBody:function(){return je(this._options.callbacks.afterBody.apply(this,arguments))},getFooter:function(){var t=this,e=t._options.callbacks,n=e.beforeFooter.apply(t,arguments),i=e.footer.apply(t,arguments),a=e.afterFooter.apply(t,arguments),r=[];return r=Ee(r,We(n)),r=Ee(r,We(i)),r=Ee(r,We(a))},update:function(t){var e,n,i,a,r,o,s,l,u,d,h=this,c=h._options,f=h._model,g=h._model=Ve(c),p=h._active,m=h._data,v={xAlign:f.xAlign,yAlign:f.yAlign},b={x:f.x,y:f.y},x={width:f.width,height:f.height},y={x:f.caretX,y:f.caretY};if(p.length){g.opacity=1;var _=[],k=[];y=Be[c.position].call(h,p,h._eventPosition);var w=[];for(e=0,n=p.length;e<n;++e)w.push((i=p[e],a=void 0,r=void 0,o=void 0,s=void 0,l=void 0,u=void 0,d=void 0,a=i._xScale,r=i._yScale||i._scale,o=i._index,s=i._datasetIndex,l=i._chart.getDatasetMeta(s).controller,u=l._getIndexScale(),d=l._getValueScale(),{xLabel:a?a.getLabelForIndex(o,s):"",yLabel:r?r.getLabelForIndex(o,s):"",label:u?""+u.getLabelForIndex(o,s):"",value:d?""+d.getLabelForIndex(o,s):"",index:o,datasetIndex:s,x:i._model.x,y:i._model.y}));c.filter&&(w=w.filter((function(t){return c.filter(t,m)}))),c.itemSort&&(w=w.sort((function(t,e){return c.itemSort(t,e,m)}))),H.each(w,(function(t){_.push(c.callbacks.labelColor.call(h,t,h._chart)),k.push(c.callbacks.labelTextColor.call(h,t,h._chart))})),g.title=h.getTitle(w,m),g.beforeBody=h.getBeforeBody(w,m),g.body=h.getBody(w,m),g.afterBody=h.getAfterBody(w,m),g.footer=h.getFooter(w,m),g.x=y.x,g.y=y.y,g.caretPadding=c.caretPadding,g.labelColors=_,g.labelTextColors=k,g.dataPoints=w,x=function(t,e){var n=t._chart.ctx,i=2*e.yPadding,a=0,r=e.body,o=r.reduce((function(t,e){return t+e.before.length+e.lines.length+e.after.length}),0);o+=e.beforeBody.length+e.afterBody.length;var s=e.title.length,l=e.footer.length,u=e.titleFontSize,d=e.bodyFontSize,h=e.footerFontSize;i+=s*u,i+=s?(s-1)*e.titleSpacing:0,i+=s?e.titleMarginBottom:0,i+=o*d,i+=o?(o-1)*e.bodySpacing:0,i+=l?e.footerMarginTop:0,i+=l*h,i+=l?(l-1)*e.footerSpacing:0;var c=0,f=function(t){a=Math.max(a,n.measureText(t).width+c)};return n.font=H.fontString(u,e._titleFontStyle,e._titleFontFamily),H.each(e.title,f),n.font=H.fontString(d,e._bodyFontStyle,e._bodyFontFamily),H.each(e.beforeBody.concat(e.afterBody),f),c=e.displayColors?d+2:0,H.each(r,(function(t){H.each(t.before,f),H.each(t.lines,f),H.each(t.after,f)})),c=0,n.font=H.fontString(h,e._footerFontStyle,e._footerFontFamily),H.each(e.footer,f),{width:a+=2*e.xPadding,height:i}}(this,g),b=function(t,e,n,i){var a=t.x,r=t.y,o=t.caretSize,s=t.caretPadding,l=t.cornerRadius,u=n.xAlign,d=n.yAlign,h=o+s,c=l+s;return"right"===u?a-=e.width:"center"===u&&((a-=e.width/2)+e.width>i.width&&(a=i.width-e.width),a<0&&(a=0)),"top"===d?r+=h:r-="bottom"===d?e.height+h:e.height/2,"center"===d?"left"===u?a+=h:"right"===u&&(a-=h):"left"===u?a-=c:"right"===u&&(a+=c),{x:a,y:r}}(g,x,v=function(t,e){var n,i,a,r,o,s=t._model,l=t._chart,u=t._chart.chartArea,d="center",h="center";s.y<e.height?h="top":s.y>l.height-e.height&&(h="bottom");var c=(u.left+u.right)/2,f=(u.top+u.bottom)/2;"center"===h?(n=function(t){return t<=c},i=function(t){return t>c}):(n=function(t){return t<=e.width/2},i=function(t){return t>=l.width-e.width/2}),a=function(t){return t+e.width+s.caretSize+s.caretPadding>l.width},r=function(t){return t-e.width-s.caretSize-s.caretPadding<0},o=function(t){return t<=f?"top":"bottom"},n(s.x)?(d="left",a(s.x)&&(d="center",h=o(s.y))):i(s.x)&&(d="right",r(s.x)&&(d="center",h=o(s.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:d,yAlign:g.yAlign?g.yAlign:h}}(this,x),h._chart)}else g.opacity=0;return g.xAlign=v.xAlign,g.yAlign=v.yAlign,g.x=b.x,g.y=b.y,g.width=x.width,g.height=x.height,g.caretX=y.x,g.caretY=y.y,h._model=g,t&&c.custom&&c.custom.call(h,g),h},drawCaret:function(t,e){var n=this._chart.ctx,i=this._view,a=this.getCaretPosition(t,e,i);n.lineTo(a.x1,a.y1),n.lineTo(a.x2,a.y2),n.lineTo(a.x3,a.y3)},getCaretPosition:function(t,e,n){var i,a,r,o,s,l,u=n.caretSize,d=n.cornerRadius,h=n.xAlign,c=n.yAlign,f=t.x,g=t.y,p=e.width,m=e.height;if("center"===c)s=g+m/2,"left"===h?(a=(i=f)-u,r=i,o=s+u,l=s-u):(a=(i=f+p)+u,r=i,o=s-u,l=s+u);else if("left"===h?(i=(a=f+d+u)-u,r=a+u):"right"===h?(i=(a=f+p-d-u)-u,r=a+u):(i=(a=n.caretX)-u,r=a+u),"top"===c)s=(o=g)-u,l=o;else{s=(o=g+m)+u,l=o;var v=r;r=i,i=v}return{x1:i,x2:a,x3:r,y1:o,y2:s,y3:l}},drawTitle:function(t,e,n){var i,a,r,o=e.title,s=o.length;if(s){var l=Ne(e.rtl,e.x,e.width);for(t.x=He(e,e._titleAlign),n.textAlign=l.textAlign(e._titleAlign),n.textBaseline="middle",i=e.titleFontSize,a=e.titleSpacing,n.fillStyle=e.titleFontColor,n.font=H.fontString(i,e._titleFontStyle,e._titleFontFamily),r=0;r<s;++r)n.fillText(o[r],l.x(t.x),t.y+i/2),t.y+=i+a,r+1===s&&(t.y+=e.titleMarginBottom-a)}},drawBody:function(t,e,n){var i,a,r,o,s,l,u,d,h=e.bodyFontSize,c=e.bodySpacing,f=e._bodyAlign,g=e.body,p=e.displayColors,m=0,v=p?He(e,"left"):0,b=Ne(e.rtl,e.x,e.width),x=function(e){n.fillText(e,b.x(t.x+m),t.y+h/2),t.y+=h+c},y=b.textAlign(f);for(n.textAlign=f,n.textBaseline="middle",n.font=H.fontString(h,e._bodyFontStyle,e._bodyFontFamily),t.x=He(e,y),n.fillStyle=e.bodyFontColor,H.each(e.beforeBody,x),m=p&&"right"!==y?"center"===f?h/2+1:h+2:0,s=0,u=g.length;s<u;++s){for(i=g[s],a=e.labelTextColors[s],r=e.labelColors[s],n.fillStyle=a,H.each(i.before,x),l=0,d=(o=i.lines).length;l<d;++l){if(p){var _=b.x(v);n.fillStyle=e.legendColorBackground,n.fillRect(b.leftForLtr(_,h),t.y,h,h),n.lineWidth=1,n.strokeStyle=r.borderColor,n.strokeRect(b.leftForLtr(_,h),t.y,h,h),n.fillStyle=r.backgroundColor,n.fillRect(b.leftForLtr(b.xPlus(_,1),h-2),t.y+1,h-2,h-2),n.fillStyle=a}x(o[l])}H.each(i.after,x)}m=0,H.each(e.afterBody,x),t.y-=c},drawFooter:function(t,e,n){var i,a,r=e.footer,o=r.length;if(o){var s=Ne(e.rtl,e.x,e.width);for(t.x=He(e,e._footerAlign),t.y+=e.footerMarginTop,n.textAlign=s.textAlign(e._footerAlign),n.textBaseline="middle",i=e.footerFontSize,n.fillStyle=e.footerFontColor,n.font=H.fontString(i,e._footerFontStyle,e._footerFontFamily),a=0;a<o;++a)n.fillText(r[a],s.x(t.x),t.y+i/2),t.y+=i+e.footerSpacing}},drawBackground:function(t,e,n,i){n.fillStyle=e.backgroundColor,n.strokeStyle=e.borderColor,n.lineWidth=e.borderWidth;var a=e.xAlign,r=e.yAlign,o=t.x,s=t.y,l=i.width,u=i.height,d=e.cornerRadius;n.beginPath(),n.moveTo(o+d,s),"top"===r&&this.drawCaret(t,i),n.lineTo(o+l-d,s),n.quadraticCurveTo(o+l,s,o+l,s+d),"center"===r&&"right"===a&&this.drawCaret(t,i),n.lineTo(o+l,s+u-d),n.quadraticCurveTo(o+l,s+u,o+l-d,s+u),"bottom"===r&&this.drawCaret(t,i),n.lineTo(o+d,s+u),n.quadraticCurveTo(o,s+u,o,s+u-d),"center"===r&&"left"===a&&this.drawCaret(t,i),n.lineTo(o,s+d),n.quadraticCurveTo(o,s,o+d,s),n.closePath(),n.fill(),e.borderWidth>0&&n.stroke()},draw:function(){var t=this._chart.ctx,e=this._view;if(0!==e.opacity){var n={width:e.width,height:e.height},i={x:e.x,y:e.y},a=Math.abs(e.opacity<.001)?0:e.opacity,r=e.title.length||e.beforeBody.length||e.body.length||e.afterBody.length||e.footer.length;this._options.enabled&&r&&(t.save(),t.globalAlpha=a,this.drawBackground(i,e,t,n),i.y+=e.yPadding,H.rtl.overrideTextDirection(t,e.textDirection),this.drawTitle(i,e,t),this.drawBody(i,e,t),this.drawFooter(i,e,t),H.rtl.restoreTextDirection(t,e.textDirection),t.restore())}},handleEvent:function(t){var e,n=this,i=n._options;return n._lastActive=n._lastActive||[],"mouseout"===t.type?n._active=[]:(n._active=n._chart.getElementsAtEventForMode(t,i.mode,i),i.reverse&&n._active.reverse()),(e=!H.arrayEquals(n._active,n._lastActive))&&(n._lastActive=n._active,(i.enabled||i.custom)&&(n._eventPosition={x:t.x,y:t.y},n.update(!0),n.pivot())),e}}),Ue=Be,Ye=qe;Ye.positioners=Ue;var Ge=H.valueOrDefault;function Xe(){return H.merge(Object.create(null),[].slice.call(arguments),{merger:function(t,e,n,i){if("xAxes"===t||"yAxes"===t){var a,r,o,s=n[t].length;for(e[t]||(e[t]=[]),a=0;a<s;++a)o=n[t][a],r=Ge(o.type,"xAxes"===t?"category":"linear"),a>=e[t].length&&e[t].push({}),!e[t][a].type||o.type&&o.type!==e[t][a].type?H.merge(e[t][a],[Re.getScaleDefaults(r),o]):H.merge(e[t][a],o)}else H._merger(t,e,n,i)}})}function Ke(){return H.merge(Object.create(null),[].slice.call(arguments),{merger:function(t,e,n,i){var a=e[t]||Object.create(null),r=n[t];"scales"===t?e[t]=Xe(a,r):"scale"===t?e[t]=H.merge(a,[Re.getScaleDefaults(r.type),r]):H._merger(t,e,n,i)}})}function Ze(t){var e=t.options;H.each(t.scales,(function(e){pe.removeBox(t,e)})),e=Ke(N.global,N[t.config.type],e),t.options=t.config.options=e,t.ensureScalesHaveIDs(),t.buildOrUpdateScales(),t.tooltip._options=e.tooltips,t.tooltip.initialize()}function $e(t,e,n){var i,a=function(t){return t.id===i};do{i=e+n++}while(H.findIndex(t,a)>=0);return i}function Je(t){return"top"===t||"bottom"===t}function Qe(t,e){return function(n,i){return n[t]===i[t]?n[e]-i[e]:n[t]-i[t]}}N._set("global",{elements:{},events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,maintainAspectRatio:!0,responsive:!0,responsiveAnimationDuration:0});var tn=function(t,e){return this.construct(t,e),this};H.extend(tn.prototype,{construct:function(t,e){var n=this;e=function(t){var e=(t=t||Object.create(null)).data=t.data||{};return e.datasets=e.datasets||[],e.labels=e.labels||[],t.options=Ke(N.global,N[t.type],t.options||{}),t}(e);var i=Oe.acquireContext(t,e),a=i&&i.canvas,r=a&&a.height,o=a&&a.width;n.id=H.uid(),n.ctx=i,n.canvas=a,n.config=e,n.width=o,n.height=r,n.aspectRatio=r?o/r:null,n.options=e.options,n._bufferedRender=!1,n._layers=[],n.chart=n,n.controller=n,tn.instances[n.id]=n,Object.defineProperty(n,"data",{get:function(){return n.config.data},set:function(t){n.config.data=t}}),i&&a?(n.initialize(),n.update()):console.error("Failed to create chart: can't acquire context from the given item")},initialize:function(){var t=this;return Le.notify(t,"beforeInit"),H.retinaScale(t,t.options.devicePixelRatio),t.bindEvents(),t.options.responsive&&t.resize(!0),t.initToolTip(),Le.notify(t,"afterInit"),t},clear:function(){return H.canvas.clear(this),this},stop:function(){return J.cancelAnimation(this),this},resize:function(t){var e=this,n=e.options,i=e.canvas,a=n.maintainAspectRatio&&e.aspectRatio||null,r=Math.max(0,Math.floor(H.getMaximumWidth(i))),o=Math.max(0,Math.floor(a?r/a:H.getMaximumHeight(i)));if((e.width!==r||e.height!==o)&&(i.width=e.width=r,i.height=e.height=o,i.style.width=r+"px",i.style.height=o+"px",H.retinaScale(e,n.devicePixelRatio),!t)){var s={width:r,height:o};Le.notify(e,"resize",[s]),n.onResize&&n.onResize(e,s),e.stop(),e.update({duration:n.responsiveAnimationDuration})}},ensureScalesHaveIDs:function(){var t=this.options,e=t.scales||{},n=t.scale;H.each(e.xAxes,(function(t,n){t.id||(t.id=$e(e.xAxes,"x-axis-",n))})),H.each(e.yAxes,(function(t,n){t.id||(t.id=$e(e.yAxes,"y-axis-",n))})),n&&(n.id=n.id||"scale")},buildOrUpdateScales:function(){var t=this,e=t.options,n=t.scales||{},i=[],a=Object.keys(n).reduce((function(t,e){return t[e]=!1,t}),{});e.scales&&(i=i.concat((e.scales.xAxes||[]).map((function(t){return{options:t,dtype:"category",dposition:"bottom"}})),(e.scales.yAxes||[]).map((function(t){return{options:t,dtype:"linear",dposition:"left"}})))),e.scale&&i.push({options:e.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),H.each(i,(function(e){var i=e.options,r=i.id,o=Ge(i.type,e.dtype);Je(i.position)!==Je(e.dposition)&&(i.position=e.dposition),a[r]=!0;var s=null;if(r in n&&n[r].type===o)(s=n[r]).options=i,s.ctx=t.ctx,s.chart=t;else{var l=Re.getScaleConstructor(o);if(!l)return;s=new l({id:r,type:o,options:i,ctx:t.ctx,chart:t}),n[s.id]=s}s.mergeTicksOptions(),e.isDefault&&(t.scale=s)})),H.each(a,(function(t,e){t||delete n[e]})),t.scales=n,Re.addScalesToLayout(this)},buildOrUpdateControllers:function(){var t,e,n=this,i=[],a=n.data.datasets;for(t=0,e=a.length;t<e;t++){var r=a[t],o=n.getDatasetMeta(t),s=r.type||n.config.type;if(o.type&&o.type!==s&&(n.destroyDatasetMeta(t),o=n.getDatasetMeta(t)),o.type=s,o.order=r.order||0,o.index=t,o.controller)o.controller.updateIndex(t),o.controller.linkScales();else{var l=Jt[o.type];if(void 0===l)throw new Error('"'+o.type+'" is not a chart type.');o.controller=new l(n,t),i.push(o.controller)}}return i},resetElements:function(){var t=this;H.each(t.data.datasets,(function(e,n){t.getDatasetMeta(n).controller.reset()}),t)},reset:function(){this.resetElements(),this.tooltip.initialize()},update:function(t){var e,n,i=this;if(t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]}),Ze(i),Le._invalidate(i),!1!==Le.notify(i,"beforeUpdate")){i.tooltip._data=i.data;var a=i.buildOrUpdateControllers();for(e=0,n=i.data.datasets.length;e<n;e++)i.getDatasetMeta(e).controller.buildOrUpdateElements();i.updateLayout(),i.options.animation&&i.options.animation.duration&&H.each(a,(function(t){t.reset()})),i.updateDatasets(),i.tooltip.initialize(),i.lastActive=[],Le.notify(i,"afterUpdate"),i._layers.sort(Qe("z","_idx")),i._bufferedRender?i._bufferedRequest={duration:t.duration,easing:t.easing,lazy:t.lazy}:i.render(t)}},updateLayout:function(){var t=this;!1!==Le.notify(t,"beforeLayout")&&(pe.update(this,this.width,this.height),t._layers=[],H.each(t.boxes,(function(e){e._configure&&e._configure(),t._layers.push.apply(t._layers,e._layers())}),t),t._layers.forEach((function(t,e){t._idx=e})),Le.notify(t,"afterScaleUpdate"),Le.notify(t,"afterLayout"))},updateDatasets:function(){if(!1!==Le.notify(this,"beforeDatasetsUpdate")){for(var t=0,e=this.data.datasets.length;t<e;++t)this.updateDataset(t);Le.notify(this,"afterDatasetsUpdate")}},updateDataset:function(t){var e=this.getDatasetMeta(t),n={meta:e,index:t};!1!==Le.notify(this,"beforeDatasetUpdate",[n])&&(e.controller._update(),Le.notify(this,"afterDatasetUpdate",[n]))},render:function(t){var e=this;t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]});var n=e.options.animation,i=Ge(t.duration,n&&n.duration),a=t.lazy;if(!1!==Le.notify(e,"beforeRender")){var r=function(t){Le.notify(e,"afterRender"),H.callback(n&&n.onComplete,[t],e)};if(n&&i){var o=new $({numSteps:i/16.66,easing:t.easing||n.easing,render:function(t,e){var n=H.easing.effects[e.easing],i=e.currentStep,a=i/e.numSteps;t.draw(n(a),a,i)},onAnimationProgress:n.onProgress,onAnimationComplete:r});J.addAnimation(e,o,i,a)}else e.draw(),r(new $({numSteps:0,chart:e}));return e}},draw:function(t){var e,n,i=this;if(i.clear(),H.isNullOrUndef(t)&&(t=1),i.transition(t),!(i.width<=0||i.height<=0)&&!1!==Le.notify(i,"beforeDraw",[t])){for(n=i._layers,e=0;e<n.length&&n[e].z<=0;++e)n[e].draw(i.chartArea);for(i.drawDatasets(t);e<n.length;++e)n[e].draw(i.chartArea);i._drawTooltip(t),Le.notify(i,"afterDraw",[t])}},transition:function(t){for(var e=0,n=(this.data.datasets||[]).length;e<n;++e)this.isDatasetVisible(e)&&this.getDatasetMeta(e).controller.transition(t);this.tooltip.transition(t)},_getSortedDatasetMetas:function(t){var e,n,i=[];for(e=0,n=(this.data.datasets||[]).length;e<n;++e)t&&!this.isDatasetVisible(e)||i.push(this.getDatasetMeta(e));return i.sort(Qe("order","index")),i},_getSortedVisibleDatasetMetas:function(){return this._getSortedDatasetMetas(!0)},drawDatasets:function(t){var e,n;if(!1!==Le.notify(this,"beforeDatasetsDraw",[t])){for(n=(e=this._getSortedVisibleDatasetMetas()).length-1;n>=0;--n)this.drawDataset(e[n],t);Le.notify(this,"afterDatasetsDraw",[t])}},drawDataset:function(t,e){var n={meta:t,index:t.index,easingValue:e};!1!==Le.notify(this,"beforeDatasetDraw",[n])&&(t.controller.draw(e),Le.notify(this,"afterDatasetDraw",[n]))},_drawTooltip:function(t){var e=this.tooltip,n={tooltip:e,easingValue:t};!1!==Le.notify(this,"beforeTooltipDraw",[n])&&(e.draw(),Le.notify(this,"afterTooltipDraw",[n]))},getElementAtEvent:function(t){return re.modes.single(this,t)},getElementsAtEvent:function(t){return re.modes.label(this,t,{intersect:!0})},getElementsAtXAxis:function(t){return re.modes["x-axis"](this,t,{intersect:!0})},getElementsAtEventForMode:function(t,e,n){var i=re.modes[e];return"function"==typeof i?i(this,t,n):[]},getDatasetAtEvent:function(t){return re.modes.dataset(this,t,{intersect:!0})},getDatasetMeta:function(t){var e=this.data.datasets[t];e._meta||(e._meta={});var n=e._meta[this.id];return n||(n=e._meta[this.id]={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e.order||0,index:t}),n},getVisibleDatasetCount:function(){for(var t=0,e=0,n=this.data.datasets.length;e<n;++e)this.isDatasetVisible(e)&&t++;return t},isDatasetVisible:function(t){var e=this.getDatasetMeta(t);return"boolean"==typeof e.hidden?!e.hidden:!this.data.datasets[t].hidden},generateLegend:function(){return this.options.legendCallback(this)},destroyDatasetMeta:function(t){var e=this.id,n=this.data.datasets[t],i=n._meta&&n._meta[e];i&&(i.controller.destroy(),delete n._meta[e])},destroy:function(){var t,e,n=this,i=n.canvas;for(n.stop(),t=0,e=n.data.datasets.length;t<e;++t)n.destroyDatasetMeta(t);i&&(n.unbindEvents(),H.canvas.clear(n),Oe.releaseContext(n.ctx),n.canvas=null,n.ctx=null),Le.notify(n,"destroy"),delete tn.instances[n.id]},toBase64Image:function(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function(){var t=this;t.tooltip=new Ye({_chart:t,_chartInstance:t,_data:t.data,_options:t.options.tooltips},t)},bindEvents:function(){var t=this,e=t._listeners={},n=function(){t.eventHandler.apply(t,arguments)};H.each(t.options.events,(function(i){Oe.addEventListener(t,i,n),e[i]=n})),t.options.responsive&&(n=function(){t.resize()},Oe.addEventListener(t,"resize",n),e.resize=n)},unbindEvents:function(){var t=this,e=t._listeners;e&&(delete t._listeners,H.each(e,(function(e,n){Oe.removeEventListener(t,n,e)})))},updateHoverStyle:function(t,e,n){var i,a,r,o=n?"set":"remove";for(a=0,r=t.length;a<r;++a)(i=t[a])&&this.getDatasetMeta(i._datasetIndex).controller[o+"HoverStyle"](i);"dataset"===e&&this.getDatasetMeta(t[0]._datasetIndex).controller["_"+o+"DatasetHoverStyle"]()},eventHandler:function(t){var e=this,n=e.tooltip;if(!1!==Le.notify(e,"beforeEvent",[t])){e._bufferedRender=!0,e._bufferedRequest=null;var i=e.handleEvent(t);n&&(i=n._start?n.handleEvent(t):i|n.handleEvent(t)),Le.notify(e,"afterEvent",[t]);var a=e._bufferedRequest;return a?e.render(a):i&&!e.animating&&(e.stop(),e.render({duration:e.options.hover.animationDuration,lazy:!0})),e._bufferedRender=!1,e._bufferedRequest=null,e}},handleEvent:function(t){var e,n=this,i=n.options||{},a=i.hover;return n.lastActive=n.lastActive||[],"mouseout"===t.type?n.active=[]:n.active=n.getElementsAtEventForMode(t,a.mode,a),H.callback(i.onHover||i.hover.onHover,[t.native,n.active],n),"mouseup"!==t.type&&"click"!==t.type||i.onClick&&i.onClick.call(n,t.native,n.active),n.lastActive.length&&n.updateHoverStyle(n.lastActive,a.mode,!1),n.active.length&&a.mode&&n.updateHoverStyle(n.active,a.mode,!0),e=!H.arrayEquals(n.active,n.lastActive),n.lastActive=n.active,e}}),tn.instances={};var en=tn;tn.Controller=tn,tn.types={},H.configMerge=Ke,H.scaleMerge=Xe;function nn(){throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")}function an(t){this.options=t||{}}H.extend(an.prototype,{formats:nn,parse:nn,format:nn,add:nn,diff:nn,startOf:nn,endOf:nn,_create:function(t){return t}}),an.override=function(t){H.extend(an.prototype,t)};var rn={_date:an},on={formatters:{values:function(t){return H.isArray(t)?t:""+t},linear:function(t,e,n){var i=n.length>3?n[2]-n[1]:n[1]-n[0];Math.abs(i)>1&&t!==Math.floor(t)&&(i=t-Math.floor(t));var a=H.log10(Math.abs(i)),r="";if(0!==t)if(Math.max(Math.abs(n[0]),Math.abs(n[n.length-1]))<1e-4){var o=H.log10(Math.abs(t)),s=Math.floor(o)-Math.floor(a);s=Math.max(Math.min(s,20),0),r=t.toExponential(s)}else{var l=-1*Math.floor(a);l=Math.max(Math.min(l,20),0),r=t.toFixed(l)}else r="0";return r},logarithmic:function(t,e,n){var i=t/Math.pow(10,Math.floor(H.log10(t)));return 0===t?"0":1===i||2===i||5===i||0===e||e===n.length-1?t.toExponential():""}}},sn=H.isArray,ln=H.isNullOrUndef,un=H.valueOrDefault,dn=H.valueAtIndexOrDefault;function hn(t,e,n){var i,a=t.getTicks().length,r=Math.min(e,a-1),o=t.getPixelForTick(r),s=t._startPixel,l=t._endPixel;if(!(n&&(i=1===a?Math.max(o-s,l-o):0===e?(t.getPixelForTick(1)-o)/2:(o-t.getPixelForTick(r-1))/2,(o+=r<e?i:-i)<s-1e-6||o>l+1e-6)))return o}function cn(t,e,n,i){var a,r,o,s,l,u,d,h,c,f,g,p,m,v=n.length,b=[],x=[],y=[],_=0,k=0;for(a=0;a<v;++a){if(s=n[a].label,l=n[a].major?e.major:e.minor,t.font=u=l.string,d=i[u]=i[u]||{data:{},gc:[]},h=l.lineHeight,c=f=0,ln(s)||sn(s)){if(sn(s))for(r=0,o=s.length;r<o;++r)g=s[r],ln(g)||sn(g)||(c=H.measureText(t,d.data,d.gc,c,g),f+=h)}else c=H.measureText(t,d.data,d.gc,c,s),f=h;b.push(c),x.push(f),y.push(h/2),_=Math.max(c,_),k=Math.max(f,k)}function w(t){return{width:b[t]||0,height:x[t]||0,offset:y[t]||0}}return function(t,e){H.each(t,(function(t){var n,i=t.gc,a=i.length/2;if(a>e){for(n=0;n<a;++n)delete t.data[i[n]];i.splice(0,a)}}))}(i,v),p=b.indexOf(_),m=x.indexOf(k),{first:w(0),last:w(v-1),widest:w(p),highest:w(m)}}function fn(t){return t.drawTicks?t.tickMarkLength:0}function gn(t){var e,n;return t.display?(e=H.options._parseFont(t),n=H.options.toPadding(t.padding),e.lineHeight+n.height):0}function pn(t,e){return H.extend(H.options._parseFont({fontFamily:un(e.fontFamily,t.fontFamily),fontSize:un(e.fontSize,t.fontSize),fontStyle:un(e.fontStyle,t.fontStyle),lineHeight:un(e.lineHeight,t.lineHeight)}),{color:H.options.resolve([e.fontColor,t.fontColor,N.global.defaultFontColor])})}function mn(t){var e=pn(t,t.minor);return{minor:e,major:t.major.enabled?pn(t,t.major):e}}function vn(t){var e,n,i,a=[];for(n=0,i=t.length;n<i;++n)void 0!==(e=t[n])._index&&a.push(e);return a}function bn(t,e,n,i){var a,r,o,s,l=un(n,0),u=Math.min(un(i,t.length),t.length),d=0;for(e=Math.ceil(e),i&&(e=(a=i-n)/Math.floor(a/e)),s=l;s<0;)d++,s=Math.round(l+d*e);for(r=Math.max(l,0);r<u;r++)o=t[r],r===s?(o._index=r,d++,s=Math.round(l+d*e)):delete o.label}N._set("scale",{display:!0,position:"left",offset:!1,gridLines:{display:!0,color:"rgba(0,0,0,0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},scaleLabel:{display:!1,labelString:"",padding:{top:4,bottom:4}},ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,callback:on.formatters.values,minor:{},major:{}}});var xn=K.extend({zeroLineIndex:0,getPadding:function(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}},getTicks:function(){return this._ticks},_getLabels:function(){var t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]},mergeTicksOptions:function(){},beforeUpdate:function(){H.callback(this.options.beforeUpdate,[this])},update:function(t,e,n){var i,a,r,o,s,l=this,u=l.options.ticks,d=u.sampleSize;if(l.beforeUpdate(),l.maxWidth=t,l.maxHeight=e,l.margins=H.extend({left:0,right:0,top:0,bottom:0},n),l._ticks=null,l.ticks=null,l._labelSizes=null,l._maxLabelLines=0,l.longestLabelWidth=0,l.longestTextCache=l.longestTextCache||{},l._gridLineItems=null,l._labelItems=null,l.beforeSetDimensions(),l.setDimensions(),l.afterSetDimensions(),l.beforeDataLimits(),l.determineDataLimits(),l.afterDataLimits(),l.beforeBuildTicks(),o=l.buildTicks()||[],(!(o=l.afterBuildTicks(o)||o)||!o.length)&&l.ticks)for(o=[],i=0,a=l.ticks.length;i<a;++i)o.push({value:l.ticks[i],major:!1});return l._ticks=o,s=d<o.length,r=l._convertTicksToLabels(s?function(t,e){for(var n=[],i=t.length/e,a=0,r=t.length;a<r;a+=i)n.push(t[Math.floor(a)]);return n}(o,d):o),l._configure(),l.beforeCalculateTickRotation(),l.calculateTickRotation(),l.afterCalculateTickRotation(),l.beforeFit(),l.fit(),l.afterFit(),l._ticksToDraw=u.display&&(u.autoSkip||"auto"===u.source)?l._autoSkip(o):o,s&&(r=l._convertTicksToLabels(l._ticksToDraw)),l.ticks=r,l.afterUpdate(),l.minSize},_configure:function(){var t,e,n=this,i=n.options.ticks.reverse;n.isHorizontal()?(t=n.left,e=n.right):(t=n.top,e=n.bottom,i=!i),n._startPixel=t,n._endPixel=e,n._reversePixels=i,n._length=e-t},afterUpdate:function(){H.callback(this.options.afterUpdate,[this])},beforeSetDimensions:function(){H.callback(this.options.beforeSetDimensions,[this])},setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0},afterSetDimensions:function(){H.callback(this.options.afterSetDimensions,[this])},beforeDataLimits:function(){H.callback(this.options.beforeDataLimits,[this])},determineDataLimits:H.noop,afterDataLimits:function(){H.callback(this.options.afterDataLimits,[this])},beforeBuildTicks:function(){H.callback(this.options.beforeBuildTicks,[this])},buildTicks:H.noop,afterBuildTicks:function(t){var e=this;return sn(t)&&t.length?H.callback(e.options.afterBuildTicks,[e,t]):(e.ticks=H.callback(e.options.afterBuildTicks,[e,e.ticks])||e.ticks,t)},beforeTickToLabelConversion:function(){H.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function(){var t=this.options.ticks;this.ticks=this.ticks.map(t.userCallback||t.callback,this)},afterTickToLabelConversion:function(){H.callback(this.options.afterTickToLabelConversion,[this])},beforeCalculateTickRotation:function(){H.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function(){var t,e,n,i,a,r,o,s=this,l=s.options,u=l.ticks,d=s.getTicks().length,h=u.minRotation||0,c=u.maxRotation,f=h;!s._isVisible()||!u.display||h>=c||d<=1||!s.isHorizontal()?s.labelRotation=h:(e=(t=s._getLabelSizes()).widest.width,n=t.highest.height-t.highest.offset,i=Math.min(s.maxWidth,s.chart.width-e),e+6>(a=l.offset?s.maxWidth/d:i/(d-1))&&(a=i/(d-(l.offset?.5:1)),r=s.maxHeight-fn(l.gridLines)-u.padding-gn(l.scaleLabel),o=Math.sqrt(e*e+n*n),f=H.toDegrees(Math.min(Math.asin(Math.min((t.highest.height+6)/a,1)),Math.asin(Math.min(r/o,1))-Math.asin(n/o))),f=Math.max(h,Math.min(c,f))),s.labelRotation=f)},afterCalculateTickRotation:function(){H.callback(this.options.afterCalculateTickRotation,[this])},beforeFit:function(){H.callback(this.options.beforeFit,[this])},fit:function(){var t=this,e=t.minSize={width:0,height:0},n=t.chart,i=t.options,a=i.ticks,r=i.scaleLabel,o=i.gridLines,s=t._isVisible(),l="bottom"===i.position,u=t.isHorizontal();if(u?e.width=t.maxWidth:s&&(e.width=fn(o)+gn(r)),u?s&&(e.height=fn(o)+gn(r)):e.height=t.maxHeight,a.display&&s){var d=mn(a),h=t._getLabelSizes(),c=h.first,f=h.last,g=h.widest,p=h.highest,m=.4*d.minor.lineHeight,v=a.padding;if(u){var b=0!==t.labelRotation,x=H.toRadians(t.labelRotation),y=Math.cos(x),_=Math.sin(x),k=_*g.width+y*(p.height-(b?p.offset:0))+(b?0:m);e.height=Math.min(t.maxHeight,e.height+k+v);var w,M,S=t.getPixelForTick(0)-t.left,C=t.right-t.getPixelForTick(t.getTicks().length-1);b?(w=l?y*c.width+_*c.offset:_*(c.height-c.offset),M=l?_*(f.height-f.offset):y*f.width+_*f.offset):(w=c.width/2,M=f.width/2),t.paddingLeft=Math.max((w-S)*t.width/(t.width-S),0)+3,t.paddingRight=Math.max((M-C)*t.width/(t.width-C),0)+3}else{var P=a.mirror?0:g.width+v+m;e.width=Math.min(t.maxWidth,e.width+P),t.paddingTop=c.height/2,t.paddingBottom=f.height/2}}t.handleMargins(),u?(t.width=t._length=n.width-t.margins.left-t.margins.right,t.height=e.height):(t.width=e.width,t.height=t._length=n.height-t.margins.top-t.margins.bottom)},handleMargins:function(){var t=this;t.margins&&(t.margins.left=Math.max(t.paddingLeft,t.margins.left),t.margins.top=Math.max(t.paddingTop,t.margins.top),t.margins.right=Math.max(t.paddingRight,t.margins.right),t.margins.bottom=Math.max(t.paddingBottom,t.margins.bottom))},afterFit:function(){H.callback(this.options.afterFit,[this])},isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},isFullWidth:function(){return this.options.fullWidth},getRightValue:function(t){if(ln(t))return NaN;if(("number"==typeof t||t instanceof Number)&&!isFinite(t))return NaN;if(t)if(this.isHorizontal()){if(void 0!==t.x)return this.getRightValue(t.x)}else if(void 0!==t.y)return this.getRightValue(t.y);return t},_convertTicksToLabels:function(t){var e,n,i,a=this;for(a.ticks=t.map((function(t){return t.value})),a.beforeTickToLabelConversion(),e=a.convertTicksToLabels(t)||a.ticks,a.afterTickToLabelConversion(),n=0,i=t.length;n<i;++n)t[n].label=e[n];return e},_getLabelSizes:function(){var t=this,e=t._labelSizes;return e||(t._labelSizes=e=cn(t.ctx,mn(t.options.ticks),t.getTicks(),t.longestTextCache),t.longestLabelWidth=e.widest.width),e},_parseValue:function(t){var e,n,i,a;return sn(t)?(e=+this.getRightValue(t[0]),n=+this.getRightValue(t[1]),i=Math.min(e,n),a=Math.max(e,n)):(e=void 0,n=t=+this.getRightValue(t),i=t,a=t),{min:i,max:a,start:e,end:n}},_getScaleLabel:function(t){var e=this._parseValue(t);return void 0!==e.start?"["+e.start+", "+e.end+"]":+this.getRightValue(t)},getLabelForIndex:H.noop,getPixelForValue:H.noop,getValueForPixel:H.noop,getPixelForTick:function(t){var e=this.options.offset,n=this._ticks.length,i=1/Math.max(n-(e?0:1),1);return t<0||t>n-1?null:this.getPixelForDecimal(t*i+(e?i/2:0))},getPixelForDecimal:function(t){return this._reversePixels&&(t=1-t),this._startPixel+t*this._length},getDecimalForPixel:function(t){var e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e},getBasePixel:function(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function(){var t=this.min,e=this.max;return this.beginAtZero?0:t<0&&e<0?e:t>0&&e>0?t:0},_autoSkip:function(t){var e,n,i,a,r=this.options.ticks,o=this._length,s=r.maxTicksLimit||o/this._tickSize()+1,l=r.major.enabled?function(t){var e,n,i=[];for(e=0,n=t.length;e<n;e++)t[e].major&&i.push(e);return i}(t):[],u=l.length,d=l[0],h=l[u-1];if(u>s)return function(t,e,n){var i,a,r=0,o=e[0];for(n=Math.ceil(n),i=0;i<t.length;i++)a=t[i],i===o?(a._index=i,o=e[++r*n]):delete a.label}(t,l,u/s),vn(t);if(i=function(t,e,n,i){var a,r,o,s,l=function(t){var e,n,i=t.length;if(i<2)return!1;for(n=t[0],e=1;e<i;++e)if(t[e]-t[e-1]!==n)return!1;return n}(t),u=(e.length-1)/i;if(!l)return Math.max(u,1);for(o=0,s=(a=H.math._factorize(l)).length-1;o<s;o++)if((r=a[o])>u)return r;return Math.max(u,1)}(l,t,0,s),u>0){for(e=0,n=u-1;e<n;e++)bn(t,i,l[e],l[e+1]);return a=u>1?(h-d)/(u-1):null,bn(t,i,H.isNullOrUndef(a)?0:d-a,d),bn(t,i,h,H.isNullOrUndef(a)?t.length:h+a),vn(t)}return bn(t,i),vn(t)},_tickSize:function(){var t=this.options.ticks,e=H.toRadians(this.labelRotation),n=Math.abs(Math.cos(e)),i=Math.abs(Math.sin(e)),a=this._getLabelSizes(),r=t.autoSkipPadding||0,o=a?a.widest.width+r:0,s=a?a.highest.height+r:0;return this.isHorizontal()?s*n>o*i?o/n:s/i:s*i<o*n?s/n:o/i},_isVisible:function(){var t,e,n,i=this.chart,a=this.options.display;if("auto"!==a)return!!a;for(t=0,e=i.data.datasets.length;t<e;++t)if(i.isDatasetVisible(t)&&((n=i.getDatasetMeta(t)).xAxisID===this.id||n.yAxisID===this.id))return!0;return!1},_computeGridLineItems:function(t){var e,n,i,a,r,o,s,l,u,d,h,c,f,g,p,m,v,b=this,x=b.chart,y=b.options,_=y.gridLines,k=y.position,w=_.offsetGridLines,M=b.isHorizontal(),S=b._ticksToDraw,C=S.length+(w?1:0),P=fn(_),A=[],D=_.drawBorder?dn(_.lineWidth,0,0):0,T=D/2,I=H._alignPixel,F=function(t){return I(x,t,D)};for("top"===k?(e=F(b.bottom),s=b.bottom-P,u=e-T,h=F(t.top)+T,f=t.bottom):"bottom"===k?(e=F(b.top),h=t.top,f=F(t.bottom)-T,s=e+T,u=b.top+P):"left"===k?(e=F(b.right),o=b.right-P,l=e-T,d=F(t.left)+T,c=t.right):(e=F(b.left),d=t.left,c=F(t.right)-T,o=e+T,l=b.left+P),n=0;n<C;++n)i=S[n]||{},ln(i.label)&&n<S.length||(n===b.zeroLineIndex&&y.offset===w?(g=_.zeroLineWidth,p=_.zeroLineColor,m=_.zeroLineBorderDash||[],v=_.zeroLineBorderDashOffset||0):(g=dn(_.lineWidth,n,1),p=dn(_.color,n,"rgba(0,0,0,0.1)"),m=_.borderDash||[],v=_.borderDashOffset||0),void 0!==(a=hn(b,i._index||n,w))&&(r=I(x,a,g),M?o=l=d=c=r:s=u=h=f=r,A.push({tx1:o,ty1:s,tx2:l,ty2:u,x1:d,y1:h,x2:c,y2:f,width:g,color:p,borderDash:m,borderDashOffset:v})));return A.ticksLength=C,A.borderValue=e,A},_computeLabelItems:function(){var t,e,n,i,a,r,o,s,l,u,d,h,c=this,f=c.options,g=f.ticks,p=f.position,m=g.mirror,v=c.isHorizontal(),b=c._ticksToDraw,x=mn(g),y=g.padding,_=fn(f.gridLines),k=-H.toRadians(c.labelRotation),w=[];for("top"===p?(r=c.bottom-_-y,o=k?"left":"center"):"bottom"===p?(r=c.top+_+y,o=k?"right":"center"):"left"===p?(a=c.right-(m?0:_)-y,o=m?"left":"right"):(a=c.left+(m?0:_)+y,o=m?"right":"left"),t=0,e=b.length;t<e;++t)i=(n=b[t]).label,ln(i)||(s=c.getPixelForTick(n._index||t)+g.labelOffset,u=(l=n.major?x.major:x.minor).lineHeight,d=sn(i)?i.length:1,v?(a=s,h="top"===p?((k?1:.5)-d)*u:(k?0:.5)*u):(r=s,h=(1-d)*u/2),w.push({x:a,y:r,rotation:k,label:i,font:l,textOffset:h,textAlign:o}));return w},_drawGrid:function(t){var e=this,n=e.options.gridLines;if(n.display){var i,a,r,o,s,l=e.ctx,u=e.chart,d=H._alignPixel,h=n.drawBorder?dn(n.lineWidth,0,0):0,c=e._gridLineItems||(e._gridLineItems=e._computeGridLineItems(t));for(r=0,o=c.length;r<o;++r)i=(s=c[r]).width,a=s.color,i&&a&&(l.save(),l.lineWidth=i,l.strokeStyle=a,l.setLineDash&&(l.setLineDash(s.borderDash),l.lineDashOffset=s.borderDashOffset),l.beginPath(),n.drawTicks&&(l.moveTo(s.tx1,s.ty1),l.lineTo(s.tx2,s.ty2)),n.drawOnChartArea&&(l.moveTo(s.x1,s.y1),l.lineTo(s.x2,s.y2)),l.stroke(),l.restore());if(h){var f,g,p,m,v=h,b=dn(n.lineWidth,c.ticksLength-1,1),x=c.borderValue;e.isHorizontal()?(f=d(u,e.left,v)-v/2,g=d(u,e.right,b)+b/2,p=m=x):(p=d(u,e.top,v)-v/2,m=d(u,e.bottom,b)+b/2,f=g=x),l.lineWidth=h,l.strokeStyle=dn(n.color,0),l.beginPath(),l.moveTo(f,p),l.lineTo(g,m),l.stroke()}}},_drawLabels:function(){var t=this;if(t.options.ticks.display){var e,n,i,a,r,o,s,l,u=t.ctx,d=t._labelItems||(t._labelItems=t._computeLabelItems());for(e=0,i=d.length;e<i;++e){if(o=(r=d[e]).font,u.save(),u.translate(r.x,r.y),u.rotate(r.rotation),u.font=o.string,u.fillStyle=o.color,u.textBaseline="middle",u.textAlign=r.textAlign,s=r.label,l=r.textOffset,sn(s))for(n=0,a=s.length;n<a;++n)u.fillText(""+s[n],0,l),l+=o.lineHeight;else u.fillText(s,0,l);u.restore()}}},_drawTitle:function(){var t=this,e=t.ctx,n=t.options,i=n.scaleLabel;if(i.display){var a,r,o=un(i.fontColor,N.global.defaultFontColor),s=H.options._parseFont(i),l=H.options.toPadding(i.padding),u=s.lineHeight/2,d=n.position,h=0;if(t.isHorizontal())a=t.left+t.width/2,r="bottom"===d?t.bottom-u-l.bottom:t.top+u+l.top;else{var c="left"===d;a=c?t.left+u+l.top:t.right-u-l.top,r=t.top+t.height/2,h=c?-.5*Math.PI:.5*Math.PI}e.save(),e.translate(a,r),e.rotate(h),e.textAlign="center",e.textBaseline="middle",e.fillStyle=o,e.font=s.string,e.fillText(i.labelString,0,0),e.restore()}},draw:function(t){this._isVisible()&&(this._drawGrid(t),this._drawTitle(),this._drawLabels())},_layers:function(){var t=this,e=t.options,n=e.ticks&&e.ticks.z||0,i=e.gridLines&&e.gridLines.z||0;return t._isVisible()&&n!==i&&t.draw===t._draw?[{z:i,draw:function(){t._drawGrid.apply(t,arguments),t._drawTitle.apply(t,arguments)}},{z:n,draw:function(){t._drawLabels.apply(t,arguments)}}]:[{z:n,draw:function(){t.draw.apply(t,arguments)}}]},_getMatchingVisibleMetas:function(t){var e=this,n=e.isHorizontal();return e.chart._getSortedVisibleDatasetMetas().filter((function(i){return(!t||i.type===t)&&(n?i.xAxisID===e.id:i.yAxisID===e.id)}))}});xn.prototype._draw=xn.prototype.draw;var yn=xn,_n=H.isNullOrUndef,kn=yn.extend({determineDataLimits:function(){var t,e=this,n=e._getLabels(),i=e.options.ticks,a=i.min,r=i.max,o=0,s=n.length-1;void 0!==a&&(t=n.indexOf(a))>=0&&(o=t),void 0!==r&&(t=n.indexOf(r))>=0&&(s=t),e.minIndex=o,e.maxIndex=s,e.min=n[o],e.max=n[s]},buildTicks:function(){var t=this._getLabels(),e=this.minIndex,n=this.maxIndex;this.ticks=0===e&&n===t.length-1?t:t.slice(e,n+1)},getLabelForIndex:function(t,e){var n=this.chart;return n.getDatasetMeta(e).controller._getValueScaleId()===this.id?this.getRightValue(n.data.datasets[e].data[t]):this._getLabels()[t]},_configure:function(){var t=this,e=t.options.offset,n=t.ticks;yn.prototype._configure.call(t),t.isHorizontal()||(t._reversePixels=!t._reversePixels),n&&(t._startValue=t.minIndex-(e?.5:0),t._valueRange=Math.max(n.length-(e?0:1),1))},getPixelForValue:function(t,e,n){var i,a,r,o=this;return _n(e)||_n(n)||(t=o.chart.data.datasets[n].data[e]),_n(t)||(i=o.isHorizontal()?t.x:t.y),(void 0!==i||void 0!==t&&isNaN(e))&&(a=o._getLabels(),t=H.valueOrDefault(i,t),e=-1!==(r=a.indexOf(t))?r:e,isNaN(e)&&(e=t)),o.getPixelForDecimal((e-o._startValue)/o._valueRange)},getPixelForTick:function(t){var e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t],t+this.minIndex)},getValueForPixel:function(t){var e=Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange);return Math.min(Math.max(e,0),this.ticks.length-1)},getBasePixel:function(){return this.bottom}}),wn={position:"bottom"};kn._defaults=wn;var Mn=H.noop,Sn=H.isNullOrUndef;var Cn=yn.extend({getRightValue:function(t){return"string"==typeof t?+t:yn.prototype.getRightValue.call(this,t)},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;if(e.beginAtZero){var n=H.sign(t.min),i=H.sign(t.max);n<0&&i<0?t.max=0:n>0&&i>0&&(t.min=0)}var a=void 0!==e.min||void 0!==e.suggestedMin,r=void 0!==e.max||void 0!==e.suggestedMax;void 0!==e.min?t.min=e.min:void 0!==e.suggestedMin&&(null===t.min?t.min=e.suggestedMin:t.min=Math.min(t.min,e.suggestedMin)),void 0!==e.max?t.max=e.max:void 0!==e.suggestedMax&&(null===t.max?t.max=e.suggestedMax:t.max=Math.max(t.max,e.suggestedMax)),a!==r&&t.min>=t.max&&(a?t.max=t.min+1:t.min=t.max-1),t.min===t.max&&(t.max++,e.beginAtZero||t.min--)},getTickLimit:function(){var t,e=this.options.ticks,n=e.stepSize,i=e.maxTicksLimit;return n?t=Math.ceil(this.max/n)-Math.floor(this.min/n)+1:(t=this._computeTickLimit(),i=i||11),i&&(t=Math.min(i,t)),t},_computeTickLimit:function(){return Number.POSITIVE_INFINITY},handleDirectionalChanges:Mn,buildTicks:function(){var t=this,e=t.options.ticks,n=t.getTickLimit(),i={maxTicks:n=Math.max(2,n),min:e.min,max:e.max,precision:e.precision,stepSize:H.valueOrDefault(e.fixedStepSize,e.stepSize)},a=t.ticks=function(t,e){var n,i,a,r,o=[],s=t.stepSize,l=s||1,u=t.maxTicks-1,d=t.min,h=t.max,c=t.precision,f=e.min,g=e.max,p=H.niceNum((g-f)/u/l)*l;if(p<1e-14&&Sn(d)&&Sn(h))return[f,g];(r=Math.ceil(g/p)-Math.floor(f/p))>u&&(p=H.niceNum(r*p/u/l)*l),s||Sn(c)?n=Math.pow(10,H._decimalPlaces(p)):(n=Math.pow(10,c),p=Math.ceil(p*n)/n),i=Math.floor(f/p)*p,a=Math.ceil(g/p)*p,s&&(!Sn(d)&&H.almostWhole(d/p,p/1e3)&&(i=d),!Sn(h)&&H.almostWhole(h/p,p/1e3)&&(a=h)),r=(a-i)/p,r=H.almostEquals(r,Math.round(r),p/1e3)?Math.round(r):Math.ceil(r),i=Math.round(i*n)/n,a=Math.round(a*n)/n,o.push(Sn(d)?i:d);for(var m=1;m<r;++m)o.push(Math.round((i+m*p)*n)/n);return o.push(Sn(h)?a:h),o}(i,t);t.handleDirectionalChanges(),t.max=H.max(a),t.min=H.min(a),e.reverse?(a.reverse(),t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max)},convertTicksToLabels:function(){var t=this;t.ticksAsNumbers=t.ticks.slice(),t.zeroLineIndex=t.ticks.indexOf(0),yn.prototype.convertTicksToLabels.call(t)},_configure:function(){var t,e=this,n=e.getTicks(),i=e.min,a=e.max;yn.prototype._configure.call(e),e.options.offset&&n.length&&(i-=t=(a-i)/Math.max(n.length-1,1)/2,a+=t),e._startValue=i,e._endValue=a,e._valueRange=a-i}}),Pn={position:"left",ticks:{callback:on.formatters.linear}};function An(t,e,n,i){var a,r,o=t.options,s=function(t,e,n){var i=[n.type,void 0===e&&void 0===n.stack?n.index:"",n.stack].join(".");return void 0===t[i]&&(t[i]={pos:[],neg:[]}),t[i]}(e,o.stacked,n),l=s.pos,u=s.neg,d=i.length;for(a=0;a<d;++a)r=t._parseValue(i[a]),isNaN(r.min)||isNaN(r.max)||n.data[a].hidden||(l[a]=l[a]||0,u[a]=u[a]||0,o.relativePoints?l[a]=100:r.min<0||r.max<0?u[a]+=r.min:l[a]+=r.max)}function Dn(t,e,n){var i,a,r=n.length;for(i=0;i<r;++i)a=t._parseValue(n[i]),isNaN(a.min)||isNaN(a.max)||e.data[i].hidden||(t.min=Math.min(t.min,a.min),t.max=Math.max(t.max,a.max))}var Tn=Cn.extend({determineDataLimits:function(){var t,e,n,i,a=this,r=a.options,o=a.chart.data.datasets,s=a._getMatchingVisibleMetas(),l=r.stacked,u={},d=s.length;if(a.min=Number.POSITIVE_INFINITY,a.max=Number.NEGATIVE_INFINITY,void 0===l)for(t=0;!l&&t<d;++t)l=void 0!==(e=s[t]).stack;for(t=0;t<d;++t)n=o[(e=s[t]).index].data,l?An(a,u,e,n):Dn(a,e,n);H.each(u,(function(t){i=t.pos.concat(t.neg),a.min=Math.min(a.min,H.min(i)),a.max=Math.max(a.max,H.max(i))})),a.min=H.isFinite(a.min)&&!isNaN(a.min)?a.min:0,a.max=H.isFinite(a.max)&&!isNaN(a.max)?a.max:1,a.handleTickRangeOptions()},_computeTickLimit:function(){var t;return this.isHorizontal()?Math.ceil(this.width/40):(t=H.options._parseFont(this.options.ticks),Math.ceil(this.height/t.lineHeight))},handleDirectionalChanges:function(){this.isHorizontal()||this.ticks.reverse()},getLabelForIndex:function(t,e){return this._getScaleLabel(this.chart.data.datasets[e].data[t])},getPixelForValue:function(t){return this.getPixelForDecimal((+this.getRightValue(t)-this._startValue)/this._valueRange)},getValueForPixel:function(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange},getPixelForTick:function(t){var e=this.ticksAsNumbers;return t<0||t>e.length-1?null:this.getPixelForValue(e[t])}}),In=Pn;Tn._defaults=In;var Fn=H.valueOrDefault,On=H.math.log10;var Ln={position:"left",ticks:{callback:on.formatters.logarithmic}};function Rn(t,e){return H.isFinite(t)&&t>=0?t:e}var zn=yn.extend({determineDataLimits:function(){var t,e,n,i,a,r,o=this,s=o.options,l=o.chart,u=l.data.datasets,d=o.isHorizontal();function h(t){return d?t.xAxisID===o.id:t.yAxisID===o.id}o.min=Number.POSITIVE_INFINITY,o.max=Number.NEGATIVE_INFINITY,o.minNotZero=Number.POSITIVE_INFINITY;var c=s.stacked;if(void 0===c)for(t=0;t<u.length;t++)if(e=l.getDatasetMeta(t),l.isDatasetVisible(t)&&h(e)&&void 0!==e.stack){c=!0;break}if(s.stacked||c){var f={};for(t=0;t<u.length;t++){var g=[(e=l.getDatasetMeta(t)).type,void 0===s.stacked&&void 0===e.stack?t:"",e.stack].join(".");if(l.isDatasetVisible(t)&&h(e))for(void 0===f[g]&&(f[g]=[]),a=0,r=(i=u[t].data).length;a<r;a++){var p=f[g];n=o._parseValue(i[a]),isNaN(n.min)||isNaN(n.max)||e.data[a].hidden||n.min<0||n.max<0||(p[a]=p[a]||0,p[a]+=n.max)}}H.each(f,(function(t){if(t.length>0){var e=H.min(t),n=H.max(t);o.min=Math.min(o.min,e),o.max=Math.max(o.max,n)}}))}else for(t=0;t<u.length;t++)if(e=l.getDatasetMeta(t),l.isDatasetVisible(t)&&h(e))for(a=0,r=(i=u[t].data).length;a<r;a++)n=o._parseValue(i[a]),isNaN(n.min)||isNaN(n.max)||e.data[a].hidden||n.min<0||n.max<0||(o.min=Math.min(n.min,o.min),o.max=Math.max(n.max,o.max),0!==n.min&&(o.minNotZero=Math.min(n.min,o.minNotZero)));o.min=H.isFinite(o.min)?o.min:null,o.max=H.isFinite(o.max)?o.max:null,o.minNotZero=H.isFinite(o.minNotZero)?o.minNotZero:null,this.handleTickRangeOptions()},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;t.min=Rn(e.min,t.min),t.max=Rn(e.max,t.max),t.min===t.max&&(0!==t.min&&null!==t.min?(t.min=Math.pow(10,Math.floor(On(t.min))-1),t.max=Math.pow(10,Math.floor(On(t.max))+1)):(t.min=1,t.max=10)),null===t.min&&(t.min=Math.pow(10,Math.floor(On(t.max))-1)),null===t.max&&(t.max=0!==t.min?Math.pow(10,Math.floor(On(t.min))+1):10),null===t.minNotZero&&(t.min>0?t.minNotZero=t.min:t.max<1?t.minNotZero=Math.pow(10,Math.floor(On(t.max))):t.minNotZero=1)},buildTicks:function(){var t=this,e=t.options.ticks,n=!t.isHorizontal(),i={min:Rn(e.min),max:Rn(e.max)},a=t.ticks=function(t,e){var n,i,a=[],r=Fn(t.min,Math.pow(10,Math.floor(On(e.min)))),o=Math.floor(On(e.max)),s=Math.ceil(e.max/Math.pow(10,o));0===r?(n=Math.floor(On(e.minNotZero)),i=Math.floor(e.minNotZero/Math.pow(10,n)),a.push(r),r=i*Math.pow(10,n)):(n=Math.floor(On(r)),i=Math.floor(r/Math.pow(10,n)));var l=n<0?Math.pow(10,Math.abs(n)):1;do{a.push(r),10===++i&&(i=1,l=++n>=0?1:l),r=Math.round(i*Math.pow(10,n)*l)/l}while(n<o||n===o&&i<s);var u=Fn(t.max,r);return a.push(u),a}(i,t);t.max=H.max(a),t.min=H.min(a),e.reverse?(n=!n,t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max),n&&a.reverse()},convertTicksToLabels:function(){this.tickValues=this.ticks.slice(),yn.prototype.convertTicksToLabels.call(this)},getLabelForIndex:function(t,e){return this._getScaleLabel(this.chart.data.datasets[e].data[t])},getPixelForTick:function(t){var e=this.tickValues;return t<0||t>e.length-1?null:this.getPixelForValue(e[t])},_getFirstTickValue:function(t){var e=Math.floor(On(t));return Math.floor(t/Math.pow(10,e))*Math.pow(10,e)},_configure:function(){var t=this,e=t.min,n=0;yn.prototype._configure.call(t),0===e&&(e=t._getFirstTickValue(t.minNotZero),n=Fn(t.options.ticks.fontSize,N.global.defaultFontSize)/t._length),t._startValue=On(e),t._valueOffset=n,t._valueRange=(On(t.max)-On(e))/(1-n)},getPixelForValue:function(t){var e=this,n=0;return(t=+e.getRightValue(t))>e.min&&t>0&&(n=(On(t)-e._startValue)/e._valueRange+e._valueOffset),e.getPixelForDecimal(n)},getValueForPixel:function(t){var e=this,n=e.getDecimalForPixel(t);return 0===n&&0===e.min?0:Math.pow(10,e._startValue+(n-e._valueOffset)*e._valueRange)}}),Nn=Ln;zn._defaults=Nn;var Bn=H.valueOrDefault,En=H.valueAtIndexOrDefault,Wn=H.options.resolve,Vn={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0,0,0,0.1)",lineWidth:1,borderDash:[],borderDashOffset:0},gridLines:{circular:!1},ticks:{showLabelBackdrop:!0,backdropColor:"rgba(255,255,255,0.75)",backdropPaddingY:2,backdropPaddingX:2,callback:on.formatters.linear},pointLabels:{display:!0,fontSize:10,callback:function(t){return t}}};function Hn(t){var e=t.ticks;return e.display&&t.display?Bn(e.fontSize,N.global.defaultFontSize)+2*e.backdropPaddingY:0}function jn(t,e,n,i,a){return t===i||t===a?{start:e-n/2,end:e+n/2}:t<i||t>a?{start:e-n,end:e}:{start:e,end:e+n}}function qn(t){return 0===t||180===t?"center":t<180?"left":"right"}function Un(t,e,n,i){var a,r,o=n.y+i/2;if(H.isArray(e))for(a=0,r=e.length;a<r;++a)t.fillText(e[a],n.x,o),o+=i;else t.fillText(e,n.x,o)}function Yn(t,e,n){90===t||270===t?n.y-=e.h/2:(t>270||t<90)&&(n.y-=e.h)}function Gn(t){return H.isNumber(t)?t:0}var Xn=Cn.extend({setDimensions:function(){var t=this;t.width=t.maxWidth,t.height=t.maxHeight,t.paddingTop=Hn(t.options)/2,t.xCenter=Math.floor(t.width/2),t.yCenter=Math.floor((t.height-t.paddingTop)/2),t.drawingArea=Math.min(t.height-t.paddingTop,t.width)/2},determineDataLimits:function(){var t=this,e=t.chart,n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;H.each(e.data.datasets,(function(a,r){if(e.isDatasetVisible(r)){var o=e.getDatasetMeta(r);H.each(a.data,(function(e,a){var r=+t.getRightValue(e);isNaN(r)||o.data[a].hidden||(n=Math.min(r,n),i=Math.max(r,i))}))}})),t.min=n===Number.POSITIVE_INFINITY?0:n,t.max=i===Number.NEGATIVE_INFINITY?0:i,t.handleTickRangeOptions()},_computeTickLimit:function(){return Math.ceil(this.drawingArea/Hn(this.options))},convertTicksToLabels:function(){var t=this;Cn.prototype.convertTicksToLabels.call(t),t.pointLabels=t.chart.data.labels.map((function(){var e=H.callback(t.options.pointLabels.callback,arguments,t);return e||0===e?e:""}))},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},fit:function(){var t=this.options;t.display&&t.pointLabels.display?function(t){var e,n,i,a=H.options._parseFont(t.options.pointLabels),r={l:0,r:t.width,t:0,b:t.height-t.paddingTop},o={};t.ctx.font=a.string,t._pointLabelSizes=[];var s,l,u,d=t.chart.data.labels.length;for(e=0;e<d;e++){i=t.getPointPosition(e,t.drawingArea+5),s=t.ctx,l=a.lineHeight,u=t.pointLabels[e],n=H.isArray(u)?{w:H.longestText(s,s.font,u),h:u.length*l}:{w:s.measureText(u).width,h:l},t._pointLabelSizes[e]=n;var h=t.getIndexAngle(e),c=H.toDegrees(h)%360,f=jn(c,i.x,n.w,0,180),g=jn(c,i.y,n.h,90,270);f.start<r.l&&(r.l=f.start,o.l=h),f.end>r.r&&(r.r=f.end,o.r=h),g.start<r.t&&(r.t=g.start,o.t=h),g.end>r.b&&(r.b=g.end,o.b=h)}t.setReductions(t.drawingArea,r,o)}(this):this.setCenterPoint(0,0,0,0)},setReductions:function(t,e,n){var i=this,a=e.l/Math.sin(n.l),r=Math.max(e.r-i.width,0)/Math.sin(n.r),o=-e.t/Math.cos(n.t),s=-Math.max(e.b-(i.height-i.paddingTop),0)/Math.cos(n.b);a=Gn(a),r=Gn(r),o=Gn(o),s=Gn(s),i.drawingArea=Math.min(Math.floor(t-(a+r)/2),Math.floor(t-(o+s)/2)),i.setCenterPoint(a,r,o,s)},setCenterPoint:function(t,e,n,i){var a=this,r=a.width-e-a.drawingArea,o=t+a.drawingArea,s=n+a.drawingArea,l=a.height-a.paddingTop-i-a.drawingArea;a.xCenter=Math.floor((o+r)/2+a.left),a.yCenter=Math.floor((s+l)/2+a.top+a.paddingTop)},getIndexAngle:function(t){var e=this.chart,n=(t*(360/e.data.labels.length)+((e.options||{}).startAngle||0))%360;return(n<0?n+360:n)*Math.PI*2/360},getDistanceFromCenterForValue:function(t){var e=this;if(H.isNullOrUndef(t))return NaN;var n=e.drawingArea/(e.max-e.min);return e.options.ticks.reverse?(e.max-t)*n:(t-e.min)*n},getPointPosition:function(t,e){var n=this.getIndexAngle(t)-Math.PI/2;return{x:Math.cos(n)*e+this.xCenter,y:Math.sin(n)*e+this.yCenter}},getPointPositionForValue:function(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))},getBasePosition:function(t){var e=this.min,n=this.max;return this.getPointPositionForValue(t||0,this.beginAtZero?0:e<0&&n<0?n:e>0&&n>0?e:0)},_drawGrid:function(){var t,e,n,i=this,a=i.ctx,r=i.options,o=r.gridLines,s=r.angleLines,l=Bn(s.lineWidth,o.lineWidth),u=Bn(s.color,o.color);if(r.pointLabels.display&&function(t){var e=t.ctx,n=t.options,i=n.pointLabels,a=Hn(n),r=t.getDistanceFromCenterForValue(n.ticks.reverse?t.min:t.max),o=H.options._parseFont(i);e.save(),e.font=o.string,e.textBaseline="middle";for(var s=t.chart.data.labels.length-1;s>=0;s--){var l=0===s?a/2:0,u=t.getPointPosition(s,r+l+5),d=En(i.fontColor,s,N.global.defaultFontColor);e.fillStyle=d;var h=t.getIndexAngle(s),c=H.toDegrees(h);e.textAlign=qn(c),Yn(c,t._pointLabelSizes[s],u),Un(e,t.pointLabels[s],u,o.lineHeight)}e.restore()}(i),o.display&&H.each(i.ticks,(function(t,n){0!==n&&(e=i.getDistanceFromCenterForValue(i.ticksAsNumbers[n]),function(t,e,n,i){var a,r=t.ctx,o=e.circular,s=t.chart.data.labels.length,l=En(e.color,i-1),u=En(e.lineWidth,i-1);if((o||s)&&l&&u){if(r.save(),r.strokeStyle=l,r.lineWidth=u,r.setLineDash&&(r.setLineDash(e.borderDash||[]),r.lineDashOffset=e.borderDashOffset||0),r.beginPath(),o)r.arc(t.xCenter,t.yCenter,n,0,2*Math.PI);else{a=t.getPointPosition(0,n),r.moveTo(a.x,a.y);for(var d=1;d<s;d++)a=t.getPointPosition(d,n),r.lineTo(a.x,a.y)}r.closePath(),r.stroke(),r.restore()}}(i,o,e,n))})),s.display&&l&&u){for(a.save(),a.lineWidth=l,a.strokeStyle=u,a.setLineDash&&(a.setLineDash(Wn([s.borderDash,o.borderDash,[]])),a.lineDashOffset=Wn([s.borderDashOffset,o.borderDashOffset,0])),t=i.chart.data.labels.length-1;t>=0;t--)e=i.getDistanceFromCenterForValue(r.ticks.reverse?i.min:i.max),n=i.getPointPosition(t,e),a.beginPath(),a.moveTo(i.xCenter,i.yCenter),a.lineTo(n.x,n.y),a.stroke();a.restore()}},_drawLabels:function(){var t=this,e=t.ctx,n=t.options.ticks;if(n.display){var i,a,r=t.getIndexAngle(0),o=H.options._parseFont(n),s=Bn(n.fontColor,N.global.defaultFontColor);e.save(),e.font=o.string,e.translate(t.xCenter,t.yCenter),e.rotate(r),e.textAlign="center",e.textBaseline="middle",H.each(t.ticks,(function(r,l){(0!==l||n.reverse)&&(i=t.getDistanceFromCenterForValue(t.ticksAsNumbers[l]),n.showLabelBackdrop&&(a=e.measureText(r).width,e.fillStyle=n.backdropColor,e.fillRect(-a/2-n.backdropPaddingX,-i-o.size/2-n.backdropPaddingY,a+2*n.backdropPaddingX,o.size+2*n.backdropPaddingY)),e.fillStyle=s,e.fillText(r,0,-i))})),e.restore()}},_drawTitle:H.noop}),Kn=Vn;Xn._defaults=Kn;var Zn=H._deprecated,$n=H.options.resolve,Jn=H.valueOrDefault,Qn=Number.MIN_SAFE_INTEGER||-9007199254740991,ti=Number.MAX_SAFE_INTEGER||9007199254740991,ei={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},ni=Object.keys(ei);function ii(t,e){return t-e}function ai(t){return H.valueOrDefault(t.time.min,t.ticks.min)}function ri(t){return H.valueOrDefault(t.time.max,t.ticks.max)}function oi(t,e,n,i){var a=function(t,e,n){for(var i,a,r,o=0,s=t.length-1;o>=0&&o<=s;){if(a=t[(i=o+s>>1)-1]||null,r=t[i],!a)return{lo:null,hi:r};if(r[e]<n)o=i+1;else{if(!(a[e]>n))return{lo:a,hi:r};s=i-1}}return{lo:r,hi:null}}(t,e,n),r=a.lo?a.hi?a.lo:t[t.length-2]:t[0],o=a.lo?a.hi?a.hi:t[t.length-1]:t[1],s=o[e]-r[e],l=s?(n-r[e])/s:0,u=(o[i]-r[i])*l;return r[i]+u}function si(t,e){var n=t._adapter,i=t.options.time,a=i.parser,r=a||i.format,o=e;return"function"==typeof a&&(o=a(o)),H.isFinite(o)||(o="string"==typeof r?n.parse(o,r):n.parse(o)),null!==o?+o:(a||"function"!=typeof r||(o=r(e),H.isFinite(o)||(o=n.parse(o))),o)}function li(t,e){if(H.isNullOrUndef(e))return null;var n=t.options.time,i=si(t,t.getRightValue(e));return null===i?i:(n.round&&(i=+t._adapter.startOf(i,n.round)),i)}function ui(t,e,n,i){var a,r,o,s=ni.length;for(a=ni.indexOf(t);a<s-1;++a)if(o=(r=ei[ni[a]]).steps?r.steps:ti,r.common&&Math.ceil((n-e)/(o*r.size))<=i)return ni[a];return ni[s-1]}function di(t,e,n){var i,a,r=[],o={},s=e.length;for(i=0;i<s;++i)o[a=e[i]]=i,r.push({value:a,major:!1});return 0!==s&&n?function(t,e,n,i){var a,r,o=t._adapter,s=+o.startOf(e[0].value,i),l=e[e.length-1].value;for(a=s;a<=l;a=+o.add(a,1,i))(r=n[a])>=0&&(e[r].major=!0);return e}(t,r,o,n):r}var hi=yn.extend({initialize:function(){this.mergeTicksOptions(),yn.prototype.initialize.call(this)},update:function(){var t=this,e=t.options,n=e.time||(e.time={}),i=t._adapter=new rn._date(e.adapters.date);return Zn("time scale",n.format,"time.format","time.parser"),Zn("time scale",n.min,"time.min","ticks.min"),Zn("time scale",n.max,"time.max","ticks.max"),H.mergeIf(n.displayFormats,i.formats()),yn.prototype.update.apply(t,arguments)},getRightValue:function(t){return t&&void 0!==t.t&&(t=t.t),yn.prototype.getRightValue.call(this,t)},determineDataLimits:function(){var t,e,n,i,a,r,o,s=this,l=s.chart,u=s._adapter,d=s.options,h=d.time.unit||"day",c=ti,f=Qn,g=[],p=[],m=[],v=s._getLabels();for(t=0,n=v.length;t<n;++t)m.push(li(s,v[t]));for(t=0,n=(l.data.datasets||[]).length;t<n;++t)if(l.isDatasetVisible(t))if(a=l.data.datasets[t].data,H.isObject(a[0]))for(p[t]=[],e=0,i=a.length;e<i;++e)r=li(s,a[e]),g.push(r),p[t][e]=r;else p[t]=m.slice(0),o||(g=g.concat(m),o=!0);else p[t]=[];m.length&&(c=Math.min(c,m[0]),f=Math.max(f,m[m.length-1])),g.length&&(g=n>1?function(t){var e,n,i,a={},r=[];for(e=0,n=t.length;e<n;++e)a[i=t[e]]||(a[i]=!0,r.push(i));return r}(g).sort(ii):g.sort(ii),c=Math.min(c,g[0]),f=Math.max(f,g[g.length-1])),c=li(s,ai(d))||c,f=li(s,ri(d))||f,c=c===ti?+u.startOf(Date.now(),h):c,f=f===Qn?+u.endOf(Date.now(),h)+1:f,s.min=Math.min(c,f),s.max=Math.max(c+1,f),s._table=[],s._timestamps={data:g,datasets:p,labels:m}},buildTicks:function(){var t,e,n,i=this,a=i.min,r=i.max,o=i.options,s=o.ticks,l=o.time,u=i._timestamps,d=[],h=i.getLabelCapacity(a),c=s.source,f=o.distribution;for(u="data"===c||"auto"===c&&"series"===f?u.data:"labels"===c?u.labels:function(t,e,n,i){var a,r=t._adapter,o=t.options,s=o.time,l=s.unit||ui(s.minUnit,e,n,i),u=$n([s.stepSize,s.unitStepSize,1]),d="week"===l&&s.isoWeekday,h=e,c=[];if(d&&(h=+r.startOf(h,"isoWeek",d)),h=+r.startOf(h,d?"day":l),r.diff(n,e,l)>1e5*u)throw e+" and "+n+" are too far apart with stepSize of "+u+" "+l;for(a=h;a<n;a=+r.add(a,u,l))c.push(a);return a!==n&&"ticks"!==o.bounds||c.push(a),c}(i,a,r,h),"ticks"===o.bounds&&u.length&&(a=u[0],r=u[u.length-1]),a=li(i,ai(o))||a,r=li(i,ri(o))||r,t=0,e=u.length;t<e;++t)(n=u[t])>=a&&n<=r&&d.push(n);return i.min=a,i.max=r,i._unit=l.unit||(s.autoSkip?ui(l.minUnit,i.min,i.max,h):function(t,e,n,i,a){var r,o;for(r=ni.length-1;r>=ni.indexOf(n);r--)if(o=ni[r],ei[o].common&&t._adapter.diff(a,i,o)>=e-1)return o;return ni[n?ni.indexOf(n):0]}(i,d.length,l.minUnit,i.min,i.max)),i._majorUnit=s.major.enabled&&"year"!==i._unit?function(t){for(var e=ni.indexOf(t)+1,n=ni.length;e<n;++e)if(ei[ni[e]].common)return ni[e]}(i._unit):void 0,i._table=function(t,e,n,i){if("linear"===i||!t.length)return[{time:e,pos:0},{time:n,pos:1}];var a,r,o,s,l,u=[],d=[e];for(a=0,r=t.length;a<r;++a)(s=t[a])>e&&s<n&&d.push(s);for(d.push(n),a=0,r=d.length;a<r;++a)l=d[a+1],o=d[a-1],s=d[a],void 0!==o&&void 0!==l&&Math.round((l+o)/2)===s||u.push({time:s,pos:a/(r-1)});return u}(i._timestamps.data,a,r,f),i._offsets=function(t,e,n,i,a){var r,o,s=0,l=0;return a.offset&&e.length&&(r=oi(t,"time",e[0],"pos"),s=1===e.length?1-r:(oi(t,"time",e[1],"pos")-r)/2,o=oi(t,"time",e[e.length-1],"pos"),l=1===e.length?o:(o-oi(t,"time",e[e.length-2],"pos"))/2),{start:s,end:l,factor:1/(s+1+l)}}(i._table,d,0,0,o),s.reverse&&d.reverse(),di(i,d,i._majorUnit)},getLabelForIndex:function(t,e){var n=this,i=n._adapter,a=n.chart.data,r=n.options.time,o=a.labels&&t<a.labels.length?a.labels[t]:"",s=a.datasets[e].data[t];return H.isObject(s)&&(o=n.getRightValue(s)),r.tooltipFormat?i.format(si(n,o),r.tooltipFormat):"string"==typeof o?o:i.format(si(n,o),r.displayFormats.datetime)},tickFormatFunction:function(t,e,n,i){var a=this._adapter,r=this.options,o=r.time.displayFormats,s=o[this._unit],l=this._majorUnit,u=o[l],d=n[e],h=r.ticks,c=l&&u&&d&&d.major,f=a.format(t,i||(c?u:s)),g=c?h.major:h.minor,p=$n([g.callback,g.userCallback,h.callback,h.userCallback]);return p?p(f,e,n):f},convertTicksToLabels:function(t){var e,n,i=[];for(e=0,n=t.length;e<n;++e)i.push(this.tickFormatFunction(t[e].value,e,t));return i},getPixelForOffset:function(t){var e=this._offsets,n=oi(this._table,"time",t,"pos");return this.getPixelForDecimal((e.start+n)*e.factor)},getPixelForValue:function(t,e,n){var i=null;if(void 0!==e&&void 0!==n&&(i=this._timestamps.datasets[n][e]),null===i&&(i=li(this,t)),null!==i)return this.getPixelForOffset(i)},getPixelForTick:function(t){var e=this.getTicks();return t>=0&&t<e.length?this.getPixelForOffset(e[t].value):null},getValueForPixel:function(t){var e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end,i=oi(this._table,"pos",n,"time");return this._adapter._create(i)},_getLabelSize:function(t){var e=this.options.ticks,n=this.ctx.measureText(t).width,i=H.toRadians(this.isHorizontal()?e.maxRotation:e.minRotation),a=Math.cos(i),r=Math.sin(i),o=Jn(e.fontSize,N.global.defaultFontSize);return{w:n*a+o*r,h:n*r+o*a}},getLabelWidth:function(t){return this._getLabelSize(t).w},getLabelCapacity:function(t){var e=this,n=e.options.time,i=n.displayFormats,a=i[n.unit]||i.millisecond,r=e.tickFormatFunction(t,0,di(e,[t],e._majorUnit),a),o=e._getLabelSize(r),s=Math.floor(e.isHorizontal()?e.width/o.w:e.height/o.h);return e.options.offset&&s--,s>0?s:1}}),ci={position:"bottom",distribution:"linear",bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,displayFormat:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{autoSkip:!1,source:"auto",major:{enabled:!1}}};hi._defaults=ci;var fi={category:kn,linear:Tn,logarithmic:zn,radialLinear:Xn,time:hi},gi={datetime:"MMM D, YYYY, h:mm:ss a",millisecond:"h:mm:ss.SSS a",second:"h:mm:ss a",minute:"h:mm a",hour:"hA",day:"MMM D",week:"ll",month:"MMM YYYY",quarter:"[Q]Q - YYYY",year:"YYYY"};rn._date.override("function"==typeof t?{_id:"moment",formats:function(){return gi},parse:function(e,n){return"string"==typeof e&&"string"==typeof n?e=t(e,n):e instanceof t||(e=t(e)),e.isValid()?e.valueOf():null},format:function(e,n){return t(e).format(n)},add:function(e,n,i){return t(e).add(n,i).valueOf()},diff:function(e,n,i){return t(e).diff(t(n),i)},startOf:function(e,n,i){return e=t(e),"isoWeek"===n?e.isoWeekday(i).valueOf():e.startOf(n).valueOf()},endOf:function(e,n){return t(e).endOf(n).valueOf()},_create:function(e){return t(e)}}:{}),N._set("global",{plugins:{filler:{propagate:!0}}});var pi={dataset:function(t){var e=t.fill,n=t.chart,i=n.getDatasetMeta(e),a=i&&n.isDatasetVisible(e)&&i.dataset._children||[],r=a.length||0;return r?function(t,e){return e<r&&a[e]._view||null}:null},boundary:function(t){var e=t.boundary,n=e?e.x:null,i=e?e.y:null;return H.isArray(e)?function(t,n){return e[n]}:function(t){return{x:null===n?t.x:n,y:null===i?t.y:i}}}};function mi(t,e,n){var i,a=t._model||{},r=a.fill;if(void 0===r&&(r=!!a.backgroundColor),!1===r||null===r)return!1;if(!0===r)return"origin";if(i=parseFloat(r,10),isFinite(i)&&Math.floor(i)===i)return"-"!==r[0]&&"+"!==r[0]||(i=e+i),!(i===e||i<0||i>=n)&&i;switch(r){case"bottom":return"start";case"top":return"end";case"zero":return"origin";case"origin":case"start":case"end":return r;default:return!1}}function vi(t){return(t.el._scale||{}).getPointPositionForValue?function(t){var e,n,i,a,r,o=t.el._scale,s=o.options,l=o.chart.data.labels.length,u=t.fill,d=[];if(!l)return null;for(e=s.ticks.reverse?o.max:o.min,n=s.ticks.reverse?o.min:o.max,i=o.getPointPositionForValue(0,e),a=0;a<l;++a)r="start"===u||"end"===u?o.getPointPositionForValue(a,"start"===u?e:n):o.getBasePosition(a),s.gridLines.circular&&(r.cx=i.x,r.cy=i.y,r.angle=o.getIndexAngle(a)-Math.PI/2),d.push(r);return d}(t):function(t){var e,n=t.el._model||{},i=t.el._scale||{},a=t.fill,r=null;if(isFinite(a))return null;if("start"===a?r=void 0===n.scaleBottom?i.bottom:n.scaleBottom:"end"===a?r=void 0===n.scaleTop?i.top:n.scaleTop:void 0!==n.scaleZero?r=n.scaleZero:i.getBasePixel&&(r=i.getBasePixel()),null!=r){if(void 0!==r.x&&void 0!==r.y)return r;if(H.isFinite(r))return{x:(e=i.isHorizontal())?r:null,y:e?null:r}}return null}(t)}function bi(t,e,n){var i,a=t[e].fill,r=[e];if(!n)return a;for(;!1!==a&&-1===r.indexOf(a);){if(!isFinite(a))return a;if(!(i=t[a]))return!1;if(i.visible)return a;r.push(a),a=i.fill}return!1}function xi(t){var e=t.fill,n="dataset";return!1===e?null:(isFinite(e)||(n="boundary"),pi[n](t))}function yi(t){return t&&!t.skip}function _i(t,e,n,i,a){var r,o,s,l;if(i&&a){for(t.moveTo(e[0].x,e[0].y),r=1;r<i;++r)H.canvas.lineTo(t,e[r-1],e[r]);if(void 0===n[0].angle)for(t.lineTo(n[a-1].x,n[a-1].y),r=a-1;r>0;--r)H.canvas.lineTo(t,n[r],n[r-1],!0);else for(o=n[0].cx,s=n[0].cy,l=Math.sqrt(Math.pow(n[0].x-o,2)+Math.pow(n[0].y-s,2)),r=a-1;r>0;--r)t.arc(o,s,l,n[r].angle,n[r-1].angle,!0)}}function ki(t,e,n,i,a,r){var o,s,l,u,d,h,c,f,g=e.length,p=i.spanGaps,m=[],v=[],b=0,x=0;for(t.beginPath(),o=0,s=g;o<s;++o)d=n(u=e[l=o%g]._view,l,i),h=yi(u),c=yi(d),r&&void 0===f&&h&&(s=g+(f=o+1)),h&&c?(b=m.push(u),x=v.push(d)):b&&x&&(p?(h&&m.push(u),c&&v.push(d)):(_i(t,m,v,b,x),b=x=0,m=[],v=[]));_i(t,m,v,b,x),t.closePath(),t.fillStyle=a,t.fill()}var wi={id:"filler",afterDatasetsUpdate:function(t,e){var n,i,a,r,o=(t.data.datasets||[]).length,s=e.propagate,l=[];for(i=0;i<o;++i)r=null,(a=(n=t.getDatasetMeta(i)).dataset)&&a._model&&a instanceof kt.Line&&(r={visible:t.isDatasetVisible(i),fill:mi(a,i,o),chart:t,el:a}),n.$filler=r,l.push(r);for(i=0;i<o;++i)(r=l[i])&&(r.fill=bi(l,i,s),r.boundary=vi(r),r.mapper=xi(r))},beforeDatasetsDraw:function(t){var e,n,i,a,r,o,s,l=t._getSortedVisibleDatasetMetas(),u=t.ctx;for(n=l.length-1;n>=0;--n)(e=l[n].$filler)&&e.visible&&(a=(i=e.el)._view,r=i._children||[],o=e.mapper,s=a.backgroundColor||N.global.defaultColor,o&&s&&r.length&&(H.canvas.clipArea(u,t.chartArea),ki(u,r,o,a,s,i._loop),H.canvas.unclipArea(u)))}},Mi=H.rtl.getRtlAdapter,Si=H.noop,Ci=H.valueOrDefault;function Pi(t,e){return t.usePointStyle&&t.boxWidth>e?e:t.boxWidth}N._set("global",{legend:{display:!0,position:"top",align:"center",fullWidth:!0,reverse:!1,weight:1e3,onClick:function(t,e){var n=e.datasetIndex,i=this.chart,a=i.getDatasetMeta(n);a.hidden=null===a.hidden?!i.data.datasets[n].hidden:null,i.update()},onHover:null,onLeave:null,labels:{boxWidth:40,padding:10,generateLabels:function(t){var e=t.data.datasets,n=t.options.legend||{},i=n.labels&&n.labels.usePointStyle;return t._getSortedDatasetMetas().map((function(n){var a=n.controller.getStyle(i?0:void 0);return{text:e[n.index].label,fillStyle:a.backgroundColor,hidden:!t.isDatasetVisible(n.index),lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:a.borderWidth,strokeStyle:a.borderColor,pointStyle:a.pointStyle,rotation:a.rotation,datasetIndex:n.index}}),this)}}},legendCallback:function(t){var e,n,i,a=document.createElement("ul"),r=t.data.datasets;for(a.setAttribute("class",t.id+"-legend"),e=0,n=r.length;e<n;e++)(i=a.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor=r[e].backgroundColor,r[e].label&&i.appendChild(document.createTextNode(r[e].label));return a.outerHTML}});var Ai=K.extend({initialize:function(t){H.extend(this,t),this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1},beforeUpdate:Si,update:function(t,e,n){var i=this;return i.beforeUpdate(),i.maxWidth=t,i.maxHeight=e,i.margins=n,i.beforeSetDimensions(),i.setDimensions(),i.afterSetDimensions(),i.beforeBuildLabels(),i.buildLabels(),i.afterBuildLabels(),i.beforeFit(),i.fit(),i.afterFit(),i.afterUpdate(),i.minSize},afterUpdate:Si,beforeSetDimensions:Si,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:Si,beforeBuildLabels:Si,buildLabels:function(){var t=this,e=t.options.labels||{},n=H.callback(e.generateLabels,[t.chart],t)||[];e.filter&&(n=n.filter((function(n){return e.filter(n,t.chart.data)}))),t.options.reverse&&n.reverse(),t.legendItems=n},afterBuildLabels:Si,beforeFit:Si,fit:function(){var t=this,e=t.options,n=e.labels,i=e.display,a=t.ctx,r=H.options._parseFont(n),o=r.size,s=t.legendHitBoxes=[],l=t.minSize,u=t.isHorizontal();if(u?(l.width=t.maxWidth,l.height=i?10:0):(l.width=i?10:0,l.height=t.maxHeight),i){if(a.font=r.string,u){var d=t.lineWidths=[0],h=0;a.textAlign="left",a.textBaseline="middle",H.each(t.legendItems,(function(t,e){var i=Pi(n,o)+o/2+a.measureText(t.text).width;(0===e||d[d.length-1]+i+2*n.padding>l.width)&&(h+=o+n.padding,d[d.length-(e>0?0:1)]=0),s[e]={left:0,top:0,width:i,height:o},d[d.length-1]+=i+n.padding})),l.height+=h}else{var c=n.padding,f=t.columnWidths=[],g=t.columnHeights=[],p=n.padding,m=0,v=0;H.each(t.legendItems,(function(t,e){var i=Pi(n,o)+o/2+a.measureText(t.text).width;e>0&&v+o+2*c>l.height&&(p+=m+n.padding,f.push(m),g.push(v),m=0,v=0),m=Math.max(m,i),v+=o+c,s[e]={left:0,top:0,width:i,height:o}})),p+=m,f.push(m),g.push(v),l.width+=p}t.width=l.width,t.height=l.height}else t.width=l.width=t.height=l.height=0},afterFit:Si,isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},draw:function(){var t=this,e=t.options,n=e.labels,i=N.global,a=i.defaultColor,r=i.elements.line,o=t.height,s=t.columnHeights,l=t.width,u=t.lineWidths;if(e.display){var d,h=Mi(e.rtl,t.left,t.minSize.width),c=t.ctx,f=Ci(n.fontColor,i.defaultFontColor),g=H.options._parseFont(n),p=g.size;c.textAlign=h.textAlign("left"),c.textBaseline="middle",c.lineWidth=.5,c.strokeStyle=f,c.fillStyle=f,c.font=g.string;var m=Pi(n,p),v=t.legendHitBoxes,b=function(t,i){switch(e.align){case"start":return n.padding;case"end":return t-i;default:return(t-i+n.padding)/2}},x=t.isHorizontal();d=x?{x:t.left+b(l,u[0]),y:t.top+n.padding,line:0}:{x:t.left+n.padding,y:t.top+b(o,s[0]),line:0},H.rtl.overrideTextDirection(t.ctx,e.textDirection);var y=p+n.padding;H.each(t.legendItems,(function(e,i){var f=c.measureText(e.text).width,g=m+p/2+f,_=d.x,k=d.y;h.setWidth(t.minSize.width),x?i>0&&_+g+n.padding>t.left+t.minSize.width&&(k=d.y+=y,d.line++,_=d.x=t.left+b(l,u[d.line])):i>0&&k+y>t.top+t.minSize.height&&(_=d.x=_+t.columnWidths[d.line]+n.padding,d.line++,k=d.y=t.top+b(o,s[d.line]));var w=h.x(_);!function(t,e,i){if(!(isNaN(m)||m<=0)){c.save();var o=Ci(i.lineWidth,r.borderWidth);if(c.fillStyle=Ci(i.fillStyle,a),c.lineCap=Ci(i.lineCap,r.borderCapStyle),c.lineDashOffset=Ci(i.lineDashOffset,r.borderDashOffset),c.lineJoin=Ci(i.lineJoin,r.borderJoinStyle),c.lineWidth=o,c.strokeStyle=Ci(i.strokeStyle,a),c.setLineDash&&c.setLineDash(Ci(i.lineDash,r.borderDash)),n&&n.usePointStyle){var s=m*Math.SQRT2/2,l=h.xPlus(t,m/2),u=e+p/2;H.canvas.drawPoint(c,i.pointStyle,s,l,u,i.rotation)}else c.fillRect(h.leftForLtr(t,m),e,m,p),0!==o&&c.strokeRect(h.leftForLtr(t,m),e,m,p);c.restore()}}(w,k,e),v[i].left=h.leftForLtr(w,v[i].width),v[i].top=k,function(t,e,n,i){var a=p/2,r=h.xPlus(t,m+a),o=e+a;c.fillText(n.text,r,o),n.hidden&&(c.beginPath(),c.lineWidth=2,c.moveTo(r,o),c.lineTo(h.xPlus(r,i),o),c.stroke())}(w,k,e,f),x?d.x+=g+n.padding:d.y+=y})),H.rtl.restoreTextDirection(t.ctx,e.textDirection)}},_getLegendItemAt:function(t,e){var n,i,a,r=this;if(t>=r.left&&t<=r.right&&e>=r.top&&e<=r.bottom)for(a=r.legendHitBoxes,n=0;n<a.length;++n)if(t>=(i=a[n]).left&&t<=i.left+i.width&&e>=i.top&&e<=i.top+i.height)return r.legendItems[n];return null},handleEvent:function(t){var e,n=this,i=n.options,a="mouseup"===t.type?"click":t.type;if("mousemove"===a){if(!i.onHover&&!i.onLeave)return}else{if("click"!==a)return;if(!i.onClick)return}e=n._getLegendItemAt(t.x,t.y),"click"===a?e&&i.onClick&&i.onClick.call(n,t.native,e):(i.onLeave&&e!==n._hoveredItem&&(n._hoveredItem&&i.onLeave.call(n,t.native,n._hoveredItem),n._hoveredItem=e),i.onHover&&e&&i.onHover.call(n,t.native,e))}});function Di(t,e){var n=new Ai({ctx:t.ctx,options:e,chart:t});pe.configure(t,n,e),pe.addBox(t,n),t.legend=n}var Ti={id:"legend",_element:Ai,beforeInit:function(t){var e=t.options.legend;e&&Di(t,e)},beforeUpdate:function(t){var e=t.options.legend,n=t.legend;e?(H.mergeIf(e,N.global.legend),n?(pe.configure(t,n,e),n.options=e):Di(t,e)):n&&(pe.removeBox(t,n),delete t.legend)},afterEvent:function(t,e){var n=t.legend;n&&n.handleEvent(e)}},Ii=H.noop;N._set("global",{title:{display:!1,fontStyle:"bold",fullWidth:!0,padding:10,position:"top",text:"",weight:2e3}});var Fi=K.extend({initialize:function(t){H.extend(this,t),this.legendHitBoxes=[]},beforeUpdate:Ii,update:function(t,e,n){var i=this;return i.beforeUpdate(),i.maxWidth=t,i.maxHeight=e,i.margins=n,i.beforeSetDimensions(),i.setDimensions(),i.afterSetDimensions(),i.beforeBuildLabels(),i.buildLabels(),i.afterBuildLabels(),i.beforeFit(),i.fit(),i.afterFit(),i.afterUpdate(),i.minSize},afterUpdate:Ii,beforeSetDimensions:Ii,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:Ii,beforeBuildLabels:Ii,buildLabels:Ii,afterBuildLabels:Ii,beforeFit:Ii,fit:function(){var t,e=this,n=e.options,i=e.minSize={},a=e.isHorizontal();n.display?(t=(H.isArray(n.text)?n.text.length:1)*H.options._parseFont(n).lineHeight+2*n.padding,e.width=i.width=a?e.maxWidth:t,e.height=i.height=a?t:e.maxHeight):e.width=i.width=e.height=i.height=0},afterFit:Ii,isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},draw:function(){var t=this,e=t.ctx,n=t.options;if(n.display){var i,a,r,o=H.options._parseFont(n),s=o.lineHeight,l=s/2+n.padding,u=0,d=t.top,h=t.left,c=t.bottom,f=t.right;e.fillStyle=H.valueOrDefault(n.fontColor,N.global.defaultFontColor),e.font=o.string,t.isHorizontal()?(a=h+(f-h)/2,r=d+l,i=f-h):(a="left"===n.position?h+l:f-l,r=d+(c-d)/2,i=c-d,u=Math.PI*("left"===n.position?-.5:.5)),e.save(),e.translate(a,r),e.rotate(u),e.textAlign="center",e.textBaseline="middle";var g=n.text;if(H.isArray(g))for(var p=0,m=0;m<g.length;++m)e.fillText(g[m],0,p,i),p+=s;else e.fillText(g,0,0,i);e.restore()}}});function Oi(t,e){var n=new Fi({ctx:t.ctx,options:e,chart:t});pe.configure(t,n,e),pe.addBox(t,n),t.titleBlock=n}var Li={},Ri=wi,zi=Ti,Ni={id:"title",_element:Fi,beforeInit:function(t){var e=t.options.title;e&&Oi(t,e)},beforeUpdate:function(t){var e=t.options.title,n=t.titleBlock;e?(H.mergeIf(e,N.global.title),n?(pe.configure(t,n,e),n.options=e):Oi(t,e)):n&&(pe.removeBox(t,n),delete t.titleBlock)}};for(var Bi in Li.filler=Ri,Li.legend=zi,Li.title=Ni,en.helpers=H,function(){function t(t,e,n){var i;return"string"==typeof t?(i=parseInt(t,10),-1!==t.indexOf("%")&&(i=i/100*e.parentNode[n])):i=t,i}function e(t){return null!=t&&"none"!==t}function n(n,i,a){var r=document.defaultView,o=H._getParentNode(n),s=r.getComputedStyle(n)[i],l=r.getComputedStyle(o)[i],u=e(s),d=e(l),h=Number.POSITIVE_INFINITY;return u||d?Math.min(u?t(s,n,a):h,d?t(l,o,a):h):"none"}H.where=function(t,e){if(H.isArray(t)&&Array.prototype.filter)return t.filter(e);var n=[];return H.each(t,(function(t){e(t)&&n.push(t)})),n},H.findIndex=Array.prototype.findIndex?function(t,e,n){return t.findIndex(e,n)}:function(t,e,n){n=void 0===n?t:n;for(var i=0,a=t.length;i<a;++i)if(e.call(n,t[i],i,t))return i;return-1},H.findNextWhere=function(t,e,n){H.isNullOrUndef(n)&&(n=-1);for(var i=n+1;i<t.length;i++){var a=t[i];if(e(a))return a}},H.findPreviousWhere=function(t,e,n){H.isNullOrUndef(n)&&(n=t.length);for(var i=n-1;i>=0;i--){var a=t[i];if(e(a))return a}},H.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},H.almostEquals=function(t,e,n){return Math.abs(t-e)<n},H.almostWhole=function(t,e){var n=Math.round(t);return n-e<=t&&n+e>=t},H.max=function(t){return t.reduce((function(t,e){return isNaN(e)?t:Math.max(t,e)}),Number.NEGATIVE_INFINITY)},H.min=function(t){return t.reduce((function(t,e){return isNaN(e)?t:Math.min(t,e)}),Number.POSITIVE_INFINITY)},H.sign=Math.sign?function(t){return Math.sign(t)}:function(t){return 0===(t=+t)||isNaN(t)?t:t>0?1:-1},H.toRadians=function(t){return t*(Math.PI/180)},H.toDegrees=function(t){return t*(180/Math.PI)},H._decimalPlaces=function(t){if(H.isFinite(t)){for(var e=1,n=0;Math.round(t*e)/e!==t;)e*=10,n++;return n}},H.getAngleFromPoint=function(t,e){var n=e.x-t.x,i=e.y-t.y,a=Math.sqrt(n*n+i*i),r=Math.atan2(i,n);return r<-.5*Math.PI&&(r+=2*Math.PI),{angle:r,distance:a}},H.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},H.aliasPixel=function(t){return t%2==0?0:.5},H._alignPixel=function(t,e,n){var i=t.currentDevicePixelRatio,a=n/2;return Math.round((e-a)*i)/i+a},H.splineCurve=function(t,e,n,i){var a=t.skip?e:t,r=e,o=n.skip?e:n,s=Math.sqrt(Math.pow(r.x-a.x,2)+Math.pow(r.y-a.y,2)),l=Math.sqrt(Math.pow(o.x-r.x,2)+Math.pow(o.y-r.y,2)),u=s/(s+l),d=l/(s+l),h=i*(u=isNaN(u)?0:u),c=i*(d=isNaN(d)?0:d);return{previous:{x:r.x-h*(o.x-a.x),y:r.y-h*(o.y-a.y)},next:{x:r.x+c*(o.x-a.x),y:r.y+c*(o.y-a.y)}}},H.EPSILON=Number.EPSILON||1e-14,H.splineCurveMonotone=function(t){var e,n,i,a,r,o,s,l,u,d=(t||[]).map((function(t){return{model:t._model,deltaK:0,mK:0}})),h=d.length;for(e=0;e<h;++e)if(!(i=d[e]).model.skip){if(n=e>0?d[e-1]:null,(a=e<h-1?d[e+1]:null)&&!a.model.skip){var c=a.model.x-i.model.x;i.deltaK=0!==c?(a.model.y-i.model.y)/c:0}!n||n.model.skip?i.mK=i.deltaK:!a||a.model.skip?i.mK=n.deltaK:this.sign(n.deltaK)!==this.sign(i.deltaK)?i.mK=0:i.mK=(n.deltaK+i.deltaK)/2}for(e=0;e<h-1;++e)i=d[e],a=d[e+1],i.model.skip||a.model.skip||(H.almostEquals(i.deltaK,0,this.EPSILON)?i.mK=a.mK=0:(r=i.mK/i.deltaK,o=a.mK/i.deltaK,(l=Math.pow(r,2)+Math.pow(o,2))<=9||(s=3/Math.sqrt(l),i.mK=r*s*i.deltaK,a.mK=o*s*i.deltaK)));for(e=0;e<h;++e)(i=d[e]).model.skip||(n=e>0?d[e-1]:null,a=e<h-1?d[e+1]:null,n&&!n.model.skip&&(u=(i.model.x-n.model.x)/3,i.model.controlPointPreviousX=i.model.x-u,i.model.controlPointPreviousY=i.model.y-u*i.mK),a&&!a.model.skip&&(u=(a.model.x-i.model.x)/3,i.model.controlPointNextX=i.model.x+u,i.model.controlPointNextY=i.model.y+u*i.mK))},H.nextItem=function(t,e,n){return n?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},H.previousItem=function(t,e,n){return n?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},H.niceNum=function(t,e){var n=Math.floor(H.log10(t)),i=t/Math.pow(10,n);return(e?i<1.5?1:i<3?2:i<7?5:10:i<=1?1:i<=2?2:i<=5?5:10)*Math.pow(10,n)},H.requestAnimFrame="undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)},H.getRelativePosition=function(t,e){var n,i,a=t.originalEvent||t,r=t.target||t.srcElement,o=r.getBoundingClientRect(),s=a.touches;s&&s.length>0?(n=s[0].clientX,i=s[0].clientY):(n=a.clientX,i=a.clientY);var l=parseFloat(H.getStyle(r,"padding-left")),u=parseFloat(H.getStyle(r,"padding-top")),d=parseFloat(H.getStyle(r,"padding-right")),h=parseFloat(H.getStyle(r,"padding-bottom")),c=o.right-o.left-l-d,f=o.bottom-o.top-u-h;return{x:n=Math.round((n-o.left-l)/c*r.width/e.currentDevicePixelRatio),y:i=Math.round((i-o.top-u)/f*r.height/e.currentDevicePixelRatio)}},H.getConstraintWidth=function(t){return n(t,"max-width","clientWidth")},H.getConstraintHeight=function(t){return n(t,"max-height","clientHeight")},H._calculatePadding=function(t,e,n){return(e=H.getStyle(t,e)).indexOf("%")>-1?n*parseInt(e,10)/100:parseInt(e,10)},H._getParentNode=function(t){var e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e},H.getMaximumWidth=function(t){var e=H._getParentNode(t);if(!e)return t.clientWidth;var n=e.clientWidth,i=n-H._calculatePadding(e,"padding-left",n)-H._calculatePadding(e,"padding-right",n),a=H.getConstraintWidth(t);return isNaN(a)?i:Math.min(i,a)},H.getMaximumHeight=function(t){var e=H._getParentNode(t);if(!e)return t.clientHeight;var n=e.clientHeight,i=n-H._calculatePadding(e,"padding-top",n)-H._calculatePadding(e,"padding-bottom",n),a=H.getConstraintHeight(t);return isNaN(a)?i:Math.min(i,a)},H.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},H.retinaScale=function(t,e){var n=t.currentDevicePixelRatio=e||"undefined"!=typeof window&&window.devicePixelRatio||1;if(1!==n){var i=t.canvas,a=t.height,r=t.width;i.height=a*n,i.width=r*n,t.ctx.scale(n,n),i.style.height||i.style.width||(i.style.height=a+"px",i.style.width=r+"px")}},H.fontString=function(t,e,n){return e+" "+t+"px "+n},H.longestText=function(t,e,n,i){var a=(i=i||{}).data=i.data||{},r=i.garbageCollect=i.garbageCollect||[];i.font!==e&&(a=i.data={},r=i.garbageCollect=[],i.font=e),t.font=e;var o,s,l,u,d,h=0,c=n.length;for(o=0;o<c;o++)if(null!=(u=n[o])&&!0!==H.isArray(u))h=H.measureText(t,a,r,h,u);else if(H.isArray(u))for(s=0,l=u.length;s<l;s++)null==(d=u[s])||H.isArray(d)||(h=H.measureText(t,a,r,h,d));var f=r.length/2;if(f>n.length){for(o=0;o<f;o++)delete a[r[o]];r.splice(0,f)}return h},H.measureText=function(t,e,n,i,a){var r=e[a];return r||(r=e[a]=t.measureText(a).width,n.push(a)),r>i&&(i=r),i},H.numberOfLabelLines=function(t){var e=1;return H.each(t,(function(t){H.isArray(t)&&t.length>e&&(e=t.length)})),e},H.color=_?function(t){return t instanceof CanvasGradient&&(t=N.global.defaultColor),_(t)}:function(t){return console.error("Color.js not found!"),t},H.getHoverColor=function(t){return t instanceof CanvasPattern||t instanceof CanvasGradient?t:H.color(t).saturate(.5).darken(.1).rgbString()}}(),en._adapters=rn,en.Animation=$,en.animationService=J,en.controllers=Jt,en.DatasetController=it,en.defaults=N,en.Element=K,en.elements=kt,en.Interaction=re,en.layouts=pe,en.platform=Oe,en.plugins=Le,en.Scale=yn,en.scaleService=Re,en.Ticks=on,en.Tooltip=Ye,en.helpers.each(fi,(function(t,e){en.scaleService.registerScaleType(e,t,t._defaults)})),Li)Li.hasOwnProperty(Bi)&&en.plugins.register(Li[Bi]);en.platform.initialize();var Ei=en;return"undefined"!=typeof window&&(window.Chart=en),en.Chart=en,en.Legend=Li.legend._element,en.Title=Li.title._element,en.pluginService=en.plugins,en.PluginBase=en.Element.extend({}),en.canvasHelpers=en.helpers.canvas,en.layoutService=en.layouts,en.LinearScaleBase=Cn,en.helpers.each(["Bar","Bubble","Doughnut","Line","PolarArea","Radar","Scatter"],(function(t){en[t]=function(e,n){return new en(e,en.helpers.merge(n||{},{type:t.charAt(0).toLowerCase()+t.slice(1)}))}})),Ei}));
  admin-Public-Admin-plugins-datatables-fixedheader-css-fixedHeader.bootstrap4.css: |
    table.dataTable.fixedHeader-floating,
    table.dataTable.fixedHeader-locked {
      background-color: white;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
    }

    table.dataTable.fixedHeader-floating {
      position: fixed !important;
    }

    table.dataTable.fixedHeader-locked {
      position: absolute !important;
    }

    @media print {
      table.fixedHeader-floating {
        display: none;
      }
    }
  admin-Public-Admin-plugins-datatables-fixedheader-css-fixedHeader.bootstrap4.min.css: |
    table.dataTable.fixedHeader-floating,table.dataTable.fixedHeader-locked{background-color:white;margin-top:0 !important;margin-bottom:0 !important}table.dataTable.fixedHeader-floating{position:fixed !important}table.dataTable.fixedHeader-locked{position:absolute !important}@media print{table.fixedHeader-floating{display:none}}
  admin-Public-Admin-plugins-datatables-fixedheader-js-dataTables.fixedHeader.js: "/*!
    FixedHeader 3.1.9\n * ©2009-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n
    * @summary     FixedHeader\n * @description Fix a table's header or footer, so
    it is always visible while\n *              scrolling\n * @version     3.1.9\n
    * @file        dataTables.fixedHeader.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n
    * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2009-2021
    SpryMedia Ltd.\n *\n * This source file is free software, available under the
    following license:\n *   MIT license - http://datatables.net/license/mit\n *\n
    * This source file is distributed in the hope that it will be useful, but\n *
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n *
    or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n
    * For details please refer to: http://www.datatables.net\n */\n\n(function( factory
    ){\n\tif ( typeof define === 'function' && define.amd ) {\n\t\t// AMD\n\t\tdefine(
    ['jquery', 'datatables.net'], function ( $ ) {\n\t\t\treturn factory( $, window,
    document );\n\t\t} );\n\t}\n\telse if ( typeof exports === 'object' ) {\n\t\t//
    CommonJS\n\t\tmodule.exports = function (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot
    = window;\n\t\t\t}\n\n\t\t\tif ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net')(root,
    $).$;\n\t\t\t}\n\n\t\t\treturn factory( $, root, root.document );\n\t\t};\n\t}\n\telse
    {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function(
    $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\nvar
    _instCounter = 0;\n\nvar FixedHeader = function ( dt, config ) {\n\t// Sanity
    check - you just know it will happen\n\tif ( ! (this instanceof FixedHeader) )
    {\n\t\tthrow \"FixedHeader must be initialised with the 'new' keyword.\";\n\t}\n\n\t//
    Allow a boolean true for defaults\n\tif ( config === true ) {\n\t\tconfig = {};\n\t}\n\n\tdt
    = new DataTable.Api( dt );\n\n\tthis.c = $.extend( true, {}, FixedHeader.defaults,
    config );\n\n\tthis.s = {\n\t\tdt: dt,\n\t\tposition: {\n\t\t\ttheadTop: 0,\n\t\t\ttbodyTop:
    0,\n\t\t\ttfootTop: 0,\n\t\t\ttfootBottom: 0,\n\t\t\twidth: 0,\n\t\t\tleft: 0,\n\t\t\ttfootHeight:
    0,\n\t\t\ttheadHeight: 0,\n\t\t\twindowHeight: $(window).height(),\n\t\t\tvisible:
    true\n\t\t},\n\t\theaderMode: null,\n\t\tfooterMode: null,\n\t\tautoWidth: dt.settings()[0].oFeatures.bAutoWidth,\n\t\tnamespace:
    '.dtfc'+(_instCounter++),\n\t\tscrollLeft: {\n\t\t\theader: -1,\n\t\t\tfooter:
    -1\n\t\t},\n\t\tenable: true\n\t};\n\n\tthis.dom = {\n\t\tfloatingHeader: null,\n\t\tthead:
    $(dt.table().header()),\n\t\ttbody: $(dt.table().body()),\n\t\ttfoot: $(dt.table().footer()),\n\t\theader:
    {\n\t\t\thost: null,\n\t\t\tfloating: null,\n\t\t\tplaceholder: null\n\t\t},\n\t\tfooter:
    {\n\t\t\thost: null,\n\t\t\tfloating: null,\n\t\t\tplaceholder: null\n\t\t}\n\t};\n\n\tthis.dom.header.host
    = this.dom.thead.parent();\n\tthis.dom.footer.host = this.dom.tfoot.parent();\n\n\tvar
    dtSettings = dt.settings()[0];\n\tif ( dtSettings._fixedHeader ) {\n\t\tthrow
    \"FixedHeader already initialised on table \"+dtSettings.nTable.id;\n\t}\n\n\tdtSettings._fixedHeader
    = this;\n\n\tthis._constructor();\n};\n\n\n/*\n * Variable: FixedHeader\n * Purpose:
    \ Prototype for FixedHeader\n * Scope:    global\n */\n$.extend( FixedHeader.prototype,
    {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    *\n\t * API methods\n\t */\n\n\t/**\n\t * Kill off FH and any events\n\t */\n\tdestroy:
    function () {\n\t\tthis.s.dt.off( '.dtfc' );\n\t\t$(window).off( this.s.namespace
    );\n\n\t\tif ( this.c.header ) {\n\t\t\tthis._modeChange( 'in-place', 'header',
    true );\n\t\t}\n\n\t\tif ( this.c.footer && this.dom.tfoot.length ) {\n\t\t\tthis._modeChange(
    'in-place', 'footer', true );\n\t\t}\n\t},\n\n\t/**\n\t * Enable / disable the
    fixed elements\n\t *\n\t * @param  {boolean} enable `true` to enable, `false`
    to disable\n\t */\n\tenable: function ( enable, update )\n\t{\n\t\tthis.s.enable
    = enable;\n\n\t\tif ( update || update === undefined ) {\n\t\t\tthis._positions();\n\t\t\tthis._scroll(
    true );\n\t\t}\n\t},\n\n\t/**\n\t * Get enabled status\n\t */\n\tenabled: function
    ()\n\t{\n\t\treturn this.s.enable;\n\t},\n\t\n\t/**\n\t * Set header offset \n\t
    *\n\t * @param  {int} new value for headerOffset\n\t */\n\theaderOffset: function
    ( offset )\n\t{\n\t\tif ( offset !== undefined ) {\n\t\t\tthis.c.headerOffset
    = offset;\n\t\t\tthis.update();\n\t\t}\n\n\t\treturn this.c.headerOffset;\n\t},\n\t\n\t/**\n\t
    * Set footer offset\n\t *\n\t * @param  {int} new value for footerOffset\n\t */\n\tfooterOffset:
    function ( offset )\n\t{\n\t\tif ( offset !== undefined ) {\n\t\t\tthis.c.footerOffset
    = offset;\n\t\t\tthis.update();\n\t\t}\n\n\t\treturn this.c.footerOffset;\n\t},\n\n\t\n\t/**\n\t
    * Recalculate the position of the fixed elements and force them into place\n\t
    */\n\tupdate: function ()\n\t{\n\t\tvar table = this.s.dt.table().node();\n\n\t\tif
    ( $(table).is(':visible') ) {\n\t\t\tthis.enable( true, false );\n\t\t}\n\t\telse
    {\n\t\t\tthis.enable( false, false );\n\t\t}\n\n\t\tthis._positions();\n\t\tthis._scroll(
    true );\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * *
    * * * * * * * * *\n\t * Constructor\n\t */\n\t\n\t/**\n\t * FixedHeader constructor
    - adding the required event listeners and\n\t * simple initialisation\n\t *\n\t
    * @private\n\t */\n\t_constructor: function ()\n\t{\n\t\tvar that = this;\n\t\tvar
    dt = this.s.dt;\n\n\t\t$(window)\n\t\t\t.on( 'scroll'+this.s.namespace, function
    () {\n\t\t\t\tthat._scroll();\n\t\t\t} )\n\t\t\t.on( 'resize'+this.s.namespace,
    DataTable.util.throttle( function () {\n\t\t\t\tthat.s.position.windowHeight =
    $(window).height();\n\t\t\t\tthat.update();\n\t\t\t}, 50 ) );\n\n\t\tvar autoHeader
    = $('.fh-fixedHeader');\n\t\tif ( ! this.c.headerOffset && autoHeader.length )
    {\n\t\t\tthis.c.headerOffset = autoHeader.outerHeight();\n\t\t}\n\n\t\tvar autoFooter
    = $('.fh-fixedFooter');\n\t\tif ( ! this.c.footerOffset && autoFooter.length )
    {\n\t\t\tthis.c.footerOffset = autoFooter.outerHeight();\n\t\t}\n\n\t\tdt.on(
    'column-reorder.dt.dtfc column-visibility.dt.dtfc draw.dt.dtfc column-sizing.dt.dtfc
    responsive-display.dt.dtfc', function () {\n\t\t\tthat.update();\n\t\t} );\n\n\t\tdt.on(
    'destroy.dtfc', function () {\n\t\t\tthat.destroy();\n\t\t} );\n\n\t\tthis._positions();\n\t\tthis._scroll();\n\t},\n\n\n\t/*
    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t *
    Private methods\n\t */\n\n\t/**\n\t * Clone a fixed item to act as a place holder
    for the original element\n\t * which is moved into a clone of the table element,
    and moved around the\n\t * document to give the fixed effect.\n\t *\n\t * @param
    \ {string}  item  'header' or 'footer'\n\t * @param  {boolean} force Force the
    clone to happen, or allow automatic\n\t *   decision (reuse existing if available)\n\t
    * @private\n\t */\n\t_clone: function ( item, force )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar
    itemDom = this.dom[ item ];\n\t\tvar itemElement = item === 'header' ?\n\t\t\tthis.dom.thead
    :\n\t\t\tthis.dom.tfoot;\n\n\t\tif ( ! force && itemDom.floating ) {\n\t\t\t//
    existing floating element - reuse it\n\t\t\titemDom.floating.removeClass( 'fixedHeader-floating
    fixedHeader-locked' );\n\t\t}\n\t\telse {\n\t\t\tif ( itemDom.floating ) {\n\t\t\t\titemDom.placeholder.remove();\n\t\t\t\tthis._unsize(
    item );\n\t\t\t\titemDom.floating.children().detach();\n\t\t\t\titemDom.floating.remove();\n\t\t\t}\n\n\t\t\titemDom.floating
    = $( dt.table().node().cloneNode( false ) )\n\t\t\t\t.css( 'table-layout', 'fixed'
    )\n\t\t\t\t.attr( 'aria-hidden', 'true' )\n\t\t\t\t.removeAttr( 'id' )\n\t\t\t\t.append(
    itemElement )\n\t\t\t\t.appendTo( 'body' );\n\n\t\t\t// Insert a fake thead/tfoot
    into the DataTable to stop it jumping around\n\t\t\titemDom.placeholder = itemElement.clone(
    false );\n\t\t\titemDom.placeholder\n\t\t\t\t.find( '*[id]' )\n\t\t\t\t.removeAttr(
    'id' );\n\n\t\t\titemDom.host.prepend( itemDom.placeholder );\n\n\t\t\t// Clone
    widths\n\t\t\tthis._matchWidths( itemDom.placeholder, itemDom.floating );\n\t\t}\n\t},\n\n\t/**\n\t
    * Copy widths from the cells in one element to another. This is required\n\t *
    for the footer as the footer in the main table takes its sizes from the\n\t *
    header columns. That isn't present in the footer so to have it still\n\t * align
    correctly, the sizes need to be copied over. It is also required\n\t * for the
    header when auto width is not enabled\n\t *\n\t * @param  {jQuery} from Copy widths
    from\n\t * @param  {jQuery} to   Copy widths to\n\t * @private\n\t */\n\t_matchWidths:
    function ( from, to ) {\n\t\tvar get = function ( name ) {\n\t\t\treturn $(name,
    from)\n\t\t\t\t.map( function () {\n\t\t\t\t\treturn $(this).css('width').replace(/[^\\d\\.]/g,
    '') * 1;\n\t\t\t\t} ).toArray();\n\t\t};\n\n\t\tvar set = function ( name, toWidths
    ) {\n\t\t\t$(name, to).each( function ( i ) {\n\t\t\t\t$(this).css( {\n\t\t\t\t\twidth:
    toWidths[i],\n\t\t\t\t\tminWidth: toWidths[i]\n\t\t\t\t} );\n\t\t\t} );\n\t\t};\n\n\t\tvar
    thWidths = get( 'th' );\n\t\tvar tdWidths = get( 'td' );\n\n\t\tset( 'th', thWidths
    );\n\t\tset( 'td', tdWidths );\n\t},\n\n\t/**\n\t * Remove assigned widths from
    the cells in an element. This is required\n\t * when inserting the footer back
    into the main table so the size is defined\n\t * by the header columns and also
    when auto width is disabled in the\n\t * DataTable.\n\t *\n\t * @param  {string}
    item The `header` or `footer`\n\t * @private\n\t */\n\t_unsize: function ( item
    ) {\n\t\tvar el = this.dom[ item ].floating;\n\n\t\tif ( el && (item === 'footer'
    || (item === 'header' && ! this.s.autoWidth)) ) {\n\t\t\t$('th, td', el).css(
    {\n\t\t\t\twidth: '',\n\t\t\t\tminWidth: ''\n\t\t\t} );\n\t\t}\n\t\telse if (
    el && item === 'header' ) {\n\t\t\t$('th, td', el).css( 'min-width', '' );\n\t\t}\n\t},\n\n\t/**\n\t
    * Reposition the floating elements to take account of horizontal page\n\t * scroll\n\t
    *\n\t * @param  {string} item       The `header` or `footer`\n\t * @param  {int}
    \   scrollLeft Document scrollLeft\n\t * @private\n\t */\n\t_horizontal: function
    ( item, scrollLeft )\n\t{\n\t\tvar itemDom = this.dom[ item ];\n\t\tvar position
    = this.s.position;\n\t\tvar lastScrollLeft = this.s.scrollLeft;\n\n\t\tif ( itemDom.floating
    && lastScrollLeft[ item ] !== scrollLeft ) {\n\t\t\titemDom.floating.css( 'left',
    position.left - scrollLeft );\n\n\t\t\tlastScrollLeft[ item ] = scrollLeft;\n\t\t}\n\t},\n\n\t/**\n\t
    * Change from one display mode to another. Each fixed item can be in one\n\t *
    of:\n\t *\n\t * * `in-place` - In the main DataTable\n\t * * `in` - Floating over
    the DataTable\n\t * * `below` - (Header only) Fixed to the bottom of the table
    body\n\t * * `above` - (Footer only) Fixed to the top of the table body\n\t *
    \n\t * @param  {string}  mode        Mode that the item should be shown in\n\t
    * @param  {string}  item        'header' or 'footer'\n\t * @param  {boolean} forceChange
    Force a redraw of the mode, even if already\n\t *     in that mode.\n\t * @private\n\t
    */\n\t_modeChange: function ( mode, item, forceChange )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar
    itemDom = this.dom[ item ];\n\t\tvar position = this.s.position;\n\n\t\t// It
    isn't trivial to add a !important css attribute...\n\t\tvar importantWidth = function
    (w) {\n\t\t\titemDom.floating.attr('style', function(i,s) {\n\t\t\t\treturn (s
    || '') + 'width: '+w+'px !important;';\n\t\t\t});\n\t\t};\n\n\t\t// Record focus.
    Browser's will cause input elements to loose focus if\n\t\t// they are inserted
    else where in the doc\n\t\tvar tablePart = this.dom[ item==='footer' ? 'tfoot'
    : 'thead' ];\n\t\tvar focus = $.contains( tablePart[0], document.activeElement
    ) ?\n\t\t\tdocument.activeElement :\n\t\t\tnull;\n\t\t\n\t\tif ( focus ) {\n\t\t\tfocus.blur();\n\t\t}\n\n\t\tif
    ( mode === 'in-place' ) {\n\t\t\t// Insert the header back into the table's real
    header\n\t\t\tif ( itemDom.placeholder ) {\n\t\t\t\titemDom.placeholder.remove();\n\t\t\t\titemDom.placeholder
    = null;\n\t\t\t}\n\n\t\t\tthis._unsize( item );\n\n\t\t\tif ( item === 'header'
    ) {\n\t\t\t\titemDom.host.prepend( tablePart );\n\t\t\t}\n\t\t\telse {\n\t\t\t\titemDom.host.append(
    tablePart );\n\t\t\t}\n\n\t\t\tif ( itemDom.floating ) {\n\t\t\t\titemDom.floating.remove();\n\t\t\t\titemDom.floating
    = null;\n\t\t\t}\n\t\t}\n\t\telse if ( mode === 'in' ) {\n\t\t\t// Remove the
    header from the read header and insert into a fixed\n\t\t\t// positioned floating
    table clone\n\t\t\tthis._clone( item, forceChange );\n\n\t\t\titemDom.floating\n\t\t\t\t.addClass(
    'fixedHeader-floating' )\n\t\t\t\t.css( item === 'header' ? 'top' : 'bottom',
    this.c[item+'Offset'] )\n\t\t\t\t.css( 'left', position.left+'px' );\n\n\t\t\timportantWidth(position.width);\n\n\t\t\tif
    ( item === 'footer' ) {\n\t\t\t\titemDom.floating.css( 'top', '' );\n\t\t\t}\n\t\t}\n\t\telse
    if ( mode === 'below' ) { // only used for the header\n\t\t\t// Fix the position
    of the floating header at base of the table body\n\t\t\tthis._clone( item, forceChange
    );\n\n\t\t\titemDom.floating\n\t\t\t\t.addClass( 'fixedHeader-locked' )\n\t\t\t\t.css(
    'top', position.tfootTop - position.theadHeight )\n\t\t\t\t.css( 'left', position.left+'px'
    );\n\n\t\t\timportantWidth(position.width);\n\t\t}\n\t\telse if ( mode === 'above'
    ) { // only used for the footer\n\t\t\t// Fix the position of the floating footer
    at top of the table body\n\t\t\tthis._clone( item, forceChange );\n\n\t\t\titemDom.floating\n\t\t\t\t.addClass(
    'fixedHeader-locked' )\n\t\t\t\t.css( 'top', position.tbodyTop )\n\t\t\t\t.css(
    'left', position.left+'px' );\n\n\t\t\timportantWidth(position.width);\n\t\t}\n\n\t\t//
    Restore focus if it was lost\n\t\tif ( focus && focus !== document.activeElement
    ) {\n\t\t\tsetTimeout( function () {\n\t\t\t\tfocus.focus();\n\t\t\t}, 10 );\n\t\t}\n\n\t\tthis.s.scrollLeft.header
    = -1;\n\t\tthis.s.scrollLeft.footer = -1;\n\t\tthis.s[item+'Mode'] = mode;\n\t},\n\n\t/**\n\t
    * Cache the positional information that is required for the mode\n\t * calculations
    that FixedHeader performs.\n\t *\n\t * @private\n\t */\n\t_positions: function
    ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar table = dt.table();\n\t\tvar position
    = this.s.position;\n\t\tvar dom = this.dom;\n\t\tvar tableNode = $(table.node());\n\n\t\t//
    Need to use the header and footer that are in the main table,\n\t\t// regardless
    of if they are clones, since they hold the positions we\n\t\t// want to measure
    from\n\t\tvar thead = tableNode.children('thead');\n\t\tvar tfoot = tableNode.children('tfoot');\n\t\tvar
    tbody = dom.tbody;\n\n\t\tposition.visible = tableNode.is(':visible');\n\t\tposition.width
    = tableNode.outerWidth();\n\t\tposition.left = tableNode.offset().left;\n\t\tposition.theadTop
    = thead.offset().top;\n\t\tposition.tbodyTop = tbody.offset().top;\n\t\tposition.tbodyHeight
    = tbody.outerHeight();\n\t\tposition.theadHeight = position.tbodyTop - position.theadTop;\n\n\t\tif
    ( tfoot.length ) {\n\t\t\tposition.tfootTop = tfoot.offset().top;\n\t\t\tposition.tfootBottom
    = position.tfootTop + tfoot.outerHeight();\n\t\t\tposition.tfootHeight = position.tfootBottom
    - position.tfootTop;\n\t\t}\n\t\telse {\n\t\t\tposition.tfootTop = position.tbodyTop
    + tbody.outerHeight();\n\t\t\tposition.tfootBottom = position.tfootTop;\n\t\t\tposition.tfootHeight
    = position.tfootTop;\n\t\t}\n\t},\n\n\n\t/**\n\t * Mode calculation - determine
    what mode the fixed items should be placed\n\t * into.\n\t *\n\t * @param  {boolean}
    forceChange Force a redraw of the mode, even if already\n\t *     in that mode.\n\t
    * @private\n\t */\n\t_scroll: function ( forceChange )\n\t{\n\t\tvar windowTop
    = $(document).scrollTop();\n\t\tvar windowLeft = $(document).scrollLeft();\n\t\tvar
    position = this.s.position;\n\t\tvar headerMode, footerMode;\n\n\t\tif ( this.c.header
    ) {\n\t\t\tif ( ! this.s.enable ) {\n\t\t\t\theaderMode = 'in-place';\n\t\t\t}\n\t\t\telse
    if ( ! position.visible || windowTop <= position.theadTop - this.c.headerOffset
    ) {\n\t\t\t\theaderMode = 'in-place';\n\t\t\t}\n\t\t\telse if ( windowTop <= position.tfootTop
    - position.theadHeight - this.c.headerOffset ) {\n\t\t\t\theaderMode = 'in';\n\t\t\t}\n\t\t\telse
    {\n\t\t\t\theaderMode = 'below';\n\t\t\t}\n\n\t\t\tif ( forceChange || headerMode
    !== this.s.headerMode ) {\n\t\t\t\tthis._modeChange( headerMode, 'header', forceChange
    );\n\t\t\t}\n\n\t\t\tthis._horizontal( 'header', windowLeft );\n\t\t}\n\n\t\tif
    ( this.c.footer && this.dom.tfoot.length ) {\n\t\t\tif ( ! this.s.enable ) {\n\t\t\t\tfooterMode
    = 'in-place';\n\t\t\t}\n\t\t\telse if ( ! position.visible || windowTop + position.windowHeight
    >= position.tfootBottom + this.c.footerOffset ) {\n\t\t\t\tfooterMode = 'in-place';\n\t\t\t}\n\t\t\telse
    if ( position.windowHeight + windowTop > position.tbodyTop + position.tfootHeight
    + this.c.footerOffset ) {\n\t\t\t\tfooterMode = 'in';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfooterMode
    = 'above';\n\t\t\t}\n\n\t\t\tif ( forceChange || footerMode !== this.s.footerMode
    ) {\n\t\t\t\tthis._modeChange( footerMode, 'footer', forceChange );\n\t\t\t}\n\n\t\t\tthis._horizontal(
    'footer', windowLeft );\n\t\t}\n\t}\n} );\n\n\n/**\n * Version\n * @type {String}\n
    * @static\n */\nFixedHeader.version = \"3.1.9\";\n\n/**\n * Defaults\n * @type
    {Object}\n * @static\n */\nFixedHeader.defaults = {\n\theader: true,\n\tfooter:
    false,\n\theaderOffset: 0,\n\tfooterOffset: 0\n};\n\n\n/* * * * * * * * * * *
    * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables interfaces\n
    */\n\n// Attach for constructor access\n$.fn.dataTable.FixedHeader = FixedHeader;\n$.fn.DataTable.FixedHeader
    = FixedHeader;\n\n\n// DataTables creation - check if the FixedHeader option has
    been defined on the\n// table and if so, initialise\n$(document).on( 'init.dt.dtfh',
    function (e, settings, json) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tvar
    init = settings.oInit.fixedHeader;\n\tvar defaults = DataTable.defaults.fixedHeader;\n\n\tif
    ( (init || defaults) && ! settings._fixedHeader ) {\n\t\tvar opts = $.extend(
    {}, defaults, init );\n\n\t\tif ( init !== false ) {\n\t\t\tnew FixedHeader( settings,
    opts );\n\t\t}\n\t}\n} );\n\n// DataTables API methods\nDataTable.Api.register(
    'fixedHeader()', function () {} );\n\nDataTable.Api.register( 'fixedHeader.adjust()',
    function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tvar fh
    = ctx._fixedHeader;\n\n\t\tif ( fh ) {\n\t\t\tfh.update();\n\t\t}\n\t} );\n} );\n\nDataTable.Api.register(
    'fixedHeader.enable()', function ( flag ) {\n\treturn this.iterator( 'table',
    function ( ctx ) {\n\t\tvar fh = ctx._fixedHeader;\n\n\t\tflag = ( flag !== undefined
    ? flag : true );\n\t\tif ( fh && flag !== fh.enabled() ) {\n\t\t\tfh.enable( flag
    );\n\t\t}\n\t} );\n} );\n\nDataTable.Api.register( 'fixedHeader.enabled()', function
    () {\n\tif ( this.context.length ) {\n\t\tvar fh = this.context[0]._fixedHeader;\n\n\t\tif
    ( fh ) {\n\t\t\treturn fh.enabled();\n\t\t}\n\t}\n\n\treturn false;\n} );\n\nDataTable.Api.register(
    'fixedHeader.disable()', function ( ) {\n\treturn this.iterator( 'table', function
    ( ctx ) {\n\t\tvar fh = ctx._fixedHeader;\n\n\t\tif ( fh && fh.enabled() ) {\n\t\t\tfh.enable(
    false );\n\t\t}\n\t} );\n} );\n\n$.each( ['header', 'footer'], function ( i, el
    ) {\n\tDataTable.Api.register( 'fixedHeader.'+el+'Offset()', function ( offset
    ) {\n\t\tvar ctx = this.context;\n\n\t\tif ( offset === undefined ) {\n\t\t\treturn
    ctx.length && ctx[0]._fixedHeader ?\n\t\t\t\tctx[0]._fixedHeader[el +'Offset']()
    :\n\t\t\t\tundefined;\n\t\t}\n\n\t\treturn this.iterator( 'table', function (
    ctx ) {\n\t\t\tvar fh = ctx._fixedHeader;\n\n\t\t\tif ( fh ) {\n\t\t\t\tfh[ el
    +'Offset' ]( offset );\n\t\t\t}\n\t\t} );\n\t} );\n} );\n\n\nreturn FixedHeader;\n}));\n"
  admin-Public-Admin-plugins-datatables-fixedheader-js-dataTables.fixedHeader.min.js: |
    /*!
     FixedHeader 3.1.9
     ©2009-2021 SpryMedia Ltd - datatables.net/license
    */
    (function(d){"function"===typeof define&&define.amd?define(["jquery","datatables.net"],function(g){return d(g,window,document)}):"object"===typeof exports?module.exports=function(g,j){g||(g=window);if(!j||!j.fn.dataTable)j=require("datatables.net")(g,j).$;return d(j,g,g.document)}:d(jQuery,window,document)})(function(d,g,j,k){var i=d.fn.dataTable,l=0,h=function(a,b){if(!(this instanceof h))throw"FixedHeader must be initialised with the 'new' keyword.";!0===b&&(b={});a=new i.Api(a);this.c=d.extend(!0,
    {},h.defaults,b);this.s={dt:a,position:{theadTop:0,tbodyTop:0,tfootTop:0,tfootBottom:0,width:0,left:0,tfootHeight:0,theadHeight:0,windowHeight:d(g).height(),visible:!0},headerMode:null,footerMode:null,autoWidth:a.settings()[0].oFeatures.bAutoWidth,namespace:".dtfc"+l++,scrollLeft:{header:-1,footer:-1},enable:!0};this.dom={floatingHeader:null,thead:d(a.table().header()),tbody:d(a.table().body()),tfoot:d(a.table().footer()),header:{host:null,floating:null,placeholder:null},footer:{host:null,floating:null,
    placeholder:null}};this.dom.header.host=this.dom.thead.parent();this.dom.footer.host=this.dom.tfoot.parent();var e=a.settings()[0];if(e._fixedHeader)throw"FixedHeader already initialised on table "+e.nTable.id;e._fixedHeader=this;this._constructor()};d.extend(h.prototype,{destroy:function(){this.s.dt.off(".dtfc");d(g).off(this.s.namespace);this.c.header&&this._modeChange("in-place","header",!0);this.c.footer&&this.dom.tfoot.length&&this._modeChange("in-place","footer",!0)},enable:function(a,b){this.s.enable=
    a;if(b||b===k)this._positions(),this._scroll(!0)},enabled:function(){return this.s.enable},headerOffset:function(a){a!==k&&(this.c.headerOffset=a,this.update());return this.c.headerOffset},footerOffset:function(a){a!==k&&(this.c.footerOffset=a,this.update());return this.c.footerOffset},update:function(){var a=this.s.dt.table().node();d(a).is(":visible")?this.enable(!0,!1):this.enable(!1,!1);this._positions();this._scroll(!0)},_constructor:function(){var a=this,b=this.s.dt;d(g).on("scroll"+this.s.namespace,
    function(){a._scroll()}).on("resize"+this.s.namespace,i.util.throttle(function(){a.s.position.windowHeight=d(g).height();a.update()},50));var e=d(".fh-fixedHeader");!this.c.headerOffset&&e.length&&(this.c.headerOffset=e.outerHeight());e=d(".fh-fixedFooter");!this.c.footerOffset&&e.length&&(this.c.footerOffset=e.outerHeight());b.on("column-reorder.dt.dtfc column-visibility.dt.dtfc draw.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc",function(){a.update()});b.on("destroy.dtfc",function(){a.destroy()});
    this._positions();this._scroll()},_clone:function(a,b){var e=this.s.dt,c=this.dom[a],f="header"===a?this.dom.thead:this.dom.tfoot;!b&&c.floating?c.floating.removeClass("fixedHeader-floating fixedHeader-locked"):(c.floating&&(c.placeholder.remove(),this._unsize(a),c.floating.children().detach(),c.floating.remove()),c.floating=d(e.table().node().cloneNode(!1)).css("table-layout","fixed").attr("aria-hidden","true").removeAttr("id").append(f).appendTo("body"),c.placeholder=f.clone(!1),c.placeholder.find("*[id]").removeAttr("id"),
    c.host.prepend(c.placeholder),this._matchWidths(c.placeholder,c.floating))},_matchWidths:function(a,b){var e=function(b){return d(b,a).map(function(){return 1*d(this).css("width").replace(/[^\d\.]/g,"")}).toArray()},c=function(a,c){d(a,b).each(function(a){d(this).css({width:c[a],minWidth:c[a]})})},f=e("th"),e=e("td");c("th",f);c("td",e)},_unsize:function(a){var b=this.dom[a].floating;b&&("footer"===a||"header"===a&&!this.s.autoWidth)?d("th, td",b).css({width:"",minWidth:""}):b&&"header"===a&&d("th, td",
    b).css("min-width","")},_horizontal:function(a,b){var e=this.dom[a],c=this.s.position,d=this.s.scrollLeft;e.floating&&d[a]!==b&&(e.floating.css("left",c.left-b),d[a]=b)},_modeChange:function(a,b,e){var c=this.dom[b],f=this.s.position,g=function(a){c.floating.attr("style",function(b,c){return(c||"")+"width: "+a+"px !important;"})},i=this.dom["footer"===b?"tfoot":"thead"],h=d.contains(i[0],j.activeElement)?j.activeElement:null;h&&h.blur();if("in-place"===a){if(c.placeholder&&(c.placeholder.remove(),
    c.placeholder=null),this._unsize(b),"header"===b?c.host.prepend(i):c.host.append(i),c.floating)c.floating.remove(),c.floating=null}else"in"===a?(this._clone(b,e),c.floating.addClass("fixedHeader-floating").css("header"===b?"top":"bottom",this.c[b+"Offset"]).css("left",f.left+"px"),g(f.width),"footer"===b&&c.floating.css("top","")):"below"===a?(this._clone(b,e),c.floating.addClass("fixedHeader-locked").css("top",f.tfootTop-f.theadHeight).css("left",f.left+"px"),g(f.width)):"above"===a&&(this._clone(b,
    e),c.floating.addClass("fixedHeader-locked").css("top",f.tbodyTop).css("left",f.left+"px"),g(f.width));h&&h!==j.activeElement&&setTimeout(function(){h.focus()},10);this.s.scrollLeft.header=-1;this.s.scrollLeft.footer=-1;this.s[b+"Mode"]=a},_positions:function(){var a=this.s.dt.table(),b=this.s.position,e=this.dom,a=d(a.node()),c=a.children("thead"),f=a.children("tfoot"),e=e.tbody;b.visible=a.is(":visible");b.width=a.outerWidth();b.left=a.offset().left;b.theadTop=c.offset().top;b.tbodyTop=e.offset().top;
    b.tbodyHeight=e.outerHeight();b.theadHeight=b.tbodyTop-b.theadTop;f.length?(b.tfootTop=f.offset().top,b.tfootBottom=b.tfootTop+f.outerHeight(),b.tfootHeight=b.tfootBottom-b.tfootTop):(b.tfootTop=b.tbodyTop+e.outerHeight(),b.tfootBottom=b.tfootTop,b.tfootHeight=b.tfootTop)},_scroll:function(a){var b=d(j).scrollTop(),e=d(j).scrollLeft(),c=this.s.position,f;this.c.header&&(f=this.s.enable?!c.visible||b<=c.theadTop-this.c.headerOffset?"in-place":b<=c.tfootTop-c.theadHeight-this.c.headerOffset?"in":"below":
    "in-place",(a||f!==this.s.headerMode)&&this._modeChange(f,"header",a),this._horizontal("header",e));this.c.footer&&this.dom.tfoot.length&&(b=this.s.enable?!c.visible||b+c.windowHeight>=c.tfootBottom+this.c.footerOffset?"in-place":c.windowHeight+b>c.tbodyTop+c.tfootHeight+this.c.footerOffset?"in":"above":"in-place",(a||b!==this.s.footerMode)&&this._modeChange(b,"footer",a),this._horizontal("footer",e))}});h.version="3.1.9";h.defaults={header:!0,footer:!1,headerOffset:0,footerOffset:0};d.fn.dataTable.FixedHeader=
    h;d.fn.DataTable.FixedHeader=h;d(j).on("init.dt.dtfh",function(a,b){if("dt"===a.namespace){var e=b.oInit.fixedHeader,c=i.defaults.fixedHeader;if((e||c)&&!b._fixedHeader)c=d.extend({},c,e),!1!==e&&new h(b,c)}});i.Api.register("fixedHeader()",function(){});i.Api.register("fixedHeader.adjust()",function(){return this.iterator("table",function(a){(a=a._fixedHeader)&&a.update()})});i.Api.register("fixedHeader.enable()",function(a){return this.iterator("table",function(b){b=b._fixedHeader;a=a!==k?a:!0;
    b&&a!==b.enabled()&&b.enable(a)})});i.Api.register("fixedHeader.enabled()",function(){if(this.context.length){var a=this.context[0]._fixedHeader;if(a)return a.enabled()}return!1});i.Api.register("fixedHeader.disable()",function(){return this.iterator("table",function(a){(a=a._fixedHeader)&&a.enabled()&&a.enable(!1)})});d.each(["header","footer"],function(a,b){i.Api.register("fixedHeader."+b+"Offset()",function(a){var c=this.context;return a===k?c.length&&c[0]._fixedHeader?c[0]._fixedHeader[b+"Offset"]():
    k:this.iterator("table",function(c){if(c=c._fixedHeader)c[b+"Offset"](a)})})});return h});
  admin-Public-Admin-plugins-datatables-fixedheader-js-fixedHeader.bootstrap4.js: "/*!
    Bootstrap 4 styling wrapper for FixedHeader\n * ©2018 SpryMedia Ltd - datatables.net/license\n
    */\n\n(function( factory ){\n\tif ( typeof define === 'function' && define.amd
    ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'datatables.net-bs4', 'datatables.net-fixedheader'],
    function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse
    if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tmodule.exports = function
    (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot = window;\n\t\t\t}\n\n\t\t\tif
    ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net-bs4')(root,
    $).$;\n\t\t\t}\n\n\t\t\tif ( ! $.fn.dataTable.FixedHeader ) {\n\t\t\t\trequire('datatables.net-fixedheader')(root,
    $);\n\t\t\t}\n\n\t\t\treturn factory( $, root, root.document );\n\t\t};\n\t}\n\telse
    {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function(
    $, window, document, undefined ) {\n\nreturn $.fn.dataTable;\n\n}));"
  admin-Public-Admin-plugins-datatables-fixedheader-js-fixedHeader.bootstrap4.min.js: |
    /*!
     Bootstrap 4 styling wrapper for FixedHeader
     ©2018 SpryMedia Ltd - datatables.net/license
    */
    (function(c){"function"===typeof define&&define.amd?define(["jquery","datatables.net-bs4","datatables.net-fixedheader"],function(a){return c(a,window,document)}):"object"===typeof exports?module.exports=function(a,b){a||(a=window);if(!b||!b.fn.dataTable)b=require("datatables.net-bs4")(a,b).$;b.fn.dataTable.FixedHeader||require("datatables.net-fixedheader")(a,b);return c(b,a,a.document)}:c(jQuery,window,document)})(function(c){return c.fn.dataTable});
  admin-Public-Admin-plugins-datatables-rowgroup-css-rowGroup.bootstrap4.css: |
    table.dataTable tr.dtrg-group td {
      background-color: #e0e0e0;
    }

    table.dataTable tr.dtrg-group.dtrg-level-0 td {
      font-weight: bold;
    }

    table.dataTable tr.dtrg-group.dtrg-level-1 td,
    table.dataTable tr.dtrg-group.dtrg-level-2 td,
    table.dataTable tr.dtrg-group.dtrg-level-3 td,
    table.dataTable tr.dtrg-group.dtrg-level-4 td,
    table.dataTable tr.dtrg-group.dtrg-level-5 td {
      background-color: #f0f0f0;
      padding-top: 0.25em;
      padding-bottom: 0.25em;
      padding-left: 2em;
      font-size: 0.9em;
    }

    table.dataTable tr.dtrg-group.dtrg-level-2 td {
      background-color: #f3f3f3;
      padding-left: 2.5em;
    }

    table.dataTable tr.dtrg-group.dtrg-level-3 td {
      background-color: #f3f3f3;
      padding-left: 3em;
    }

    table.dataTable tr.dtrg-group.dtrg-level-4 td {
      background-color: #f3f3f3;
      padding-left: 3.5em;
    }

    table.dataTable tr.dtrg-group.dtrg-level-5 td {
      background-color: #f3f3f3;
      padding-left: 4em;
    }
  admin-Public-Admin-plugins-datatables-rowgroup-css-rowGroup.bootstrap4.min.css: |
    table.dataTable tr.dtrg-group td{background-color:#e0e0e0}table.dataTable tr.dtrg-group.dtrg-level-0 td{font-weight:bold}table.dataTable tr.dtrg-group.dtrg-level-1 td,table.dataTable tr.dtrg-group.dtrg-level-2 td,table.dataTable tr.dtrg-group.dtrg-level-3 td,table.dataTable tr.dtrg-group.dtrg-level-4 td,table.dataTable tr.dtrg-group.dtrg-level-5 td{background-color:#f0f0f0;padding-top:.25em;padding-bottom:.25em;padding-left:2em;font-size:.9em}table.dataTable tr.dtrg-group.dtrg-level-2 td{background-color:#f3f3f3;padding-left:2.5em}table.dataTable tr.dtrg-group.dtrg-level-3 td{background-color:#f3f3f3;padding-left:3em}table.dataTable tr.dtrg-group.dtrg-level-4 td{background-color:#f3f3f3;padding-left:3.5em}table.dataTable tr.dtrg-group.dtrg-level-5 td{background-color:#f3f3f3;padding-left:4em}
  admin-Public-Admin-plugins-datatables-rowgroup-js-dataTables.rowGroup.js: "/*! RowGroup
    1.1.3\n * ©2017-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary
    \    RowGroup\n * @description RowGrouping for DataTables\n * @version     1.1.3\n
    * @file        dataTables.rowGroup.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n
    * @contact     datatables.net\n * @copyright   Copyright 2017-2021 SpryMedia Ltd.\n
    *\n * This source file is free software, available under the following license:\n
    *   MIT license - http://datatables.net/license/mit\n *\n * This source file is
    distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY;
    without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR
    PURPOSE. See the license files for details.\n *\n * For details please refer to:
    http://www.datatables.net\n */\n\n(function( factory ){\n\tif ( typeof define
    === 'function' && define.amd ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'datatables.net'],
    function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse
    if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tmodule.exports = function
    (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot = window;\n\t\t\t}\n\n\t\t\tif
    ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net')(root, $).$;\n\t\t\t}\n\n\t\t\treturn
    factory( $, root, root.document );\n\t\t};\n\t}\n\telse {\n\t\t// Browser\n\t\tfactory(
    jQuery, window, document );\n\t}\n}(function( $, window, document, undefined )
    {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\nvar RowGroup = function
    ( dt, opts ) {\n\t// Sanity check that we are using DataTables 1.10 or newer\n\tif
    ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.8' ) ) {\n\t\tthrow
    'RowGroup requires DataTables 1.10.8 or newer';\n\t}\n\n\t// User and defaults
    configuration object\n\tthis.c = $.extend( true, {},\n\t\tDataTable.defaults.rowGroup,\n\t\tRowGroup.defaults,\n\t\topts\n\t);\n\n\t//
    Internal settings\n\tthis.s = {\n\t\tdt: new DataTable.Api( dt )\n\t};\n\n\t//
    DOM items\n\tthis.dom = {\n\n\t};\n\n\t// Check if row grouping has already been
    initialised on this table\n\tvar settings = this.s.dt.settings()[0];\n\tvar existing
    = settings.rowGroup;\n\tif ( existing ) {\n\t\treturn existing;\n\t}\n\n\tsettings.rowGroup
    = this;\n\tthis._constructor();\n};\n\n\n$.extend( RowGroup.prototype, {\n\t/*
    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t
    * API methods for DataTables API interface\n\t */\n\n\t/**\n\t * Get/set the grouping
    data source - need to call draw after this is\n\t * executed as a setter\n\t *
    @returns string~RowGroup\n\t */\n\tdataSrc: function ( val )\n\t{\n\t\tif ( val
    === undefined ) {\n\t\t\treturn this.c.dataSrc;\n\t\t}\n\n\t\tvar dt = this.s.dt;\n\n\t\tthis.c.dataSrc
    = val;\n\n\t\t$(dt.table().node()).triggerHandler( 'rowgroup-datasrc.dt', [ dt,
    val ] );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Disable - need to call draw
    after this is executed\n\t * @returns RowGroup\n\t */\n\tdisable: function ()\n\t{\n\t\tthis.c.enable
    = false;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Enable - need to call draw after
    this is executed\n\t * @returns RowGroup\n\t */\n\tenable: function ( flag )\n\t{\n\t\tif
    ( flag === false ) {\n\t\t\treturn this.disable();\n\t\t}\n\n\t\tthis.c.enable
    = true;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get enabled flag\n\t * @returns
    boolean\n\t */\n\tenabled: function ()\n\t{\n\t\treturn this.c.enable;\n\t},\n\n\n\t/*
    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t
    * Constructor\n\t */\n\t_constructor: function ()\n\t{\n\t\tvar that = this;\n\t\tvar
    dt = this.s.dt;\n\t\tvar hostSettings = dt.settings()[0];\n\n\t\tdt.on( 'draw.dtrg',
    function (e, s) {\n\t\t\tif ( that.c.enable && hostSettings === s ) {\n\t\t\t\tthat._draw();\n\t\t\t}\n\t\t}
    );\n\n\t\tdt.on( 'column-visibility.dt.dtrg responsive-resize.dt.dtrg', function
    () {\n\t\t\tthat._adjustColspan();\n\t\t} );\n\n\t\tdt.on( 'destroy', function
    () {\n\t\t\tdt.off( '.dtrg' );\n\t\t} );\n\t},\n\n\n\t/* * * * * * * * * * * *
    * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t
    */\n\n\t/**\n\t * Adjust column span when column visibility changes\n\t * @private\n\t
    */\n\t_adjustColspan: function ()\n\t{\n\t\t$( 'tr.'+this.c.className, this.s.dt.table().body()
    ).find('td:visible')\n\t\t\t.attr( 'colspan', this._colspan() );\n\t},\n\n\t/**\n\t
    * Get the number of columns that a grouping row should span\n\t * @private\n\t
    */\n\t_colspan: function ()\n\t{\n\t\treturn this.s.dt.columns().visible().reduce(
    function (a, b) {\n\t\t\treturn a + b;\n\t\t}, 0 );\n\t},\n\n\n\t/**\n\t * Update
    function that is called whenever we need to draw the grouping rows.\n\t * This
    is basically a bootstrap for the self iterative _group and _groupDisplay\n\t *
    methods\n\t * @private\n\t */\n\t_draw: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar
    groupedRows = this._group( 0, dt.rows( { page: 'current' } ).indexes() );\n\n\t\tthis._groupDisplay(
    0, groupedRows );\n\t},\n\n\t/**\n\t * Get the grouping information from a data
    set (index) of rows\n\t * @param {number} level Nesting level\n\t * @param {DataTables.Api}
    rows API of the rows to consider for this group\n\t * @returns {object[]} Nested
    grouping information - it is structured like this:\n\t *\t{\n\t *\t\tdataPoint:
    'Edinburgh',\n\t *\t\trows: [ 1,2,3,4,5,6,7 ],\n\t *\t\tchildren: [ {\n\t *\t\t\tdataPoint:
    'developer'\n\t *\t\t\trows: [ 1, 2, 3 ]\n\t *\t\t},\n\t *\t\t{\n\t *\t\t\tdataPoint:
    'support',\n\t *\t\t\trows: [ 4, 5, 6, 7 ]\n\t *\t\t} ]\n\t *\t}\n\t * @private\n\t
    */\n\t_group: function ( level, rows ) {\n\t\tvar fns = Array.isArray( this.c.dataSrc
    ) ? this.c.dataSrc : [ this.c.dataSrc ];\n\t\tvar fn = DataTable.ext.oApi._fnGetObjectDataFn(
    fns[ level ] );\n\t\tvar dt = this.s.dt;\n\t\tvar group, last;\n\t\tvar data =
    [];\n\t\tvar that = this;\n\n\t\tfor ( var i=0, ien=rows.length ; i<ien ; i++
    ) {\n\t\t\tvar rowIndex = rows[i];\n\t\t\tvar rowData = dt.row( rowIndex ).data();\n\t\t\tvar
    group = fn( rowData );\n\n\t\t\tif ( group === null || group === undefined ) {\n\t\t\t\tgroup
    = that.c.emptyDataGroup;\n\t\t\t}\n\t\t\t\n\t\t\tif ( last === undefined || group
    !== last ) {\n\t\t\t\tdata.push( {\n\t\t\t\t\tdataPoint: group,\n\t\t\t\t\trows:
    []\n\t\t\t\t} );\n\n\t\t\t\tlast = group;\n\t\t\t}\n\n\t\t\tdata[ data.length-1
    ].rows.push( rowIndex );\n\t\t}\n\n\t\tif ( fns[ level+1 ] !== undefined ) {\n\t\t\tfor
    ( var i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t\t\tdata[i].children = this._group(
    level+1, data[i].rows );\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t},\n\n\t/**\n\t
    * Row group display - insert the rows into the document\n\t * @param {number}
    level Nesting level\n\t * @param {object[]} groups Takes the nested array from
    `_group`\n\t * @private\n\t */\n\t_groupDisplay: function ( level, groups )\n\t{\n\t\tvar
    dt = this.s.dt;\n\t\tvar display;\n\t\n\t\tfor ( var i=0, ien=groups.length ;
    i<ien ; i++ ) {\n\t\t\tvar group = groups[i];\n\t\t\tvar groupName = group.dataPoint;\n\t\t\tvar
    row;\n\t\t\tvar rows = group.rows;\n\n\t\t\tif ( this.c.startRender ) {\n\t\t\t\tdisplay
    = this.c.startRender.call( this, dt.rows(rows), groupName, level );\n\t\t\t\trow
    = this._rowWrap( display, this.c.startClassName, level );\n\n\t\t\t\tif ( row
    ) {\n\t\t\t\t\trow.insertBefore( dt.row( rows[0] ).node() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif
    ( this.c.endRender ) {\n\t\t\t\tdisplay = this.c.endRender.call( this, dt.rows(rows),
    groupName, level );\n\t\t\t\trow = this._rowWrap( display, this.c.endClassName,
    level );\n\n\t\t\t\tif ( row ) {\n\t\t\t\t\trow.insertAfter( dt.row( rows[ rows.length-1
    ] ).node() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( group.children ) {\n\t\t\t\tthis._groupDisplay(
    level+1, group.children );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Take a rendered
    value from an end user and make it suitable for display\n\t * as a row, by wrapping
    it in a row, or detecting that it is a row.\n\t * @param {node|jQuery|string}
    display Display value\n\t * @param {string} className Class to add to the row\n\t
    * @param {array} group\n\t * @param {number} group level\n\t * @private\n\t */\n\t_rowWrap:
    function ( display, className, level )\n\t{\n\t\tvar row;\n\t\t\n\t\tif ( display
    === null || display === '' ) {\n\t\t\tdisplay = this.c.emptyDataGroup;\n\t\t}\n\n\t\tif
    ( display === undefined || display === null ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif
    ( typeof display === 'object' && display.nodeName && display.nodeName.toLowerCase()
    === 'tr') {\n\t\t\trow = $(display);\n\t\t}\n\t\telse if (display instanceof $
    && display.length && display[0].nodeName.toLowerCase() === 'tr') {\n\t\t\trow
    = display;\n\t\t}\n\t\telse {\n\t\t\trow = $('<tr/>')\n\t\t\t\t.append(\n\t\t\t\t\t$('<td/>')\n\t\t\t\t\t\t.attr(
    'colspan', this._colspan() )\n\t\t\t\t\t\t.append( display  )\n\t\t\t\t);\n\t\t}\n\n\t\treturn
    row\n\t\t\t.addClass( this.c.className )\n\t\t\t.addClass( className )\n\t\t\t.addClass(
    'dtrg-level-'+level );\n\t}\n} );\n\n\n/**\n * RowGroup default settings for initialisation\n
    *\n * @namespace\n * @name RowGroup.defaults\n * @static\n */\nRowGroup.defaults
    = {\n\t/**\n\t * Class to apply to grouping rows - applied to both the start and\n\t
    * end grouping rows.\n\t * @type string\n\t */\n\tclassName: 'dtrg-group',\n\n\t/**\n\t
    * Data property from which to read the grouping information\n\t * @type string|integer|array\n\t
    */\n\tdataSrc: 0,\n\n\t/**\n\t * Text to show if no data is found for a group\n\t
    * @type string\n\t */\n\temptyDataGroup: 'No group',\n\n\t/**\n\t * Initial enablement
    state\n\t * @boolean\n\t */\n\tenable: true,\n\n\t/**\n\t * Class name to give
    to the end grouping row\n\t * @type string\n\t */\n\tendClassName: 'dtrg-end',\n\n\t/**\n\t
    * End grouping label function\n\t * @function\n\t */\n\tendRender: null,\n\n\t/**\n\t
    * Class name to give to the start grouping row\n\t * @type string\n\t */\n\tstartClassName:
    'dtrg-start',\n\n\t/**\n\t * Start grouping label function\n\t * @function\n\t
    */\n\tstartRender: function ( rows, group ) {\n\t\treturn group;\n\t}\n};\n\n\nRowGroup.version
    = \"1.1.3\";\n\n\n$.fn.dataTable.RowGroup = RowGroup;\n$.fn.DataTable.RowGroup
    = RowGroup;\n\n\nDataTable.Api.register( 'rowGroup()', function () {\n\treturn
    this;\n} );\n\nDataTable.Api.register( 'rowGroup().disable()', function () {\n\treturn
    this.iterator( 'table', function (ctx) {\n\t\tif ( ctx.rowGroup ) {\n\t\t\tctx.rowGroup.enable(
    false );\n\t\t}\n\t} );\n} );\n\nDataTable.Api.register( 'rowGroup().enable()',
    function ( opts ) {\n\treturn this.iterator( 'table', function (ctx) {\n\t\tif
    ( ctx.rowGroup ) {\n\t\t\tctx.rowGroup.enable( opts === undefined ? true : opts
    );\n\t\t}\n\t} );\n} );\n\nDataTable.Api.register( 'rowGroup().enabled()', function
    () {\n\tvar ctx = this.context;\n\n\treturn ctx.length && ctx[0].rowGroup ?\n\t\tctx[0].rowGroup.enabled()
    :\n\t\tfalse;\n} );\n\nDataTable.Api.register( 'rowGroup().dataSrc()', function
    ( val ) {\n\tif ( val === undefined ) {\n\t\treturn this.context[0].rowGroup.dataSrc();\n\t}\n\n\treturn
    this.iterator( 'table', function (ctx) {\n\t\tif ( ctx.rowGroup ) {\n\t\t\tctx.rowGroup.dataSrc(
    val );\n\t\t}\n\t} );\n} );\n\n\n// Attach a listener to the document which listens
    for DataTables initialisation\n// events so we can automatically initialise\n$(document).on(
    'preInit.dt.dtrg', function (e, settings, json) {\n\tif ( e.namespace !== 'dt'
    ) {\n\t\treturn;\n\t}\n\n\tvar init = settings.oInit.rowGroup;\n\tvar defaults
    = DataTable.defaults.rowGroup;\n\n\tif ( init || defaults ) {\n\t\tvar opts =
    $.extend( {}, defaults, init );\n\n\t\tif ( init !== false ) {\n\t\t\tnew RowGroup(
    settings, opts  );\n\t\t}\n\t}\n} );\n\n\nreturn RowGroup;\n\n}));\n"
  admin-Public-Admin-plugins-datatables-rowgroup-js-dataTables.rowGroup.min.js: |
    /*!
     RowGroup 1.1.3
     ©2017-2021 SpryMedia Ltd - datatables.net/license
    */
    (function(c){"function"===typeof define&&define.amd?define(["jquery","datatables.net"],function(f){return c(f,window,document)}):"object"===typeof exports?module.exports=function(f,i){f||(f=window);if(!i||!i.fn.dataTable)i=require("datatables.net")(f,i).$;return c(i,f,f.document)}:c(jQuery,window,document)})(function(c,f,i,k){var d=c.fn.dataTable,g=function(a,b){if(!d.versionCheck||!d.versionCheck("1.10.8"))throw"RowGroup requires DataTables 1.10.8 or newer";this.c=c.extend(!0,{},d.defaults.rowGroup,
    g.defaults,b);this.s={dt:new d.Api(a)};this.dom={};var m=this.s.dt.settings()[0],e=m.rowGroup;if(e)return e;m.rowGroup=this;this._constructor()};c.extend(g.prototype,{dataSrc:function(a){if(a===k)return this.c.dataSrc;var b=this.s.dt;this.c.dataSrc=a;c(b.table().node()).triggerHandler("rowgroup-datasrc.dt",[b,a]);return this},disable:function(){this.c.enable=!1;return this},enable:function(a){if(!1===a)return this.disable();this.c.enable=!0;return this},enabled:function(){return this.c.enable},_constructor:function(){var a=
    this,b=this.s.dt,m=b.settings()[0];b.on("draw.dtrg",function(b,c){a.c.enable&&m===c&&a._draw()});b.on("column-visibility.dt.dtrg responsive-resize.dt.dtrg",function(){a._adjustColspan()});b.on("destroy",function(){b.off(".dtrg")})},_adjustColspan:function(){c("tr."+this.c.className,this.s.dt.table().body()).find("td:visible").attr("colspan",this._colspan())},_colspan:function(){return this.s.dt.columns().visible().reduce(function(a,b){return a+b},0)},_draw:function(){var a=this._group(0,this.s.dt.rows({page:"current"}).indexes());
    this._groupDisplay(0,a)},_group:function(a,b){for(var c=Array.isArray(this.c.dataSrc)?this.c.dataSrc:[this.c.dataSrc],e=d.ext.oApi._fnGetObjectDataFn(c[a]),f=this.s.dt,j,g,l=[],h=0,i=b.length;h<i;h++){var n=b[h];j=f.row(n).data();j=e(j);if(null===j||j===k)j=this.c.emptyDataGroup;if(g===k||j!==g)l.push({dataPoint:j,rows:[]}),g=j;l[l.length-1].rows.push(n)}if(c[a+1]!==k){h=0;for(i=l.length;h<i;h++)l[h].children=this._group(a+1,l[h].rows)}return l},_groupDisplay:function(a,b){for(var c=this.s.dt,e,g=
    0,i=b.length;g<i;g++){var d=b[g],f=d.dataPoint,h=d.rows;this.c.startRender&&(e=this.c.startRender.call(this,c.rows(h),f,a),(e=this._rowWrap(e,this.c.startClassName,a))&&e.insertBefore(c.row(h[0]).node()));this.c.endRender&&(e=this.c.endRender.call(this,c.rows(h),f,a),(e=this._rowWrap(e,this.c.endClassName,a))&&e.insertAfter(c.row(h[h.length-1]).node()));d.children&&this._groupDisplay(a+1,d.children)}},_rowWrap:function(a,b,d){if(null===a||""===a)a=this.c.emptyDataGroup;return a===k||null===a?null:
    ("object"===typeof a&&a.nodeName&&"tr"===a.nodeName.toLowerCase()?c(a):a instanceof c&&a.length&&"tr"===a[0].nodeName.toLowerCase()?a:c("<tr/>").append(c("<td/>").attr("colspan",this._colspan()).append(a))).addClass(this.c.className).addClass(b).addClass("dtrg-level-"+d)}});g.defaults={className:"dtrg-group",dataSrc:0,emptyDataGroup:"No group",enable:!0,endClassName:"dtrg-end",endRender:null,startClassName:"dtrg-start",startRender:function(a,b){return b}};g.version="1.1.3";c.fn.dataTable.RowGroup=
    g;c.fn.DataTable.RowGroup=g;d.Api.register("rowGroup()",function(){return this});d.Api.register("rowGroup().disable()",function(){return this.iterator("table",function(a){a.rowGroup&&a.rowGroup.enable(!1)})});d.Api.register("rowGroup().enable()",function(a){return this.iterator("table",function(b){b.rowGroup&&b.rowGroup.enable(a===k?!0:a)})});d.Api.register("rowGroup().enabled()",function(){var a=this.context;return a.length&&a[0].rowGroup?a[0].rowGroup.enabled():!1});d.Api.register("rowGroup().dataSrc()",
    function(a){return a===k?this.context[0].rowGroup.dataSrc():this.iterator("table",function(b){b.rowGroup&&b.rowGroup.dataSrc(a)})});c(i).on("preInit.dt.dtrg",function(a,b){if("dt"===a.namespace){var f=b.oInit.rowGroup,e=d.defaults.rowGroup;if(f||e)e=c.extend({},e,f),!1!==f&&new g(b,e)}});return g});
  admin-Public-Admin-plugins-datatables-rowgroup-js-rowGroup.bootstrap4.js: "/*! Bootstrap
    4 styling wrapper for RowGroup\n * ©2018 SpryMedia Ltd - datatables.net/license\n
    */\n\n(function( factory ){\n\tif ( typeof define === 'function' && define.amd
    ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'datatables.net-bs4', 'datatables.net-rowgroup'],
    function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse
    if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tmodule.exports = function
    (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot = window;\n\t\t\t}\n\n\t\t\tif
    ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net-bs4')(root,
    $).$;\n\t\t\t}\n\n\t\t\tif ( ! $.fn.dataTable.RowGroup ) {\n\t\t\t\trequire('datatables.net-rowgroup')(root,
    $);\n\t\t\t}\n\n\t\t\treturn factory( $, root, root.document );\n\t\t};\n\t}\n\telse
    {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function(
    $, window, document, undefined ) {\n\nreturn $.fn.dataTable;\n\n}));"
  admin-Public-Admin-plugins-datatables-rowgroup-js-rowGroup.bootstrap4.min.js: |
    /*!
     Bootstrap 4 styling wrapper for RowGroup
     ©2018 SpryMedia Ltd - datatables.net/license
    */
    (function(c){"function"===typeof define&&define.amd?define(["jquery","datatables.net-bs4","datatables.net-rowgroup"],function(a){return c(a,window,document)}):"object"===typeof exports?module.exports=function(a,b){a||(a=window);if(!b||!b.fn.dataTable)b=require("datatables.net-bs4")(a,b).$;b.fn.dataTable.RowGroup||require("datatables.net-rowgroup")(a,b);return c(b,a,a.document)}:c(jQuery,window,document)})(function(c){return c.fn.dataTable});
  admin-Public-Admin-plugins-popper-esm-popper-utils.js: |
    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.16.1
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      var window = element.ownerDocument.defaultView;
      var css = window.getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well

      var _getStyleComputedProp = getStyleComputedProperty(element),
          overflow = _getStyleComputedProp.overflow,
          overflowX = _getStyleComputedProp.overflowX,
          overflowY = _getStyleComputedProp.overflowY;

      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent(getParentNode(element));
    }

    /**
     * Returns the reference node of the reference object, or the reference object itself.
     * @method
     * @memberof Popper.Utils
     * @param {Element|Object} reference - the reference element (the popper will be relative to this)
     * @returns {Element} parent
     */
    function getReferenceNode(reference) {
      return reference && reference.referenceNode ? reference.referenceNode : reference;
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      var noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      var offsetParent = element.offsetParent || null;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      var nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TH, TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      var nodeName = element.nodeName;

      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      var start = order ? element1 : element2;
      var end = order ? element2 : element1;

      // Get common ancestor container
      var range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      var commonAncestorContainer = range.commonAncestorContainer;

      // Both nodes are inside #document

      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      var element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

      var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      var nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element) {
      var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      var modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      var sideA = axis === 'x' ? 'Left' : 'Top';
      var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
    }

    function getWindowSizes(document) {
      var body = document.body;
      var html = document.documentElement;
      var computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      var rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          var scrollTop = getScroll(element, 'top');
          var scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
      var width = sizes.width || element.clientWidth || result.width;
      var height = sizes.height || element.clientHeight || result.height;

      var horizScrollbar = element.offsetWidth - width;
      var vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent) {
      var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isIE10 = isIE(10);
      var isHTML = parent.nodeName === 'HTML';
      var childrenRect = getBoundingClientRect(children);
      var parentRect = getBoundingClientRect(parent);
      var scrollParent = getScrollParent(children);

      var styles = getStyleComputedProperty(parent);
      var borderTopWidth = parseFloat(styles.borderTopWidth);
      var borderLeftWidth = parseFloat(styles.borderLeftWidth);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop);
        var marginLeft = parseFloat(styles.marginLeft);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
      var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var html = element.ownerDocument.documentElement;
      var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      var width = Math.max(html.clientWidth, window.innerWidth || 0);
      var height = Math.max(html.clientHeight, window.innerHeight || 0);

      var scrollTop = !excludeScroll ? getScroll(html) : 0;
      var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      var nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      var parentNode = getParentNode(element);
      if (!parentNode) {
        return false;
      }
      return isFixed(parentNode);
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      var el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement) {
      var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      // NOTE: 1 DOM access here

      var boundaries = { top: 0, left: 0 };
      var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          var _getWindowSizes = getWindowSizes(popper.ownerDocument),
              height = _getWindowSizes.height,
              width = _getWindowSizes.width;

          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      padding = padding || 0;
      var isPaddingNumber = typeof padding === 'number';
      boundaries.left += isPaddingNumber ? padding : padding.left || 0;
      boundaries.top += isPaddingNumber ? padding : padding.top || 0;
      boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
      boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

      return boundaries;
    }

    function getArea(_ref) {
      var width = _ref.width,
          height = _ref.height;

      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
      var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      var rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      var sortedAreas = Object.keys(rects).map(function (key) {
        return _extends({
          key: key
        }, rects[key], {
          area: getArea(rects[key])
        });
      }).sort(function (a, b) {
        return b.area - a.area;
      });

      var filteredAreas = sortedAreas.filter(function (_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
      });

      var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      var variation = placement.split('-')[1];

      return computedPlacement + (variation ? '-' + variation : '');
    }

    var timeoutDuration = function () {
      var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
      for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
          return 1;
        }
      }
      return 0;
    }();

    function microtaskDebounce(fn) {
      var called = false;
      return function () {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(function () {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      var scheduled = false;
      return function () {
        if (!scheduled) {
          scheduled = true;
          setTimeout(function () {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    var supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(function (cur) {
          return cur[prop] === value;
        });
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      var match = find(arr, function (obj) {
        return obj[prop] === value;
      });
      return arr.indexOf(match);
    }

    /**
     * Get the position of the given element, relative to its offset parent
     * @method
     * @memberof Popper.Utils
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
    function getOffsetRect(element) {
      var elementRect = void 0;
      if (element.nodeName === 'HTML') {
        var _getWindowSizes = getWindowSizes(element.ownerDocument),
            width = _getWindowSizes.width,
            height = _getWindowSizes.height;

        elementRect = {
          width: width,
          height: height,
          left: 0,
          top: 0
        };
      } else {
        elementRect = {
          width: element.offsetWidth,
          height: element.offsetHeight,
          left: element.offsetLeft,
          top: element.offsetTop
        };
      }

      // position
      return getClientRect(elementRect);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      var window = element.ownerDocument.defaultView;
      var styles = window.getComputedStyle(element);
      var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
      var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
      var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash[matched];
      });
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      var popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      var mainSide = isHoriz ? 'top' : 'left';
      var secondarySide = isHoriz ? 'left' : 'top';
      var measurement = isHoriz ? 'height' : 'width';
      var secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference) {
      var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
      var getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(function (_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
      });
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      var requesting = find(modifiers, function (_ref) {
        var name = _ref.name;
        return name === requestingName;
      });

      var isRequired = !!requesting && modifiers.some(function (modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
      }
      return isRequired;
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      var ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(function (target) {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(function (modifier) {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        var value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(function (prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      var isBody = scrollParent.nodeName === 'BODY';
      var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      var scrollElement = getScrollParent(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    // This is here just for backward compatibility with versions lower than v1.10.3
    // you should import the utilities using named exports, if you want them all use:
    // ```
    // import * as PopperUtils from 'popper-utils';
    // ```
    // The default export will be removed in the next major version.
    var index = {
      computeAutoPlacement: computeAutoPlacement,
      debounce: debounce,
      findIndex: findIndex,
      getBordersSize: getBordersSize,
      getBoundaries: getBoundaries,
      getBoundingClientRect: getBoundingClientRect,
      getClientRect: getClientRect,
      getOffsetParent: getOffsetParent,
      getOffsetRect: getOffsetRect,
      getOffsetRectRelativeToArbitraryNode: getOffsetRectRelativeToArbitraryNode,
      getOuterSizes: getOuterSizes,
      getParentNode: getParentNode,
      getPopperOffsets: getPopperOffsets,
      getReferenceOffsets: getReferenceOffsets,
      getScroll: getScroll,
      getScrollParent: getScrollParent,
      getStyleComputedProperty: getStyleComputedProperty,
      getSupportedPropertyName: getSupportedPropertyName,
      getWindowSizes: getWindowSizes,
      isFixed: isFixed,
      isFunction: isFunction,
      isModifierEnabled: isModifierEnabled,
      isModifierRequired: isModifierRequired,
      isNumeric: isNumeric,
      removeEventListeners: removeEventListeners,
      runModifiers: runModifiers,
      setAttributes: setAttributes,
      setStyles: setStyles,
      setupEventListeners: setupEventListeners
    };

    export { computeAutoPlacement, debounce, findIndex, getBordersSize, getBoundaries, getBoundingClientRect, getClientRect, getOffsetParent, getOffsetRect, getOffsetRectRelativeToArbitraryNode, getOuterSizes, getParentNode, getPopperOffsets, getReferenceOffsets, getScroll, getScrollParent, getStyleComputedProperty, getSupportedPropertyName, getWindowSizes, isFixed, isFunction, isModifierEnabled, isModifierRequired, isNumeric, removeEventListeners, runModifiers, setAttributes, setStyles, setupEventListeners };
    export default index;
    //# sourceMappingURL=popper-utils.js.map
  admin-Public-Admin-plugins-popper-esm-popper-utils.js.map: '{"version":3,"file":"popper-utils.js","sources":["../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isBrowser.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/debounce.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/getOffsetRect.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getSupportedPropertyName.js","../../src/utils/isFunction.js","../../src/utils/isModifierEnabled.js","../../src/utils/isModifierRequired.js","../../src/utils/isNumeric.js","../../src/utils/getWindow.js","../../src/utils/removeEventListeners.js","../../src/utils/runModifiers.js","../../src/utils/setAttributes.js","../../src/utils/setStyles.js","../../src/utils/setupEventListeners.js","../../src/utils/index.js"],"sourcesContent":["/**\n
    * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Eement} element\n * @argument {String} property\n */\nexport default
    function getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window =
    element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element,
    null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode
    or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element\n * @returns {Element} parent\n */\nexport default function
    getParentNode(element) {\n  if (element.nodeName === ''HTML'') {\n    return element;\n  }\n  return
    element.parentNode || element.host;\n}\n","import getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getParentNode from ''./getParentNode'';\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll`
    will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return
    document.body\n  }\n\n  switch (element.nodeName) {\n    case ''HTML'':\n    case
    ''BODY'':\n      return element.ownerDocument.body\n    case ''#document'':\n      return
    element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as
    well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if
    (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines
    if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n *
    @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n *
    @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nexport default function find(arr, check) {\n  // use native find if
    supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  //
    use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import
    find from ''./find'';\n\n/**\n * Return the index of the matching object\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop,
    value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex)
    {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find`
    + `indexOf` if `findIndex` isn''t supported\n  const match = find(arr, obj =>
    obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import getWindowSizes
    from ''./getWindowSizes'';\nimport getClientRect from ''./getClientRect'';\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nexport default function
    getOffsetRect(element) {\n  let elementRect;\n  if (element.nodeName === ''HTML'')
    {\n    const { width, height } = getWindowSizes(element.ownerDocument);\n    elementRect
    = {\n      width,\n      height,\n      left: 0,\n      top: 0,\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left:
    element.offsetLeft,\n      top: element.offsetTop,\n    };\n  }\n\n  // position\n  return
    getClientRect(elementRect);\n}\n","/**\n * Get the outer sizes of the given element
    (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Object} object containing width and height properties\n
    */\nexport default function getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const
    styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  const result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport
    default function getOppositePlacement(placement) {\n  const hash = { left: ''right'',
    right: ''left'', bottom: ''top'', top: ''bottom'' };\n  return placement.replace(/left|right|bottom|top/g,
    matched => hash[matched]);\n}\n","import getOuterSizes from ''./getOuterSizes'';\nimport
    getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n * Get offsets to
    the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split(''-'')[0];\n\n  //
    Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add
    position, width and height to our offsets object\n  const popperOffsets = {\n    width:
    popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the
    popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","/**\n * Check if the given variable
    is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck
    - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport
    default function isFunction(functionToCheck) {\n  const getType = {};\n  return
    (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === ''[object
    Function]''\n  );\n}\n","/**\n * Helper used to know if the given modifier is
    enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport
    default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({
    name, enabled }) => enabled && name === modifierName\n  );\n}\n","import find
    from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n *
    Get the window associated with the element\n * @argument {Element} element\n *
    @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getWindow from ''./getWindow'';\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nexport default function removeEventListeners(reference, state)
    {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import isFunction
    from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport getClientRect
    from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list of modifiers
    and run them in order,\n * each of them will then edit the data object.\n * @method\n
    * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n
    * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n
    */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun
    = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers,
    ''name'', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier[''function''])
    { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the attributes
    to\n * @argument {Object} styles\n * Object with a list of properties and values
    which will be applied to the element\n */\nexport default function setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","import getScrollParent from ''./getScrollParent'';\nimport
    getWindow from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName ===
    ''BODY'';\n  const target = isBody ? scrollParent.ownerDocument.defaultView :
    scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if
    (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    computeAutoPlacement from ''./computeAutoPlacement'';\nimport debounce from ''./debounce'';\nimport
    findIndex from ''./findIndex'';\nimport getBordersSize from ''./getBordersSize'';\nimport
    getBoundaries from ''./getBoundaries'';\nimport getBoundingClientRect from ''./getBoundingClientRect'';\nimport
    getClientRect from ''./getClientRect'';\nimport getOffsetParent from ''./getOffsetParent'';\nimport
    getOffsetRect from ''./getOffsetRect'';\nimport getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getOuterSizes from ''./getOuterSizes'';\nimport
    getParentNode from ''./getParentNode'';\nimport getPopperOffsets from ''./getPopperOffsets'';\nimport
    getReferenceOffsets from ''./getReferenceOffsets'';\nimport getScroll from ''./getScroll'';\nimport
    getScrollParent from ''./getScrollParent'';\nimport getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getSupportedPropertyName from ''./getSupportedPropertyName'';\nimport
    getWindowSizes from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport
    isFunction from ''./isFunction'';\nimport isModifierEnabled from ''./isModifierEnabled'';\nimport
    isModifierRequired from ''./isModifierRequired'';\nimport isNumeric from ''./isNumeric'';\nimport
    removeEventListeners from ''./removeEventListeners'';\nimport runModifiers from
    ''./runModifiers'';\nimport setAttributes from ''./setAttributes'';\nimport setStyles
    from ''./setStyles'';\nimport setupEventListeners from ''./setupEventListeners'';\n\n/**
    @namespace Popper.Utils */\nexport {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n\n//
    This is here just for backward compatibility with versions lower than v1.10.3\n//
    you should import the utilities using named exports, if you want them all use:\n//
    ```\n// import * as PopperUtils from ''popper-utils'';\n// ```\n// The default
    export will be removed in the next major version.\nexport default {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n"],"names":["getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","overflow","overflowX","overflowY","test","getReferenceNode","reference","referenceNode","navigator","isIE11","isBrowser","MSInputMethodContext","documentMode","isIE10","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","parseInt","getWindowSizes","getClientRect","offsets","width","height","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","isPaddingNumber","getArea","computeAutoPlacement","placement","refRect","rects","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","length","variation","split","timeoutDuration","longerTimeoutBrowsers","i","microtaskDebounce","fn","called","Promise","resolve","then","taskDebounce","scheduled","supportsMicroTasks","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","getOffsetRect","elementRect","offsetLeft","offsetTop","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","state","commonOffsetParent","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","isFunction","functionToCheck","getType","toString","call","isModifierEnabled","modifiers","modifierName","some","name","enabled","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","warn","isNumeric","n","isNaN","isFinite","getWindow","removeEventListeners","removeEventListener","updateBound","scrollParents","forEach","scrollElement","eventsEnabled","runModifiers","data","ends","modifiersToRun","undefined","setAttributes","attributes","setAttribute","removeAttribute","setStyles","unit","attachToScrollParents","event","callback","isBody","target","addEventListener","passive","push","setupEventListeners","options"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-esm-popper-utils.min.js: |
    /*
     Copyright (C) Federico Zivolo 2020
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */function a(a,b){if(1!==a.nodeType)return[];var c=a.ownerDocument.defaultView,d=c.getComputedStyle(a,null);return b?d[b]:d}function b(a){return'HTML'===a.nodeName?a:a.parentNode||a.host}function c(d){if(!d)return document.body;switch(d.nodeName){case'HTML':case'BODY':return d.ownerDocument.body;case'#document':return d.body;}var e=a(d),f=e.overflow,g=e.overflowX,h=e.overflowY;return /(auto|scroll|overlay)/.test(f+h+g)?d:c(b(d))}function d(a){return a&&a.referenceNode?a.referenceNode:a}var e='undefined'!=typeof window&&'undefined'!=typeof document&&'undefined'!=typeof navigator,f=e&&!!(window.MSInputMethodContext&&document.documentMode),g=e&&/MSIE 10/.test(navigator.userAgent);function h(a){return 11===a?f:10===a?g:f||g}function i(b){if(!b)return document.documentElement;for(var c=h(10)?document.body:null,d=b.offsetParent||null;d===c&&b.nextElementSibling;)d=(b=b.nextElementSibling).offsetParent;var e=d&&d.nodeName;return e&&'BODY'!==e&&'HTML'!==e?-1!==['TH','TD','TABLE'].indexOf(d.nodeName)&&'static'===a(d,'position')?i(d):d:b?b.ownerDocument.documentElement:document.documentElement}function j(a){var b=a.nodeName;return'BODY'!==b&&('HTML'===b||i(a.firstElementChild)===a)}function k(a){return null===a.parentNode?a:k(a.parentNode)}function l(a,b){if(!a||!a.nodeType||!b||!b.nodeType)return document.documentElement;var c=a.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_FOLLOWING,d=c?a:b,e=c?b:a,f=document.createRange();f.setStart(d,0),f.setEnd(e,0);var g=f.commonAncestorContainer;if(a!==g&&b!==g||d.contains(e))return j(g)?g:i(g);var h=k(a);return h.host?l(h.host,b):l(a,k(b).host)}function m(a){var b=1<arguments.length&&arguments[1]!==void 0?arguments[1]:'top',c='top'===b?'scrollTop':'scrollLeft',d=a.nodeName;if('BODY'===d||'HTML'===d){var e=a.ownerDocument.documentElement,f=a.ownerDocument.scrollingElement||e;return f[c]}return a[c]}function n(a,b){var c=2<arguments.length&&void 0!==arguments[2]&&arguments[2],d=m(b,'top'),e=m(b,'left'),f=c?-1:1;return a.top+=d*f,a.bottom+=d*f,a.left+=e*f,a.right+=e*f,a}function o(a,b){var c='x'===b?'Left':'Top',d='Left'==c?'Right':'Bottom';return parseFloat(a['border'+c+'Width'])+parseFloat(a['border'+d+'Width'])}function p(a,b,c,d){return Math.max(b['offset'+a],b['scroll'+a],c['client'+a],c['offset'+a],c['scroll'+a],h(10)?parseInt(c['offset'+a])+parseInt(d['margin'+('Height'===a?'Top':'Left')])+parseInt(d['margin'+('Height'===a?'Bottom':'Right')]):0)}function q(a){var b=a.body,c=a.documentElement,d=h(10)&&getComputedStyle(c);return{height:p('Height',b,c,d),width:p('Width',b,c,d)}}var r=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a};function s(a){return r({},a,{right:a.left+a.width,bottom:a.top+a.height})}function t(b){var c={};try{if(h(10)){c=b.getBoundingClientRect();var d=m(b,'top'),e=m(b,'left');c.top+=d,c.left+=e,c.bottom+=d,c.right+=e}else c=b.getBoundingClientRect()}catch(a){}var f={left:c.left,top:c.top,width:c.right-c.left,height:c.bottom-c.top},g='HTML'===b.nodeName?q(b.ownerDocument):{},i=g.width||b.clientWidth||f.width,j=g.height||b.clientHeight||f.height,k=b.offsetWidth-i,l=b.offsetHeight-j;if(k||l){var n=a(b);k-=o(n,'x'),l-=o(n,'y'),f.width-=k,f.height-=l}return s(f)}function u(b,d){var e=Math.max,f=2<arguments.length&&void 0!==arguments[2]&&arguments[2],g=h(10),i='HTML'===d.nodeName,j=t(b),k=t(d),l=c(b),m=a(d),o=parseFloat(m.borderTopWidth),p=parseFloat(m.borderLeftWidth);f&&i&&(k.top=e(k.top,0),k.left=e(k.left,0));var q=s({top:j.top-k.top-o,left:j.left-k.left-p,width:j.width,height:j.height});if(q.marginTop=0,q.marginLeft=0,!g&&i){var r=parseFloat(m.marginTop),u=parseFloat(m.marginLeft);q.top-=o-r,q.bottom-=o-r,q.left-=p-u,q.right-=p-u,q.marginTop=r,q.marginLeft=u}return(g&&!f?d.contains(l):d===l&&'BODY'!==l.nodeName)&&(q=n(q,d)),q}function v(a){var b=Math.max,c=1<arguments.length&&void 0!==arguments[1]&&arguments[1],d=a.ownerDocument.documentElement,e=u(a,d),f=b(d.clientWidth,window.innerWidth||0),g=b(d.clientHeight,window.innerHeight||0),h=c?0:m(d),i=c?0:m(d,'left'),j={top:h-e.top+e.marginTop,left:i-e.left+e.marginLeft,width:f,height:g};return s(j)}function w(c){var d=c.nodeName;if('BODY'===d||'HTML'===d)return!1;if('fixed'===a(c,'position'))return!0;var e=b(c);return!!e&&w(e)}function x(b){if(!b||!b.parentElement||h())return document.documentElement;for(var c=b.parentElement;c&&'none'===a(c,'transform');)c=c.parentElement;return c||document.documentElement}function y(a,e,f,g){var h=4<arguments.length&&void 0!==arguments[4]&&arguments[4],i={top:0,left:0},j=h?x(a):l(a,d(e));if('viewport'===g)i=v(j,h);else{var k;'scrollParent'===g?(k=c(b(e)),'BODY'===k.nodeName&&(k=a.ownerDocument.documentElement)):'window'===g?k=a.ownerDocument.documentElement:k=g;var m=u(k,j,h);if('HTML'===k.nodeName&&!w(j)){var n=q(a.ownerDocument),o=n.height,p=n.width;i.top+=m.top-m.marginTop,i.bottom=o+m.top,i.left+=m.left-m.marginLeft,i.right=p+m.left}else i=m}f=f||0;var r='number'==typeof f;return i.left+=r?f:f.left||0,i.top+=r?f:f.top||0,i.right-=r?f:f.right||0,i.bottom-=r?f:f.bottom||0,i}function z(a){var b=a.width,c=a.height;return b*c}function A(a,b,c,d,e){var f=5<arguments.length&&arguments[5]!==void 0?arguments[5]:0;if(-1===a.indexOf('auto'))return a;var g=y(c,d,f,e),h={top:{width:g.width,height:b.top-g.top},right:{width:g.right-b.right,height:g.height},bottom:{width:g.width,height:g.bottom-b.bottom},left:{width:b.left-g.left,height:g.height}},i=Object.keys(h).map(function(a){return r({key:a},h[a],{area:z(h[a])})}).sort(function(c,a){return a.area-c.area}),j=i.filter(function(a){var b=a.width,d=a.height;return b>=c.clientWidth&&d>=c.clientHeight}),k=0<j.length?j[0].key:i[0].key,l=a.split('-')[1];return k+(l?'-'+l:'')}var B=function(){for(var a=['Edge','Trident','Firefox'],b=0;b<a.length;b+=1)if(e&&0<=navigator.userAgent.indexOf(a[b]))return 1;return 0}();function C(a){var b=!1;return function(){b||(b=!0,window.Promise.resolve().then(function(){b=!1,a()}))}}function D(a){var b=!1;return function(){b||(b=!0,setTimeout(function(){b=!1,a()},B))}}var E=e&&window.Promise,F=E?C:D;function G(a,b){return Array.prototype.find?a.find(b):a.filter(b)[0]}function H(a,b,c){if(Array.prototype.findIndex)return a.findIndex(function(a){return a[b]===c});var d=G(a,function(a){return a[b]===c});return a.indexOf(d)}function I(a){var b;if('HTML'===a.nodeName){var c=q(a.ownerDocument),d=c.width,e=c.height;b={width:d,height:e,left:0,top:0}}else b={width:a.offsetWidth,height:a.offsetHeight,left:a.offsetLeft,top:a.offsetTop};return s(b)}function J(a){var b=a.ownerDocument.defaultView,c=b.getComputedStyle(a),d=parseFloat(c.marginTop||0)+parseFloat(c.marginBottom||0),e=parseFloat(c.marginLeft||0)+parseFloat(c.marginRight||0),f={width:a.offsetWidth+e,height:a.offsetHeight+d};return f}function K(a){var b={left:'right',right:'left',bottom:'top',top:'bottom'};return a.replace(/left|right|bottom|top/g,function(a){return b[a]})}function L(a,b,c){c=c.split('-')[0];var d=J(a),e={width:d.width,height:d.height},f=-1!==['right','left'].indexOf(c),g=f?'top':'left',h=f?'left':'top',i=f?'height':'width',j=f?'width':'height';return e[g]=b[g]+b[i]/2-d[i]/2,e[h]=c===h?b[h]-d[j]:b[K(h)],e}function M(a,b,c){var e=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,f=e?x(b):l(b,d(c));return u(c,f,e)}function N(a){for(var b=[!1,'ms','Webkit','Moz','O'],c=a.charAt(0).toUpperCase()+a.slice(1),d=0;d<b.length;d++){var e=b[d],f=e?''+e+c:a;if('undefined'!=typeof document.body.style[f])return f}return null}function O(a){return a&&'[object Function]'==={}.toString.call(a)}function P(a,b){return a.some(function(a){var c=a.name,d=a.enabled;return d&&c===b})}function Q(a,b,c){var d=G(a,function(a){var c=a.name;return c===b}),e=!!d&&a.some(function(a){return a.name===c&&a.enabled&&a.order<d.order});if(!e){var f='`'+b+'`';console.warn('`'+c+'`'+' modifier is required by '+f+' modifier in order to work, be sure to include it before '+f+'!')}return e}function R(a){return''!==a&&!isNaN(parseFloat(a))&&isFinite(a)}function S(a){var b=a.ownerDocument;return b?b.defaultView:window}function T(a,b){return S(a).removeEventListener('resize',b.updateBound),b.scrollParents.forEach(function(a){a.removeEventListener('scroll',b.updateBound)}),b.updateBound=null,b.scrollParents=[],b.scrollElement=null,b.eventsEnabled=!1,b}function U(a,b,c){var d=void 0===c?a:a.slice(0,H(a,'name',c));return d.forEach(function(a){a['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var c=a['function']||a.fn;a.enabled&&O(c)&&(b.offsets.popper=s(b.offsets.popper),b.offsets.reference=s(b.offsets.reference),b=c(b,a))}),b}function V(a,b){Object.keys(b).forEach(function(c){var d=b[c];!1===d?a.removeAttribute(c):a.setAttribute(c,b[c])})}function W(a,b){Object.keys(b).forEach(function(c){var d='';-1!==['width','height','top','right','bottom','left'].indexOf(c)&&R(b[c])&&(d='px'),a.style[c]=b[c]+d})}function X(a,b,d,e){var f='BODY'===a.nodeName,g=f?a.ownerDocument.defaultView:a;g.addEventListener(b,d,{passive:!0}),f||X(c(g.parentNode),b,d,e),e.push(g)}function Y(a,b,d,e){d.updateBound=e,S(a).addEventListener('resize',d.updateBound,{passive:!0});var f=c(a);return X(f,'scroll',d.updateBound,d.scrollParents),d.scrollElement=f,d.eventsEnabled=!0,d}var Z={computeAutoPlacement:A,debounce:F,findIndex:H,getBordersSize:o,getBoundaries:y,getBoundingClientRect:t,getClientRect:s,getOffsetParent:i,getOffsetRect:I,getOffsetRectRelativeToArbitraryNode:u,getOuterSizes:J,getParentNode:b,getPopperOffsets:L,getReferenceOffsets:M,getScroll:m,getScrollParent:c,getStyleComputedProperty:a,getSupportedPropertyName:N,getWindowSizes:q,isFixed:w,isFunction:O,isModifierEnabled:P,isModifierRequired:Q,isNumeric:R,removeEventListeners:T,runModifiers:U,setAttributes:V,setStyles:W,setupEventListeners:Y};export{A as computeAutoPlacement,F as debounce,H as findIndex,o as getBordersSize,y as getBoundaries,t as getBoundingClientRect,s as getClientRect,i as getOffsetParent,I as getOffsetRect,u as getOffsetRectRelativeToArbitraryNode,J as getOuterSizes,b as getParentNode,L as getPopperOffsets,M as getReferenceOffsets,m as getScroll,c as getScrollParent,a as getStyleComputedProperty,N as getSupportedPropertyName,q as getWindowSizes,w as isFixed,O as isFunction,P as isModifierEnabled,Q as isModifierRequired,R as isNumeric,T as removeEventListeners,U as runModifiers,V as setAttributes,W as setStyles,Y as setupEventListeners};export default Z;
    //# sourceMappingURL=popper-utils.min.js.map
  admin-Public-Admin-plugins-popper-esm-popper-utils.min.js.map: '{"version":3,"file":"popper-utils.min.js","sources":["../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isBrowser.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/debounce.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/getOffsetRect.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getSupportedPropertyName.js","../../src/utils/isFunction.js","../../src/utils/isModifierEnabled.js","../../src/utils/isModifierRequired.js","../../src/utils/isNumeric.js","../../src/utils/getWindow.js","../../src/utils/removeEventListeners.js","../../src/utils/runModifiers.js","../../src/utils/setAttributes.js","../../src/utils/setStyles.js","../../src/utils/setupEventListeners.js","../../src/utils/index.js"],"sourcesContent":["/**\n
    * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Eement} element\n * @argument {String} property\n */\nexport default
    function getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window =
    element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element,
    null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode
    or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element\n * @returns {Element} parent\n */\nexport default function
    getParentNode(element) {\n  if (element.nodeName === ''HTML'') {\n    return element;\n  }\n  return
    element.parentNode || element.host;\n}\n","import getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getParentNode from ''./getParentNode'';\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll`
    will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return
    document.body\n  }\n\n  switch (element.nodeName) {\n    case ''HTML'':\n    case
    ''BODY'':\n      return element.ownerDocument.body\n    case ''#document'':\n      return
    element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as
    well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if
    (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines
    if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n *
    @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n *
    @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nexport default function find(arr, check) {\n  // use native find if
    supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  //
    use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import
    find from ''./find'';\n\n/**\n * Return the index of the matching object\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop,
    value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex)
    {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find`
    + `indexOf` if `findIndex` isn''t supported\n  const match = find(arr, obj =>
    obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import getWindowSizes
    from ''./getWindowSizes'';\nimport getClientRect from ''./getClientRect'';\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nexport default function
    getOffsetRect(element) {\n  let elementRect;\n  if (element.nodeName === ''HTML'')
    {\n    const { width, height } = getWindowSizes(element.ownerDocument);\n    elementRect
    = {\n      width,\n      height,\n      left: 0,\n      top: 0,\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left:
    element.offsetLeft,\n      top: element.offsetTop,\n    };\n  }\n\n  // position\n  return
    getClientRect(elementRect);\n}\n","/**\n * Get the outer sizes of the given element
    (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Object} object containing width and height properties\n
    */\nexport default function getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const
    styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  const result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport
    default function getOppositePlacement(placement) {\n  const hash = { left: ''right'',
    right: ''left'', bottom: ''top'', top: ''bottom'' };\n  return placement.replace(/left|right|bottom|top/g,
    matched => hash[matched]);\n}\n","import getOuterSizes from ''./getOuterSizes'';\nimport
    getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n * Get offsets to
    the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split(''-'')[0];\n\n  //
    Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add
    position, width and height to our offsets object\n  const popperOffsets = {\n    width:
    popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the
    popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","/**\n * Check if the given variable
    is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck
    - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport
    default function isFunction(functionToCheck) {\n  const getType = {};\n  return
    (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === ''[object
    Function]''\n  );\n}\n","/**\n * Helper used to know if the given modifier is
    enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport
    default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({
    name, enabled }) => enabled && name === modifierName\n  );\n}\n","import find
    from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n *
    Get the window associated with the element\n * @argument {Element} element\n *
    @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getWindow from ''./getWindow'';\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nexport default function removeEventListeners(reference, state)
    {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import isFunction
    from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport getClientRect
    from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list of modifiers
    and run them in order,\n * each of them will then edit the data object.\n * @method\n
    * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n
    * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n
    */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun
    = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers,
    ''name'', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier[''function''])
    { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the attributes
    to\n * @argument {Object} styles\n * Object with a list of properties and values
    which will be applied to the element\n */\nexport default function setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","import getScrollParent from ''./getScrollParent'';\nimport
    getWindow from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName ===
    ''BODY'';\n  const target = isBody ? scrollParent.ownerDocument.defaultView :
    scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if
    (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    computeAutoPlacement from ''./computeAutoPlacement'';\nimport debounce from ''./debounce'';\nimport
    findIndex from ''./findIndex'';\nimport getBordersSize from ''./getBordersSize'';\nimport
    getBoundaries from ''./getBoundaries'';\nimport getBoundingClientRect from ''./getBoundingClientRect'';\nimport
    getClientRect from ''./getClientRect'';\nimport getOffsetParent from ''./getOffsetParent'';\nimport
    getOffsetRect from ''./getOffsetRect'';\nimport getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getOuterSizes from ''./getOuterSizes'';\nimport
    getParentNode from ''./getParentNode'';\nimport getPopperOffsets from ''./getPopperOffsets'';\nimport
    getReferenceOffsets from ''./getReferenceOffsets'';\nimport getScroll from ''./getScroll'';\nimport
    getScrollParent from ''./getScrollParent'';\nimport getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getSupportedPropertyName from ''./getSupportedPropertyName'';\nimport
    getWindowSizes from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport
    isFunction from ''./isFunction'';\nimport isModifierEnabled from ''./isModifierEnabled'';\nimport
    isModifierRequired from ''./isModifierRequired'';\nimport isNumeric from ''./isNumeric'';\nimport
    removeEventListeners from ''./removeEventListeners'';\nimport runModifiers from
    ''./runModifiers'';\nimport setAttributes from ''./setAttributes'';\nimport setStyles
    from ''./setStyles'';\nimport setupEventListeners from ''./setupEventListeners'';\n\n/**
    @namespace Popper.Utils */\nexport {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n\n//
    This is here just for backward compatibility with versions lower than v1.10.3\n//
    you should import the utilities using named exports, if you want them all use:\n//
    ```\n// import * as PopperUtils from ''popper-utils'';\n// ```\n// The default
    export will be removed in the next major version.\nexport default {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n"],"names":["element","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","property","nodeName","parentNode","host","document","body","getStyleComputedProperty","overflow","overflowX","overflowY","test","getScrollParent","getParentNode","reference","referenceNode","navigator","isIE10","isBrowser","userAgent","version","isIE11","documentElement","noOffsetParent","isIE","offsetParent","nextElementSibling","indexOf","getOffsetParent","firstElementChild","node","getRoot","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","scrollingElement","subtract","scrollTop","getScroll","scrollLeft","modifier","top","bottom","left","right","sideA","axis","sideB","parseFloat","styles","Math","max","parseInt","computedStyle","getSize","offsets","width","height","rect","getBoundingClientRect","result","sizes","getWindowSizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getBordersSize","getClientRect","fixedPosition","runIsIE","isHTML","parent","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","excludeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","innerWidth","innerHeight","offset","isFixed","parentElement","el","boundaries","getFixedPositionOffsetParent","getReferenceNode","boundariesElement","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","popper","padding","isPaddingNumber","placement","getBoundaries","rects","refRect","sortedAreas","Object","keys","map","getArea","sort","b","area","a","filteredAreas","filter","computedPlacement","length","key","variation","split","timeoutDuration","longerTimeoutBrowsers","i","called","Promise","resolve","then","scheduled","supportsMicroTasks","Array","prototype","find","arr","findIndex","cur","match","obj","elementRect","offsetLeft","offsetTop","x","marginBottom","y","marginRight","hash","replace","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","commonOffsetParent","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","functionToCheck","getType","toString","call","modifiers","some","name","enabled","requesting","isRequired","warn","requested","n","isNaN","isFinite","removeEventListener","state","updateBound","scrollParents","forEach","scrollElement","eventsEnabled","modifiersToRun","ends","fn","isFunction","data","value","attributes","removeAttribute","setAttribute","unit","isNumeric","isBody","target","addEventListener","passive","push"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-esm-popper.js: |
    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.16.1
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

    var timeoutDuration = function () {
      var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
      for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
          return 1;
        }
      }
      return 0;
    }();

    function microtaskDebounce(fn) {
      var called = false;
      return function () {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(function () {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      var scheduled = false;
      return function () {
        if (!scheduled) {
          scheduled = true;
          setTimeout(function () {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    var supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
      var getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      var window = element.ownerDocument.defaultView;
      var css = window.getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well

      var _getStyleComputedProp = getStyleComputedProperty(element),
          overflow = _getStyleComputedProp.overflow,
          overflowX = _getStyleComputedProp.overflowX,
          overflowY = _getStyleComputedProp.overflowY;

      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent(getParentNode(element));
    }

    /**
     * Returns the reference node of the reference object, or the reference object itself.
     * @method
     * @memberof Popper.Utils
     * @param {Element|Object} reference - the reference element (the popper will be relative to this)
     * @returns {Element} parent
     */
    function getReferenceNode(reference) {
      return reference && reference.referenceNode ? reference.referenceNode : reference;
    }

    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      var noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      var offsetParent = element.offsetParent || null;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      var nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TH, TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      var nodeName = element.nodeName;

      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      var start = order ? element1 : element2;
      var end = order ? element2 : element1;

      // Get common ancestor container
      var range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      var commonAncestorContainer = range.commonAncestorContainer;

      // Both nodes are inside #document

      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      var element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

      var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      var nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element) {
      var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      var modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      var sideA = axis === 'x' ? 'Left' : 'Top';
      var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
    }

    function getWindowSizes(document) {
      var body = document.body;
      var html = document.documentElement;
      var computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();





    var defineProperty = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      var rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          var scrollTop = getScroll(element, 'top');
          var scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
      var width = sizes.width || element.clientWidth || result.width;
      var height = sizes.height || element.clientHeight || result.height;

      var horizScrollbar = element.offsetWidth - width;
      var vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent) {
      var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var isIE10 = isIE(10);
      var isHTML = parent.nodeName === 'HTML';
      var childrenRect = getBoundingClientRect(children);
      var parentRect = getBoundingClientRect(parent);
      var scrollParent = getScrollParent(children);

      var styles = getStyleComputedProperty(parent);
      var borderTopWidth = parseFloat(styles.borderTopWidth);
      var borderLeftWidth = parseFloat(styles.borderLeftWidth);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop);
        var marginLeft = parseFloat(styles.marginLeft);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
      var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var html = element.ownerDocument.documentElement;
      var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      var width = Math.max(html.clientWidth, window.innerWidth || 0);
      var height = Math.max(html.clientHeight, window.innerHeight || 0);

      var scrollTop = !excludeScroll ? getScroll(html) : 0;
      var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      var nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      var parentNode = getParentNode(element);
      if (!parentNode) {
        return false;
      }
      return isFixed(parentNode);
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      var el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement) {
      var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      // NOTE: 1 DOM access here

      var boundaries = { top: 0, left: 0 };
      var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          var _getWindowSizes = getWindowSizes(popper.ownerDocument),
              height = _getWindowSizes.height,
              width = _getWindowSizes.width;

          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      padding = padding || 0;
      var isPaddingNumber = typeof padding === 'number';
      boundaries.left += isPaddingNumber ? padding : padding.left || 0;
      boundaries.top += isPaddingNumber ? padding : padding.top || 0;
      boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
      boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

      return boundaries;
    }

    function getArea(_ref) {
      var width = _ref.width,
          height = _ref.height;

      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
      var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      var rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      var sortedAreas = Object.keys(rects).map(function (key) {
        return _extends({
          key: key
        }, rects[key], {
          area: getArea(rects[key])
        });
      }).sort(function (a, b) {
        return b.area - a.area;
      });

      var filteredAreas = sortedAreas.filter(function (_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
      });

      var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      var variation = placement.split('-')[1];

      return computedPlacement + (variation ? '-' + variation : '');
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference) {
      var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      var window = element.ownerDocument.defaultView;
      var styles = window.getComputedStyle(element);
      var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
      var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
      var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash[matched];
      });
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      var popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      var mainSide = isHoriz ? 'top' : 'left';
      var secondarySide = isHoriz ? 'left' : 'top';
      var measurement = isHoriz ? 'height' : 'width';
      var secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(function (cur) {
          return cur[prop] === value;
        });
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      var match = find(arr, function (obj) {
        return obj[prop] === value;
      });
      return arr.indexOf(match);
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(function (modifier) {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Updates the position of the popper, computing the new offsets and applying
     * the new style.<br />
     * Prefer `scheduleUpdate` over `update` because of performance reasons.
     * @method
     * @memberof Popper
     */
    function update() {
      // if popper is destroyed, don't perform any further update
      if (this.state.isDestroyed) {
        return;
      }

      var data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
      };

      // compute reference element offsets
      data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

      // store the computed placement inside `originalPlacement`
      data.originalPlacement = data.placement;

      data.positionFixed = this.options.positionFixed;

      // compute the popper offsets
      data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

      data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

      // run the modifiers
      data = runModifiers(this.modifiers, data);

      // the first `update` will call `onCreate` callback
      // the other ones will call `onUpdate` callback
      if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
      } else {
        this.options.onUpdate(data);
      }
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(function (_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
      });
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Destroys the popper.
     * @method
     * @memberof Popper
     */
    function destroy() {
      this.state.isDestroyed = true;

      // touch DOM only if `applyStyle` modifier is enabled
      if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
      }

      this.disableEventListeners();

      // remove the popper if user explicitly asked for the deletion on destroy
      // do not use `remove` because IE11 doesn't support it
      if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
      }
      return this;
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      var ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      var isBody = scrollParent.nodeName === 'BODY';
      var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      var scrollElement = getScrollParent(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    /**
     * It will add resize/scroll events and start recalculating
     * position of the popper element when they are triggered.
     * @method
     * @memberof Popper
     */
    function enableEventListeners() {
      if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
      }
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(function (target) {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * It will remove resize/scroll events and won't recalculate popper position
     * when they are triggered. It also won't trigger `onUpdate` callback anymore,
     * unless you call `update` method manually.
     * @method
     * @memberof Popper
     */
    function disableEventListeners() {
      if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
      }
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(function (prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        var value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} data.styles - List of style properties - values to apply to popper element
     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The same data object
     */
    function applyStyle(data) {
      // any property present in `data.styles` will be applied to the popper,
      // in this way we can make the 3rd party modifiers add custom styles to it
      // Be aware, modifiers could override the properties defined in the previous
      // lines of this modifier!
      setStyles(data.instance.popper, data.styles);

      // any property present in `data.attributes` will be applied to the popper,
      // they will be set as HTML attributes of the element
      setAttributes(data.instance.popper, data.attributes);

      // if arrowElement is defined and arrowStyles has some properties
      if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
      }

      return data;
    }

    /**
     * Set the x-placement attribute before everything else because it could be used
     * to add margins to the popper margins needs to be calculated to get the
     * correct popper offsets.
     * @method
     * @memberof Popper.modifiers
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper
     * @param {Object} options - Popper.js options
     */
    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
      // compute reference element offsets
      var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

      popper.setAttribute('x-placement', placement);

      // Apply `position` to popper before anything else because
      // without the position applied we can't guarantee correct computations
      setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

      return options;
    }

    /**
     * @function
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Boolean} shouldRound - If the offsets should be rounded at all
     * @returns {Object} The popper's position offsets rounded
     *
     * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
     * good as it can be within reason.
     * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
     *
     * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
     * as well on High DPI screens).
     *
     * Firefox prefers no rounding for positioning and does not have blurriness on
     * high DPI screens.
     *
     * Only horizontal placement and left/right values need to be considered.
     */
    function getRoundedOffsets(data, shouldRound) {
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;
      var round = Math.round,
          floor = Math.floor;

      var noRound = function noRound(v) {
        return v;
      };

      var referenceWidth = round(reference.width);
      var popperWidth = round(popper.width);

      var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
      var isVariation = data.placement.indexOf('-') !== -1;
      var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
      var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

      var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
      var verticalToInteger = !shouldRound ? noRound : round;

      return {
        left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
        top: verticalToInteger(popper.top),
        bottom: verticalToInteger(popper.bottom),
        right: horizontalToInteger(popper.right)
      };
    }

    var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeStyle(data, options) {
      var x = options.x,
          y = options.y;
      var popper = data.offsets.popper;

      // Remove this legacy support in Popper.js v2

      var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'applyStyle';
      }).gpuAcceleration;
      if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
      }
      var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

      var offsetParent = getOffsetParent(data.instance.popper);
      var offsetParentRect = getBoundingClientRect(offsetParent);

      // Styles
      var styles = {
        position: popper.position
      };

      var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

      var sideA = x === 'bottom' ? 'top' : 'bottom';
      var sideB = y === 'right' ? 'left' : 'right';

      // if gpuAcceleration is set to `true` and transform is supported,
      //  we use `translate3d` to apply the position to the popper we
      // automatically use the supported prefixed version if needed
      var prefixedProperty = getSupportedPropertyName('transform');

      // now, let's make a step back and look at this code closely (wtf?)
      // If the content of the popper grows once it's been positioned, it
      // may happen that the popper gets misplaced because of the new content
      // overflowing its reference element
      // To avoid this problem, we provide two options (x and y), which allow
      // the consumer to define the offset origin.
      // If we position a popper on top of a reference element, we can set
      // `x` to `top` to make the popper grow towards its top instead of
      // its bottom.
      var left = void 0,
          top = void 0;
      if (sideA === 'bottom') {
        // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
        // and not the bottom of the html element
        if (offsetParent.nodeName === 'HTML') {
          top = -offsetParent.clientHeight + offsets.bottom;
        } else {
          top = -offsetParentRect.height + offsets.bottom;
        }
      } else {
        top = offsets.top;
      }
      if (sideB === 'right') {
        if (offsetParent.nodeName === 'HTML') {
          left = -offsetParent.clientWidth + offsets.right;
        } else {
          left = -offsetParentRect.width + offsets.right;
        }
      } else {
        left = offsets.left;
      }
      if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
      } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        var invertTop = sideA === 'bottom' ? -1 : 1;
        var invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = sideA + ', ' + sideB;
      }

      // Attributes
      var attributes = {
        'x-placement': data.placement
      };

      // Update `data` attributes, styles and arrowStyles
      data.attributes = _extends({}, attributes, data.attributes);
      data.styles = _extends({}, styles, data.styles);
      data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

      return data;
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      var requesting = find(modifiers, function (_ref) {
        var name = _ref.name;
        return name === requestingName;
      });

      var isRequired = !!requesting && modifiers.some(function (modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
      }
      return isRequired;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function arrow(data, options) {
      var _data$offsets$arrow;

      // arrow depends on keepTogether in order to work
      if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
      }

      var arrowElement = options.element;

      // if arrowElement is a string, suppose it's a CSS selector
      if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
          return data;
        }
      } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
          console.warn('WARNING: `arrow.element` must be child of its popper element!');
          return data;
        }
      }

      var placement = data.placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isVertical = ['left', 'right'].indexOf(placement) !== -1;

      var len = isVertical ? 'height' : 'width';
      var sideCapitalized = isVertical ? 'Top' : 'Left';
      var side = sideCapitalized.toLowerCase();
      var altSide = isVertical ? 'left' : 'top';
      var opSide = isVertical ? 'bottom' : 'right';
      var arrowElementSize = getOuterSizes(arrowElement)[len];

      //
      // extends keepTogether behavior making sure the popper and its
      // reference have enough pixels in conjunction
      //

      // top/left side
      if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
      }
      // bottom/right side
      if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
      }
      data.offsets.popper = getClientRect(data.offsets.popper);

      // compute center of the popper
      var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

      // Compute the sideValue using the updated popper offsets
      // take popper margin in account because we don't have this info available
      var css = getStyleComputedProperty(data.instance.popper);
      var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
      var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
      var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

      // prevent arrowElement from being placed not contiguously to its popper
      sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

      data.arrowElement = arrowElement;
      data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

      return data;
    }

    /**
     * Get the opposite placement variation of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement variation
     * @returns {String} flipped placement variation
     */
    function getOppositeVariation(variation) {
      if (variation === 'end') {
        return 'start';
      } else if (variation === 'start') {
        return 'end';
      }
      return variation;
    }

    /**
     * List of accepted placements to use as values of the `placement` option.<br />
     * Valid placements are:
     * - `auto`
     * - `top`
     * - `right`
     * - `bottom`
     * - `left`
     *
     * Each placement can have a variation from this list:
     * - `-start`
     * - `-end`
     *
     * Variations are interpreted easily if you think of them as the left to right
     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
     * is right.<br />
     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
     *
     * Some valid examples are:
     * - `top-end` (on top of reference, right aligned)
     * - `right-start` (on right of reference, top aligned)
     * - `bottom` (on bottom, centered)
     * - `auto-end` (on the side with more space available, alignment depends by placement)
     *
     * @static
     * @type {Array}
     * @enum {String}
     * @readonly
     * @method placements
     * @memberof Popper
     */
    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

    // Get rid of `auto` `auto-start` and `auto-end`
    var validPlacements = placements.slice(3);

    /**
     * Given an initial placement, returns all the subsequent placements
     * clockwise (or counter-clockwise).
     *
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement - A valid placement (it accepts variations)
     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
     * @returns {Array} placements including their variations
     */
    function clockwise(placement) {
      var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var index = validPlacements.indexOf(placement);
      var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
      return counter ? arr.reverse() : arr;
    }

    var BEHAVIORS = {
      FLIP: 'flip',
      CLOCKWISE: 'clockwise',
      COUNTERCLOCKWISE: 'counterclockwise'
    };

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function flip(data, options) {
      // if `inner` modifier is enabled, we can't use the `flip` modifier
      if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
      }

      if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
      }

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

      var placement = data.placement.split('-')[0];
      var placementOpposite = getOppositePlacement(placement);
      var variation = data.placement.split('-')[1] || '';

      var flipOrder = [];

      switch (options.behavior) {
        case BEHAVIORS.FLIP:
          flipOrder = [placement, placementOpposite];
          break;
        case BEHAVIORS.CLOCKWISE:
          flipOrder = clockwise(placement);
          break;
        case BEHAVIORS.COUNTERCLOCKWISE:
          flipOrder = clockwise(placement, true);
          break;
        default:
          flipOrder = options.behavior;
      }

      flipOrder.forEach(function (step, index) {
        if (placement !== step || flipOrder.length === index + 1) {
          return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        var popperOffsets = data.offsets.popper;
        var refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        var floor = Math.floor;
        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

        // flips variation if reference element overflows boundaries
        var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        // flips variation if popper content overflows boundaries
        var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

        var flippedVariation = flippedVariationByRef || flippedVariationByContent;

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
          // this boolean to detect any flip loop
          data.flipped = true;

          if (overlapsRef || overflowsBoundaries) {
            placement = flipOrder[index + 1];
          }

          if (flippedVariation) {
            variation = getOppositeVariation(variation);
          }

          data.placement = placement + (variation ? '-' + variation : '');

          // this object contains `position`, we want to preserve it along with
          // any additional property we may add in the future
          data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

          data = runModifiers(data.instance.modifiers, data, 'flip');
        }
      });
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function keepTogether(data) {
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var placement = data.placement.split('-')[0];
      var floor = Math.floor;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var side = isVertical ? 'right' : 'bottom';
      var opSide = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
      }
      if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
      }

      return data;
    }

    /**
     * Converts a string containing value + unit into a px value number
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} str - Value + unit string
     * @argument {String} measurement - `height` or `width`
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @returns {Number|String}
     * Value in pixels, or original string if no values were extracted
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
      // separate value from unit
      var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
      var value = +split[1];
      var unit = split[2];

      // If it's not a number it's an operator, I guess
      if (!value) {
        return str;
      }

      if (unit.indexOf('%') === 0) {
        var element = void 0;
        switch (unit) {
          case '%p':
            element = popperOffsets;
            break;
          case '%':
          case '%r':
          default:
            element = referenceOffsets;
        }

        var rect = getClientRect(element);
        return rect[measurement] / 100 * value;
      } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        var size = void 0;
        if (unit === 'vh') {
          size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
          size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
      } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
      }
    }

    /**
     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} offset
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @argument {String} basePlacement
     * @returns {Array} a two cells array with x and y offsets in numbers
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
      var offsets = [0, 0];

      // Use height if placement is left or right and index is 0 otherwise use width
      // in this way the first offset will use an axis and the second one
      // will use the other one
      var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

      // Split the offset string to obtain a list of values and operands
      // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
      var fragments = offset.split(/(\+|\-)/).map(function (frag) {
        return frag.trim();
      });

      // Detect if the offset string contains a pair of values or a single one
      // they could be separated by comma or space
      var divider = fragments.indexOf(find(fragments, function (frag) {
        return frag.search(/,|\s/) !== -1;
      }));

      if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
      }

      // If divider is found, we divide the list of values and operands to divide
      // them by ofset X and Y.
      var splitRegex = /\s*,\s*|\s+/;
      var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

      // Convert the values with units to absolute pixels to allow our computations
      ops = ops.map(function (op, index) {
        // Most of the units rely on the orientation of the popper
        var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        var mergeWithPrevious = false;
        return op
        // This aggregates any `+` or `-` sign that aren't considered operators
        // e.g.: 10 + +5 => [10, +, +5]
        .reduce(function (a, b) {
          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
            a[a.length - 1] = b;
            mergeWithPrevious = true;
            return a;
          } else if (mergeWithPrevious) {
            a[a.length - 1] += b;
            mergeWithPrevious = false;
            return a;
          } else {
            return a.concat(b);
          }
        }, [])
        // Here we convert the string values into number values (in px)
        .map(function (str) {
          return toValue(str, measurement, popperOffsets, referenceOffsets);
        });
      });

      // Loop trough the offsets arrays and execute the operations
      ops.forEach(function (op, index) {
        op.forEach(function (frag, index2) {
          if (isNumeric(frag)) {
            offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
          }
        });
      });
      return offsets;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @argument {Number|String} options.offset=0
     * The offset value as described in the modifier description
     * @returns {Object} The data object, properly modified
     */
    function offset(data, _ref) {
      var offset = _ref.offset;
      var placement = data.placement,
          _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var basePlacement = placement.split('-')[0];

      var offsets = void 0;
      if (isNumeric(+offset)) {
        offsets = [+offset, 0];
      } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
      }

      if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
      } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
      } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
      } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
      }

      data.popper = popper;
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function preventOverflow(data, options) {
      var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

      // If offsetParent is the reference element, we really want to
      // go one step up and use the next offsetParent as reference to
      // avoid to make this modifier completely useless and look like broken
      if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
      }

      // NOTE: DOM access here
      // resets the popper's position so that the document size can be calculated excluding
      // the size of the popper element itself
      var transformProp = getSupportedPropertyName('transform');
      var popperStyles = data.instance.popper.style; // assignment to help minification
      var top = popperStyles.top,
          left = popperStyles.left,
          transform = popperStyles[transformProp];

      popperStyles.top = '';
      popperStyles.left = '';
      popperStyles[transformProp] = '';

      var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

      // NOTE: DOM access here
      // restores the original style properties after the offsets have been computed
      popperStyles.top = top;
      popperStyles.left = left;
      popperStyles[transformProp] = transform;

      options.boundaries = boundaries;

      var order = options.priority;
      var popper = data.offsets.popper;

      var check = {
        primary: function primary(placement) {
          var value = popper[placement];
          if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
            value = Math.max(popper[placement], boundaries[placement]);
          }
          return defineProperty({}, placement, value);
        },
        secondary: function secondary(placement) {
          var mainSide = placement === 'right' ? 'left' : 'top';
          var value = popper[mainSide];
          if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
            value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
          }
          return defineProperty({}, mainSide, value);
        }
      };

      order.forEach(function (placement) {
        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends({}, popper, check[side](placement));
      });

      data.offsets.popper = popper;

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function shift(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var shiftvariation = placement.split('-')[1];

      // if shift shiftvariation is specified, run the modifier
      if (shiftvariation) {
        var _data$offsets = data.offsets,
            reference = _data$offsets.reference,
            popper = _data$offsets.popper;

        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        var side = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        var shiftOffsets = {
          start: defineProperty({}, side, reference[side]),
          end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
        };

        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function hide(data) {
      if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
      }

      var refRect = data.offsets.reference;
      var bound = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'preventOverflow';
      }).boundaries;

      if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
          return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
      } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
          return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function inner(data) {
      var placement = data.placement;
      var basePlacement = placement.split('-')[0];
      var _data$offsets = data.offsets,
          popper = _data$offsets.popper,
          reference = _data$offsets.reference;

      var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

      var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

      popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

      data.placement = getOppositePlacement(placement);
      data.offsets.popper = getClientRect(popper);

      return data;
    }

    /**
     * Modifier function, each modifier can have a function of this type assigned
     * to its `fn` property.<br />
     * These functions will be called on each update, this means that you must
     * make sure they are performant enough to avoid performance bottlenecks.
     *
     * @function ModifierFn
     * @argument {dataObject} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {dataObject} The data object, properly modified
     */

    /**
     * Modifiers are plugins used to alter the behavior of your poppers.<br />
     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
     * needed by the library.
     *
     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
     * All the other properties are configurations that could be tweaked.
     * @namespace modifiers
     */
    var modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },

      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unit-less, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the `height`.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },

      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * A scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries" — or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
      },

      /**
       * Modifier used to make sure the reference and its popper stay near each other
       * without leaving any gap between the two. Especially useful when the arrow is
       * enabled and you want to ensure that it points to its reference element.
       * It cares only about the first axis. You can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },

      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjunction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
      },

      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: 'viewport',
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
      },

      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },

      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },

      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
      },

      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define your own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: undefined
      }
    };

    /**
     * The `dataObject` is an object containing all the information used by Popper.js.
     * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
     * @name dataObject
     * @property {Object} data.instance The Popper.js instance
     * @property {String} data.placement Placement applied to popper
     * @property {String} data.originalPlacement Placement originally defined on init
     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
     * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.boundaries Offsets of the popper boundaries
     * @property {Object} data.offsets The measurements of popper, reference and arrow elements
     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
     */

    /**
     * Default options provided to Popper.js constructor.<br />
     * These can be overridden using the `options` argument of Popper.js.<br />
     * To override an option, simply pass an object with the same
     * structure of the `options` object, as the 3rd argument. For example:
     * ```
     * new Popper(ref, pop, {
     *   modifiers: {
     *     preventOverflow: { enabled: false }
     *   }
     * })
     * ```
     * @type {Object}
     * @static
     * @memberof Popper
     */
    var Defaults = {
      /**
       * Popper's placement.
       * @prop {Popper.placements} placement='bottom'
       */
      placement: 'bottom',

      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,

      /**
       * Whether events (resize, scroll) are initially enabled.
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,

      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,

      /**
       * Callback called when the popper is created.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: function onCreate() {},

      /**
       * Callback called when the popper is updated. This callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: function onUpdate() {},

      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js.
       * @prop {modifiers}
       */
      modifiers: modifiers
    };

    /**
     * @callback onCreate
     * @param {dataObject} data
     */

    /**
     * @callback onUpdate
     * @param {dataObject} data
     */

    // Utils
    // Methods
    var Popper = function () {
      /**
       * Creates a new Popper.js instance.
       * @class Popper
       * @param {Element|referenceObject} reference - The reference element used to position the popper
       * @param {Element} popper - The HTML / XML element used as the popper
       * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
       * @return {Object} instance - The generated Popper.js instance
       */
      function Popper(reference, popper) {
        var _this = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, Popper);

        this.scheduleUpdate = function () {
          return requestAnimationFrame(_this.update);
        };

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends({}, Popper.Defaults, options);

        // init state
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
          _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
          return _extends({
            name: name
          }, _this.options.modifiers[name]);
        })
        // sort the modifiers by order
        .sort(function (a, b) {
          return a.order - b.order;
        });

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(function (modifierOptions) {
          if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
          }
        });

        // fire the first update to position the popper in the right place
        this.update();

        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          // setup event listeners, they will take care of update the position in specific situations
          this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
      }

      // We can't use class properties because they don't get listed in the
      // class prototype and break stuff like Sinon stubs


      createClass(Popper, [{
        key: 'update',
        value: function update$$1() {
          return update.call(this);
        }
      }, {
        key: 'destroy',
        value: function destroy$$1() {
          return destroy.call(this);
        }
      }, {
        key: 'enableEventListeners',
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        }
      }, {
        key: 'disableEventListeners',
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        }

        /**
         * Schedules an update. It will run on the next UI update available.
         * @method scheduleUpdate
         * @memberof Popper
         */


        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */

      }]);
      return Popper;
    }();

    /**
     * The `referenceObject` is an object that provides an interface compatible with Popper.js
     * and lets you use it as replacement of a real DOM node.<br />
     * You can use this method to position a popper relatively to a set of coordinates
     * in case you don't have a DOM node to use as reference.
     *
     * ```
     * new Popper(referenceObject, popperNode);
     * ```
     *
     * NB: This feature isn't supported in Internet Explorer 10.
     * @name referenceObject
     * @property {Function} data.getBoundingClientRect
     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
     * @property {number} data.clientWidth
     * An ES6 getter that will return the width of the virtual reference element.
     * @property {number} data.clientHeight
     * An ES6 getter that will return the height of the virtual reference element.
     */


    Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;

    export default Popper;
    //# sourceMappingURL=popper.js.map
  admin-Public-Admin-plugins-popper-esm-popper.js.map: '{"version":3,"file":"popper.js","sources":["../../src/utils/isBrowser.js","../../src/utils/debounce.js","../../src/utils/isFunction.js","../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/runModifiers.js","../../src/methods/update.js","../../src/utils/isModifierEnabled.js","../../src/utils/getSupportedPropertyName.js","../../src/methods/destroy.js","../../src/utils/getWindow.js","../../src/utils/setupEventListeners.js","../../src/methods/enableEventListeners.js","../../src/utils/removeEventListeners.js","../../src/methods/disableEventListeners.js","../../src/utils/isNumeric.js","../../src/utils/setStyles.js","../../src/utils/setAttributes.js","../../src/modifiers/applyStyle.js","../../src/utils/getRoundedOffsets.js","../../src/modifiers/computeStyle.js","../../src/utils/isModifierRequired.js","../../src/modifiers/arrow.js","../../src/utils/getOppositeVariation.js","../../src/methods/placements.js","../../src/utils/clockwise.js","../../src/modifiers/flip.js","../../src/modifiers/keepTogether.js","../../src/modifiers/offset.js","../../src/modifiers/preventOverflow.js","../../src/modifiers/shift.js","../../src/modifiers/hide.js","../../src/modifiers/inner.js","../../src/modifiers/index.js","../../src/methods/defaults.js","../../src/index.js"],"sourcesContent":["export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n
    * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer
    to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const
    getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck)
    === ''[object Function]''\n  );\n}\n","/**\n * Get CSS computed property of the
    given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n
    * @argument {String} property\n */\nexport default function getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const
    css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName
    === ''HTML'') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getParentNode
    from ''./getParentNode'';\n\n/**\n * Returns the scrolling parent of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n
    * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element)
    {\n  // Return body, `getScroll` will take care to get the correct `scrollTop`
    from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName)
    {\n    case ''HTML'':\n    case ''BODY'':\n      return element.ownerDocument.body\n    case
    ''#document'':\n      return element.body\n  }\n\n  // Firefox want us to check
    `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } =
    getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow
    + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nexport default function getOuterSizes(element)
    {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const
    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const
    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  const
    result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the
    given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement)
    {\n  const hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom''
    };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import
    getOuterSizes from ''./getOuterSizes'';\nimport getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n
    * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param
    {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement}
    popper - the popper element\n * @param {Object} referenceOffsets - the reference
    offsets (the popper will be relative to this)\n * @param {String} placement -
    one of the valid placement options\n * @returns {Object} popperOffsets - An object
    containing the offsets which will be applied to the popper\n */\nexport default
    function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement
    = placement.split(''-'')[0];\n\n  // Get popper node sizes\n  const popperRect
    = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets
    object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  //
    depending by the popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function find(arr, check)
    {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    isFunction from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport
    getClientRect from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list
    of modifiers and run them in order,\n * each of them will then edit the data object.\n
    * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array}
    modifiers\n * @param {String} ends - Optional modifier name used as stopper\n
    * @returns {dataObject}\n */\nexport default function runModifiers(modifiers,
    data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    :
    modifiers.slice(0, findIndex(modifiers, ''name'', ends));\n\n  modifiersToRun.forEach(modifier
    => {\n    if (modifier[''function'']) { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","import computeAutoPlacement from ''../utils/computeAutoPlacement'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\n\n/**\n
    * Updates the position of the popper, computing the new offsets and applying\n
    * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance
    reasons.\n * @method\n * @memberof Popper\n */\nexport default function update()
    {\n  // if popper is destroyed, don''t perform any further update\n  if (this.state.isDestroyed)
    {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles:
    {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  //
    compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  //
    compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  //
    store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position
    = this.options.positionFixed\n    ? ''fixed''\n    : ''absolute'';\n\n  // run
    the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first
    `update` will call `onCreate` callback\n  // the other ones will call `onUpdate`
    callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  }
    else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know
    if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns
    {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName)
    {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from ''../utils/isModifierEnabled'';\nimport
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * Destroys the popper.\n * @method\n * @memberof Popper\n */\nexport default function
    destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle`
    modifier is enabled\n  if (isModifierEnabled(this.modifiers, ''applyStyle''))
    {\n    this.popper.removeAttribute(''x-placement'');\n    this.popper.style.position
    = '''';\n    this.popper.style.top = '''';\n    this.popper.style.left = '''';\n    this.popper.style.right
    = '''';\n    this.popper.style.bottom = '''';\n    this.popper.style.willChange
    = '''';\n    this.popper.style[getSupportedPropertyName(''transform'')] = '''';\n  }\n\n  this.disableEventListeners();\n\n  //
    remove the popper if user explicitly asked for the deletion on destroy\n  // do
    not use `remove` because IE11 doesn''t support it\n  if (this.options.removeOnDestroy)
    {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n
    * Get the window associated with the element\n * @argument {Element} element\n
    * @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getScrollParent from ''./getScrollParent'';\nimport getWindow
    from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  const isBody = scrollParent.nodeName === ''BODY'';\n  const
    target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    setupEventListeners from ''../utils/setupEventListeners'';\n\n/**\n * It will
    add resize/scroll events and start recalculating\n * position of the popper element
    when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default
    function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state
    = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import
    getWindow from ''./getWindow'';\n\n/**\n * Remove event listeners used to update
    the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport
    default function removeEventListeners(reference, state) {\n  // Remove resize
    event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners
    from ''../utils/removeEventListeners'';\n\n/**\n * It will remove resize/scroll
    events and won''t recalculate popper position\n * when they are triggered. It
    also won''t trigger `onUpdate` callback anymore,\n * unless you call `update`
    method manually.\n * @method\n * @memberof Popper\n */\nexport default function
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state
    = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nexport default
    function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop)
    {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    setStyles from ''../utils/setStyles'';\nimport setAttributes from ''../utils/setAttributes'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport computeAutoPlacement
    from ''../utils/computeAutoPlacement'';\n\n/**\n * @function\n * @memberof Modifiers\n
    * @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} data.styles - List of style properties - values to apply to popper element\n
    * @argument {Object} data.attributes - List of attribute properties - values to
    apply to popper element\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The same data object\n */\nexport default function
    applyStyle(data) {\n  // any property present in `data.styles` will be applied
    to the popper,\n  // in this way we can make the 3rd party modifiers add custom
    styles to it\n  // Be aware, modifiers could override the properties defined in
    the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper,
    data.styles);\n\n  // any property present in `data.attributes` will be applied
    to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper,
    data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some
    properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement,
    data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute
    before everything else because it could be used\n * to add margins to the popper
    margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n
    * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference
    element used to position the popper\n * @param {HTMLElement} popper - The HTML
    element used as popper\n * @param {Object} options - Popper.js options\n */\nexport
    function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n)
    {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state,
    popper, reference, options.positionFixed);\n\n  // compute auto placement, store
    placement inside the data object,\n  // modifiers will be able to edit `placement`
    if needed\n  // and refer to originalPlacement to know the original value\n  const
    placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute(''x-placement'',
    placement);\n\n  // Apply `position` to popper before anything else because\n  //
    without the position applied we can''t guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? ''fixed'' : ''absolute'' });\n\n  return options;\n}\n","/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper''s position
    offsets rounded\n *\n * The tale of pixel-perfect positioning. It''s still not
    100% perfect, but as\n * good as it can be within reason.\n * Discussion here:
    https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause
    a popper to be blurry if not using full pixels (Safari\n * as well on High DPI
    screens).\n *\n * Firefox prefers no rounding for positioning and does not have
    blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right
    values need to be considered.\n */\nexport default function getRoundedOffsets(data,
    shouldRound) {\n  const { popper, reference } = data.offsets;\n  const { round,
    floor } = Math;\n  const noRound = v => v;\n  \n  const referenceWidth = round(reference.width);\n  const
    popperWidth = round(popper.width);\n  \n  const isVertical = [''left'', ''right''].indexOf(data.placement)
    !== -1;\n  const isVariation = data.placement.indexOf(''-'') !== -1;\n  const
    sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  const bothOddWidth
    = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  const horizontalToInteger
    = !shouldRound\n    ? noRound\n    : isVertical || isVariation || sameWidthParity\n    ?
    round\n    : floor;\n  const verticalToInteger = !shouldRound ? noRound : round;\n\n  return
    {\n    left: horizontalToInteger(\n      bothOddWidth && !isVariation && shouldRound\n        ?
    popper.left - 1\n        : popper.left\n    ),\n    top: verticalToInteger(popper.top),\n    bottom:
    verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right),\n  };\n}\n","import
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\nimport find
    from ''../utils/find'';\nimport getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundingClientRect from ''../utils/getBoundingClientRect'';\nimport getRoundedOffsets
    from ''../utils/getRoundedOffsets'';\nimport isBrowser from ''../utils/isBrowser'';\n\nconst
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeStyle(data, options) {\n  const { x, y } = options;\n  const
    { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const
    legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''applyStyle''\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption
    !== undefined) {\n    console.warn(\n      ''WARNING: `gpuAcceleration` option
    moved to `computeStyle` modifier and will not be supported in future versions
    of Popper.js!''\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption
    !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const
    offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position:
    popper.position,\n  };\n\n  const offsets = getRoundedOffsets(\n    data,\n    window.devicePixelRatio
    < 2 || !isFirefox\n  );\n\n  const sideA = x === ''bottom'' ? ''top'' : ''bottom'';\n  const
    sideB = y === ''right'' ? ''left'' : ''right'';\n\n  // if gpuAcceleration is
    set to `true` and transform is supported,\n  //  we use `translate3d` to apply
    the position to the popper we\n  // automatically use the supported prefixed version
    if needed\n  const prefixedProperty = getSupportedPropertyName(''transform'');\n\n  //
    now, let''s make a step back and look at this code closely (wtf?)\n  // If the
    content of the popper grows once it''s been positioned, it\n  // may happen that
    the popper gets misplaced because of the new content\n  // overflowing its reference
    element\n  // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA ===
    ''bottom'') {\n    // when offsetParent is <html> the positioning is relative
    to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom
    of the html element\n    if (offsetParent.nodeName === ''HTML'') {\n      top
    = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height
    + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB
    === ''right'') {\n    if (offsetParent.nodeName === ''HTML'') {\n      left =
    -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width
    + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration
    && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px,
    ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange
    = ''transform'';\n  } else {\n    // othwerise, we use the standard `top`, `left`,
    `bottom` and `right` properties\n    const invertTop = sideA === ''bottom'' ?
    -1 : 1;\n    const invertLeft = sideB === ''right'' ? -1 : 1;\n    styles[sideA]
    = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange
    = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    ''x-placement'':
    data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles
    };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return
    data;\n}\n","import find from ''./find'';\n\n/**\n * Helper used to know if the
    given modifier depends from another one.<br />\n * It checks if the needed modifier
    is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array}
    modifiers - list of modifiers\n * @param {String} requestingName - name of requesting
    modifier\n * @param {String} requestedName - name of requested modifier\n * @returns
    {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","import getClientRect
    from ''../utils/getClientRect'';\nimport getOuterSizes from ''../utils/getOuterSizes'';\nimport
    isModifierRequired from ''../utils/isModifierRequired'';\nimport getStyleComputedProperty
    from ''../utils/getStyleComputedProperty'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by update method\n
    * @argument {Object} options - Modifiers configuration and options\n * @returns
    {Object} The data object, properly modified\n */\nexport default function arrow(data,
    options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers,
    ''arrow'', ''keepTogether'')) {\n    return data;\n  }\n\n  let arrowElement =
    options.element;\n\n  // if arrowElement is a string, suppose it''s a CSS selector\n  if
    (typeof arrowElement === ''string'') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    //
    if arrowElement is not found, don''t run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn''t a
    query selector we must check that the\n    // provided DOM node is child of its
    popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        ''WARNING:
    `arrow.element` must be child of its popper element!''\n      );\n      return
    data;\n    }\n  }\n\n  const placement = data.placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isVertical = [''left'', ''right''].indexOf(placement)
    !== -1;\n\n  const len = isVertical ? ''height'' : ''width'';\n  const sideCapitalized
    = isVertical ? ''Top'' : ''Left'';\n  const side = sideCapitalized.toLowerCase();\n  const
    altSide = isVertical ? ''left'' : ''top'';\n  const opSide = isVertical ? ''bottom''
    : ''right'';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  //
    extends keepTogether behavior making sure the popper and its\n  // reference have
    enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide]
    - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side]
    - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side]
    + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side]
    + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  //
    compute center of the popper\n  const center = reference[side] + reference[len]
    / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper
    offsets\n  // take popper margin in account because we don''t have this info available\n  const
    css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide
    = parseFloat(css[`margin${sideCapitalized}`]);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let
    sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  //
    prevent arrowElement from being placed not contiguously to its popper\n  sideValue
    = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement
    = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]:
    '''', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return
    data;\n}\n","/**\n * Get the opposite placement variation of the given one\n *
    @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n
    * @returns {String} flipped placement variation\n */\nexport default function
    getOppositeVariation(variation) {\n  if (variation === ''end'') {\n    return
    ''start'';\n  } else if (variation === ''start'') {\n    return ''end'';\n  }\n  return
    variation;\n}\n","/**\n * List of accepted placements to use as values of the
    `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n
    * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation
    from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted
    easily if you think of them as the left to right\n * written languages. Horizontally
    (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically
    (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples
    are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start`
    (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n *
    - `auto-end` (on the side with more space available, alignment depends by placement)\n
    *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n
    * @memberof Popper\n */\nexport default [\n  ''auto-start'',\n  ''auto'',\n  ''auto-end'',\n  ''top-start'',\n  ''top'',\n  ''top-end'',\n  ''right-start'',\n  ''right'',\n  ''right-end'',\n  ''bottom-end'',\n  ''bottom'',\n  ''bottom-start'',\n  ''left-end'',\n  ''left'',\n  ''left-start'',\n];\n","import
    placements from ''../methods/placements'';\n\n// Get rid of `auto` `auto-start`
    and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given
    an initial placement, returns all the subsequent placements\n * clockwise (or
    counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String}
    placement - A valid placement (it accepts variations)\n * @argument {Boolean}
    counter - Set to true to walk the placements counterclockwise\n * @returns {Array}
    placements including their variations\n */\nexport default function clockwise(placement,
    counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const
    arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0,
    index));\n  return counter ? arr.reverse() : arr;\n}\n","import getOppositePlacement
    from ''../utils/getOppositePlacement'';\nimport getOppositeVariation from ''../utils/getOppositeVariation'';\nimport
    getPopperOffsets from ''../utils/getPopperOffsets'';\nimport runModifiers from
    ''../utils/runModifiers'';\nimport getBoundaries from ''../utils/getBoundaries'';\nimport
    isModifierEnabled from ''../utils/isModifierEnabled'';\nimport clockwise from
    ''../utils/clockwise'';\n\nconst BEHAVIORS = {\n  FLIP: ''flip'',\n  CLOCKWISE:
    ''clockwise'',\n  COUNTERCLOCKWISE: ''counterclockwise'',\n};\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by update method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function flip(data, options) {\n  // if `inner` modifier is enabled, we
    can''t use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    ''inner'')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there''s not enough space on any of the flippable sides\n    return data;\n  }\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let
    placement = data.placement.split(''-'')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let
    variation = data.placement.split(''-'')[1] || '''';\n\n  let flipOrder = [];\n\n  switch
    (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder
    = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step,
    index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return
    data;\n    }\n\n    placement = data.placement.split(''-'')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const
    refOffsets = data.offsets.reference;\n\n    // using floor because the reference
    offsets may contain decimals we are not going to consider here\n    const floor
    = Math.floor;\n    const overlapsRef =\n      (placement === ''left'' &&\n        floor(popperOffsets.right)
    > floor(refOffsets.left)) ||\n      (placement === ''right'' &&\n        floor(popperOffsets.left)
    < floor(refOffsets.right)) ||\n      (placement === ''top'' &&\n        floor(popperOffsets.bottom)
    > floor(refOffsets.top)) ||\n      (placement === ''bottom'' &&\n        floor(popperOffsets.top)
    < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top)
    < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement
    === ''left'' && overflowsLeft) ||\n      (placement === ''right'' && overflowsRight)
    ||\n      (placement === ''top'' && overflowsTop) ||\n      (placement === ''bottom''
    && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical
    = [''top'', ''bottom''].indexOf(placement) !== -1;\n\n    // flips variation if
    reference element overflows boundaries\n    const flippedVariationByRef =\n      !!options.flipVariations
    &&\n      ((isVertical && variation === ''start'' && overflowsLeft) ||\n        (isVertical
    && variation === ''end'' && overflowsRight) ||\n        (!isVertical && variation
    === ''start'' && overflowsTop) ||\n        (!isVertical && variation === ''end''
    && overflowsBottom));\n\n    // flips variation if popper content overflows boundaries\n    const
    flippedVariationByContent =\n      !!options.flipVariationsByContent &&\n      ((isVertical
    && variation === ''start'' && overflowsRight) ||\n        (isVertical && variation
    === ''end'' && overflowsLeft) ||\n        (!isVertical && variation === ''start''
    && overflowsBottom) ||\n        (!isVertical && variation === ''end'' && overflowsTop));\n\n    const
    flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if
    (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean
    to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef ||
    overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if
    (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? ''-'' + variation : '''');\n\n      // this object
    contains `position`, we want to preserve it along with\n      // any additional
    property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data
    = runModifiers(data.instance.modifiers, data, ''flip'');\n    }\n  });\n  return
    data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nexport default function keepTogether(data) {\n  const { popper,
    reference } = data.offsets;\n  const placement = data.placement.split(''-'')[0];\n  const
    floor = Math.floor;\n  const isVertical = [''top'', ''bottom''].indexOf(placement)
    !== -1;\n  const side = isVertical ? ''right'' : ''bottom'';\n  const opSide =
    isVertical ? ''left'' : ''top'';\n  const measurement = isVertical ? ''width''
    : ''height'';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide]
    =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide]
    > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return
    data;\n}\n","import isNumeric from ''../utils/isNumeric'';\nimport getClientRect
    from ''../utils/getClientRect'';\nimport find from ''../utils/find'';\n\n/**\n
    * Converts a string containing value + unit into a px value number\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value
    + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument
    {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n
    * Value in pixels, or original string if no values were extracted\n */\nexport
    function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate
    value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const
    value = +split[1];\n  const unit = split[2];\n\n  // If it''s not a number it''s
    an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf(''%'')
    === 0) {\n    let element;\n    switch (unit) {\n      case ''%p'':\n        element
    = popperOffsets;\n        break;\n      case ''%'':\n      case ''%r'':\n      default:\n        element
    = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return
    rect[measurement] / 100 * value;\n  } else if (unit === ''vh'' || unit === ''vw'')
    {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let
    size;\n    if (unit === ''vh'') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight
    || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth
    || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is
    an explicit pixel unit, we get rid of the unit and keep the value\n    // if is
    an implicit unit, it''s px, and we return just the value\n    return value;\n  }\n}\n\n/**\n
    * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n *
    @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument
    {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets
    in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n)
    {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right
    and index is 0 otherwise use width\n  // in this way the first offset will use
    an axis and the second one\n  // will use the other one\n  const useHeight = [''right'',
    ''left''].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain
    a list of values and operands\n  // The regex addresses values with the plus or
    minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag
    => frag.trim());\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  const divider
    = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if
    (fragments[divider] && fragments[divider].indexOf('','') === -1) {\n    console.warn(\n      ''Offsets
    separated by white space(s) are deprecated, use a comma (,) instead.''\n    );\n  }\n\n  //
    If divider is found, we divide the list of values and operands to divide\n  //
    them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider
    !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider
    + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with
    units to absolute pixels to allow our computations\n  ops = ops.map((op, index)
    => {\n    // Most of the units rely on the orientation of the popper\n    const
    measurement = (index === 1 ? !useHeight : useHeight)\n      ? ''height''\n      :
    ''width'';\n    let mergeWithPrevious = false;\n    return (\n      op\n        //
    This aggregates any `+` or `-` sign that aren''t considered operators\n        //
    e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length
    - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {\n            a[a.length -
    1] = b;\n            mergeWithPrevious = true;\n            return a;\n          }
    else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious
    = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        },
    [])\n        // Here we convert the string values into number values (in px)\n        .map(str
    => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  //
    Loop trough the offsets arrays and execute the operations\n  ops.forEach((op,
    index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index]
    += frag * (op[index2 - 1] === ''-'' ? -1 : 1);\n      }\n    });\n  });\n  return
    offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n
    * The offset value as described in the modifier description\n * @returns {Object}
    The data object, properly modified\n */\nexport default function offset(data,
    { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const
    basePlacement = placement.split(''-'')[0];\n\n  let offsets;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === ''left'') {\n    popper.top
    += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement ===
    ''right'') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  }
    else if (basePlacement === ''top'') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === ''bottom'') {\n    popper.left
    += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n","import getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundaries from ''../utils/getBoundaries'';\nimport getSupportedPropertyName
    from ''../utils/getSupportedPropertyName'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by `update`
    method\n * @argument {Object} options - Modifiers configuration and options\n
    * @returns {Object} The data object, properly modified\n */\nexport default function
    preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement
    || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference
    element, we really want to\n  // go one step up and use the next offsetParent
    as reference to\n  // avoid to make this modifier completely useless and look
    like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement
    = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  //
    resets the popper''s position so that the document size can be calculated excluding\n  //
    the size of the popper element itself\n  const transformProp = getSupportedPropertyName(''transform'');\n  const
    popperStyles = data.instance.popper.style; // assignment to help minification\n  const
    { top, left, [transformProp]: transform } = popperStyles;\n  popperStyles.top
    = '''';\n  popperStyles.left = '''';\n  popperStyles[transformProp] = '''';\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement,\n    data.positionFixed\n  );\n\n  //
    NOTE: DOM access here\n  // restores the original style properties after the offsets
    have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp]
    = transform;\n\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let
    popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let
    value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement)
    {\n      const mainSide = placement === ''right'' ? ''left'' : ''top'';\n      let
    value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement]
    -\n            (placement === ''right'' ? popper.width : popper.height)\n        );\n      }\n      return
    { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const
    side =\n      [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ''secondary'';\n    popper
    = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper =
    popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function shift(data) {\n  const
    placement = data.placement;\n  const basePlacement = placement.split(''-'')[0];\n  const
    shiftvariation = placement.split(''-'')[1];\n\n  // if shift shiftvariation is
    specified, run the modifier\n  if (shiftvariation) {\n    const { reference, popper
    } = data.offsets;\n    const isVertical = [''bottom'', ''top''].indexOf(basePlacement)
    !== -1;\n    const side = isVertical ? ''left'' : ''top'';\n    const measurement
    = isVertical ? ''width'' : ''height'';\n\n    const shiftOffsets = {\n      start:
    { [side]: reference[side] },\n      end: {\n        [side]: reference[side] +
    reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper
    = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import
    isModifierRequired from ''../utils/isModifierRequired'';\nimport find from ''../utils/find'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function hide(data) {\n  if (!isModifierRequired(data.instance.modifiers,
    ''hide'', ''preventOverflow'')) {\n    return data;\n  }\n\n  const refRect =
    data.offsets.reference;\n  const bound = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''preventOverflow''\n  ).boundaries;\n\n  if (\n    refRect.bottom
    < bound.top ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom
    ||\n    refRect.right < bound.left\n  ) {\n    // Avoid unnecessary DOM access
    if visibility hasn''t changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide
    = true;\n    data.attributes[''x-out-of-boundaries''] = '''';\n  } else {\n    //
    Avoid unnecessary DOM access if visibility hasn''t changed\n    if (data.hide
    === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes[''x-out-of-boundaries'']
    = false;\n  }\n\n  return data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport
    getOppositePlacement from ''../utils/getOppositePlacement'';\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function inner(data) {\n  const placement = data.placement;\n  const basePlacement
    = placement.split(''-'')[0];\n  const { popper, reference } = data.offsets;\n  const
    isHoriz = [''left'', ''right''].indexOf(basePlacement) !== -1;\n\n  const subtractLength
    = [''top'', ''left''].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? ''left''
    : ''top''] =\n    reference[basePlacement] -\n    (subtractLength ? popper[isHoriz
    ? ''width'' : ''height''] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper
    = getClientRect(popper);\n\n  return data;\n}\n","import applyStyle, { applyStyleOnLoad
    } from ''./applyStyle'';\nimport computeStyle from ''./computeStyle'';\nimport
    arrow from ''./arrow'';\nimport flip from ''./flip'';\nimport keepTogether from
    ''./keepTogether'';\nimport offset from ''./offset'';\nimport preventOverflow
    from ''./preventOverflow'';\nimport shift from ''./shift'';\nimport hide from
    ''./hide'';\nimport inner from ''./inner'';\n\n/**\n * Modifier function, each
    modifier can have a function of this type assigned\n * to its `fn` property.<br
    />\n * These functions will be called on each update, this means that you must\n
    * make sure they are performant enough to avoid performance bottlenecks.\n *\n
    * @function ModifierFn\n * @argument {dataObject} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n
    * Modifiers are plugins used to alter the behavior of your poppers.<br />\n *
    Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n
    * needed by the library.\n *\n * Usually you don''t want to override the `order`,
    `fn` and `onLoad` props.\n * All the other properties are configurations that
    could be tweaked.\n * @namespace modifiers\n */\nexport default {\n  /**\n   *
    Modifier used to shift the popper on the start or end of its reference\n   * element.<br
    />\n   * It will read the variation of the `placement` property.<br />\n   * It
    can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift:
    {\n    /** @prop {number} order=100 - Index used to define the order of execution
    */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier
    is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn:
    shift,\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both
    its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less,
    interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of
    the reference element\n   * - `%p`, percentage relative to the length of the popper
    element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height
    unit\n   *\n   * For length is intended the main axis relative to the placement
    of the popper.<br />\n   * This means that if the placement is `top` or `bottom`,
    the length will be the\n   * `width`. In case of `left` or `right`, it will be
    the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`),
    or a pair of values\n   * as `String` divided by a comma or one (or more) white
    spaces.<br />\n   * The latter is a deprecated method because it leads to confusion
    and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions
    and subtractions between different units.\n   * Note that multiplications and
    divisions aren''t supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   *
    ''10%''\n   * ''10, 10''\n   * ''10%, 10''\n   * ''10 + 10%''\n   * ''10 - 5vh
    + 3%''\n   * ''-10px + 5vh, 5px - 6%''\n   * ```\n   * > **NB**: If you desire
    to apply offsets to your poppers in a way that may make them overlap\n   * > with
    their reference element, unfortunately, you will have to disable the `flip` modifier.\n   *
    > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200
    - Index used to define the order of execution */\n    order: 200,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String}
    offset=0\n     * The offset value as described in the modifier description\n     */\n    offset:
    0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned
    outside the boundary.\n   *\n   * A scenario exists where the reference itself
    is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"
    — or just \"escaped\".<br />\n   * In this case we need to decide whether the
    popper should either:\n   *\n   * - detach from the reference and remain \"trapped\"
    in the boundaries, or\n   * - if it should ignore the boundary and \"escape with
    its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference
    is completely\n   * outside its boundaries, the popper will overflow (or completely
    leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number}
    order=300 - Index used to define the order of execution */\n    order: 300,\n    /**
    @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]\n     * Popper
    will try to prevent overflow following these priorities by default,\n     * then,
    it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    [''left'', ''right'', ''top'', ''bottom''],\n    /**\n     * @prop {number} padding=5\n     *
    Amount of pixel used to define a minimum distance between the boundaries\n     *
    and the popper. This makes sure the popper always has a little padding\n     *
    between the edges of its container\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''scrollParent''\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: ''scrollParent'',\n  },\n\n  /**\n   *
    Modifier used to make sure the reference and its popper stay near each other\n   *
    without leaving any gap between the two. Especially useful when the arrow is\n   *
    enabled and you want to ensure that it points to its reference element.\n   *
    It cares only about the first axis. You can still have poppers with margin\n   *
    between the popper and its reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used
    to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier
    is used to move the `arrowElement` of the popper to make\n   * sure it is positioned
    between the reference element and its popper element.\n   * It will read the outer
    size of the `arrowElement` node to detect how many\n   * pixels of conjunction
    are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   *
    @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500
    - Index used to define the order of execution */\n    order: 500,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement}
    element=''[x-arrow]'' - Selector or node used as arrow */\n    element: ''[x-arrow]'',\n  },\n\n  /**\n   *
    Modifier used to flip the popper''s placement when it starts to overlap its\n   *
    reference element.\n   *\n   * Requires the `preventOverflow` modifier before
    it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current
    update cycle and will\n   * restart it if it detects the need to flip the placement.\n   *
    @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600
    - Index used to define the order of execution */\n    order: 600,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array}
    behavior=''flip''\n     * The behavior used to change the popper''s placement.
    It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with
    a list of valid\n     * placements (with optional variations)\n     */\n    behavior:
    ''flip'',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip
    if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''viewport''\n     * The element
    which will define the boundaries of the popper position.\n     * The popper will
    never be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: ''viewport'',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariations:
    false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     *
    The popper will switch placement variation between `-start` and `-end` when\n     *
    the popper element overlaps its reference boundaries.\n     *\n     * The original
    placement should have a set variation.\n     */\n    flipVariationsByContent:
    false,\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define
    the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false
    - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop
    {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the
    popper when its reference element is outside of the\n   * popper boundaries. It
    will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with
    a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   *
    Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof
    modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index
    used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that
    will be applied to the popper element to gets\n   * properly positioned.\n   *\n   *
    Note that this modifier will not touch the DOM, it just prepares the styles\n   *
    so that `applyStyle` modifier can apply it. This separation is useful\n   * in
    case you need to replace `applyStyle` with a custom implementation.\n   *\n   *
    This modifier has `850` as `order` value to maintain backward compatibility\n   *
    with previous versions of Popper.js. Expect the modifiers ordering method\n   *
    to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used
    to define the order of execution */\n    order: 850,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean}
    gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position
    the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    true,\n    /**\n     * @prop {string} [x=''bottom'']\n     * Where to anchor the
    X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper
    should grow in a direction different from `bottom`\n     */\n    x: ''bottom'',\n    /**\n     *
    @prop {string} [x=''left'']\n     * Where to anchor the Y axis (`left` or `right`).
    AKA Y offset origin.\n     * Change this if your popper should grow in a direction
    different from `right`\n     */\n    y: ''right'',\n  },\n\n  /**\n   * Applies
    the computed styles to the popper element.\n   *\n   * All the DOM manipulations
    are limited to this modifier. This is useful in case\n   * you want to integrate
    Popper.js inside a framework or view library and you\n   * want to delegate all
    the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier,
    you must make sure the popper element\n   * has its position set to `absolute`
    before Popper.js can do its work!\n   *\n   * Just disable this modifier and define
    your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used
    to define the order of execution */\n    order: 900,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad:
    applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property
    moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     *
    If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n
    * The `dataObject` is an object containing all the information used by Popper.js.\n
    * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n
    * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n
    * @property {String} data.placement Placement applied to popper\n * @property
    {String} data.originalPlacement Placement originally defined on init\n * @property
    {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property
    {Boolean} data.hide True if the reference element is out of boundaries, useful
    to know when to hide the popper\n * @property {HTMLElement} data.arrowElement
    Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS
    property defined here will be applied to the popper. It expects the JavaScript
    nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any
    CSS property defined here will be applied to the popper arrow. It expects the
    JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n","import
    modifiers from ''../modifiers/index'';\n\n/**\n * Default options provided to
    Popper.js constructor.<br />\n * These can be overridden using the `options` argument
    of Popper.js.<br />\n * To override an option, simply pass an object with the
    same\n * structure of the `options` object, as the 3rd argument. For example:\n
    * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: {
    enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof
    Popper\n */\nexport default {\n  /**\n   * Popper''s placement.\n   * @prop {Popper.placements}
    placement=''bottom''\n   */\n  placement: ''bottom'',\n\n  /**\n   * Set this
    to true if you want popper to position it self in ''fixed'' mode\n   * @prop {Boolean}
    positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events
    (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled:
    true,\n\n  /**\n   * Set to true if you want to automatically remove the popper
    when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called
    when the popper is updated. This callback is not called\n   * on the initialization/creation
    of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it
    is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers
    used to modify the offsets before they are applied to the popper.\n   * They provide
    most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n
    * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n
    * @param {dataObject} data\n */\n","// Utils\nimport debounce from ''./utils/debounce'';\nimport
    isFunction from ''./utils/isFunction'';\n\n// Methods\nimport update from ''./methods/update'';\nimport
    destroy from ''./methods/destroy'';\nimport enableEventListeners from ''./methods/enableEventListeners'';\nimport
    disableEventListeners from ''./methods/disableEventListeners'';\nimport Defaults
    from ''./methods/defaults'';\nimport placements from ''./methods/placements'';\n\nexport
    default class Popper {\n  /**\n   * Creates a new Popper.js instance.\n   * @class
    Popper\n   * @param {Element|referenceObject} reference - The reference element
    used to position the popper\n   * @param {Element} popper - The HTML / XML element
    used as the popper\n   * @param {Object} options - Your custom options to override
    the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The
    generated Popper.js instance\n   */\n  constructor(reference, popper, options
    = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update
    = debounce(this.update.bind(this));\n\n    // with {} we create a new object with
    the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    //
    init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents:
    [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference
    = reference && reference.jquery ? reference[0] : reference;\n    this.popper =
    popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name
    => {\n      this.options.modifiers[name] = {\n        // If it''s a built-in modifier,
    use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        //
    If there are custom options, override and merge with default ones\n        ...(options.modifiers
    ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers''
    list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name
    => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      //
    sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    //
    modifiers have the ability to execute arbitrary code when Popper.js get inited\n    //
    such code is executed in the same order of its modifier\n    // they could add
    new properties to their options configuration\n    // BE AWARE: don''t add options
    to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions
    => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad))
    {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    //
    fire the first update to position the popper in the right place\n    this.update();\n\n    const
    eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      //
    setup event listeners, they will take care of update the position in specific
    situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can''t use class properties because they don''t
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update()
    {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners()
    {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners()
    {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedules
    an update. It will run on the next UI update available.\n   * @method scheduleUpdate\n   *
    @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   *
    Collection of utilities useful when writing custom modifiers.\n   * Starting from
    version 1.7, this method is available only if you\n   * include `popper-utils.js`
    before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils
    is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly
    instead.\n   * Due to the high instability of the methods contained in Utils,
    we can''t\n   * guarantee them to follow semver. Use them at your own risk!\n   *
    @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   *
    @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !==
    ''undefined'' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static
    Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides
    an interface compatible with Popper.js\n * and lets you use it as replacement
    of a real DOM node.<br />\n * You can use this method to position a popper relatively
    to a set of coordinates\n * in case you don''t have a DOM node to use as reference.\n
    *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This
    feature isn''t supported in Internet Explorer 10.\n * @name referenceObject\n
    * @property {Function} data.getBoundingClientRect\n * A function that returns
    a set of coordinates compatible with the native `getBoundingClientRect` method.\n
    * @property {number} data.clientWidth\n * An ES6 getter that will return the width
    of the virtual reference element.\n * @property {number} data.clientHeight\n *
    An ES6 getter that will return the height of the virtual reference element.\n
    */\n"],"names":["window","document","navigator","timeoutDuration","longerTimeoutBrowsers","i","length","isBrowser","userAgent","indexOf","microtaskDebounce","fn","called","Promise","resolve","then","taskDebounce","scheduled","supportsMicroTasks","isFunction","functionToCheck","getType","toString","call","getStyleComputedProperty","element","property","nodeType","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","body","overflow","overflowX","overflowY","test","getReferenceNode","reference","referenceNode","isIE11","MSInputMethodContext","documentMode","isIE10","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","parseInt","getWindowSizes","getClientRect","offsets","width","height","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","isPaddingNumber","getArea","computeAutoPlacement","placement","refRect","rects","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","variation","split","getReferenceOffsets","state","commonOffsetParent","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","runModifiers","modifiers","data","ends","modifiersToRun","undefined","slice","forEach","warn","enabled","update","isDestroyed","options","positionFixed","flip","originalPlacement","position","isCreated","onCreate","onUpdate","isModifierEnabled","modifierName","some","name","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","prefix","toCheck","style","destroy","removeAttribute","willChange","disableEventListeners","removeOnDestroy","removeChild","getWindow","attachToScrollParents","event","callback","scrollParents","isBody","target","addEventListener","passive","push","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","removeEventListener","isNumeric","n","isNaN","isFinite","setStyles","unit","setAttributes","attributes","setAttribute","applyStyle","instance","arrowElement","arrowStyles","applyStyleOnLoad","modifierOptions","getRoundedOffsets","shouldRound","round","floor","noRound","v","referenceWidth","popperWidth","isVertical","isVariation","sameWidthParity","bothOddWidth","horizontalToInteger","verticalToInteger","isFirefox","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","devicePixelRatio","prefixedProperty","invertTop","invertLeft","arrow","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","querySelector","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","getOppositeVariation","validPlacements","placements","clockwise","counter","index","concat","reverse","BEHAVIORS","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariationByRef","flipVariations","flippedVariationByContent","flipVariationsByContent","flippedVariation","keepTogether","toValue","str","size","parseOffset","basePlacement","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","transformProp","popperStyles","transform","priority","escapeWithReference","shift","shiftvariation","shiftOffsets","hide","bound","inner","subtractLength","Popper","requestAnimationFrame","debounce","bind","Defaults","jquery","onLoad","Utils","global","PopperUtils"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,gBAAe,OAAOA,MAAP,KAAkB,WAAlB,IAAiC,OAAOC,QAAP,KAAoB,WAArD,IAAoE,OAAOC,SAAP,KAAqB,WAAxG;;ACEA,IAAMC,kBAAmB,YAAU;MAC3BC,wBAAwB,CAAC,MAAD,EAAS,SAAT,EAAoB,SAApB,CAA9B;OACK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,sBAAsBE,MAA1C,EAAkDD,KAAK,CAAvD,EAA0D;QACpDE,aAAaL,UAAUM,SAAV,CAAoBC,OAApB,CAA4BL,sBAAsBC,CAAtB,CAA5B,KAAyD,CAA1E,EAA6E;aACpE,CAAP;;;SAGG,CAAP;CAPuB,EAAzB;;AAUA,AAAO,SAASK,iBAAT,CAA2BC,EAA3B,EAA+B;MAChCC,SAAS,KAAb;SACO,YAAM;QACPA,MAAJ,EAAY;;;aAGH,IAAT;WACOC,OAAP,CAAeC,OAAf,GAAyBC,IAAzB,CAA8B,YAAM;eACzB,KAAT;;KADF;GALF;;;AAYF,AAAO,SAASC,YAAT,CAAsBL,EAAtB,EAA0B;MAC3BM,YAAY,KAAhB;SACO,YAAM;QACP,CAACA,SAAL,EAAgB;kBACF,IAAZ;iBACW,YAAM;oBACH,KAAZ;;OADF,EAGGd,eAHH;;GAHJ;;;AAWF,IAAMe,qBAAqBX,aAAaP,OAAOa,OAA/C;;;;;;;;;;;AAYA,eAAgBK,qBACZR,iBADY,GAEZM,YAFJ;;ACnDA;;;;;;;AAOA,AAAe,SAASG,UAAT,CAAoBC,eAApB,EAAqC;MAC5CC,UAAU,EAAhB;SAEED,mBACAC,QAAQC,QAAR,CAAiBC,IAAjB,CAAsBH,eAAtB,MAA2C,mBAF7C;;;ACTF;;;;;;;AAOA,AAAe,SAASI,wBAAT,CAAkCC,OAAlC,EAA2CC,QAA3C,EAAqD;MAC9DD,QAAQE,QAAR,KAAqB,CAAzB,EAA4B;WACnB,EAAP;;;MAGI3B,SAASyB,QAAQG,aAAR,CAAsBC,WAArC;MACMC,MAAM9B,OAAO+B,gBAAP,CAAwBN,OAAxB,EAAiC,IAAjC,CAAZ;SACOC,WAAWI,IAAIJ,QAAJ,CAAX,GAA2BI,GAAlC;;;ACdF;;;;;;;AAOA,AAAe,SAASE,aAAT,CAAuBP,OAAvB,EAAgC;MACzCA,QAAQQ,QAAR,KAAqB,MAAzB,EAAiC;WACxBR,OAAP;;SAEKA,QAAQS,UAAR,IAAsBT,QAAQU,IAArC;;;ACRF;;;;;;;AAOA,AAAe,SAASC,eAAT,CAAyBX,OAAzB,EAAkC;;MAE3C,CAACA,OAAL,EAAc;WACLxB,SAASoC,IAAhB;;;UAGMZ,QAAQQ,QAAhB;SACO,MAAL;SACK,MAAL;aACSR,QAAQG,aAAR,CAAsBS,IAA7B;SACG,WAAL;aACSZ,QAAQY,IAAf;;;;;8BAIuCb,yBAAyBC,OAAzB,CAfI;MAevCa,QAfuC,yBAevCA,QAfuC;MAe7BC,SAf6B,yBAe7BA,SAf6B;MAelBC,SAfkB,yBAelBA,SAfkB;;MAgB3C,wBAAwBC,IAAxB,CAA6BH,WAAWE,SAAX,GAAuBD,SAApD,CAAJ,EAAoE;WAC3Dd,OAAP;;;SAGKW,gBAAgBJ,cAAcP,OAAd,CAAhB,CAAP;;;AC9BF;;;;;;;AAOA,AAAe,SAASiB,gBAAT,CAA0BC,SAA1B,EAAqC;SAC3CA,aAAaA,UAAUC,aAAvB,GAAuCD,UAAUC,aAAjD,GAAiED,SAAxE;;;ACNF,IAAME,SAAStC,aAAa,CAAC,EAAEP,OAAO8C,oBAAP,IAA+B7C,SAAS8C,YAA1C,CAA7B;AACA,IAAMC,SAASzC,aAAa,UAAUkC,IAAV,CAAevC,UAAUM,SAAzB,CAA5B;;;;;;;;;AASA,AAAe,SAASyC,IAAT,CAAcC,OAAd,EAAuB;MAChCA,YAAY,EAAhB,EAAoB;WACXL,MAAP;;MAEEK,YAAY,EAAhB,EAAoB;WACXF,MAAP;;SAEKH,UAAUG,MAAjB;;;ACjBF;;;;;;;AAOA,AAAe,SAASG,eAAT,CAAyB1B,OAAzB,EAAkC;MAC3C,CAACA,OAAL,EAAc;WACLxB,SAASmD,eAAhB;;;MAGIC,iBAAiBJ,KAAK,EAAL,IAAWhD,SAASoC,IAApB,GAA2B,IAAlD;;;MAGIiB,eAAe7B,QAAQ6B,YAAR,IAAwB,IAA3C;;SAEOA,iBAAiBD,cAAjB,IAAmC5B,QAAQ8B,kBAAlD,EAAsE;mBACrD,CAAC9B,UAAUA,QAAQ8B,kBAAnB,EAAuCD,YAAtD;;;MAGIrB,WAAWqB,gBAAgBA,aAAarB,QAA9C;;MAEI,CAACA,QAAD,IAAaA,aAAa,MAA1B,IAAoCA,aAAa,MAArD,EAA6D;WACpDR,UAAUA,QAAQG,aAAR,CAAsBwB,eAAhC,GAAkDnD,SAASmD,eAAlE;;;;;MAMA,CAAC,IAAD,EAAO,IAAP,EAAa,OAAb,EAAsB3C,OAAtB,CAA8B6C,aAAarB,QAA3C,MAAyD,CAAC,CAA1D,IACAT,yBAAyB8B,YAAzB,EAAuC,UAAvC,MAAuD,QAFzD,EAGE;WACOH,gBAAgBG,YAAhB,CAAP;;;SAGKA,YAAP;;;ACpCa,SAASE,iBAAT,CAA2B/B,OAA3B,EAAoC;MACzCQ,QADyC,GAC5BR,OAD4B,CACzCQ,QADyC;;MAE7CA,aAAa,MAAjB,EAAyB;WAChB,KAAP;;SAGAA,aAAa,MAAb,IAAuBkB,gBAAgB1B,QAAQgC,iBAAxB,MAA+ChC,OADxE;;;ACPF;;;;;;;AAOA,AAAe,SAASiC,OAAT,CAAiBC,IAAjB,EAAuB;MAChCA,KAAKzB,UAAL,KAAoB,IAAxB,EAA8B;WACrBwB,QAAQC,KAAKzB,UAAb,CAAP;;;SAGKyB,IAAP;;;ACRF;;;;;;;;AAQA,AAAe,SAASC,sBAAT,CAAgCC,QAAhC,EAA0CC,QAA1C,EAAoD;;MAE7D,CAACD,QAAD,IAAa,CAACA,SAASlC,QAAvB,IAAmC,CAACmC,QAApC,IAAgD,CAACA,SAASnC,QAA9D,EAAwE;WAC/D1B,SAASmD,eAAhB;;;;MAIIW,QACJF,SAASG,uBAAT,CAAiCF,QAAjC,IACAG,KAAKC,2BAFP;MAGMC,QAAQJ,QAAQF,QAAR,GAAmBC,QAAjC;MACMM,MAAML,QAAQD,QAAR,GAAmBD,QAA/B;;;MAGMQ,QAAQpE,SAASqE,WAAT,EAAd;QACMC,QAAN,CAAeJ,KAAf,EAAsB,CAAtB;QACMK,MAAN,CAAaJ,GAAb,EAAkB,CAAlB;MACQK,uBAjByD,GAiB7BJ,KAjB6B,CAiBzDI,uBAjByD;;;;MAqB9DZ,aAAaY,uBAAb,IACCX,aAAaW,uBADf,IAEAN,MAAMO,QAAN,CAAeN,GAAf,CAHF,EAIE;QACIZ,kBAAkBiB,uBAAlB,CAAJ,EAAgD;aACvCA,uBAAP;;;WAGKtB,gBAAgBsB,uBAAhB,CAAP;;;;MAIIE,eAAejB,QAAQG,QAAR,CAArB;MACIc,aAAaxC,IAAjB,EAAuB;WACdyB,uBAAuBe,aAAaxC,IAApC,EAA0C2B,QAA1C,CAAP;GADF,MAEO;WACEF,uBAAuBC,QAAvB,EAAiCH,QAAQI,QAAR,EAAkB3B,IAAnD,CAAP;;;;ACjDJ;;;;;;;;AAQA,AAAe,SAASyC,SAAT,CAAmBnD,OAAnB,EAA0C;MAAdoD,IAAc,uEAAP,KAAO;;MACjDC,YAAYD,SAAS,KAAT,GAAiB,WAAjB,GAA+B,YAAjD;MACM5C,WAAWR,QAAQQ,QAAzB;;MAEIA,aAAa,MAAb,IAAuBA,aAAa,MAAxC,EAAgD;QACxC8C,OAAOtD,QAAQG,aAAR,CAAsBwB,eAAnC;QACM4B,mBAAmBvD,QAAQG,aAAR,CAAsBoD,gBAAtB,IAA0CD,IAAnE;WACOC,iBAAiBF,SAAjB,CAAP;;;SAGKrD,QAAQqD,SAAR,CAAP;;;AChBF;;;;;;;;;AASA,AAAe,SAASG,aAAT,CAAuBC,IAAvB,EAA6BzD,OAA7B,EAAwD;MAAlB0D,QAAkB,uEAAP,KAAO;;MAC/DC,YAAYR,UAAUnD,OAAV,EAAmB,KAAnB,CAAlB;MACM4D,aAAaT,UAAUnD,OAAV,EAAmB,MAAnB,CAAnB;MACM6D,WAAWH,WAAW,CAAC,CAAZ,GAAgB,CAAjC;OACKI,GAAL,IAAYH,YAAYE,QAAxB;OACKE,MAAL,IAAeJ,YAAYE,QAA3B;OACKG,IAAL,IAAaJ,aAAaC,QAA1B;OACKI,KAAL,IAAcL,aAAaC,QAA3B;SACOJ,IAAP;;;ACnBF;;;;;;;;;;AAUA,AAAe,SAASS,cAAT,CAAwBC,MAAxB,EAAgCC,IAAhC,EAAsC;MAC7CC,QAAQD,SAAS,GAAT,GAAe,MAAf,GAAwB,KAAtC;MACME,QAAQD,UAAU,MAAV,GAAmB,OAAnB,GAA6B,QAA3C;;SAGEE,WAAWJ,kBAAgBE,KAAhB,WAAX,IACAE,WAAWJ,kBAAgBG,KAAhB,WAAX,CAFF;;;ACZF,SAASE,OAAT,CAAiBJ,IAAjB,EAAuBxD,IAAvB,EAA6B0C,IAA7B,EAAmCmB,aAAnC,EAAkD;SACzCC,KAAKC,GAAL,CACL/D,gBAAcwD,IAAd,CADK,EAELxD,gBAAcwD,IAAd,CAFK,EAGLd,gBAAcc,IAAd,CAHK,EAILd,gBAAcc,IAAd,CAJK,EAKLd,gBAAcc,IAAd,CALK,EAML5C,KAAK,EAAL,IACKoD,SAAStB,gBAAcc,IAAd,CAAT,IACHQ,SAASH,0BAAuBL,SAAS,QAAT,GAAoB,KAApB,GAA4B,MAAnD,EAAT,CADG,GAEHQ,SAASH,0BAAuBL,SAAS,QAAT,GAAoB,QAApB,GAA+B,OAAtD,EAAT,CAHF,GAIE,CAVG,CAAP;;;AAcF,AAAe,SAASS,cAAT,CAAwBrG,QAAxB,EAAkC;MACzCoC,OAAOpC,SAASoC,IAAtB;MACM0C,OAAO9E,SAASmD,eAAtB;MACM8C,gBAAgBjD,KAAK,EAAL,KAAYlB,iBAAiBgD,IAAjB,CAAlC;;SAEO;YACGkB,QAAQ,QAAR,EAAkB5D,IAAlB,EAAwB0C,IAAxB,EAA8BmB,aAA9B,CADH;WAEED,QAAQ,OAAR,EAAiB5D,IAAjB,EAAuB0C,IAAvB,EAA6BmB,aAA7B;GAFT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBF;;;;;;;AAOA,AAAe,SAASK,aAAT,CAAuBC,OAAvB,EAAgC;sBAExCA,OADL;WAESA,QAAQf,IAAR,GAAee,QAAQC,KAFhC;YAGUD,QAAQjB,GAAR,GAAciB,QAAQE;;;;ACJlC;;;;;;;AAOA,AAAe,SAASC,qBAAT,CAA+BlF,OAA/B,EAAwC;MACjDyD,OAAO,EAAX;;;;;MAKI;QACEjC,KAAK,EAAL,CAAJ,EAAc;aACLxB,QAAQkF,qBAAR,EAAP;UACMvB,YAAYR,UAAUnD,OAAV,EAAmB,KAAnB,CAAlB;UACM4D,aAAaT,UAAUnD,OAAV,EAAmB,MAAnB,CAAnB;WACK8D,GAAL,IAAYH,SAAZ;WACKK,IAAL,IAAaJ,UAAb;WACKG,MAAL,IAAeJ,SAAf;WACKM,KAAL,IAAcL,UAAd;KAPF,MASK;aACI5D,QAAQkF,qBAAR,EAAP;;GAXJ,CAcA,OAAMC,CAAN,EAAQ;;MAEFC,SAAS;UACP3B,KAAKO,IADE;SAERP,KAAKK,GAFG;WAGNL,KAAKQ,KAAL,GAAaR,KAAKO,IAHZ;YAILP,KAAKM,MAAL,GAAcN,KAAKK;GAJ7B;;;MAQMuB,QAAQrF,QAAQQ,QAAR,KAAqB,MAArB,GAA8BqE,eAAe7E,QAAQG,aAAvB,CAA9B,GAAsE,EAApF;MACM6E,QACJK,MAAML,KAAN,IAAehF,QAAQsF,WAAvB,IAAsCF,OAAOJ,KAD/C;MAEMC,SACJI,MAAMJ,MAAN,IAAgBjF,QAAQuF,YAAxB,IAAwCH,OAAOH,MADjD;;MAGIO,iBAAiBxF,QAAQyF,WAAR,GAAsBT,KAA3C;MACIU,gBAAgB1F,QAAQ2F,YAAR,GAAuBV,MAA3C;;;;MAIIO,kBAAkBE,aAAtB,EAAqC;QAC7BvB,SAASpE,yBAAyBC,OAAzB,CAAf;sBACkBkE,eAAeC,MAAf,EAAuB,GAAvB,CAAlB;qBACiBD,eAAeC,MAAf,EAAuB,GAAvB,CAAjB;;WAEOa,KAAP,IAAgBQ,cAAhB;WACOP,MAAP,IAAiBS,aAAjB;;;SAGKZ,cAAcM,MAAd,CAAP;;;ACzDa,SAASQ,oCAAT,CAA8CC,QAA9C,EAAwDC,MAAxD,EAAuF;MAAvBC,aAAuB,uEAAP,KAAO;;MAC9FxE,SAASyE,KAAQ,EAAR,CAAf;MACMC,SAASH,OAAOtF,QAAP,KAAoB,MAAnC;MACM0F,eAAehB,sBAAsBW,QAAtB,CAArB;MACMM,aAAajB,sBAAsBY,MAAtB,CAAnB;MACMM,eAAezF,gBAAgBkF,QAAhB,CAArB;;MAEM1B,SAASpE,yBAAyB+F,MAAzB,CAAf;MACMO,iBAAiB9B,WAAWJ,OAAOkC,cAAlB,CAAvB;MACMC,kBAAkB/B,WAAWJ,OAAOmC,eAAlB,CAAxB;;;MAGGP,iBAAiBE,MAApB,EAA4B;eACfnC,GAAX,GAAiBY,KAAKC,GAAL,CAASwB,WAAWrC,GAApB,EAAyB,CAAzB,CAAjB;eACWE,IAAX,GAAkBU,KAAKC,GAAL,CAASwB,WAAWnC,IAApB,EAA0B,CAA1B,CAAlB;;MAEEe,UAAUD,cAAc;SACrBoB,aAAapC,GAAb,GAAmBqC,WAAWrC,GAA9B,GAAoCuC,cADf;UAEpBH,aAAalC,IAAb,GAAoBmC,WAAWnC,IAA/B,GAAsCsC,eAFlB;WAGnBJ,aAAalB,KAHM;YAIlBkB,aAAajB;GAJT,CAAd;UAMQsB,SAAR,GAAoB,CAApB;UACQC,UAAR,GAAqB,CAArB;;;;;;MAMI,CAACjF,MAAD,IAAW0E,MAAf,EAAuB;QACfM,YAAYhC,WAAWJ,OAAOoC,SAAlB,CAAlB;QACMC,aAAajC,WAAWJ,OAAOqC,UAAlB,CAAnB;;YAEQ1C,GAAR,IAAeuC,iBAAiBE,SAAhC;YACQxC,MAAR,IAAkBsC,iBAAiBE,SAAnC;YACQvC,IAAR,IAAgBsC,kBAAkBE,UAAlC;YACQvC,KAAR,IAAiBqC,kBAAkBE,UAAnC;;;YAGQD,SAAR,GAAoBA,SAApB;YACQC,UAAR,GAAqBA,UAArB;;;MAIAjF,UAAU,CAACwE,aAAX,GACID,OAAO7C,QAAP,CAAgBmD,YAAhB,CADJ,GAEIN,WAAWM,YAAX,IAA2BA,aAAa5F,QAAb,KAA0B,MAH3D,EAIE;cACUgD,cAAcuB,OAAd,EAAuBe,MAAvB,CAAV;;;SAGKf,OAAP;;;ACtDa,SAAS0B,6CAAT,CAAuDzG,OAAvD,EAAuF;MAAvB0G,aAAuB,uEAAP,KAAO;;MAC9FpD,OAAOtD,QAAQG,aAAR,CAAsBwB,eAAnC;MACMgF,iBAAiBf,qCAAqC5F,OAArC,EAA8CsD,IAA9C,CAAvB;MACM0B,QAAQN,KAAKC,GAAL,CAASrB,KAAKgC,WAAd,EAA2B/G,OAAOqI,UAAP,IAAqB,CAAhD,CAAd;MACM3B,SAASP,KAAKC,GAAL,CAASrB,KAAKiC,YAAd,EAA4BhH,OAAOsI,WAAP,IAAsB,CAAlD,CAAf;;MAEMlD,YAAY,CAAC+C,aAAD,GAAiBvD,UAAUG,IAAV,CAAjB,GAAmC,CAArD;MACMM,aAAa,CAAC8C,aAAD,GAAiBvD,UAAUG,IAAV,EAAgB,MAAhB,CAAjB,GAA2C,CAA9D;;MAEMwD,SAAS;SACRnD,YAAYgD,eAAe7C,GAA3B,GAAiC6C,eAAeJ,SADxC;UAEP3C,aAAa+C,eAAe3C,IAA5B,GAAmC2C,eAAeH,UAF3C;gBAAA;;GAAf;;SAOO1B,cAAcgC,MAAd,CAAP;;;ACjBF;;;;;;;;AAQA,AAAe,SAASC,OAAT,CAAiB/G,OAAjB,EAA0B;MACjCQ,WAAWR,QAAQQ,QAAzB;MACIA,aAAa,MAAb,IAAuBA,aAAa,MAAxC,EAAgD;WACvC,KAAP;;MAEET,yBAAyBC,OAAzB,EAAkC,UAAlC,MAAkD,OAAtD,EAA+D;WACtD,IAAP;;MAEIS,aAAaF,cAAcP,OAAd,CAAnB;MACI,CAACS,UAAL,EAAiB;WACR,KAAP;;SAEKsG,QAAQtG,UAAR,CAAP;;;ACrBF;;;;;;;;AAQA,AAAe,SAASuG,4BAAT,CAAsChH,OAAtC,EAA+C;;MAEvD,CAACA,OAAD,IAAY,CAACA,QAAQiH,aAArB,IAAsCzF,MAA1C,EAAkD;WAC1ChD,SAASmD,eAAhB;;MAEEuF,KAAKlH,QAAQiH,aAAjB;SACOC,MAAMnH,yBAAyBmH,EAAzB,EAA6B,WAA7B,MAA8C,MAA3D,EAAmE;SAC5DA,GAAGD,aAAR;;SAEKC,MAAM1I,SAASmD,eAAtB;;;ACTF;;;;;;;;;;;AAWA,AAAe,SAASwF,aAAT,CACbC,MADa,EAEblG,SAFa,EAGbmG,OAHa,EAIbC,iBAJa,EAMb;MADAvB,aACA,uEADgB,KAChB;;;;MAGIwB,aAAa,EAAEzD,KAAK,CAAP,EAAUE,MAAM,CAAhB,EAAjB;MACMnC,eAAekE,gBAAgBiB,6BAA6BI,MAA7B,CAAhB,GAAuDjF,uBAAuBiF,MAAvB,EAA+BnG,iBAAiBC,SAAjB,CAA/B,CAA5E;;;MAGIoG,sBAAsB,UAA1B,EAAuC;iBACxBb,8CAA8C5E,YAA9C,EAA4DkE,aAA5D,CAAb;GADF,MAIK;;QAECyB,uBAAJ;QACIF,sBAAsB,cAA1B,EAA0C;uBACvB3G,gBAAgBJ,cAAcW,SAAd,CAAhB,CAAjB;UACIsG,eAAehH,QAAf,KAA4B,MAAhC,EAAwC;yBACrB4G,OAAOjH,aAAP,CAAqBwB,eAAtC;;KAHJ,MAKO,IAAI2F,sBAAsB,QAA1B,EAAoC;uBACxBF,OAAOjH,aAAP,CAAqBwB,eAAtC;KADK,MAEA;uBACY2F,iBAAjB;;;QAGIvC,UAAUa,qCACd4B,cADc,EAEd3F,YAFc,EAGdkE,aAHc,CAAhB;;;QAOIyB,eAAehH,QAAf,KAA4B,MAA5B,IAAsC,CAACuG,QAAQlF,YAAR,CAA3C,EAAkE;4BACtCgD,eAAeuC,OAAOjH,aAAtB,CADsC;UACxD8E,MADwD,mBACxDA,MADwD;UAChDD,KADgD,mBAChDA,KADgD;;iBAErDlB,GAAX,IAAkBiB,QAAQjB,GAAR,GAAciB,QAAQwB,SAAxC;iBACWxC,MAAX,GAAoBkB,SAASF,QAAQjB,GAArC;iBACWE,IAAX,IAAmBe,QAAQf,IAAR,GAAee,QAAQyB,UAA1C;iBACWvC,KAAX,GAAmBe,QAAQD,QAAQf,IAAnC;KALF,MAMO;;mBAEQe,OAAb;;;;;YAKMsC,WAAW,CAArB;MACMI,kBAAkB,OAAOJ,OAAP,KAAmB,QAA3C;aACWrD,IAAX,IAAmByD,kBAAkBJ,OAAlB,GAA4BA,QAAQrD,IAAR,IAAgB,CAA/D;aACWF,GAAX,IAAkB2D,kBAAkBJ,OAAlB,GAA4BA,QAAQvD,GAAR,IAAe,CAA7D;aACWG,KAAX,IAAoBwD,kBAAkBJ,OAAlB,GAA4BA,QAAQpD,KAAR,IAAiB,CAAjE;aACWF,MAAX,IAAqB0D,kBAAkBJ,OAAlB,GAA4BA,QAAQtD,MAAR,IAAkB,CAAnE;;SAEOwD,UAAP;;;AC7EF,SAASG,OAAT,OAAoC;MAAjB1C,KAAiB,QAAjBA,KAAiB;MAAVC,MAAU,QAAVA,MAAU;;SAC3BD,QAAQC,MAAf;;;;;;;;;;;;AAYF,AAAe,SAAS0C,oBAAT,CACbC,SADa,EAEbC,OAFa,EAGbT,MAHa,EAIblG,SAJa,EAKboG,iBALa,EAOb;MADAD,OACA,uEADU,CACV;;MACIO,UAAU5I,OAAV,CAAkB,MAAlB,MAA8B,CAAC,CAAnC,EAAsC;WAC7B4I,SAAP;;;MAGIL,aAAaJ,cACjBC,MADiB,EAEjBlG,SAFiB,EAGjBmG,OAHiB,EAIjBC,iBAJiB,CAAnB;;MAOMQ,QAAQ;SACP;aACIP,WAAWvC,KADf;cAEK6C,QAAQ/D,GAAR,GAAcyD,WAAWzD;KAHvB;WAKL;aACEyD,WAAWtD,KAAX,GAAmB4D,QAAQ5D,KAD7B;cAEGsD,WAAWtC;KAPT;YASJ;aACCsC,WAAWvC,KADZ;cAEEuC,WAAWxD,MAAX,GAAoB8D,QAAQ9D;KAX1B;UAaN;aACG8D,QAAQ7D,IAAR,GAAeuD,WAAWvD,IAD7B;cAEIuD,WAAWtC;;GAfvB;;MAmBM8C,cAAcC,OAAOC,IAAP,CAAYH,KAAZ,EACjBI,GADiB,CACb;;;OAEAJ,MAAMK,GAAN,CAFA;YAGGT,QAAQI,MAAMK,GAAN,CAAR;;GAJU,EAMjBC,IANiB,CAMZ,UAACC,CAAD,EAAIC,CAAJ;WAAUA,EAAEC,IAAF,GAASF,EAAEE,IAArB;GANY,CAApB;;MAQMC,gBAAgBT,YAAYU,MAAZ,CACpB;QAAGzD,KAAH,SAAGA,KAAH;QAAUC,MAAV,SAAUA,MAAV;WACED,SAASoC,OAAO9B,WAAhB,IAA+BL,UAAUmC,OAAO7B,YADlD;GADoB,CAAtB;;MAKMmD,oBAAoBF,cAAc3J,MAAd,GAAuB,CAAvB,GACtB2J,cAAc,CAAd,EAAiBL,GADK,GAEtBJ,YAAY,CAAZ,EAAeI,GAFnB;;MAIMQ,YAAYf,UAAUgB,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAlB;;SAEOF,qBAAqBC,kBAAgBA,SAAhB,GAA8B,EAAnD,CAAP;;;ACnEF;;;;;;;;;;AAUA,AAAe,SAASE,mBAAT,CAA6BC,KAA7B,EAAoC1B,MAApC,EAA4ClG,SAA5C,EAA6E;MAAtB6E,aAAsB,uEAAN,IAAM;;MACpFgD,qBAAqBhD,gBAAgBiB,6BAA6BI,MAA7B,CAAhB,GAAuDjF,uBAAuBiF,MAAvB,EAA+BnG,iBAAiBC,SAAjB,CAA/B,CAAlF;SACO0E,qCAAqC1E,SAArC,EAAgD6H,kBAAhD,EAAoEhD,aAApE,CAAP;;;ACjBF;;;;;;;AAOA,AAAe,SAASiD,aAAT,CAAuBhJ,OAAvB,EAAgC;MACvCzB,SAASyB,QAAQG,aAAR,CAAsBC,WAArC;MACM+D,SAAS5F,OAAO+B,gBAAP,CAAwBN,OAAxB,CAAf;MACMiJ,IAAI1E,WAAWJ,OAAOoC,SAAP,IAAoB,CAA/B,IAAoChC,WAAWJ,OAAO+E,YAAP,IAAuB,CAAlC,CAA9C;MACMC,IAAI5E,WAAWJ,OAAOqC,UAAP,IAAqB,CAAhC,IAAqCjC,WAAWJ,OAAOiF,WAAP,IAAsB,CAAjC,CAA/C;MACMhE,SAAS;WACNpF,QAAQyF,WAAR,GAAsB0D,CADhB;YAELnJ,QAAQ2F,YAAR,GAAuBsD;GAFjC;SAIO7D,MAAP;;;AChBF;;;;;;;AAOA,AAAe,SAASiE,oBAAT,CAA8BzB,SAA9B,EAAyC;MAChD0B,OAAO,EAAEtF,MAAM,OAAR,EAAiBC,OAAO,MAAxB,EAAgCF,QAAQ,KAAxC,EAA+CD,KAAK,QAApD,EAAb;SACO8D,UAAU2B,OAAV,CAAkB,wBAAlB,EAA4C;WAAWD,KAAKE,OAAL,CAAX;GAA5C,CAAP;;;ACNF;;;;;;;;;;AAUA,AAAe,SAASC,gBAAT,CAA0BrC,MAA1B,EAAkCsC,gBAAlC,EAAoD9B,SAApD,EAA+D;cAChEA,UAAUgB,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAZ;;;MAGMe,aAAaX,cAAc5B,MAAd,CAAnB;;;MAGMwC,gBAAgB;WACbD,WAAW3E,KADE;YAEZ2E,WAAW1E;GAFrB;;;MAMM4E,UAAU,CAAC,OAAD,EAAU,MAAV,EAAkB7K,OAAlB,CAA0B4I,SAA1B,MAAyC,CAAC,CAA1D;MACMkC,WAAWD,UAAU,KAAV,GAAkB,MAAnC;MACME,gBAAgBF,UAAU,MAAV,GAAmB,KAAzC;MACMG,cAAcH,UAAU,QAAV,GAAqB,OAAzC;MACMI,uBAAuB,CAACJ,OAAD,GAAW,QAAX,GAAsB,OAAnD;;gBAEcC,QAAd,IACEJ,iBAAiBI,QAAjB,IACAJ,iBAAiBM,WAAjB,IAAgC,CADhC,GAEAL,WAAWK,WAAX,IAA0B,CAH5B;MAIIpC,cAAcmC,aAAlB,EAAiC;kBACjBA,aAAd,IACEL,iBAAiBK,aAAjB,IAAkCJ,WAAWM,oBAAX,CADpC;GADF,MAGO;kBACSF,aAAd,IACEL,iBAAiBL,qBAAqBU,aAArB,CAAjB,CADF;;;SAIKH,aAAP;;;AC5CF;;;;;;;;;AASA,AAAe,SAASM,IAAT,CAAcC,GAAd,EAAmBC,KAAnB,EAA0B;;MAEnCC,MAAMC,SAAN,CAAgBJ,IAApB,EAA0B;WACjBC,IAAID,IAAJ,CAASE,KAAT,CAAP;;;;SAIKD,IAAI1B,MAAJ,CAAW2B,KAAX,EAAkB,CAAlB,CAAP;;;ACdF;;;;;;;;;AASA,AAAe,SAASG,SAAT,CAAmBJ,GAAnB,EAAwBK,IAAxB,EAA8BC,KAA9B,EAAqC;;MAE9CJ,MAAMC,SAAN,CAAgBC,SAApB,EAA+B;WACtBJ,IAAII,SAAJ,CAAc;aAAOG,IAAIF,IAAJ,MAAcC,KAArB;KAAd,CAAP;;;;MAIIE,QAAQT,KAAKC,GAAL,EAAU;WAAOS,IAAIJ,IAAJ,MAAcC,KAArB;GAAV,CAAd;SACON,IAAInL,OAAJ,CAAY2L,KAAZ,CAAP;;;ACfF;;;;;;;;;;AAUA,AAAe,SAASE,YAAT,CAAsBC,SAAtB,EAAiCC,IAAjC,EAAuCC,IAAvC,EAA6C;MACpDC,iBAAiBD,SAASE,SAAT,GACnBJ,SADmB,GAEnBA,UAAUK,KAAV,CAAgB,CAAhB,EAAmBZ,UAAUO,SAAV,EAAqB,MAArB,EAA6BE,IAA7B,CAAnB,CAFJ;;iBAIeI,OAAf,CAAuB,oBAAY;QAC7BvH,SAAS,UAAT,CAAJ,EAA0B;;cAChBwH,IAAR,CAAa,uDAAb;;QAEInM,KAAK2E,SAAS,UAAT,KAAwBA,SAAS3E,EAA5C,CAJiC;QAK7B2E,SAASyH,OAAT,IAAoB5L,WAAWR,EAAX,CAAxB,EAAwC;;;;WAIjC6F,OAAL,CAAaqC,MAAb,GAAsBtC,cAAciG,KAAKhG,OAAL,CAAaqC,MAA3B,CAAtB;WACKrC,OAAL,CAAa7D,SAAb,GAAyB4D,cAAciG,KAAKhG,OAAL,CAAa7D,SAA3B,CAAzB;;aAEOhC,GAAG6L,IAAH,EAASlH,QAAT,CAAP;;GAZJ;;SAgBOkH,IAAP;;;AC9BF;;;;;;;AAOA,AAAe,SAASQ,MAAT,GAAkB;;MAE3B,KAAKzC,KAAL,CAAW0C,WAAf,EAA4B;;;;MAIxBT,OAAO;cACC,IADD;YAED,EAFC;iBAGI,EAHJ;gBAIG,EAJH;aAKA,KALA;aAMA;GANX;;;OAUKhG,OAAL,CAAa7D,SAAb,GAAyB2H,oBACvB,KAAKC,KADkB,EAEvB,KAAK1B,MAFkB,EAGvB,KAAKlG,SAHkB,EAIvB,KAAKuK,OAAL,CAAaC,aAJU,CAAzB;;;;;OAUK9D,SAAL,GAAiBD,qBACf,KAAK8D,OAAL,CAAa7D,SADE,EAEfmD,KAAKhG,OAAL,CAAa7D,SAFE,EAGf,KAAKkG,MAHU,EAIf,KAAKlG,SAJU,EAKf,KAAKuK,OAAL,CAAaX,SAAb,CAAuBa,IAAvB,CAA4BrE,iBALb,EAMf,KAAKmE,OAAL,CAAaX,SAAb,CAAuBa,IAAvB,CAA4BtE,OANb,CAAjB;;;OAUKuE,iBAAL,GAAyBb,KAAKnD,SAA9B;;OAEK8D,aAAL,GAAqB,KAAKD,OAAL,CAAaC,aAAlC;;;OAGK3G,OAAL,CAAaqC,MAAb,GAAsBqC,iBACpB,KAAKrC,MADe,EAEpB2D,KAAKhG,OAAL,CAAa7D,SAFO,EAGpB6J,KAAKnD,SAHe,CAAtB;;OAMK7C,OAAL,CAAaqC,MAAb,CAAoByE,QAApB,GAA+B,KAAKJ,OAAL,CAAaC,aAAb,GAC3B,OAD2B,GAE3B,UAFJ;;;SAKOb,aAAa,KAAKC,SAAlB,EAA6BC,IAA7B,CAAP;;;;MAII,CAAC,KAAKjC,KAAL,CAAWgD,SAAhB,EAA2B;SACpBhD,KAAL,CAAWgD,SAAX,GAAuB,IAAvB;SACKL,OAAL,CAAaM,QAAb,CAAsBhB,IAAtB;GAFF,MAGO;SACAU,OAAL,CAAaO,QAAb,CAAsBjB,IAAtB;;;;ACxEJ;;;;;;AAMA,AAAe,SAASkB,iBAAT,CAA2BnB,SAA3B,EAAsCoB,YAAtC,EAAoD;SAC1DpB,UAAUqB,IAAV,CACL;QAAGC,IAAH,QAAGA,IAAH;QAASd,OAAT,QAASA,OAAT;WAAuBA,WAAWc,SAASF,YAA3C;GADK,CAAP;;;ACPF;;;;;;;AAOA,AAAe,SAASG,wBAAT,CAAkCpM,QAAlC,EAA4C;MACnDqM,WAAW,CAAC,KAAD,EAAQ,IAAR,EAAc,QAAd,EAAwB,KAAxB,EAA+B,GAA/B,CAAjB;MACMC,YAAYtM,SAASuM,MAAT,CAAgB,CAAhB,EAAmBC,WAAnB,KAAmCxM,SAASkL,KAAT,CAAe,CAAf,CAArD;;OAEK,IAAIvM,IAAI,CAAb,EAAgBA,IAAI0N,SAASzN,MAA7B,EAAqCD,GAArC,EAA0C;QAClC8N,SAASJ,SAAS1N,CAAT,CAAf;QACM+N,UAAUD,cAAYA,MAAZ,GAAqBH,SAArB,GAAmCtM,QAAnD;QACI,OAAOzB,SAASoC,IAAT,CAAcgM,KAAd,CAAoBD,OAApB,CAAP,KAAwC,WAA5C,EAAyD;aAChDA,OAAP;;;SAGG,IAAP;;;ACfF;;;;;AAKA,AAAe,SAASE,OAAT,GAAmB;OAC3B/D,KAAL,CAAW0C,WAAX,GAAyB,IAAzB;;;MAGIS,kBAAkB,KAAKnB,SAAvB,EAAkC,YAAlC,CAAJ,EAAqD;SAC9C1D,MAAL,CAAY0F,eAAZ,CAA4B,aAA5B;SACK1F,MAAL,CAAYwF,KAAZ,CAAkBf,QAAlB,GAA6B,EAA7B;SACKzE,MAAL,CAAYwF,KAAZ,CAAkB9I,GAAlB,GAAwB,EAAxB;SACKsD,MAAL,CAAYwF,KAAZ,CAAkB5I,IAAlB,GAAyB,EAAzB;SACKoD,MAAL,CAAYwF,KAAZ,CAAkB3I,KAAlB,GAA0B,EAA1B;SACKmD,MAAL,CAAYwF,KAAZ,CAAkB7I,MAAlB,GAA2B,EAA3B;SACKqD,MAAL,CAAYwF,KAAZ,CAAkBG,UAAlB,GAA+B,EAA/B;SACK3F,MAAL,CAAYwF,KAAZ,CAAkBP,yBAAyB,WAAzB,CAAlB,IAA2D,EAA3D;;;OAGGW,qBAAL;;;;MAII,KAAKvB,OAAL,CAAawB,eAAjB,EAAkC;SAC3B7F,MAAL,CAAY3G,UAAZ,CAAuByM,WAAvB,CAAmC,KAAK9F,MAAxC;;SAEK,IAAP;;;AC9BF;;;;;AAKA,AAAe,SAAS+F,SAAT,CAAmBnN,OAAnB,EAA4B;MACnCG,gBAAgBH,QAAQG,aAA9B;SACOA,gBAAgBA,cAAcC,WAA9B,GAA4C7B,MAAnD;;;ACJF,SAAS6O,qBAAT,CAA+BhH,YAA/B,EAA6CiH,KAA7C,EAAoDC,QAApD,EAA8DC,aAA9D,EAA6E;MACrEC,SAASpH,aAAa5F,QAAb,KAA0B,MAAzC;MACMiN,SAASD,SAASpH,aAAajG,aAAb,CAA2BC,WAApC,GAAkDgG,YAAjE;SACOsH,gBAAP,CAAwBL,KAAxB,EAA+BC,QAA/B,EAAyC,EAAEK,SAAS,IAAX,EAAzC;;MAEI,CAACH,MAAL,EAAa;0BAET7M,gBAAgB8M,OAAOhN,UAAvB,CADF,EAEE4M,KAFF,EAGEC,QAHF,EAIEC,aAJF;;gBAOYK,IAAd,CAAmBH,MAAnB;;;;;;;;;AASF,AAAe,SAASI,mBAAT,CACb3M,SADa,EAEbuK,OAFa,EAGb3C,KAHa,EAIbgF,WAJa,EAKb;;QAEMA,WAAN,GAAoBA,WAApB;YACU5M,SAAV,EAAqBwM,gBAArB,CAAsC,QAAtC,EAAgD5E,MAAMgF,WAAtD,EAAmE,EAAEH,SAAS,IAAX,EAAnE;;;MAGMI,gBAAgBpN,gBAAgBO,SAAhB,CAAtB;wBAEE6M,aADF,EAEE,QAFF,EAGEjF,MAAMgF,WAHR,EAIEhF,MAAMyE,aAJR;QAMMQ,aAAN,GAAsBA,aAAtB;QACMC,aAAN,GAAsB,IAAtB;;SAEOlF,KAAP;;;AC5CF;;;;;;AAMA,AAAe,SAASmF,oBAAT,GAAgC;MACzC,CAAC,KAAKnF,KAAL,CAAWkF,aAAhB,EAA+B;SACxBlF,KAAL,GAAa+E,oBACX,KAAK3M,SADM,EAEX,KAAKuK,OAFM,EAGX,KAAK3C,KAHM,EAIX,KAAKoF,cAJM,CAAb;;;;ACRJ;;;;;;AAMA,AAAe,SAASC,oBAAT,CAA8BjN,SAA9B,EAAyC4H,KAAzC,EAAgD;;YAEnD5H,SAAV,EAAqBkN,mBAArB,CAAyC,QAAzC,EAAmDtF,MAAMgF,WAAzD;;;QAGMP,aAAN,CAAoBnC,OAApB,CAA4B,kBAAU;WAC7BgD,mBAAP,CAA2B,QAA3B,EAAqCtF,MAAMgF,WAA3C;GADF;;;QAKMA,WAAN,GAAoB,IAApB;QACMP,aAAN,GAAsB,EAAtB;QACMQ,aAAN,GAAsB,IAAtB;QACMC,aAAN,GAAsB,KAAtB;SACOlF,KAAP;;;ACpBF;;;;;;;AAOA,AAAe,SAASkE,qBAAT,GAAiC;MAC1C,KAAKlE,KAAL,CAAWkF,aAAf,EAA8B;yBACP,KAAKE,cAA1B;SACKpF,KAAL,GAAaqF,qBAAqB,KAAKjN,SAA1B,EAAqC,KAAK4H,KAA1C,CAAb;;;;ACZJ;;;;;;;AAOA,AAAe,SAASuF,SAAT,CAAmBC,CAAnB,EAAsB;SAC5BA,MAAM,EAAN,IAAY,CAACC,MAAMhK,WAAW+J,CAAX,CAAN,CAAb,IAAqCE,SAASF,CAAT,CAA5C;;;ACNF;;;;;;;;AAQA,AAAe,SAASG,SAAT,CAAmBzO,OAAnB,EAA4BmE,MAA5B,EAAoC;SAC1C8D,IAAP,CAAY9D,MAAZ,EAAoBiH,OAApB,CAA4B,gBAAQ;QAC9BsD,OAAO,EAAX;;QAGE,CAAC,OAAD,EAAU,QAAV,EAAoB,KAApB,EAA2B,OAA3B,EAAoC,QAApC,EAA8C,MAA9C,EAAsD1P,OAAtD,CAA8DwL,IAA9D,MACE,CAAC,CADH,IAEA6D,UAAUlK,OAAOqG,IAAP,CAAV,CAHF,EAIE;aACO,IAAP;;YAEMoC,KAAR,CAAcpC,IAAd,IAAsBrG,OAAOqG,IAAP,IAAekE,IAArC;GAVF;;;ACXF;;;;;;;;AAQA,AAAe,SAASC,aAAT,CAAuB3O,OAAvB,EAAgC4O,UAAhC,EAA4C;SAClD3G,IAAP,CAAY2G,UAAZ,EAAwBxD,OAAxB,CAAgC,UAASZ,IAAT,EAAe;QACvCC,QAAQmE,WAAWpE,IAAX,CAAd;QACIC,UAAU,KAAd,EAAqB;cACXoE,YAAR,CAAqBrE,IAArB,EAA2BoE,WAAWpE,IAAX,CAA3B;KADF,MAEO;cACGsC,eAAR,CAAwBtC,IAAxB;;GALJ;;;ACJF;;;;;;;;;AASA,AAAe,SAASsE,UAAT,CAAoB/D,IAApB,EAA0B;;;;;YAK7BA,KAAKgE,QAAL,CAAc3H,MAAxB,EAAgC2D,KAAK5G,MAArC;;;;gBAIc4G,KAAKgE,QAAL,CAAc3H,MAA5B,EAAoC2D,KAAK6D,UAAzC;;;MAGI7D,KAAKiE,YAAL,IAAqBhH,OAAOC,IAAP,CAAY8C,KAAKkE,WAAjB,EAA8BpQ,MAAvD,EAA+D;cACnDkM,KAAKiE,YAAf,EAA6BjE,KAAKkE,WAAlC;;;SAGKlE,IAAP;;;;;;;;;;;;;AAaF,AAAO,SAASmE,gBAAT,CACLhO,SADK,EAELkG,MAFK,EAGLqE,OAHK,EAIL0D,eAJK,EAKLrG,KALK,EAML;;MAEMY,mBAAmBb,oBAAoBC,KAApB,EAA2B1B,MAA3B,EAAmClG,SAAnC,EAA8CuK,QAAQC,aAAtD,CAAzB;;;;;MAKM9D,YAAYD,qBAChB8D,QAAQ7D,SADQ,EAEhB8B,gBAFgB,EAGhBtC,MAHgB,EAIhBlG,SAJgB,EAKhBuK,QAAQX,SAAR,CAAkBa,IAAlB,CAAuBrE,iBALP,EAMhBmE,QAAQX,SAAR,CAAkBa,IAAlB,CAAuBtE,OANP,CAAlB;;SASOwH,YAAP,CAAoB,aAApB,EAAmCjH,SAAnC;;;;YAIUR,MAAV,EAAkB,EAAEyE,UAAUJ,QAAQC,aAAR,GAAwB,OAAxB,GAAkC,UAA9C,EAAlB;;SAEOD,OAAP;;;ACvEF;;;;;;;;;;;;;;;;;;;AAmBA,AAAe,SAAS2D,iBAAT,CAA2BrE,IAA3B,EAAiCsE,WAAjC,EAA8C;sBAC7BtE,KAAKhG,OADwB;MACnDqC,MADmD,iBACnDA,MADmD;MAC3ClG,SAD2C,iBAC3CA,SAD2C;MAEnDoO,KAFmD,GAElC5K,IAFkC,CAEnD4K,KAFmD;MAE5CC,KAF4C,GAElC7K,IAFkC,CAE5C6K,KAF4C;;MAGrDC,UAAU,SAAVA,OAAU;WAAKC,CAAL;GAAhB;;MAEMC,iBAAiBJ,MAAMpO,UAAU8D,KAAhB,CAAvB;MACM2K,cAAcL,MAAMlI,OAAOpC,KAAb,CAApB;;MAEM4K,aAAa,CAAC,MAAD,EAAS,OAAT,EAAkB5Q,OAAlB,CAA0B+L,KAAKnD,SAA/B,MAA8C,CAAC,CAAlE;MACMiI,cAAc9E,KAAKnD,SAAL,CAAe5I,OAAf,CAAuB,GAAvB,MAAgC,CAAC,CAArD;MACM8Q,kBAAkBJ,iBAAiB,CAAjB,KAAuBC,cAAc,CAA7D;MACMI,eAAeL,iBAAiB,CAAjB,KAAuB,CAAvB,IAA4BC,cAAc,CAAd,KAAoB,CAArE;;MAEMK,sBAAsB,CAACX,WAAD,GACxBG,OADwB,GAExBI,cAAcC,WAAd,IAA6BC,eAA7B,GACAR,KADA,GAEAC,KAJJ;MAKMU,oBAAoB,CAACZ,WAAD,GAAeG,OAAf,GAAyBF,KAAnD;;SAEO;UACCU,oBACJD,gBAAgB,CAACF,WAAjB,IAAgCR,WAAhC,GACIjI,OAAOpD,IAAP,GAAc,CADlB,GAEIoD,OAAOpD,IAHP,CADD;SAMAiM,kBAAkB7I,OAAOtD,GAAzB,CANA;YAOGmM,kBAAkB7I,OAAOrD,MAAzB,CAPH;WAQEiM,oBAAoB5I,OAAOnD,KAA3B;GART;;;AChCF,IAAMiM,YAAYpR,aAAa,WAAWkC,IAAX,CAAgBvC,UAAUM,SAA1B,CAA/B;;;;;;;;;AASA,AAAe,SAASoR,YAAT,CAAsBpF,IAAtB,EAA4BU,OAA5B,EAAqC;MAC1CxC,CAD0C,GACjCwC,OADiC,CAC1CxC,CAD0C;MACvCE,CADuC,GACjCsC,OADiC,CACvCtC,CADuC;MAE1C/B,MAF0C,GAE/B2D,KAAKhG,OAF0B,CAE1CqC,MAF0C;;;;MAK5CgJ,8BAA8BlG,KAClCa,KAAKgE,QAAL,CAAcjE,SADoB,EAElC;WAAYjH,SAASuI,IAAT,KAAkB,YAA9B;GAFkC,EAGlCiE,eAHF;MAIID,gCAAgClF,SAApC,EAA+C;YACrCG,IAAR,CACE,+HADF;;MAIIgF,kBACJD,gCAAgClF,SAAhC,GACIkF,2BADJ,GAEI3E,QAAQ4E,eAHd;;MAKMxO,eAAeH,gBAAgBqJ,KAAKgE,QAAL,CAAc3H,MAA9B,CAArB;MACMkJ,mBAAmBpL,sBAAsBrD,YAAtB,CAAzB;;;MAGMsC,SAAS;cACHiD,OAAOyE;GADnB;;MAIM9G,UAAUqK,kBACdrE,IADc,EAEdxM,OAAOgS,gBAAP,GAA0B,CAA1B,IAA+B,CAACL,SAFlB,CAAhB;;MAKM7L,QAAQ4E,MAAM,QAAN,GAAiB,KAAjB,GAAyB,QAAvC;MACM3E,QAAQ6E,MAAM,OAAN,GAAgB,MAAhB,GAAyB,OAAvC;;;;;MAKMqH,mBAAmBnE,yBAAyB,WAAzB,CAAzB;;;;;;;;;;;MAWIrI,aAAJ;MAAUF,YAAV;MACIO,UAAU,QAAd,EAAwB;;;QAGlBxC,aAAarB,QAAb,KAA0B,MAA9B,EAAsC;YAC9B,CAACqB,aAAa0D,YAAd,GAA6BR,QAAQhB,MAA3C;KADF,MAEO;YACC,CAACuM,iBAAiBrL,MAAlB,GAA2BF,QAAQhB,MAAzC;;GANJ,MAQO;UACCgB,QAAQjB,GAAd;;MAEEQ,UAAU,OAAd,EAAuB;QACjBzC,aAAarB,QAAb,KAA0B,MAA9B,EAAsC;aAC7B,CAACqB,aAAayD,WAAd,GAA4BP,QAAQd,KAA3C;KADF,MAEO;aACE,CAACqM,iBAAiBtL,KAAlB,GAA0BD,QAAQd,KAAzC;;GAJJ,MAMO;WACEc,QAAQf,IAAf;;MAEEqM,mBAAmBG,gBAAvB,EAAyC;WAChCA,gBAAP,qBAA0CxM,IAA1C,YAAqDF,GAArD;WACOO,KAAP,IAAgB,CAAhB;WACOC,KAAP,IAAgB,CAAhB;WACOyI,UAAP,GAAoB,WAApB;GAJF,MAKO;;QAEC0D,YAAYpM,UAAU,QAAV,GAAqB,CAAC,CAAtB,GAA0B,CAA5C;QACMqM,aAAapM,UAAU,OAAV,GAAoB,CAAC,CAArB,GAAyB,CAA5C;WACOD,KAAP,IAAgBP,MAAM2M,SAAtB;WACOnM,KAAP,IAAgBN,OAAO0M,UAAvB;WACO3D,UAAP,GAAuB1I,KAAvB,UAAiCC,KAAjC;;;;MAIIsK,aAAa;mBACF7D,KAAKnD;GADtB;;;OAKKgH,UAAL,gBAAuBA,UAAvB,EAAsC7D,KAAK6D,UAA3C;OACKzK,MAAL,gBAAmBA,MAAnB,EAA8B4G,KAAK5G,MAAnC;OACK8K,WAAL,gBAAwBlE,KAAKhG,OAAL,CAAa4L,KAArC,EAA+C5F,KAAKkE,WAApD;;SAEOlE,IAAP;;;AC5GF;;;;;;;;;;AAUA,AAAe,SAAS6F,kBAAT,CACb9F,SADa,EAEb+F,cAFa,EAGbC,aAHa,EAIb;MACMC,aAAa7G,KAAKY,SAAL,EAAgB;QAAGsB,IAAH,QAAGA,IAAH;WAAcA,SAASyE,cAAvB;GAAhB,CAAnB;;MAEMG,aACJ,CAAC,CAACD,UAAF,IACAjG,UAAUqB,IAAV,CAAe,oBAAY;WAEvBtI,SAASuI,IAAT,KAAkB0E,aAAlB,IACAjN,SAASyH,OADT,IAEAzH,SAASvB,KAAT,GAAiByO,WAAWzO,KAH9B;GADF,CAFF;;MAUI,CAAC0O,UAAL,EAAiB;QACTD,oBAAkBF,cAAlB,MAAN;QACMI,kBAAiBH,aAAjB,MAAN;YACQzF,IAAR,CACK4F,SADL,iCAC0CF,WAD1C,iEACgHA,WADhH;;SAIKC,UAAP;;;AC/BF;;;;;;;AAOA,AAAe,SAASL,KAAT,CAAe5F,IAAf,EAAqBU,OAArB,EAA8B;;;;MAEvC,CAACmF,mBAAmB7F,KAAKgE,QAAL,CAAcjE,SAAjC,EAA4C,OAA5C,EAAqD,cAArD,CAAL,EAA2E;WAClEC,IAAP;;;MAGEiE,eAAevD,QAAQzL,OAA3B;;;MAGI,OAAOgP,YAAP,KAAwB,QAA5B,EAAsC;mBACrBjE,KAAKgE,QAAL,CAAc3H,MAAd,CAAqB8J,aAArB,CAAmClC,YAAnC,CAAf;;;QAGI,CAACA,YAAL,EAAmB;aACVjE,IAAP;;GALJ,MAOO;;;QAGD,CAACA,KAAKgE,QAAL,CAAc3H,MAAd,CAAqBnE,QAArB,CAA8B+L,YAA9B,CAAL,EAAkD;cACxC3D,IAAR,CACE,+DADF;aAGON,IAAP;;;;MAIEnD,YAAYmD,KAAKnD,SAAL,CAAegB,KAAf,CAAqB,GAArB,EAA0B,CAA1B,CAAlB;sBAC8BmC,KAAKhG,OA5BQ;MA4BnCqC,MA5BmC,iBA4BnCA,MA5BmC;MA4B3BlG,SA5B2B,iBA4B3BA,SA5B2B;;MA6BrC0O,aAAa,CAAC,MAAD,EAAS,OAAT,EAAkB5Q,OAAlB,CAA0B4I,SAA1B,MAAyC,CAAC,CAA7D;;MAEMuJ,MAAMvB,aAAa,QAAb,GAAwB,OAApC;MACMwB,kBAAkBxB,aAAa,KAAb,GAAqB,MAA7C;MACMxM,OAAOgO,gBAAgBC,WAAhB,EAAb;MACMC,UAAU1B,aAAa,MAAb,GAAsB,KAAtC;MACM2B,SAAS3B,aAAa,QAAb,GAAwB,OAAvC;MACM4B,mBAAmBxI,cAAcgG,YAAd,EAA4BmC,GAA5B,CAAzB;;;;;;;;MAQIjQ,UAAUqQ,MAAV,IAAoBC,gBAApB,GAAuCpK,OAAOhE,IAAP,CAA3C,EAAyD;SAClD2B,OAAL,CAAaqC,MAAb,CAAoBhE,IAApB,KACEgE,OAAOhE,IAAP,KAAgBlC,UAAUqQ,MAAV,IAAoBC,gBAApC,CADF;;;MAIEtQ,UAAUkC,IAAV,IAAkBoO,gBAAlB,GAAqCpK,OAAOmK,MAAP,CAAzC,EAAyD;SAClDxM,OAAL,CAAaqC,MAAb,CAAoBhE,IAApB,KACElC,UAAUkC,IAAV,IAAkBoO,gBAAlB,GAAqCpK,OAAOmK,MAAP,CADvC;;OAGGxM,OAAL,CAAaqC,MAAb,GAAsBtC,cAAciG,KAAKhG,OAAL,CAAaqC,MAA3B,CAAtB;;;MAGMqK,SAASvQ,UAAUkC,IAAV,IAAkBlC,UAAUiQ,GAAV,IAAiB,CAAnC,GAAuCK,mBAAmB,CAAzE;;;;MAIMnR,MAAMN,yBAAyBgL,KAAKgE,QAAL,CAAc3H,MAAvC,CAAZ;MACMsK,mBAAmBnN,WAAWlE,eAAa+Q,eAAb,CAAX,CAAzB;MACMO,mBAAmBpN,WAAWlE,eAAa+Q,eAAb,WAAX,CAAzB;MACIQ,YACFH,SAAS1G,KAAKhG,OAAL,CAAaqC,MAAb,CAAoBhE,IAApB,CAAT,GAAqCsO,gBAArC,GAAwDC,gBAD1D;;;cAIYjN,KAAKC,GAAL,CAASD,KAAKmN,GAAL,CAASzK,OAAO+J,GAAP,IAAcK,gBAAvB,EAAyCI,SAAzC,CAAT,EAA8D,CAA9D,CAAZ;;OAEK5C,YAAL,GAAoBA,YAApB;OACKjK,OAAL,CAAa4L,KAAb,kEACGvN,IADH,EACUsB,KAAK4K,KAAL,CAAWsC,SAAX,CADV,uCAEGN,OAFH,EAEa,EAFb;;SAKOvG,IAAP;;;ACvFF;;;;;;;AAOA,AAAe,SAAS+G,oBAAT,CAA8BnJ,SAA9B,EAAyC;MAClDA,cAAc,KAAlB,EAAyB;WAChB,OAAP;GADF,MAEO,IAAIA,cAAc,OAAlB,EAA2B;WACzB,KAAP;;SAEKA,SAAP;;;ACbF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,iBAAe,CACb,YADa,EAEb,MAFa,EAGb,UAHa,EAIb,WAJa,EAKb,KALa,EAMb,SANa,EAOb,aAPa,EAQb,OARa,EASb,WATa,EAUb,YAVa,EAWb,QAXa,EAYb,cAZa,EAab,UAba,EAcb,MAda,EAeb,YAfa,CAAf;;AC7BA;AACA,IAAMoJ,kBAAkBC,WAAW7G,KAAX,CAAiB,CAAjB,CAAxB;;;;;;;;;;;;AAYA,AAAe,SAAS8G,SAAT,CAAmBrK,SAAnB,EAA+C;MAAjBsK,OAAiB,uEAAP,KAAO;;MACtDC,QAAQJ,gBAAgB/S,OAAhB,CAAwB4I,SAAxB,CAAd;MACMuC,MAAM4H,gBACT5G,KADS,CACHgH,QAAQ,CADL,EAETC,MAFS,CAEFL,gBAAgB5G,KAAhB,CAAsB,CAAtB,EAAyBgH,KAAzB,CAFE,CAAZ;SAGOD,UAAU/H,IAAIkI,OAAJ,EAAV,GAA0BlI,GAAjC;;;ACZF,IAAMmI,YAAY;QACV,MADU;aAEL,WAFK;oBAGE;CAHpB;;;;;;;;;AAaA,AAAe,SAAS3G,IAAT,CAAcZ,IAAd,EAAoBU,OAApB,EAA6B;;MAEtCQ,kBAAkBlB,KAAKgE,QAAL,CAAcjE,SAAhC,EAA2C,OAA3C,CAAJ,EAAyD;WAChDC,IAAP;;;MAGEA,KAAKwH,OAAL,IAAgBxH,KAAKnD,SAAL,KAAmBmD,KAAKa,iBAA5C,EAA+D;;WAEtDb,IAAP;;;MAGIxD,aAAaJ,cACjB4D,KAAKgE,QAAL,CAAc3H,MADG,EAEjB2D,KAAKgE,QAAL,CAAc7N,SAFG,EAGjBuK,QAAQpE,OAHS,EAIjBoE,QAAQnE,iBAJS,EAKjByD,KAAKW,aALY,CAAnB;;MAQI9D,YAAYmD,KAAKnD,SAAL,CAAegB,KAAf,CAAqB,GAArB,EAA0B,CAA1B,CAAhB;MACI4J,oBAAoBnJ,qBAAqBzB,SAArB,CAAxB;MACIe,YAAYoC,KAAKnD,SAAL,CAAegB,KAAf,CAAqB,GAArB,EAA0B,CAA1B,KAAgC,EAAhD;;MAEI6J,YAAY,EAAhB;;UAEQhH,QAAQiH,QAAhB;SACOJ,UAAUK,IAAf;kBACc,CAAC/K,SAAD,EAAY4K,iBAAZ,CAAZ;;SAEGF,UAAUM,SAAf;kBACcX,UAAUrK,SAAV,CAAZ;;SAEG0K,UAAUO,gBAAf;kBACcZ,UAAUrK,SAAV,EAAqB,IAArB,CAAZ;;;kBAGY6D,QAAQiH,QAApB;;;YAGMtH,OAAV,CAAkB,UAAC0H,IAAD,EAAOX,KAAP,EAAiB;QAC7BvK,cAAckL,IAAd,IAAsBL,UAAU5T,MAAV,KAAqBsT,QAAQ,CAAvD,EAA0D;aACjDpH,IAAP;;;gBAGUA,KAAKnD,SAAL,CAAegB,KAAf,CAAqB,GAArB,EAA0B,CAA1B,CAAZ;wBACoBS,qBAAqBzB,SAArB,CAApB;;QAEMgC,gBAAgBmB,KAAKhG,OAAL,CAAaqC,MAAnC;QACM2L,aAAahI,KAAKhG,OAAL,CAAa7D,SAAhC;;;QAGMqO,QAAQ7K,KAAK6K,KAAnB;QACMyD,cACHpL,cAAc,MAAd,IACC2H,MAAM3F,cAAc3F,KAApB,IAA6BsL,MAAMwD,WAAW/O,IAAjB,CAD/B,IAEC4D,cAAc,OAAd,IACC2H,MAAM3F,cAAc5F,IAApB,IAA4BuL,MAAMwD,WAAW9O,KAAjB,CAH9B,IAIC2D,cAAc,KAAd,IACC2H,MAAM3F,cAAc7F,MAApB,IAA8BwL,MAAMwD,WAAWjP,GAAjB,CALhC,IAMC8D,cAAc,QAAd,IACC2H,MAAM3F,cAAc9F,GAApB,IAA2ByL,MAAMwD,WAAWhP,MAAjB,CAR/B;;QAUMkP,gBAAgB1D,MAAM3F,cAAc5F,IAApB,IAA4BuL,MAAMhI,WAAWvD,IAAjB,CAAlD;QACMkP,iBAAiB3D,MAAM3F,cAAc3F,KAApB,IAA6BsL,MAAMhI,WAAWtD,KAAjB,CAApD;QACMkP,eAAe5D,MAAM3F,cAAc9F,GAApB,IAA2ByL,MAAMhI,WAAWzD,GAAjB,CAAhD;QACMsP,kBACJ7D,MAAM3F,cAAc7F,MAApB,IAA8BwL,MAAMhI,WAAWxD,MAAjB,CADhC;;QAGMsP,sBACHzL,cAAc,MAAd,IAAwBqL,aAAzB,IACCrL,cAAc,OAAd,IAAyBsL,cAD1B,IAECtL,cAAc,KAAd,IAAuBuL,YAFxB,IAGCvL,cAAc,QAAd,IAA0BwL,eAJ7B;;;QAOMxD,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB5Q,OAAlB,CAA0B4I,SAA1B,MAAyC,CAAC,CAA7D;;;QAGM0L,wBACJ,CAAC,CAAC7H,QAAQ8H,cAAV,KACE3D,cAAcjH,cAAc,OAA5B,IAAuCsK,aAAxC,IACErD,cAAcjH,cAAc,KAA5B,IAAqCuK,cADvC,IAEE,CAACtD,UAAD,IAAejH,cAAc,OAA7B,IAAwCwK,YAF1C,IAGE,CAACvD,UAAD,IAAejH,cAAc,KAA7B,IAAsCyK,eAJzC,CADF;;;QAQMI,4BACJ,CAAC,CAAC/H,QAAQgI,uBAAV,KACE7D,cAAcjH,cAAc,OAA5B,IAAuCuK,cAAxC,IACEtD,cAAcjH,cAAc,KAA5B,IAAqCsK,aADvC,IAEE,CAACrD,UAAD,IAAejH,cAAc,OAA7B,IAAwCyK,eAF1C,IAGE,CAACxD,UAAD,IAAejH,cAAc,KAA7B,IAAsCwK,YAJzC,CADF;;QAOMO,mBAAmBJ,yBAAyBE,yBAAlD;;QAEIR,eAAeK,mBAAf,IAAsCK,gBAA1C,EAA4D;;WAErDnB,OAAL,GAAe,IAAf;;UAEIS,eAAeK,mBAAnB,EAAwC;oBAC1BZ,UAAUN,QAAQ,CAAlB,CAAZ;;;UAGEuB,gBAAJ,EAAsB;oBACR5B,qBAAqBnJ,SAArB,CAAZ;;;WAGGf,SAAL,GAAiBA,aAAae,YAAY,MAAMA,SAAlB,GAA8B,EAA3C,CAAjB;;;;WAIK5D,OAAL,CAAaqC,MAAb,gBACK2D,KAAKhG,OAAL,CAAaqC,MADlB,EAEKqC,iBACDsB,KAAKgE,QAAL,CAAc3H,MADb,EAED2D,KAAKhG,OAAL,CAAa7D,SAFZ,EAGD6J,KAAKnD,SAHJ,CAFL;;aASOiD,aAAaE,KAAKgE,QAAL,CAAcjE,SAA3B,EAAsCC,IAAtC,EAA4C,MAA5C,CAAP;;GAjFJ;SAoFOA,IAAP;;;AChJF;;;;;;;AAOA,AAAe,SAAS4I,YAAT,CAAsB5I,IAAtB,EAA4B;sBACXA,KAAKhG,OADM;MACjCqC,MADiC,iBACjCA,MADiC;MACzBlG,SADyB,iBACzBA,SADyB;;MAEnC0G,YAAYmD,KAAKnD,SAAL,CAAegB,KAAf,CAAqB,GAArB,EAA0B,CAA1B,CAAlB;MACM2G,QAAQ7K,KAAK6K,KAAnB;MACMK,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB5Q,OAAlB,CAA0B4I,SAA1B,MAAyC,CAAC,CAA7D;MACMxE,OAAOwM,aAAa,OAAb,GAAuB,QAApC;MACM2B,SAAS3B,aAAa,MAAb,GAAsB,KAArC;MACM5F,cAAc4F,aAAa,OAAb,GAAuB,QAA3C;;MAEIxI,OAAOhE,IAAP,IAAemM,MAAMrO,UAAUqQ,MAAV,CAAN,CAAnB,EAA6C;SACtCxM,OAAL,CAAaqC,MAAb,CAAoBmK,MAApB,IACEhC,MAAMrO,UAAUqQ,MAAV,CAAN,IAA2BnK,OAAO4C,WAAP,CAD7B;;MAGE5C,OAAOmK,MAAP,IAAiBhC,MAAMrO,UAAUkC,IAAV,CAAN,CAArB,EAA6C;SACtC2B,OAAL,CAAaqC,MAAb,CAAoBmK,MAApB,IAA8BhC,MAAMrO,UAAUkC,IAAV,CAAN,CAA9B;;;SAGK2H,IAAP;;;ACpBF;;;;;;;;;;;;AAYA,AAAO,SAAS6I,OAAT,CAAiBC,GAAjB,EAAsB7J,WAAtB,EAAmCJ,aAAnC,EAAkDF,gBAAlD,EAAoE;;MAEnEd,QAAQiL,IAAIlJ,KAAJ,CAAU,2BAAV,CAAd;MACMF,QAAQ,CAAC7B,MAAM,CAAN,CAAf;MACM8F,OAAO9F,MAAM,CAAN,CAAb;;;MAGI,CAAC6B,KAAL,EAAY;WACHoJ,GAAP;;;MAGEnF,KAAK1P,OAAL,CAAa,GAAb,MAAsB,CAA1B,EAA6B;QACvBgB,gBAAJ;YACQ0O,IAAR;WACO,IAAL;kBACY9E,aAAV;;WAEG,GAAL;WACK,IAAL;;kBAEYF,gBAAV;;;QAGEjG,OAAOqB,cAAc9E,OAAd,CAAb;WACOyD,KAAKuG,WAAL,IAAoB,GAApB,GAA0BS,KAAjC;GAbF,MAcO,IAAIiE,SAAS,IAAT,IAAiBA,SAAS,IAA9B,EAAoC;;QAErCoF,aAAJ;QACIpF,SAAS,IAAb,EAAmB;aACVhK,KAAKC,GAAL,CACLnG,SAASmD,eAAT,CAAyB4D,YADpB,EAELhH,OAAOsI,WAAP,IAAsB,CAFjB,CAAP;KADF,MAKO;aACEnC,KAAKC,GAAL,CACLnG,SAASmD,eAAT,CAAyB2D,WADpB,EAEL/G,OAAOqI,UAAP,IAAqB,CAFhB,CAAP;;WAKKkN,OAAO,GAAP,GAAarJ,KAApB;GAdK,MAeA;;;WAGEA,KAAP;;;;;;;;;;;;;;;AAeJ,AAAO,SAASsJ,WAAT,CACLjN,MADK,EAEL8C,aAFK,EAGLF,gBAHK,EAILsK,aAJK,EAKL;MACMjP,UAAU,CAAC,CAAD,EAAI,CAAJ,CAAhB;;;;;MAKMkP,YAAY,CAAC,OAAD,EAAU,MAAV,EAAkBjV,OAAlB,CAA0BgV,aAA1B,MAA6C,CAAC,CAAhE;;;;MAIME,YAAYpN,OAAO8B,KAAP,CAAa,SAAb,EAAwBV,GAAxB,CAA4B;WAAQiM,KAAKC,IAAL,EAAR;GAA5B,CAAlB;;;;MAIMC,UAAUH,UAAUlV,OAAV,CACdkL,KAAKgK,SAAL,EAAgB;WAAQC,KAAKG,MAAL,CAAY,MAAZ,MAAwB,CAAC,CAAjC;GAAhB,CADc,CAAhB;;MAIIJ,UAAUG,OAAV,KAAsBH,UAAUG,OAAV,EAAmBrV,OAAnB,CAA2B,GAA3B,MAAoC,CAAC,CAA/D,EAAkE;YACxDqM,IAAR,CACE,8EADF;;;;;MAOIkJ,aAAa,aAAnB;MACIC,MAAMH,YAAY,CAAC,CAAb,GACN,CACEH,UACG/I,KADH,CACS,CADT,EACYkJ,OADZ,EAEGjC,MAFH,CAEU,CAAC8B,UAAUG,OAAV,EAAmBzL,KAAnB,CAAyB2L,UAAzB,EAAqC,CAArC,CAAD,CAFV,CADF,EAIE,CAACL,UAAUG,OAAV,EAAmBzL,KAAnB,CAAyB2L,UAAzB,EAAqC,CAArC,CAAD,EAA0CnC,MAA1C,CACE8B,UAAU/I,KAAV,CAAgBkJ,UAAU,CAA1B,CADF,CAJF,CADM,GASN,CAACH,SAAD,CATJ;;;QAYMM,IAAItM,GAAJ,CAAQ,UAACuM,EAAD,EAAKtC,KAAL,EAAe;;QAErBnI,cAAc,CAACmI,UAAU,CAAV,GAAc,CAAC8B,SAAf,GAA2BA,SAA5B,IAChB,QADgB,GAEhB,OAFJ;QAGIS,oBAAoB,KAAxB;WAEED;;;KAGGE,MAHH,CAGU,UAACtM,CAAD,EAAIC,CAAJ,EAAU;UACZD,EAAEA,EAAExJ,MAAF,GAAW,CAAb,MAAoB,EAApB,IAA0B,CAAC,GAAD,EAAM,GAAN,EAAWG,OAAX,CAAmBsJ,CAAnB,MAA0B,CAAC,CAAzD,EAA4D;UACxDD,EAAExJ,MAAF,GAAW,CAAb,IAAkByJ,CAAlB;4BACoB,IAApB;eACOD,CAAP;OAHF,MAIO,IAAIqM,iBAAJ,EAAuB;UAC1BrM,EAAExJ,MAAF,GAAW,CAAb,KAAmByJ,CAAnB;4BACoB,KAApB;eACOD,CAAP;OAHK,MAIA;eACEA,EAAE+J,MAAF,CAAS9J,CAAT,CAAP;;KAbN,EAeK,EAfL;;KAiBGJ,GAjBH,CAiBO;aAAO0L,QAAQC,GAAR,EAAa7J,WAAb,EAA0BJ,aAA1B,EAAyCF,gBAAzC,CAAP;KAjBP,CADF;GANI,CAAN;;;MA6BI0B,OAAJ,CAAY,UAACqJ,EAAD,EAAKtC,KAAL,EAAe;OACtB/G,OAAH,CAAW,UAAC+I,IAAD,EAAOS,MAAP,EAAkB;UACvBvG,UAAU8F,IAAV,CAAJ,EAAqB;gBACXhC,KAAR,KAAkBgC,QAAQM,GAAGG,SAAS,CAAZ,MAAmB,GAAnB,GAAyB,CAAC,CAA1B,GAA8B,CAAtC,CAAlB;;KAFJ;GADF;SAOO7P,OAAP;;;;;;;;;;;;AAYF,AAAe,SAAS+B,MAAT,CAAgBiE,IAAhB,QAAkC;MAAVjE,MAAU,QAAVA,MAAU;MACvCc,SADuC,GACOmD,IADP,CACvCnD,SADuC;sBACOmD,IADP,CAC5BhG,OAD4B;MACjBqC,MADiB,iBACjBA,MADiB;MACTlG,SADS,iBACTA,SADS;;MAEzC8S,gBAAgBpM,UAAUgB,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAtB;;MAEI7D,gBAAJ;MACIsJ,UAAU,CAACvH,MAAX,CAAJ,EAAwB;cACZ,CAAC,CAACA,MAAF,EAAU,CAAV,CAAV;GADF,MAEO;cACKiN,YAAYjN,MAAZ,EAAoBM,MAApB,EAA4BlG,SAA5B,EAAuC8S,aAAvC,CAAV;;;MAGEA,kBAAkB,MAAtB,EAA8B;WACrBlQ,GAAP,IAAciB,QAAQ,CAAR,CAAd;WACOf,IAAP,IAAee,QAAQ,CAAR,CAAf;GAFF,MAGO,IAAIiP,kBAAkB,OAAtB,EAA+B;WAC7BlQ,GAAP,IAAciB,QAAQ,CAAR,CAAd;WACOf,IAAP,IAAee,QAAQ,CAAR,CAAf;GAFK,MAGA,IAAIiP,kBAAkB,KAAtB,EAA6B;WAC3BhQ,IAAP,IAAee,QAAQ,CAAR,CAAf;WACOjB,GAAP,IAAciB,QAAQ,CAAR,CAAd;GAFK,MAGA,IAAIiP,kBAAkB,QAAtB,EAAgC;WAC9BhQ,IAAP,IAAee,QAAQ,CAAR,CAAf;WACOjB,GAAP,IAAciB,QAAQ,CAAR,CAAd;;;OAGGqC,MAAL,GAAcA,MAAd;SACO2D,IAAP;;;AC5LF;;;;;;;AAOA,AAAe,SAAS8J,eAAT,CAAyB9J,IAAzB,EAA+BU,OAA/B,EAAwC;MACjDnE,oBACFmE,QAAQnE,iBAAR,IAA6B5F,gBAAgBqJ,KAAKgE,QAAL,CAAc3H,MAA9B,CAD/B;;;;;MAMI2D,KAAKgE,QAAL,CAAc7N,SAAd,KAA4BoG,iBAAhC,EAAmD;wBAC7B5F,gBAAgB4F,iBAAhB,CAApB;;;;;;MAMIwN,gBAAgBzI,yBAAyB,WAAzB,CAAtB;MACM0I,eAAehK,KAAKgE,QAAL,CAAc3H,MAAd,CAAqBwF,KAA1C,CAfqD;MAgB7C9I,GAhB6C,GAgBHiR,YAhBG,CAgB7CjR,GAhB6C;MAgBxCE,IAhBwC,GAgBH+Q,YAhBG,CAgBxC/Q,IAhBwC;MAgBjBgR,SAhBiB,GAgBHD,YAhBG,CAgBjCD,aAhBiC;;eAiBxChR,GAAb,GAAmB,EAAnB;eACaE,IAAb,GAAoB,EAApB;eACa8Q,aAAb,IAA8B,EAA9B;;MAEMvN,aAAaJ,cACjB4D,KAAKgE,QAAL,CAAc3H,MADG,EAEjB2D,KAAKgE,QAAL,CAAc7N,SAFG,EAGjBuK,QAAQpE,OAHS,EAIjBC,iBAJiB,EAKjByD,KAAKW,aALY,CAAnB;;;;eAUa5H,GAAb,GAAmBA,GAAnB;eACaE,IAAb,GAAoBA,IAApB;eACa8Q,aAAb,IAA8BE,SAA9B;;UAEQzN,UAAR,GAAqBA,UAArB;;MAEMjF,QAAQmJ,QAAQwJ,QAAtB;MACI7N,SAAS2D,KAAKhG,OAAL,CAAaqC,MAA1B;;MAEMgD,QAAQ;WAAA,mBACJxC,SADI,EACO;UACb6C,QAAQrD,OAAOQ,SAAP,CAAZ;UAEER,OAAOQ,SAAP,IAAoBL,WAAWK,SAAX,CAApB,IACA,CAAC6D,QAAQyJ,mBAFX,EAGE;gBACQxQ,KAAKC,GAAL,CAASyC,OAAOQ,SAAP,CAAT,EAA4BL,WAAWK,SAAX,CAA5B,CAAR;;gCAEQA,SAAV,EAAsB6C,KAAtB;KATU;aAAA,qBAWF7C,SAXE,EAWS;UACbkC,WAAWlC,cAAc,OAAd,GAAwB,MAAxB,GAAiC,KAAlD;UACI6C,QAAQrD,OAAO0C,QAAP,CAAZ;UAEE1C,OAAOQ,SAAP,IAAoBL,WAAWK,SAAX,CAApB,IACA,CAAC6D,QAAQyJ,mBAFX,EAGE;gBACQxQ,KAAKmN,GAAL,CACNzK,OAAO0C,QAAP,CADM,EAENvC,WAAWK,SAAX,KACGA,cAAc,OAAd,GAAwBR,OAAOpC,KAA/B,GAAuCoC,OAAOnC,MADjD,CAFM,CAAR;;gCAMQ6E,QAAV,EAAqBW,KAArB;;GAxBJ;;QA4BMW,OAAN,CAAc,qBAAa;QACnBhI,OACJ,CAAC,MAAD,EAAS,KAAT,EAAgBpE,OAAhB,CAAwB4I,SAAxB,MAAuC,CAAC,CAAxC,GAA4C,SAA5C,GAAwD,WAD1D;0BAEcR,MAAd,EAAyBgD,MAAMhH,IAAN,EAAYwE,SAAZ,CAAzB;GAHF;;OAMK7C,OAAL,CAAaqC,MAAb,GAAsBA,MAAtB;;SAEO2D,IAAP;;;ACvFF;;;;;;;AAOA,AAAe,SAASoK,KAAT,CAAepK,IAAf,EAAqB;MAC5BnD,YAAYmD,KAAKnD,SAAvB;MACMoM,gBAAgBpM,UAAUgB,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAtB;MACMwM,iBAAiBxN,UAAUgB,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAvB;;;MAGIwM,cAAJ,EAAoB;wBACYrK,KAAKhG,OADjB;QACV7D,SADU,iBACVA,SADU;QACCkG,MADD,iBACCA,MADD;;QAEZwI,aAAa,CAAC,QAAD,EAAW,KAAX,EAAkB5Q,OAAlB,CAA0BgV,aAA1B,MAA6C,CAAC,CAAjE;QACM5Q,OAAOwM,aAAa,MAAb,GAAsB,KAAnC;QACM5F,cAAc4F,aAAa,OAAb,GAAuB,QAA3C;;QAEMyF,eAAe;gCACTjS,IAAV,EAAiBlC,UAAUkC,IAAV,CAAjB,CADmB;8BAGhBA,IADH,EACUlC,UAAUkC,IAAV,IAAkBlC,UAAU8I,WAAV,CAAlB,GAA2C5C,OAAO4C,WAAP,CADrD;KAFF;;SAOKjF,OAAL,CAAaqC,MAAb,gBAA2BA,MAA3B,EAAsCiO,aAAaD,cAAb,CAAtC;;;SAGKrK,IAAP;;;AC1BF;;;;;;;AAOA,AAAe,SAASuK,IAAT,CAAcvK,IAAd,EAAoB;MAC7B,CAAC6F,mBAAmB7F,KAAKgE,QAAL,CAAcjE,SAAjC,EAA4C,MAA5C,EAAoD,iBAApD,CAAL,EAA6E;WACpEC,IAAP;;;MAGIlD,UAAUkD,KAAKhG,OAAL,CAAa7D,SAA7B;MACMqU,QAAQrL,KACZa,KAAKgE,QAAL,CAAcjE,SADF,EAEZ;WAAYjH,SAASuI,IAAT,KAAkB,iBAA9B;GAFY,EAGZ7E,UAHF;;MAMEM,QAAQ9D,MAAR,GAAiBwR,MAAMzR,GAAvB,IACA+D,QAAQ7D,IAAR,GAAeuR,MAAMtR,KADrB,IAEA4D,QAAQ/D,GAAR,GAAcyR,MAAMxR,MAFpB,IAGA8D,QAAQ5D,KAAR,GAAgBsR,MAAMvR,IAJxB,EAKE;;QAEI+G,KAAKuK,IAAL,KAAc,IAAlB,EAAwB;aACfvK,IAAP;;;SAGGuK,IAAL,GAAY,IAAZ;SACK1G,UAAL,CAAgB,qBAAhB,IAAyC,EAAzC;GAZF,MAaO;;QAED7D,KAAKuK,IAAL,KAAc,KAAlB,EAAyB;aAChBvK,IAAP;;;SAGGuK,IAAL,GAAY,KAAZ;SACK1G,UAAL,CAAgB,qBAAhB,IAAyC,KAAzC;;;SAGK7D,IAAP;;;ACzCF;;;;;;;AAOA,AAAe,SAASyK,KAAT,CAAezK,IAAf,EAAqB;MAC5BnD,YAAYmD,KAAKnD,SAAvB;MACMoM,gBAAgBpM,UAAUgB,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAtB;sBAC8BmC,KAAKhG,OAHD;MAG1BqC,MAH0B,iBAG1BA,MAH0B;MAGlBlG,SAHkB,iBAGlBA,SAHkB;;MAI5B2I,UAAU,CAAC,MAAD,EAAS,OAAT,EAAkB7K,OAAlB,CAA0BgV,aAA1B,MAA6C,CAAC,CAA9D;;MAEMyB,iBAAiB,CAAC,KAAD,EAAQ,MAAR,EAAgBzW,OAAhB,CAAwBgV,aAAxB,MAA2C,CAAC,CAAnE;;SAEOnK,UAAU,MAAV,GAAmB,KAA1B,IACE3I,UAAU8S,aAAV,KACCyB,iBAAiBrO,OAAOyC,UAAU,OAAV,GAAoB,QAA3B,CAAjB,GAAwD,CADzD,CADF;;OAIKjC,SAAL,GAAiByB,qBAAqBzB,SAArB,CAAjB;OACK7C,OAAL,CAAaqC,MAAb,GAAsBtC,cAAcsC,MAAd,CAAtB;;SAEO2D,IAAP;;;ACdF;;;;;;;;;;;;;;;;;;;;;AAqBA,gBAAe;;;;;;;;;SASN;;WAEE,GAFF;;aAII,IAJJ;;QAMDoK;GAfO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAwDL;;WAEC,GAFD;;aAIG,IAJH;;QAMFrO,MANE;;;;YAUE;GAlEG;;;;;;;;;;;;;;;;;;;mBAsFI;;WAER,GAFQ;;aAIN,IAJM;;QAMX+N,eANW;;;;;;cAYL,CAAC,MAAD,EAAS,OAAT,EAAkB,KAAlB,EAAyB,QAAzB,CAZK;;;;;;;aAmBN,CAnBM;;;;;;uBAyBI;GA/GR;;;;;;;;;;;gBA2HC;;WAEL,GAFK;;aAIH,IAJG;;QAMRlB;GAjIO;;;;;;;;;;;;SA8IN;;WAEE,GAFF;;aAII,IAJJ;;QAMDhD,KANC;;aAQI;GAtJE;;;;;;;;;;;;;QAoKP;;WAEG,GAFH;;aAIK,IAJL;;QAMAhF,IANA;;;;;;;cAaM,MAbN;;;;;aAkBK,CAlBL;;;;;;;uBAyBe,UAzBf;;;;;;;;oBAiCY,KAjCZ;;;;;;;;6BAyCqB;GA7Md;;;;;;;;;SAuNN;;WAEE,GAFF;;aAII,KAJJ;;QAMD6J;GA7NO;;;;;;;;;;;;QA0OP;;WAEG,GAFH;;aAIK,IAJL;;QAMAF;GAhPO;;;;;;;;;;;;;;;;;gBAkQC;;WAEL,GAFK;;aAIH,IAJG;;QAMRnF,YANQ;;;;;;qBAYK,IAZL;;;;;;OAkBT,QAlBS;;;;;;OAwBT;GA1RQ;;;;;;;;;;;;;;;;;cA4SD;;WAEH,GAFG;;aAID,IAJC;;QAMNrB,UANM;;YAQFI,gBARE;;;;;;;qBAeOhE;;CA3TrB;;;;;;;;;;;;;;;;;;;;;AC9BA;;;;;;;;;;;;;;;;AAgBA,eAAe;;;;;aAKF,QALE;;;;;;iBAWE,KAXF;;;;;;iBAiBE,IAjBF;;;;;;;mBAwBI,KAxBJ;;;;;;;;YAgCH,oBAAM,EAhCH;;;;;;;;;;YA0CH,oBAAM,EA1CH;;;;;;;;CAAf;;;;;;;;;;;;AClBA;AACA,AAGA;AACA,IAOqBwK;;;;;;;;;kBASPxU,SAAZ,EAAuBkG,MAAvB,EAA6C;;;QAAdqE,OAAc,uEAAJ,EAAI;;;SAyF7CyC,cAzF6C,GAyF5B;aAAMyH,sBAAsB,MAAKpK,MAA3B,CAAN;KAzF4B;;;SAEtCA,MAAL,GAAcqK,SAAS,KAAKrK,MAAL,CAAYsK,IAAZ,CAAiB,IAAjB,CAAT,CAAd;;;SAGKpK,OAAL,gBAAoBiK,OAAOI,QAA3B,EAAwCrK,OAAxC;;;SAGK3C,KAAL,GAAa;mBACE,KADF;iBAEA,KAFA;qBAGI;KAHjB;;;SAOK5H,SAAL,GAAiBA,aAAaA,UAAU6U,MAAvB,GAAgC7U,UAAU,CAAV,CAAhC,GAA+CA,SAAhE;SACKkG,MAAL,GAAcA,UAAUA,OAAO2O,MAAjB,GAA0B3O,OAAO,CAAP,CAA1B,GAAsCA,MAApD;;;SAGKqE,OAAL,CAAaX,SAAb,GAAyB,EAAzB;WACO7C,IAAP,cACKyN,OAAOI,QAAP,CAAgBhL,SADrB,EAEKW,QAAQX,SAFb,GAGGM,OAHH,CAGW,gBAAQ;YACZK,OAAL,CAAaX,SAAb,CAAuBsB,IAAvB,iBAEMsJ,OAAOI,QAAP,CAAgBhL,SAAhB,CAA0BsB,IAA1B,KAAmC,EAFzC,EAIMX,QAAQX,SAAR,GAAoBW,QAAQX,SAAR,CAAkBsB,IAAlB,CAApB,GAA8C,EAJpD;KAJF;;;SAaKtB,SAAL,GAAiB9C,OAAOC,IAAP,CAAY,KAAKwD,OAAL,CAAaX,SAAzB,EACd5C,GADc,CACV;;;SAEA,MAAKuD,OAAL,CAAaX,SAAb,CAAuBsB,IAAvB,CAFA;KADU;;KAMdhE,IANc,CAMT,UAACC,CAAD,EAAIC,CAAJ;aAAUD,EAAE/F,KAAF,GAAUgG,EAAEhG,KAAtB;KANS,CAAjB;;;;;;SAYKwI,SAAL,CAAeM,OAAf,CAAuB,2BAAmB;UACpC+D,gBAAgB7D,OAAhB,IAA2B5L,WAAWyP,gBAAgB6G,MAA3B,CAA/B,EAAmE;wBACjDA,MAAhB,CACE,MAAK9U,SADP,EAEE,MAAKkG,MAFP,EAGE,MAAKqE,OAHP,EAIE0D,eAJF,EAKE,MAAKrG,KALP;;KAFJ;;;SAaKyC,MAAL;;QAEMyC,gBAAgB,KAAKvC,OAAL,CAAauC,aAAnC;QACIA,aAAJ,EAAmB;;WAEZC,oBAAL;;;SAGGnF,KAAL,CAAWkF,aAAX,GAA2BA,aAA3B;;;;;;;;;gCAKO;aACAzC,OAAOzL,IAAP,CAAY,IAAZ,CAAP;;;;iCAEQ;aACD+M,QAAQ/M,IAAR,CAAa,IAAb,CAAP;;;;8CAEqB;aACdmO,qBAAqBnO,IAArB,CAA0B,IAA1B,CAAP;;;;+CAEsB;aACfkN,sBAAsBlN,IAAtB,CAA2B,IAA3B,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1FiB4V,OAoHZO,QAAQ,CAAC,OAAO1X,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyC2X,MAA1C,EAAkDC;AApH9CT,OAsHZ1D,aAAaA;AAtHD0D,OAwHZI,WAAWA;;;;"}'
  admin-Public-Admin-plugins-popper-esm-popper.min.js: |
    /*
     Copyright (C) Federico Zivolo 2020
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */var e='undefined'!=typeof window&&'undefined'!=typeof document&&'undefined'!=typeof navigator,t=function(){for(var t=['Edge','Trident','Firefox'],o=0;o<t.length;o+=1)if(e&&0<=navigator.userAgent.indexOf(t[o]))return 1;return 0}();function o(e){var t=!1;return function(){t||(t=!0,window.Promise.resolve().then(function(){t=!1,e()}))}}function n(e){var o=!1;return function(){o||(o=!0,setTimeout(function(){o=!1,e()},t))}}var i=e&&window.Promise,r=i?o:n;function p(e){return e&&'[object Function]'==={}.toString.call(e)}function s(e,t){if(1!==e.nodeType)return[];var o=e.ownerDocument.defaultView,n=o.getComputedStyle(e,null);return t?n[t]:n}function d(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function a(e){if(!e)return document.body;switch(e.nodeName){case'HTML':case'BODY':return e.ownerDocument.body;case'#document':return e.body;}var t=s(e),o=t.overflow,n=t.overflowX,i=t.overflowY;return /(auto|scroll|overlay)/.test(o+i+n)?e:a(d(e))}function l(e){return e&&e.referenceNode?e.referenceNode:e}var f=e&&!!(window.MSInputMethodContext&&document.documentMode),m=e&&/MSIE 10/.test(navigator.userAgent);function h(e){return 11===e?f:10===e?m:f||m}function c(e){if(!e)return document.documentElement;for(var t=h(10)?document.body:null,o=e.offsetParent||null;o===t&&e.nextElementSibling;)o=(e=e.nextElementSibling).offsetParent;var n=o&&o.nodeName;return n&&'BODY'!==n&&'HTML'!==n?-1!==['TH','TD','TABLE'].indexOf(o.nodeName)&&'static'===s(o,'position')?c(o):o:e?e.ownerDocument.documentElement:document.documentElement}function g(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||c(e.firstElementChild)===e)}function u(e){return null===e.parentNode?e:u(e.parentNode)}function b(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,n=o?e:t,i=o?t:e,r=document.createRange();r.setStart(n,0),r.setEnd(i,0);var p=r.commonAncestorContainer;if(e!==p&&t!==p||n.contains(i))return g(p)?p:c(p);var s=u(e);return s.host?b(s.host,t):b(e,u(t).host)}function w(e){var t=1<arguments.length&&arguments[1]!==void 0?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',n=e.nodeName;if('BODY'===n||'HTML'===n){var i=e.ownerDocument.documentElement,r=e.ownerDocument.scrollingElement||i;return r[o]}return e[o]}function y(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],n=w(t,'top'),i=w(t,'left'),r=o?-1:1;return e.top+=n*r,e.bottom+=n*r,e.left+=i*r,e.right+=i*r,e}function E(e,t){var o='x'===t?'Left':'Top',n='Left'==o?'Right':'Bottom';return parseFloat(e['border'+o+'Width'])+parseFloat(e['border'+n+'Width'])}function x(e,t,o,n){return Math.max(t['offset'+e],t['scroll'+e],o['client'+e],o['offset'+e],o['scroll'+e],h(10)?parseInt(o['offset'+e])+parseInt(n['margin'+('Height'===e?'Top':'Left')])+parseInt(n['margin'+('Height'===e?'Bottom':'Right')]):0)}function v(e){var t=e.body,o=e.documentElement,n=h(10)&&getComputedStyle(o);return{height:x('Height',t,o,n),width:x('Width',t,o,n)}}var O=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},L=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,n){return o&&e(t.prototype,o),n&&e(t,n),t}}(),S=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},T=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e};function C(e){return T({},e,{right:e.left+e.width,bottom:e.top+e.height})}function D(e){var t={};try{if(h(10)){t=e.getBoundingClientRect();var o=w(e,'top'),n=w(e,'left');t.top+=o,t.left+=n,t.bottom+=o,t.right+=n}else t=e.getBoundingClientRect()}catch(t){}var i={left:t.left,top:t.top,width:t.right-t.left,height:t.bottom-t.top},r='HTML'===e.nodeName?v(e.ownerDocument):{},p=r.width||e.clientWidth||i.width,d=r.height||e.clientHeight||i.height,a=e.offsetWidth-p,l=e.offsetHeight-d;if(a||l){var f=s(e);a-=E(f,'x'),l-=E(f,'y'),i.width-=a,i.height-=l}return C(i)}function N(e,t){var o=Math.max,n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=h(10),r='HTML'===t.nodeName,p=D(e),d=D(t),l=a(e),f=s(t),m=parseFloat(f.borderTopWidth),c=parseFloat(f.borderLeftWidth);n&&r&&(d.top=o(d.top,0),d.left=o(d.left,0));var g=C({top:p.top-d.top-m,left:p.left-d.left-c,width:p.width,height:p.height});if(g.marginTop=0,g.marginLeft=0,!i&&r){var u=parseFloat(f.marginTop),b=parseFloat(f.marginLeft);g.top-=m-u,g.bottom-=m-u,g.left-=c-b,g.right-=c-b,g.marginTop=u,g.marginLeft=b}return(i&&!n?t.contains(l):t===l&&'BODY'!==l.nodeName)&&(g=y(g,t)),g}function P(e){var t=Math.max,o=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=e.ownerDocument.documentElement,i=N(e,n),r=t(n.clientWidth,window.innerWidth||0),p=t(n.clientHeight,window.innerHeight||0),s=o?0:w(n),d=o?0:w(n,'left'),a={top:s-i.top+i.marginTop,left:d-i.left+i.marginLeft,width:r,height:p};return C(a)}function k(e){var t=e.nodeName;if('BODY'===t||'HTML'===t)return!1;if('fixed'===s(e,'position'))return!0;var o=d(e);return!!o&&k(o)}function W(e){if(!e||!e.parentElement||h())return document.documentElement;for(var t=e.parentElement;t&&'none'===s(t,'transform');)t=t.parentElement;return t||document.documentElement}function B(e,t,o,n){var i=4<arguments.length&&void 0!==arguments[4]&&arguments[4],r={top:0,left:0},p=i?W(e):b(e,l(t));if('viewport'===n)r=P(p,i);else{var s;'scrollParent'===n?(s=a(d(t)),'BODY'===s.nodeName&&(s=e.ownerDocument.documentElement)):'window'===n?s=e.ownerDocument.documentElement:s=n;var f=N(s,p,i);if('HTML'===s.nodeName&&!k(p)){var m=v(e.ownerDocument),h=m.height,c=m.width;r.top+=f.top-f.marginTop,r.bottom=h+f.top,r.left+=f.left-f.marginLeft,r.right=c+f.left}else r=f}o=o||0;var g='number'==typeof o;return r.left+=g?o:o.left||0,r.top+=g?o:o.top||0,r.right-=g?o:o.right||0,r.bottom-=g?o:o.bottom||0,r}function H(e){var t=e.width,o=e.height;return t*o}function A(e,t,o,n,i){var r=5<arguments.length&&arguments[5]!==void 0?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=B(o,n,r,i),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return T({key:e},s[e],{area:H(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,n=e.height;return t>=o.clientWidth&&n>=o.clientHeight}),l=0<a.length?a[0].key:d[0].key,f=e.split('-')[1];return l+(f?'-'+f:'')}function M(e,t,o){var n=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,i=n?W(t):b(t,l(o));return N(o,i,n)}function F(e){var t=e.ownerDocument.defaultView,o=t.getComputedStyle(e),n=parseFloat(o.marginTop||0)+parseFloat(o.marginBottom||0),i=parseFloat(o.marginLeft||0)+parseFloat(o.marginRight||0),r={width:e.offsetWidth+i,height:e.offsetHeight+n};return r}function I(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function R(e,t,o){o=o.split('-')[0];var n=F(e),i={width:n.width,height:n.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return i[p]=t[p]+t[d]/2-n[d]/2,i[s]=o===s?t[s]-n[a]:t[I(s)],i}function U(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function Y(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var n=U(e,function(e){return e[t]===o});return e.indexOf(n)}function V(e,t,o){var n=void 0===o?e:e.slice(0,Y(e,'name',o));return n.forEach(function(e){e['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var o=e['function']||e.fn;e.enabled&&p(o)&&(t.offsets.popper=C(t.offsets.popper),t.offsets.reference=C(t.offsets.reference),t=o(t,e))}),t}function j(){if(!this.state.isDestroyed){var e={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=M(this.state,this.popper,this.reference,this.options.positionFixed),e.placement=A(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.positionFixed=this.options.positionFixed,e.offsets.popper=R(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position=this.options.positionFixed?'fixed':'absolute',e=V(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function q(e,t){return e.some(function(e){var o=e.name,n=e.enabled;return n&&o===t})}function K(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof document.body.style[r])return r}return null}function z(){return this.state.isDestroyed=!0,q(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.position='',this.popper.style.top='',this.popper.style.left='',this.popper.style.right='',this.popper.style.bottom='',this.popper.style.willChange='',this.popper.style[K('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function G(e){var t=e.ownerDocument;return t?t.defaultView:window}function _(e,t,o,n){var i='BODY'===e.nodeName,r=i?e.ownerDocument.defaultView:e;r.addEventListener(t,o,{passive:!0}),i||_(a(r.parentNode),t,o,n),n.push(r)}function X(e,t,o,n){o.updateBound=n,G(e).addEventListener('resize',o.updateBound,{passive:!0});var i=a(e);return _(i,'scroll',o.updateBound,o.scrollParents),o.scrollElement=i,o.eventsEnabled=!0,o}function J(){this.state.eventsEnabled||(this.state=X(this.reference,this.options,this.state,this.scheduleUpdate))}function Q(e,t){return G(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function Z(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=Q(this.reference,this.state))}function $(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function ee(e,t){Object.keys(t).forEach(function(o){var n='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&$(t[o])&&(n='px'),e.style[o]=t[o]+n})}function te(e,t){Object.keys(t).forEach(function(o){var n=t[o];!1===n?e.removeAttribute(o):e.setAttribute(o,t[o])})}function oe(e){return ee(e.instance.popper,e.styles),te(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&ee(e.arrowElement,e.arrowStyles),e}function ne(e,t,o,n,i){var r=M(i,t,e,o.positionFixed),p=A(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),ee(t,{position:o.positionFixed?'fixed':'absolute'}),o}function ie(e,t){var o=e.offsets,n=o.popper,i=o.reference,r=Math.round,p=Math.floor,s=function(e){return e},d=r(i.width),a=r(n.width),l=-1!==['left','right'].indexOf(e.placement),f=-1!==e.placement.indexOf('-'),m=t?l||f||d%2==a%2?r:p:s,h=t?r:s;return{left:m(1==d%2&&1==a%2&&!f&&t?n.left-1:n.left),top:h(n.top),bottom:h(n.bottom),right:m(n.right)}}var re=e&&/Firefox/i.test(navigator.userAgent);function pe(e,t){var o=t.x,n=t.y,i=e.offsets.popper,r=U(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==r&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var p,s,d=void 0===r?t.gpuAcceleration:r,a=c(e.instance.popper),l=D(a),f={position:i.position},m=ie(e,2>window.devicePixelRatio||!re),h='bottom'===o?'top':'bottom',g='right'===n?'left':'right',u=K('transform');if(s='bottom'==h?'HTML'===a.nodeName?-a.clientHeight+m.bottom:-l.height+m.bottom:m.top,p='right'==g?'HTML'===a.nodeName?-a.clientWidth+m.right:-l.width+m.right:m.left,d&&u)f[u]='translate3d('+p+'px, '+s+'px, 0)',f[h]=0,f[g]=0,f.willChange='transform';else{var b='bottom'==h?-1:1,w='right'==g?-1:1;f[h]=s*b,f[g]=p*w,f.willChange=h+', '+g}var y={"x-placement":e.placement};return e.attributes=T({},y,e.attributes),e.styles=T({},f,e.styles),e.arrowStyles=T({},e.offsets.arrow,e.arrowStyles),e}function se(e,t,o){var n=U(e,function(e){var o=e.name;return o===t}),i=!!n&&e.some(function(e){return e.name===o&&e.enabled&&e.order<n.order});if(!i){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return i}function de(e,t){var o;if(!se(e.instance.modifiers,'arrow','keepTogether'))return e;var n=t.element;if('string'==typeof n){if(n=e.instance.popper.querySelector(n),!n)return e;}else if(!e.instance.popper.contains(n))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var i=e.placement.split('-')[0],r=e.offsets,p=r.popper,d=r.reference,a=-1!==['left','right'].indexOf(i),l=a?'height':'width',f=a?'Top':'Left',m=f.toLowerCase(),h=a?'left':'top',c=a?'bottom':'right',g=F(n)[l];d[c]-g<p[m]&&(e.offsets.popper[m]-=p[m]-(d[c]-g)),d[m]+g>p[c]&&(e.offsets.popper[m]+=d[m]+g-p[c]),e.offsets.popper=C(e.offsets.popper);var u=d[m]+d[l]/2-g/2,b=s(e.instance.popper),w=parseFloat(b['margin'+f]),y=parseFloat(b['border'+f+'Width']),E=u-e.offsets.popper[m]-w-y;return E=Math.max(Math.min(p[l]-g,E),0),e.arrowElement=n,e.offsets.arrow=(o={},S(o,m,Math.round(E)),S(o,h,''),o),e}function ae(e){if('end'===e)return'start';return'start'===e?'end':e}var le=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],fe=le.slice(3);function me(e){var t=1<arguments.length&&arguments[1]!==void 0&&arguments[1],o=fe.indexOf(e),n=fe.slice(o+1).concat(fe.slice(0,o));return t?n.reverse():n}var he={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'};function ce(e,t){if(q(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=B(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement,e.positionFixed),n=e.placement.split('-')[0],i=I(n),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case he.FLIP:p=[n,i];break;case he.CLOCKWISE:p=me(n);break;case he.COUNTERCLOCKWISE:p=me(n,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(n!==s||p.length===d+1)return e;n=e.placement.split('-')[0],i=I(n);var a=e.offsets.popper,l=e.offsets.reference,f=Math.floor,m='left'===n&&f(a.right)>f(l.left)||'right'===n&&f(a.left)<f(l.right)||'top'===n&&f(a.bottom)>f(l.top)||'bottom'===n&&f(a.top)<f(l.bottom),h=f(a.left)<f(o.left),c=f(a.right)>f(o.right),g=f(a.top)<f(o.top),u=f(a.bottom)>f(o.bottom),b='left'===n&&h||'right'===n&&c||'top'===n&&g||'bottom'===n&&u,w=-1!==['top','bottom'].indexOf(n),y=!!t.flipVariations&&(w&&'start'===r&&h||w&&'end'===r&&c||!w&&'start'===r&&g||!w&&'end'===r&&u),E=!!t.flipVariationsByContent&&(w&&'start'===r&&c||w&&'end'===r&&h||!w&&'start'===r&&u||!w&&'end'===r&&g),x=y||E;(m||b||x)&&(e.flipped=!0,(m||b)&&(n=p[d+1]),x&&(r=ae(r)),e.placement=n+(r?'-'+r:''),e.offsets.popper=T({},e.offsets.popper,R(e.instance.popper,e.offsets.reference,e.placement)),e=V(e.instance.modifiers,e,'flip'))}),e}function ge(e){var t=e.offsets,o=t.popper,n=t.reference,i=e.placement.split('-')[0],r=Math.floor,p=-1!==['top','bottom'].indexOf(i),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(n[d])&&(e.offsets.popper[d]=r(n[d])-o[a]),o[d]>r(n[s])&&(e.offsets.popper[d]=r(n[s])),e}function ue(e,t,o,n){var i=Math.max,r=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),p=+r[1],s=r[2];if(!p)return e;if(0===s.indexOf('%')){var d;switch(s){case'%p':d=o;break;case'%':case'%r':default:d=n;}var a=C(d);return a[t]/100*p}if('vh'===s||'vw'===s){var l;return l='vh'===s?i(document.documentElement.clientHeight,window.innerHeight||0):i(document.documentElement.clientWidth,window.innerWidth||0),l/100*p}return p}function be(e,t,o,n){var i=[0,0],r=-1!==['right','left'].indexOf(n),p=e.split(/(\+|\-)/).map(function(e){return e.trim()}),s=p.indexOf(U(p,function(e){return-1!==e.search(/,|\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\s*,\s*|\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,n){var i=(1===n?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return ue(e,i,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,n){$(o)&&(i[t]+=o*('-'===e[n-1]?-1:1))})}),i}function we(e,t){var o,n=t.offset,i=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=i.split('-')[0];return o=$(+n)?[+n,0]:be(n,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e}function ye(e,t){var o=t.boundariesElement||c(e.instance.popper);e.instance.reference===o&&(o=c(o));var n=K('transform'),i=e.instance.popper.style,r=i.top,p=i.left,s=i[n];i.top='',i.left='',i[n]='';var d=B(e.instance.popper,e.instance.reference,t.padding,o,e.positionFixed);i.top=r,i.left=p,i[n]=s,t.boundaries=d;var a=t.priority,l=e.offsets.popper,f={primary:function(e){var o=l[e];return l[e]<d[e]&&!t.escapeWithReference&&(o=Math.max(l[e],d[e])),S({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=l[o];return l[e]>d[e]&&!t.escapeWithReference&&(n=Math.min(l[o],d[e]-('right'===e?l.width:l.height))),S({},o,n)}};return a.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';l=T({},l,f[t](e))}),e.offsets.popper=l,e}function Ee(e){var t=e.placement,o=t.split('-')[0],n=t.split('-')[1];if(n){var i=e.offsets,r=i.reference,p=i.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',l={start:S({},d,r[d]),end:S({},d,r[d]+r[a]-p[a])};e.offsets.popper=T({},p,l[n])}return e}function xe(e){if(!se(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=U(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}function ve(e){var t=e.placement,o=t.split('-')[0],n=e.offsets,i=n.popper,r=n.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return i[p?'left':'top']=r[o]-(s?i[p?'width':'height']:0),e.placement=I(t),e.offsets.popper=C(i),e}var Oe={shift:{order:100,enabled:!0,fn:Ee},offset:{order:200,enabled:!0,fn:we,offset:0},preventOverflow:{order:300,enabled:!0,fn:ye,priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:ge},arrow:{order:500,enabled:!0,fn:de,element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:ce,behavior:'flip',padding:5,boundariesElement:'viewport',flipVariations:!1,flipVariationsByContent:!1},inner:{order:700,enabled:!1,fn:ve},hide:{order:800,enabled:!0,fn:xe},computeStyle:{order:850,enabled:!0,fn:pe,gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:oe,onLoad:ne,gpuAcceleration:void 0}},Le={placement:'bottom',positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:Oe},Se=function(){function e(t,o){var n=this,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};O(this,e),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=r(this.update.bind(this)),this.options=T({},e.Defaults,i),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=t&&t.jquery?t[0]:t,this.popper=o&&o.jquery?o[0]:o,this.options.modifiers={},Object.keys(T({},e.Defaults.modifiers,i.modifiers)).forEach(function(t){n.options.modifiers[t]=T({},e.Defaults.modifiers[t]||{},i.modifiers?i.modifiers[t]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return T({name:e},n.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(e){e.enabled&&p(e.onLoad)&&e.onLoad(n.reference,n.popper,n.options,e,n.state)}),this.update();var s=this.options.eventsEnabled;s&&this.enableEventListeners(),this.state.eventsEnabled=s}return L(e,[{key:'update',value:function(){return j.call(this)}},{key:'destroy',value:function(){return z.call(this)}},{key:'enableEventListeners',value:function(){return J.call(this)}},{key:'disableEventListeners',value:function(){return Z.call(this)}}]),e}();Se.Utils=('undefined'==typeof window?global:window).PopperUtils,Se.placements=le,Se.Defaults=Le;export default Se;
    //# sourceMappingURL=popper.min.js.map
  admin-Public-Admin-plugins-popper-esm-popper.min.js.map: '{"version":3,"file":"popper.min.js","sources":["../../src/utils/isBrowser.js","../../src/utils/debounce.js","../../src/utils/isFunction.js","../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/runModifiers.js","../../src/methods/update.js","../../src/utils/isModifierEnabled.js","../../src/utils/getSupportedPropertyName.js","../../src/methods/destroy.js","../../src/utils/getWindow.js","../../src/utils/setupEventListeners.js","../../src/methods/enableEventListeners.js","../../src/utils/removeEventListeners.js","../../src/methods/disableEventListeners.js","../../src/utils/isNumeric.js","../../src/utils/setStyles.js","../../src/utils/setAttributes.js","../../src/modifiers/applyStyle.js","../../src/utils/getRoundedOffsets.js","../../src/modifiers/computeStyle.js","../../src/utils/isModifierRequired.js","../../src/modifiers/arrow.js","../../src/utils/getOppositeVariation.js","../../src/methods/placements.js","../../src/utils/clockwise.js","../../src/modifiers/flip.js","../../src/modifiers/keepTogether.js","../../src/modifiers/offset.js","../../src/modifiers/preventOverflow.js","../../src/modifiers/shift.js","../../src/modifiers/hide.js","../../src/modifiers/inner.js","../../src/modifiers/index.js","../../src/methods/defaults.js","../../src/index.js"],"sourcesContent":["export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n
    * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer
    to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const
    getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck)
    === ''[object Function]''\n  );\n}\n","/**\n * Get CSS computed property of the
    given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n
    * @argument {String} property\n */\nexport default function getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const
    css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName
    === ''HTML'') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getParentNode
    from ''./getParentNode'';\n\n/**\n * Returns the scrolling parent of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n
    * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element)
    {\n  // Return body, `getScroll` will take care to get the correct `scrollTop`
    from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName)
    {\n    case ''HTML'':\n    case ''BODY'':\n      return element.ownerDocument.body\n    case
    ''#document'':\n      return element.body\n  }\n\n  // Firefox want us to check
    `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } =
    getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow
    + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nexport default function getOuterSizes(element)
    {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const
    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const
    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  const
    result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the
    given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement)
    {\n  const hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom''
    };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import
    getOuterSizes from ''./getOuterSizes'';\nimport getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n
    * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param
    {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement}
    popper - the popper element\n * @param {Object} referenceOffsets - the reference
    offsets (the popper will be relative to this)\n * @param {String} placement -
    one of the valid placement options\n * @returns {Object} popperOffsets - An object
    containing the offsets which will be applied to the popper\n */\nexport default
    function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement
    = placement.split(''-'')[0];\n\n  // Get popper node sizes\n  const popperRect
    = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets
    object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  //
    depending by the popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function find(arr, check)
    {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    isFunction from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport
    getClientRect from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list
    of modifiers and run them in order,\n * each of them will then edit the data object.\n
    * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array}
    modifiers\n * @param {String} ends - Optional modifier name used as stopper\n
    * @returns {dataObject}\n */\nexport default function runModifiers(modifiers,
    data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    :
    modifiers.slice(0, findIndex(modifiers, ''name'', ends));\n\n  modifiersToRun.forEach(modifier
    => {\n    if (modifier[''function'']) { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","import computeAutoPlacement from ''../utils/computeAutoPlacement'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\n\n/**\n
    * Updates the position of the popper, computing the new offsets and applying\n
    * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance
    reasons.\n * @method\n * @memberof Popper\n */\nexport default function update()
    {\n  // if popper is destroyed, don''t perform any further update\n  if (this.state.isDestroyed)
    {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles:
    {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  //
    compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  //
    compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  //
    store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position
    = this.options.positionFixed\n    ? ''fixed''\n    : ''absolute'';\n\n  // run
    the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first
    `update` will call `onCreate` callback\n  // the other ones will call `onUpdate`
    callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  }
    else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know
    if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns
    {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName)
    {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from ''../utils/isModifierEnabled'';\nimport
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * Destroys the popper.\n * @method\n * @memberof Popper\n */\nexport default function
    destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle`
    modifier is enabled\n  if (isModifierEnabled(this.modifiers, ''applyStyle''))
    {\n    this.popper.removeAttribute(''x-placement'');\n    this.popper.style.position
    = '''';\n    this.popper.style.top = '''';\n    this.popper.style.left = '''';\n    this.popper.style.right
    = '''';\n    this.popper.style.bottom = '''';\n    this.popper.style.willChange
    = '''';\n    this.popper.style[getSupportedPropertyName(''transform'')] = '''';\n  }\n\n  this.disableEventListeners();\n\n  //
    remove the popper if user explicitly asked for the deletion on destroy\n  // do
    not use `remove` because IE11 doesn''t support it\n  if (this.options.removeOnDestroy)
    {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n
    * Get the window associated with the element\n * @argument {Element} element\n
    * @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getScrollParent from ''./getScrollParent'';\nimport getWindow
    from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  const isBody = scrollParent.nodeName === ''BODY'';\n  const
    target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    setupEventListeners from ''../utils/setupEventListeners'';\n\n/**\n * It will
    add resize/scroll events and start recalculating\n * position of the popper element
    when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default
    function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state
    = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import
    getWindow from ''./getWindow'';\n\n/**\n * Remove event listeners used to update
    the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport
    default function removeEventListeners(reference, state) {\n  // Remove resize
    event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners
    from ''../utils/removeEventListeners'';\n\n/**\n * It will remove resize/scroll
    events and won''t recalculate popper position\n * when they are triggered. It
    also won''t trigger `onUpdate` callback anymore,\n * unless you call `update`
    method manually.\n * @method\n * @memberof Popper\n */\nexport default function
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state
    = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nexport default
    function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop)
    {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    setStyles from ''../utils/setStyles'';\nimport setAttributes from ''../utils/setAttributes'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport computeAutoPlacement
    from ''../utils/computeAutoPlacement'';\n\n/**\n * @function\n * @memberof Modifiers\n
    * @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} data.styles - List of style properties - values to apply to popper element\n
    * @argument {Object} data.attributes - List of attribute properties - values to
    apply to popper element\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The same data object\n */\nexport default function
    applyStyle(data) {\n  // any property present in `data.styles` will be applied
    to the popper,\n  // in this way we can make the 3rd party modifiers add custom
    styles to it\n  // Be aware, modifiers could override the properties defined in
    the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper,
    data.styles);\n\n  // any property present in `data.attributes` will be applied
    to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper,
    data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some
    properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement,
    data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute
    before everything else because it could be used\n * to add margins to the popper
    margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n
    * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference
    element used to position the popper\n * @param {HTMLElement} popper - The HTML
    element used as popper\n * @param {Object} options - Popper.js options\n */\nexport
    function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n)
    {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state,
    popper, reference, options.positionFixed);\n\n  // compute auto placement, store
    placement inside the data object,\n  // modifiers will be able to edit `placement`
    if needed\n  // and refer to originalPlacement to know the original value\n  const
    placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute(''x-placement'',
    placement);\n\n  // Apply `position` to popper before anything else because\n  //
    without the position applied we can''t guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? ''fixed'' : ''absolute'' });\n\n  return options;\n}\n","/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper''s position
    offsets rounded\n *\n * The tale of pixel-perfect positioning. It''s still not
    100% perfect, but as\n * good as it can be within reason.\n * Discussion here:
    https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause
    a popper to be blurry if not using full pixels (Safari\n * as well on High DPI
    screens).\n *\n * Firefox prefers no rounding for positioning and does not have
    blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right
    values need to be considered.\n */\nexport default function getRoundedOffsets(data,
    shouldRound) {\n  const { popper, reference } = data.offsets;\n  const { round,
    floor } = Math;\n  const noRound = v => v;\n  \n  const referenceWidth = round(reference.width);\n  const
    popperWidth = round(popper.width);\n  \n  const isVertical = [''left'', ''right''].indexOf(data.placement)
    !== -1;\n  const isVariation = data.placement.indexOf(''-'') !== -1;\n  const
    sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  const bothOddWidth
    = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  const horizontalToInteger
    = !shouldRound\n    ? noRound\n    : isVertical || isVariation || sameWidthParity\n    ?
    round\n    : floor;\n  const verticalToInteger = !shouldRound ? noRound : round;\n\n  return
    {\n    left: horizontalToInteger(\n      bothOddWidth && !isVariation && shouldRound\n        ?
    popper.left - 1\n        : popper.left\n    ),\n    top: verticalToInteger(popper.top),\n    bottom:
    verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right),\n  };\n}\n","import
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\nimport find
    from ''../utils/find'';\nimport getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundingClientRect from ''../utils/getBoundingClientRect'';\nimport getRoundedOffsets
    from ''../utils/getRoundedOffsets'';\nimport isBrowser from ''../utils/isBrowser'';\n\nconst
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeStyle(data, options) {\n  const { x, y } = options;\n  const
    { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const
    legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''applyStyle''\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption
    !== undefined) {\n    console.warn(\n      ''WARNING: `gpuAcceleration` option
    moved to `computeStyle` modifier and will not be supported in future versions
    of Popper.js!''\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption
    !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const
    offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position:
    popper.position,\n  };\n\n  const offsets = getRoundedOffsets(\n    data,\n    window.devicePixelRatio
    < 2 || !isFirefox\n  );\n\n  const sideA = x === ''bottom'' ? ''top'' : ''bottom'';\n  const
    sideB = y === ''right'' ? ''left'' : ''right'';\n\n  // if gpuAcceleration is
    set to `true` and transform is supported,\n  //  we use `translate3d` to apply
    the position to the popper we\n  // automatically use the supported prefixed version
    if needed\n  const prefixedProperty = getSupportedPropertyName(''transform'');\n\n  //
    now, let''s make a step back and look at this code closely (wtf?)\n  // If the
    content of the popper grows once it''s been positioned, it\n  // may happen that
    the popper gets misplaced because of the new content\n  // overflowing its reference
    element\n  // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA ===
    ''bottom'') {\n    // when offsetParent is <html> the positioning is relative
    to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom
    of the html element\n    if (offsetParent.nodeName === ''HTML'') {\n      top
    = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height
    + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB
    === ''right'') {\n    if (offsetParent.nodeName === ''HTML'') {\n      left =
    -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width
    + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration
    && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px,
    ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange
    = ''transform'';\n  } else {\n    // othwerise, we use the standard `top`, `left`,
    `bottom` and `right` properties\n    const invertTop = sideA === ''bottom'' ?
    -1 : 1;\n    const invertLeft = sideB === ''right'' ? -1 : 1;\n    styles[sideA]
    = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange
    = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    ''x-placement'':
    data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles
    };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return
    data;\n}\n","import find from ''./find'';\n\n/**\n * Helper used to know if the
    given modifier depends from another one.<br />\n * It checks if the needed modifier
    is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array}
    modifiers - list of modifiers\n * @param {String} requestingName - name of requesting
    modifier\n * @param {String} requestedName - name of requested modifier\n * @returns
    {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","import getClientRect
    from ''../utils/getClientRect'';\nimport getOuterSizes from ''../utils/getOuterSizes'';\nimport
    isModifierRequired from ''../utils/isModifierRequired'';\nimport getStyleComputedProperty
    from ''../utils/getStyleComputedProperty'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by update method\n
    * @argument {Object} options - Modifiers configuration and options\n * @returns
    {Object} The data object, properly modified\n */\nexport default function arrow(data,
    options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers,
    ''arrow'', ''keepTogether'')) {\n    return data;\n  }\n\n  let arrowElement =
    options.element;\n\n  // if arrowElement is a string, suppose it''s a CSS selector\n  if
    (typeof arrowElement === ''string'') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    //
    if arrowElement is not found, don''t run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn''t a
    query selector we must check that the\n    // provided DOM node is child of its
    popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        ''WARNING:
    `arrow.element` must be child of its popper element!''\n      );\n      return
    data;\n    }\n  }\n\n  const placement = data.placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isVertical = [''left'', ''right''].indexOf(placement)
    !== -1;\n\n  const len = isVertical ? ''height'' : ''width'';\n  const sideCapitalized
    = isVertical ? ''Top'' : ''Left'';\n  const side = sideCapitalized.toLowerCase();\n  const
    altSide = isVertical ? ''left'' : ''top'';\n  const opSide = isVertical ? ''bottom''
    : ''right'';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  //
    extends keepTogether behavior making sure the popper and its\n  // reference have
    enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide]
    - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side]
    - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side]
    + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side]
    + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  //
    compute center of the popper\n  const center = reference[side] + reference[len]
    / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper
    offsets\n  // take popper margin in account because we don''t have this info available\n  const
    css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide
    = parseFloat(css[`margin${sideCapitalized}`]);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let
    sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  //
    prevent arrowElement from being placed not contiguously to its popper\n  sideValue
    = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement
    = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]:
    '''', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return
    data;\n}\n","/**\n * Get the opposite placement variation of the given one\n *
    @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n
    * @returns {String} flipped placement variation\n */\nexport default function
    getOppositeVariation(variation) {\n  if (variation === ''end'') {\n    return
    ''start'';\n  } else if (variation === ''start'') {\n    return ''end'';\n  }\n  return
    variation;\n}\n","/**\n * List of accepted placements to use as values of the
    `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n
    * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation
    from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted
    easily if you think of them as the left to right\n * written languages. Horizontally
    (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically
    (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples
    are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start`
    (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n *
    - `auto-end` (on the side with more space available, alignment depends by placement)\n
    *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n
    * @memberof Popper\n */\nexport default [\n  ''auto-start'',\n  ''auto'',\n  ''auto-end'',\n  ''top-start'',\n  ''top'',\n  ''top-end'',\n  ''right-start'',\n  ''right'',\n  ''right-end'',\n  ''bottom-end'',\n  ''bottom'',\n  ''bottom-start'',\n  ''left-end'',\n  ''left'',\n  ''left-start'',\n];\n","import
    placements from ''../methods/placements'';\n\n// Get rid of `auto` `auto-start`
    and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given
    an initial placement, returns all the subsequent placements\n * clockwise (or
    counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String}
    placement - A valid placement (it accepts variations)\n * @argument {Boolean}
    counter - Set to true to walk the placements counterclockwise\n * @returns {Array}
    placements including their variations\n */\nexport default function clockwise(placement,
    counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const
    arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0,
    index));\n  return counter ? arr.reverse() : arr;\n}\n","import getOppositePlacement
    from ''../utils/getOppositePlacement'';\nimport getOppositeVariation from ''../utils/getOppositeVariation'';\nimport
    getPopperOffsets from ''../utils/getPopperOffsets'';\nimport runModifiers from
    ''../utils/runModifiers'';\nimport getBoundaries from ''../utils/getBoundaries'';\nimport
    isModifierEnabled from ''../utils/isModifierEnabled'';\nimport clockwise from
    ''../utils/clockwise'';\n\nconst BEHAVIORS = {\n  FLIP: ''flip'',\n  CLOCKWISE:
    ''clockwise'',\n  COUNTERCLOCKWISE: ''counterclockwise'',\n};\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by update method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function flip(data, options) {\n  // if `inner` modifier is enabled, we
    can''t use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    ''inner'')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there''s not enough space on any of the flippable sides\n    return data;\n  }\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let
    placement = data.placement.split(''-'')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let
    variation = data.placement.split(''-'')[1] || '''';\n\n  let flipOrder = [];\n\n  switch
    (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder
    = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step,
    index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return
    data;\n    }\n\n    placement = data.placement.split(''-'')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const
    refOffsets = data.offsets.reference;\n\n    // using floor because the reference
    offsets may contain decimals we are not going to consider here\n    const floor
    = Math.floor;\n    const overlapsRef =\n      (placement === ''left'' &&\n        floor(popperOffsets.right)
    > floor(refOffsets.left)) ||\n      (placement === ''right'' &&\n        floor(popperOffsets.left)
    < floor(refOffsets.right)) ||\n      (placement === ''top'' &&\n        floor(popperOffsets.bottom)
    > floor(refOffsets.top)) ||\n      (placement === ''bottom'' &&\n        floor(popperOffsets.top)
    < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top)
    < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement
    === ''left'' && overflowsLeft) ||\n      (placement === ''right'' && overflowsRight)
    ||\n      (placement === ''top'' && overflowsTop) ||\n      (placement === ''bottom''
    && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical
    = [''top'', ''bottom''].indexOf(placement) !== -1;\n\n    // flips variation if
    reference element overflows boundaries\n    const flippedVariationByRef =\n      !!options.flipVariations
    &&\n      ((isVertical && variation === ''start'' && overflowsLeft) ||\n        (isVertical
    && variation === ''end'' && overflowsRight) ||\n        (!isVertical && variation
    === ''start'' && overflowsTop) ||\n        (!isVertical && variation === ''end''
    && overflowsBottom));\n\n    // flips variation if popper content overflows boundaries\n    const
    flippedVariationByContent =\n      !!options.flipVariationsByContent &&\n      ((isVertical
    && variation === ''start'' && overflowsRight) ||\n        (isVertical && variation
    === ''end'' && overflowsLeft) ||\n        (!isVertical && variation === ''start''
    && overflowsBottom) ||\n        (!isVertical && variation === ''end'' && overflowsTop));\n\n    const
    flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if
    (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean
    to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef ||
    overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if
    (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? ''-'' + variation : '''');\n\n      // this object
    contains `position`, we want to preserve it along with\n      // any additional
    property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data
    = runModifiers(data.instance.modifiers, data, ''flip'');\n    }\n  });\n  return
    data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nexport default function keepTogether(data) {\n  const { popper,
    reference } = data.offsets;\n  const placement = data.placement.split(''-'')[0];\n  const
    floor = Math.floor;\n  const isVertical = [''top'', ''bottom''].indexOf(placement)
    !== -1;\n  const side = isVertical ? ''right'' : ''bottom'';\n  const opSide =
    isVertical ? ''left'' : ''top'';\n  const measurement = isVertical ? ''width''
    : ''height'';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide]
    =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide]
    > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return
    data;\n}\n","import isNumeric from ''../utils/isNumeric'';\nimport getClientRect
    from ''../utils/getClientRect'';\nimport find from ''../utils/find'';\n\n/**\n
    * Converts a string containing value + unit into a px value number\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value
    + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument
    {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n
    * Value in pixels, or original string if no values were extracted\n */\nexport
    function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate
    value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const
    value = +split[1];\n  const unit = split[2];\n\n  // If it''s not a number it''s
    an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf(''%'')
    === 0) {\n    let element;\n    switch (unit) {\n      case ''%p'':\n        element
    = popperOffsets;\n        break;\n      case ''%'':\n      case ''%r'':\n      default:\n        element
    = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return
    rect[measurement] / 100 * value;\n  } else if (unit === ''vh'' || unit === ''vw'')
    {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let
    size;\n    if (unit === ''vh'') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight
    || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth
    || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is
    an explicit pixel unit, we get rid of the unit and keep the value\n    // if is
    an implicit unit, it''s px, and we return just the value\n    return value;\n  }\n}\n\n/**\n
    * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n *
    @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument
    {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets
    in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n)
    {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right
    and index is 0 otherwise use width\n  // in this way the first offset will use
    an axis and the second one\n  // will use the other one\n  const useHeight = [''right'',
    ''left''].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain
    a list of values and operands\n  // The regex addresses values with the plus or
    minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag
    => frag.trim());\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  const divider
    = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if
    (fragments[divider] && fragments[divider].indexOf('','') === -1) {\n    console.warn(\n      ''Offsets
    separated by white space(s) are deprecated, use a comma (,) instead.''\n    );\n  }\n\n  //
    If divider is found, we divide the list of values and operands to divide\n  //
    them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider
    !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider
    + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with
    units to absolute pixels to allow our computations\n  ops = ops.map((op, index)
    => {\n    // Most of the units rely on the orientation of the popper\n    const
    measurement = (index === 1 ? !useHeight : useHeight)\n      ? ''height''\n      :
    ''width'';\n    let mergeWithPrevious = false;\n    return (\n      op\n        //
    This aggregates any `+` or `-` sign that aren''t considered operators\n        //
    e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length
    - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {\n            a[a.length -
    1] = b;\n            mergeWithPrevious = true;\n            return a;\n          }
    else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious
    = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        },
    [])\n        // Here we convert the string values into number values (in px)\n        .map(str
    => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  //
    Loop trough the offsets arrays and execute the operations\n  ops.forEach((op,
    index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index]
    += frag * (op[index2 - 1] === ''-'' ? -1 : 1);\n      }\n    });\n  });\n  return
    offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n
    * The offset value as described in the modifier description\n * @returns {Object}
    The data object, properly modified\n */\nexport default function offset(data,
    { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const
    basePlacement = placement.split(''-'')[0];\n\n  let offsets;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === ''left'') {\n    popper.top
    += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement ===
    ''right'') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  }
    else if (basePlacement === ''top'') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === ''bottom'') {\n    popper.left
    += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n","import getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundaries from ''../utils/getBoundaries'';\nimport getSupportedPropertyName
    from ''../utils/getSupportedPropertyName'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by `update`
    method\n * @argument {Object} options - Modifiers configuration and options\n
    * @returns {Object} The data object, properly modified\n */\nexport default function
    preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement
    || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference
    element, we really want to\n  // go one step up and use the next offsetParent
    as reference to\n  // avoid to make this modifier completely useless and look
    like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement
    = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  //
    resets the popper''s position so that the document size can be calculated excluding\n  //
    the size of the popper element itself\n  const transformProp = getSupportedPropertyName(''transform'');\n  const
    popperStyles = data.instance.popper.style; // assignment to help minification\n  const
    { top, left, [transformProp]: transform } = popperStyles;\n  popperStyles.top
    = '''';\n  popperStyles.left = '''';\n  popperStyles[transformProp] = '''';\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement,\n    data.positionFixed\n  );\n\n  //
    NOTE: DOM access here\n  // restores the original style properties after the offsets
    have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp]
    = transform;\n\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let
    popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let
    value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement)
    {\n      const mainSide = placement === ''right'' ? ''left'' : ''top'';\n      let
    value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement]
    -\n            (placement === ''right'' ? popper.width : popper.height)\n        );\n      }\n      return
    { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const
    side =\n      [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ''secondary'';\n    popper
    = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper =
    popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function shift(data) {\n  const
    placement = data.placement;\n  const basePlacement = placement.split(''-'')[0];\n  const
    shiftvariation = placement.split(''-'')[1];\n\n  // if shift shiftvariation is
    specified, run the modifier\n  if (shiftvariation) {\n    const { reference, popper
    } = data.offsets;\n    const isVertical = [''bottom'', ''top''].indexOf(basePlacement)
    !== -1;\n    const side = isVertical ? ''left'' : ''top'';\n    const measurement
    = isVertical ? ''width'' : ''height'';\n\n    const shiftOffsets = {\n      start:
    { [side]: reference[side] },\n      end: {\n        [side]: reference[side] +
    reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper
    = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import
    isModifierRequired from ''../utils/isModifierRequired'';\nimport find from ''../utils/find'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function hide(data) {\n  if (!isModifierRequired(data.instance.modifiers,
    ''hide'', ''preventOverflow'')) {\n    return data;\n  }\n\n  const refRect =
    data.offsets.reference;\n  const bound = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''preventOverflow''\n  ).boundaries;\n\n  if (\n    refRect.bottom
    < bound.top ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom
    ||\n    refRect.right < bound.left\n  ) {\n    // Avoid unnecessary DOM access
    if visibility hasn''t changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide
    = true;\n    data.attributes[''x-out-of-boundaries''] = '''';\n  } else {\n    //
    Avoid unnecessary DOM access if visibility hasn''t changed\n    if (data.hide
    === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes[''x-out-of-boundaries'']
    = false;\n  }\n\n  return data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport
    getOppositePlacement from ''../utils/getOppositePlacement'';\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function inner(data) {\n  const placement = data.placement;\n  const basePlacement
    = placement.split(''-'')[0];\n  const { popper, reference } = data.offsets;\n  const
    isHoriz = [''left'', ''right''].indexOf(basePlacement) !== -1;\n\n  const subtractLength
    = [''top'', ''left''].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? ''left''
    : ''top''] =\n    reference[basePlacement] -\n    (subtractLength ? popper[isHoriz
    ? ''width'' : ''height''] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper
    = getClientRect(popper);\n\n  return data;\n}\n","import applyStyle, { applyStyleOnLoad
    } from ''./applyStyle'';\nimport computeStyle from ''./computeStyle'';\nimport
    arrow from ''./arrow'';\nimport flip from ''./flip'';\nimport keepTogether from
    ''./keepTogether'';\nimport offset from ''./offset'';\nimport preventOverflow
    from ''./preventOverflow'';\nimport shift from ''./shift'';\nimport hide from
    ''./hide'';\nimport inner from ''./inner'';\n\n/**\n * Modifier function, each
    modifier can have a function of this type assigned\n * to its `fn` property.<br
    />\n * These functions will be called on each update, this means that you must\n
    * make sure they are performant enough to avoid performance bottlenecks.\n *\n
    * @function ModifierFn\n * @argument {dataObject} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n
    * Modifiers are plugins used to alter the behavior of your poppers.<br />\n *
    Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n
    * needed by the library.\n *\n * Usually you don''t want to override the `order`,
    `fn` and `onLoad` props.\n * All the other properties are configurations that
    could be tweaked.\n * @namespace modifiers\n */\nexport default {\n  /**\n   *
    Modifier used to shift the popper on the start or end of its reference\n   * element.<br
    />\n   * It will read the variation of the `placement` property.<br />\n   * It
    can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift:
    {\n    /** @prop {number} order=100 - Index used to define the order of execution
    */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier
    is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn:
    shift,\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both
    its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less,
    interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of
    the reference element\n   * - `%p`, percentage relative to the length of the popper
    element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height
    unit\n   *\n   * For length is intended the main axis relative to the placement
    of the popper.<br />\n   * This means that if the placement is `top` or `bottom`,
    the length will be the\n   * `width`. In case of `left` or `right`, it will be
    the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`),
    or a pair of values\n   * as `String` divided by a comma or one (or more) white
    spaces.<br />\n   * The latter is a deprecated method because it leads to confusion
    and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions
    and subtractions between different units.\n   * Note that multiplications and
    divisions aren''t supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   *
    ''10%''\n   * ''10, 10''\n   * ''10%, 10''\n   * ''10 + 10%''\n   * ''10 - 5vh
    + 3%''\n   * ''-10px + 5vh, 5px - 6%''\n   * ```\n   * > **NB**: If you desire
    to apply offsets to your poppers in a way that may make them overlap\n   * > with
    their reference element, unfortunately, you will have to disable the `flip` modifier.\n   *
    > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200
    - Index used to define the order of execution */\n    order: 200,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String}
    offset=0\n     * The offset value as described in the modifier description\n     */\n    offset:
    0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned
    outside the boundary.\n   *\n   * A scenario exists where the reference itself
    is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"
    — or just \"escaped\".<br />\n   * In this case we need to decide whether the
    popper should either:\n   *\n   * - detach from the reference and remain \"trapped\"
    in the boundaries, or\n   * - if it should ignore the boundary and \"escape with
    its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference
    is completely\n   * outside its boundaries, the popper will overflow (or completely
    leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number}
    order=300 - Index used to define the order of execution */\n    order: 300,\n    /**
    @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]\n     * Popper
    will try to prevent overflow following these priorities by default,\n     * then,
    it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    [''left'', ''right'', ''top'', ''bottom''],\n    /**\n     * @prop {number} padding=5\n     *
    Amount of pixel used to define a minimum distance between the boundaries\n     *
    and the popper. This makes sure the popper always has a little padding\n     *
    between the edges of its container\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''scrollParent''\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: ''scrollParent'',\n  },\n\n  /**\n   *
    Modifier used to make sure the reference and its popper stay near each other\n   *
    without leaving any gap between the two. Especially useful when the arrow is\n   *
    enabled and you want to ensure that it points to its reference element.\n   *
    It cares only about the first axis. You can still have poppers with margin\n   *
    between the popper and its reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used
    to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier
    is used to move the `arrowElement` of the popper to make\n   * sure it is positioned
    between the reference element and its popper element.\n   * It will read the outer
    size of the `arrowElement` node to detect how many\n   * pixels of conjunction
    are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   *
    @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500
    - Index used to define the order of execution */\n    order: 500,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement}
    element=''[x-arrow]'' - Selector or node used as arrow */\n    element: ''[x-arrow]'',\n  },\n\n  /**\n   *
    Modifier used to flip the popper''s placement when it starts to overlap its\n   *
    reference element.\n   *\n   * Requires the `preventOverflow` modifier before
    it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current
    update cycle and will\n   * restart it if it detects the need to flip the placement.\n   *
    @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600
    - Index used to define the order of execution */\n    order: 600,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array}
    behavior=''flip''\n     * The behavior used to change the popper''s placement.
    It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with
    a list of valid\n     * placements (with optional variations)\n     */\n    behavior:
    ''flip'',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip
    if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''viewport''\n     * The element
    which will define the boundaries of the popper position.\n     * The popper will
    never be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: ''viewport'',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariations:
    false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     *
    The popper will switch placement variation between `-start` and `-end` when\n     *
    the popper element overlaps its reference boundaries.\n     *\n     * The original
    placement should have a set variation.\n     */\n    flipVariationsByContent:
    false,\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define
    the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false
    - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop
    {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the
    popper when its reference element is outside of the\n   * popper boundaries. It
    will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with
    a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   *
    Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof
    modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index
    used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that
    will be applied to the popper element to gets\n   * properly positioned.\n   *\n   *
    Note that this modifier will not touch the DOM, it just prepares the styles\n   *
    so that `applyStyle` modifier can apply it. This separation is useful\n   * in
    case you need to replace `applyStyle` with a custom implementation.\n   *\n   *
    This modifier has `850` as `order` value to maintain backward compatibility\n   *
    with previous versions of Popper.js. Expect the modifiers ordering method\n   *
    to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used
    to define the order of execution */\n    order: 850,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean}
    gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position
    the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    true,\n    /**\n     * @prop {string} [x=''bottom'']\n     * Where to anchor the
    X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper
    should grow in a direction different from `bottom`\n     */\n    x: ''bottom'',\n    /**\n     *
    @prop {string} [x=''left'']\n     * Where to anchor the Y axis (`left` or `right`).
    AKA Y offset origin.\n     * Change this if your popper should grow in a direction
    different from `right`\n     */\n    y: ''right'',\n  },\n\n  /**\n   * Applies
    the computed styles to the popper element.\n   *\n   * All the DOM manipulations
    are limited to this modifier. This is useful in case\n   * you want to integrate
    Popper.js inside a framework or view library and you\n   * want to delegate all
    the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier,
    you must make sure the popper element\n   * has its position set to `absolute`
    before Popper.js can do its work!\n   *\n   * Just disable this modifier and define
    your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used
    to define the order of execution */\n    order: 900,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad:
    applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property
    moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     *
    If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n
    * The `dataObject` is an object containing all the information used by Popper.js.\n
    * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n
    * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n
    * @property {String} data.placement Placement applied to popper\n * @property
    {String} data.originalPlacement Placement originally defined on init\n * @property
    {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property
    {Boolean} data.hide True if the reference element is out of boundaries, useful
    to know when to hide the popper\n * @property {HTMLElement} data.arrowElement
    Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS
    property defined here will be applied to the popper. It expects the JavaScript
    nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any
    CSS property defined here will be applied to the popper arrow. It expects the
    JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n","import
    modifiers from ''../modifiers/index'';\n\n/**\n * Default options provided to
    Popper.js constructor.<br />\n * These can be overridden using the `options` argument
    of Popper.js.<br />\n * To override an option, simply pass an object with the
    same\n * structure of the `options` object, as the 3rd argument. For example:\n
    * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: {
    enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof
    Popper\n */\nexport default {\n  /**\n   * Popper''s placement.\n   * @prop {Popper.placements}
    placement=''bottom''\n   */\n  placement: ''bottom'',\n\n  /**\n   * Set this
    to true if you want popper to position it self in ''fixed'' mode\n   * @prop {Boolean}
    positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events
    (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled:
    true,\n\n  /**\n   * Set to true if you want to automatically remove the popper
    when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called
    when the popper is updated. This callback is not called\n   * on the initialization/creation
    of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it
    is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers
    used to modify the offsets before they are applied to the popper.\n   * They provide
    most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n
    * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n
    * @param {dataObject} data\n */\n","// Utils\nimport debounce from ''./utils/debounce'';\nimport
    isFunction from ''./utils/isFunction'';\n\n// Methods\nimport update from ''./methods/update'';\nimport
    destroy from ''./methods/destroy'';\nimport enableEventListeners from ''./methods/enableEventListeners'';\nimport
    disableEventListeners from ''./methods/disableEventListeners'';\nimport Defaults
    from ''./methods/defaults'';\nimport placements from ''./methods/placements'';\n\nexport
    default class Popper {\n  /**\n   * Creates a new Popper.js instance.\n   * @class
    Popper\n   * @param {Element|referenceObject} reference - The reference element
    used to position the popper\n   * @param {Element} popper - The HTML / XML element
    used as the popper\n   * @param {Object} options - Your custom options to override
    the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The
    generated Popper.js instance\n   */\n  constructor(reference, popper, options
    = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update
    = debounce(this.update.bind(this));\n\n    // with {} we create a new object with
    the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    //
    init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents:
    [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference
    = reference && reference.jquery ? reference[0] : reference;\n    this.popper =
    popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name
    => {\n      this.options.modifiers[name] = {\n        // If it''s a built-in modifier,
    use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        //
    If there are custom options, override and merge with default ones\n        ...(options.modifiers
    ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers''
    list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name
    => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      //
    sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    //
    modifiers have the ability to execute arbitrary code when Popper.js get inited\n    //
    such code is executed in the same order of its modifier\n    // they could add
    new properties to their options configuration\n    // BE AWARE: don''t add options
    to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions
    => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad))
    {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    //
    fire the first update to position the popper in the right place\n    this.update();\n\n    const
    eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      //
    setup event listeners, they will take care of update the position in specific
    situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can''t use class properties because they don''t
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update()
    {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners()
    {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners()
    {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedules
    an update. It will run on the next UI update available.\n   * @method scheduleUpdate\n   *
    @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   *
    Collection of utilities useful when writing custom modifiers.\n   * Starting from
    version 1.7, this method is available only if you\n   * include `popper-utils.js`
    before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils
    is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly
    instead.\n   * Due to the high instability of the methods contained in Utils,
    we can''t\n   * guarantee them to follow semver. Use them at your own risk!\n   *
    @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   *
    @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !==
    ''undefined'' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static
    Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides
    an interface compatible with Popper.js\n * and lets you use it as replacement
    of a real DOM node.<br />\n * You can use this method to position a popper relatively
    to a set of coordinates\n * in case you don''t have a DOM node to use as reference.\n
    *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This
    feature isn''t supported in Internet Explorer 10.\n * @name referenceObject\n
    * @property {Function} data.getBoundingClientRect\n * A function that returns
    a set of coordinates compatible with the native `getBoundingClientRect` method.\n
    * @property {number} data.clientWidth\n * An ES6 getter that will return the width
    of the virtual reference element.\n * @property {number} data.clientHeight\n *
    An ES6 getter that will return the height of the virtual reference element.\n
    */\n"],"names":["window","document","navigator","longerTimeoutBrowsers","i","length","isBrowser","userAgent","indexOf","called","Promise","resolve","then","scheduled","supportsMicroTasks","functionToCheck","getType","toString","call","element","nodeType","ownerDocument","defaultView","css","getComputedStyle","property","nodeName","parentNode","host","body","getStyleComputedProperty","overflow","overflowX","overflowY","test","getScrollParent","getParentNode","reference","referenceNode","isIE11","MSInputMethodContext","documentMode","isIE10","version","documentElement","noOffsetParent","isIE","offsetParent","nextElementSibling","getOffsetParent","firstElementChild","node","getRoot","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","scrollingElement","subtract","scrollTop","getScroll","scrollLeft","modifier","top","bottom","left","right","sideA","axis","sideB","parseFloat","styles","Math","max","parseInt","computedStyle","getSize","offsets","width","height","rect","getBoundingClientRect","result","sizes","getWindowSizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getBordersSize","getClientRect","fixedPosition","runIsIE","isHTML","parent","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","excludeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","innerWidth","innerHeight","offset","isFixed","parentElement","el","boundaries","getFixedPositionOffsetParent","getReferenceNode","boundariesElement","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","popper","padding","isPaddingNumber","placement","getBoundaries","rects","refRect","sortedAreas","Object","keys","map","getArea","sort","b","area","a","filteredAreas","filter","computedPlacement","key","variation","split","commonOffsetParent","x","marginBottom","y","marginRight","hash","replace","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","Array","prototype","find","arr","findIndex","cur","match","obj","modifiersToRun","ends","modifiers","slice","forEach","warn","fn","enabled","isFunction","data","state","isDestroyed","getReferenceOffsets","options","positionFixed","computeAutoPlacement","flip","originalPlacement","getPopperOffsets","position","runModifiers","isCreated","onUpdate","onCreate","some","name","prefixes","upperProp","charAt","toUpperCase","prefix","toCheck","style","isModifierEnabled","removeAttribute","willChange","getSupportedPropertyName","disableEventListeners","removeOnDestroy","removeChild","isBody","target","addEventListener","passive","push","updateBound","scrollElement","scrollParents","eventsEnabled","setupEventListeners","scheduleUpdate","removeEventListener","removeEventListeners","n","isNaN","isFinite","unit","isNumeric","value","attributes","setAttribute","instance","arrowElement","arrowStyles","round","floor","noRound","referenceWidth","popperWidth","isVertical","isVariation","horizontalToInteger","verticalToInteger","bothOddWidth","isFirefox","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","getRoundedOffsets","devicePixelRatio","prefixedProperty","invertTop","invertLeft","arrow","requesting","isRequired","requested","isModifierRequired","querySelector","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","validPlacements","placements","counter","index","concat","reverse","BEHAVIORS","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","clockwise","COUNTERCLOCKWISE","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariationByRef","flipVariations","flippedVariationByContent","flipVariationsByContent","flippedVariation","getOppositeVariation","str","size","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","mergeWithPrevious","op","reduce","toValue","index2","basePlacement","parseOffset","transformProp","popperStyles","transform","priority","check","escapeWithReference","shiftvariation","shiftOffsets","bound","hide","subtractLength","Popper","requestAnimationFrame","update","debounce","bind","Defaults","jquery","modifierOptions","onLoad","enableEventListeners","destroy","Utils","global","PopperUtils"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-popper-utils.js: |
    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.16.1
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      const window = element.ownerDocument.defaultView;
      const css = window.getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well
      const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);
      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent(getParentNode(element));
    }

    /**
     * Returns the reference node of the reference object, or the reference object itself.
     * @method
     * @memberof Popper.Utils
     * @param {Element|Object} reference - the reference element (the popper will be relative to this)
     * @returns {Element} parent
     */
    function getReferenceNode(reference) {
      return reference && reference.referenceNode ? reference.referenceNode : reference;
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

    const isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    const isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      const noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      let offsetParent = element.offsetParent || null;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      const nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TH, TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      const { nodeName } = element;
      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      const start = order ? element1 : element2;
      const end = order ? element2 : element1;

      // Get common ancestor container
      const range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      const { commonAncestorContainer } = range;

      // Both nodes are inside #document
      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      const element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element, side = 'top') {
      const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      const nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        const html = element.ownerDocument.documentElement;
        const scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element, subtract = false) {
      const scrollTop = getScroll(element, 'top');
      const scrollLeft = getScroll(element, 'left');
      const modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      const sideA = axis === 'x' ? 'Left' : 'Top';
      const sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles[`border${sideA}Width`]) + parseFloat(styles[`border${sideB}Width`]);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body[`offset${axis}`], body[`scroll${axis}`], html[`client${axis}`], html[`offset${axis}`], html[`scroll${axis}`], isIE(10) ? parseInt(html[`offset${axis}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`]) : 0);
    }

    function getWindowSizes(document) {
      const body = document.body;
      const html = document.documentElement;
      const computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      let rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          const scrollTop = getScroll(element, 'top');
          const scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      const result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
      const width = sizes.width || element.clientWidth || result.width;
      const height = sizes.height || element.clientHeight || result.height;

      let horizScrollbar = element.offsetWidth - width;
      let vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        const styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {
      const isIE10 = isIE(10);
      const isHTML = parent.nodeName === 'HTML';
      const childrenRect = getBoundingClientRect(children);
      const parentRect = getBoundingClientRect(parent);
      const scrollParent = getScrollParent(children);

      const styles = getStyleComputedProperty(parent);
      const borderTopWidth = parseFloat(styles.borderTopWidth);
      const borderLeftWidth = parseFloat(styles.borderLeftWidth);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      let offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        const marginTop = parseFloat(styles.marginTop);
        const marginLeft = parseFloat(styles.marginLeft);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {
      const html = element.ownerDocument.documentElement;
      const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      const width = Math.max(html.clientWidth, window.innerWidth || 0);
      const height = Math.max(html.clientHeight, window.innerHeight || 0);

      const scrollTop = !excludeScroll ? getScroll(html) : 0;
      const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      const offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width,
        height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      const nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      const parentNode = getParentNode(element);
      if (!parentNode) {
        return false;
      }
      return isFixed(parentNode);
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      let el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement, fixedPosition = false) {
      // NOTE: 1 DOM access here

      let boundaries = { top: 0, left: 0 };
      const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        let boundariesNode;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          const { height, width } = getWindowSizes(popper.ownerDocument);
          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      padding = padding || 0;
      const isPaddingNumber = typeof padding === 'number';
      boundaries.left += isPaddingNumber ? padding : padding.left || 0;
      boundaries.top += isPaddingNumber ? padding : padding.top || 0;
      boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
      boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

      return boundaries;
    }

    function getArea({ width, height }) {
      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement, padding = 0) {
      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      const boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      const rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      const sortedAreas = Object.keys(rects).map(key => _extends({
        key
      }, rects[key], {
        area: getArea(rects[key])
      })).sort((a, b) => b.area - a.area);

      const filteredAreas = sortedAreas.filter(({ width, height }) => width >= popper.clientWidth && height >= popper.clientHeight);

      const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      const variation = placement.split('-')[1];

      return computedPlacement + (variation ? `-${variation}` : '');
    }

    const timeoutDuration = function () {
      const longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
      for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
          return 1;
        }
      }
      return 0;
    }();

    function microtaskDebounce(fn) {
      let called = false;
      return () => {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(() => {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      let scheduled = false;
      return () => {
        if (!scheduled) {
          scheduled = true;
          setTimeout(() => {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    const supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(cur => cur[prop] === value);
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      const match = find(arr, obj => obj[prop] === value);
      return arr.indexOf(match);
    }

    /**
     * Get the position of the given element, relative to its offset parent
     * @method
     * @memberof Popper.Utils
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
    function getOffsetRect(element) {
      let elementRect;
      if (element.nodeName === 'HTML') {
        const { width, height } = getWindowSizes(element.ownerDocument);
        elementRect = {
          width,
          height,
          left: 0,
          top: 0
        };
      } else {
        elementRect = {
          width: element.offsetWidth,
          height: element.offsetHeight,
          left: element.offsetLeft,
          top: element.offsetTop
        };
      }

      // position
      return getClientRect(elementRect);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      const window = element.ownerDocument.defaultView;
      const styles = window.getComputedStyle(element);
      const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
      const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
      const result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      const popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      const popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      const isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      const mainSide = isHoriz ? 'top' : 'left';
      const secondarySide = isHoriz ? 'left' : 'top';
      const measurement = isHoriz ? 'height' : 'width';
      const secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference, fixedPosition = null) {
      const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      const upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (let i = 0; i < prefixes.length; i++) {
        const prefix = prefixes[i];
        const toCheck = prefix ? `${prefix}${upperProp}` : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
      const getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(({ name, enabled }) => enabled && name === modifierName);
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      const requesting = find(modifiers, ({ name }) => name === requestingName);

      const isRequired = !!requesting && modifiers.some(modifier => {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        const requesting = `\`${requestingName}\``;
        const requested = `\`${requestedName}\``;
        console.warn(`${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!`);
      }
      return isRequired;
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      const ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(target => {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      const modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(modifier => {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        const fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        const value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(prop => {
        let unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      const isBody = scrollParent.nodeName === 'BODY';
      const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      const scrollElement = getScrollParent(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    // This is here just for backward compatibility with versions lower than v1.10.3
    // you should import the utilities using named exports, if you want them all use:
    // ```
    // import * as PopperUtils from 'popper-utils';
    // ```
    // The default export will be removed in the next major version.
    var index = {
      computeAutoPlacement,
      debounce,
      findIndex,
      getBordersSize,
      getBoundaries,
      getBoundingClientRect,
      getClientRect,
      getOffsetParent,
      getOffsetRect,
      getOffsetRectRelativeToArbitraryNode,
      getOuterSizes,
      getParentNode,
      getPopperOffsets,
      getReferenceOffsets,
      getScroll,
      getScrollParent,
      getStyleComputedProperty,
      getSupportedPropertyName,
      getWindowSizes,
      isFixed,
      isFunction,
      isModifierEnabled,
      isModifierRequired,
      isNumeric,
      removeEventListeners,
      runModifiers,
      setAttributes,
      setStyles,
      setupEventListeners
    };

    export { computeAutoPlacement, debounce, findIndex, getBordersSize, getBoundaries, getBoundingClientRect, getClientRect, getOffsetParent, getOffsetRect, getOffsetRectRelativeToArbitraryNode, getOuterSizes, getParentNode, getPopperOffsets, getReferenceOffsets, getScroll, getScrollParent, getStyleComputedProperty, getSupportedPropertyName, getWindowSizes, isFixed, isFunction, isModifierEnabled, isModifierRequired, isNumeric, removeEventListeners, runModifiers, setAttributes, setStyles, setupEventListeners };
    export default index;
    //# sourceMappingURL=popper-utils.js.map
  admin-Public-Admin-plugins-popper-popper-utils.js.map: '{"version":3,"file":"popper-utils.js","sources":["../src/utils/getStyleComputedProperty.js","../src/utils/getParentNode.js","../src/utils/getScrollParent.js","../src/utils/getReferenceNode.js","../src/utils/isBrowser.js","../src/utils/isIE.js","../src/utils/getOffsetParent.js","../src/utils/isOffsetContainer.js","../src/utils/getRoot.js","../src/utils/findCommonOffsetParent.js","../src/utils/getScroll.js","../src/utils/includeScroll.js","../src/utils/getBordersSize.js","../src/utils/getWindowSizes.js","../src/utils/getClientRect.js","../src/utils/getBoundingClientRect.js","../src/utils/getOffsetRectRelativeToArbitraryNode.js","../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../src/utils/isFixed.js","../src/utils/getFixedPositionOffsetParent.js","../src/utils/getBoundaries.js","../src/utils/computeAutoPlacement.js","../src/utils/debounce.js","../src/utils/find.js","../src/utils/findIndex.js","../src/utils/getOffsetRect.js","../src/utils/getOuterSizes.js","../src/utils/getOppositePlacement.js","../src/utils/getPopperOffsets.js","../src/utils/getReferenceOffsets.js","../src/utils/getSupportedPropertyName.js","../src/utils/isFunction.js","../src/utils/isModifierEnabled.js","../src/utils/isModifierRequired.js","../src/utils/isNumeric.js","../src/utils/getWindow.js","../src/utils/removeEventListeners.js","../src/utils/runModifiers.js","../src/utils/setAttributes.js","../src/utils/setStyles.js","../src/utils/setupEventListeners.js","../src/utils/index.js"],"sourcesContent":["/**\n
    * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Eement} element\n * @argument {String} property\n */\nexport default
    function getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window =
    element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element,
    null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode
    or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element\n * @returns {Element} parent\n */\nexport default function
    getParentNode(element) {\n  if (element.nodeName === ''HTML'') {\n    return element;\n  }\n  return
    element.parentNode || element.host;\n}\n","import getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getParentNode from ''./getParentNode'';\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll`
    will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return
    document.body\n  }\n\n  switch (element.nodeName) {\n    case ''HTML'':\n    case
    ''BODY'':\n      return element.ownerDocument.body\n    case ''#document'':\n      return
    element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as
    well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if
    (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines
    if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n *
    @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n *
    @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nexport default function find(arr, check) {\n  // use native find if
    supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  //
    use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import
    find from ''./find'';\n\n/**\n * Return the index of the matching object\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop,
    value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex)
    {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find`
    + `indexOf` if `findIndex` isn''t supported\n  const match = find(arr, obj =>
    obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import getWindowSizes
    from ''./getWindowSizes'';\nimport getClientRect from ''./getClientRect'';\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nexport default function
    getOffsetRect(element) {\n  let elementRect;\n  if (element.nodeName === ''HTML'')
    {\n    const { width, height } = getWindowSizes(element.ownerDocument);\n    elementRect
    = {\n      width,\n      height,\n      left: 0,\n      top: 0,\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left:
    element.offsetLeft,\n      top: element.offsetTop,\n    };\n  }\n\n  // position\n  return
    getClientRect(elementRect);\n}\n","/**\n * Get the outer sizes of the given element
    (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Object} object containing width and height properties\n
    */\nexport default function getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const
    styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  const result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport
    default function getOppositePlacement(placement) {\n  const hash = { left: ''right'',
    right: ''left'', bottom: ''top'', top: ''bottom'' };\n  return placement.replace(/left|right|bottom|top/g,
    matched => hash[matched]);\n}\n","import getOuterSizes from ''./getOuterSizes'';\nimport
    getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n * Get offsets to
    the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split(''-'')[0];\n\n  //
    Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add
    position, width and height to our offsets object\n  const popperOffsets = {\n    width:
    popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the
    popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","/**\n * Check if the given variable
    is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck
    - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport
    default function isFunction(functionToCheck) {\n  const getType = {};\n  return
    (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === ''[object
    Function]''\n  );\n}\n","/**\n * Helper used to know if the given modifier is
    enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport
    default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({
    name, enabled }) => enabled && name === modifierName\n  );\n}\n","import find
    from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n *
    Get the window associated with the element\n * @argument {Element} element\n *
    @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getWindow from ''./getWindow'';\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nexport default function removeEventListeners(reference, state)
    {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import isFunction
    from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport getClientRect
    from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list of modifiers
    and run them in order,\n * each of them will then edit the data object.\n * @method\n
    * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n
    * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n
    */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun
    = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers,
    ''name'', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier[''function''])
    { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the attributes
    to\n * @argument {Object} styles\n * Object with a list of properties and values
    which will be applied to the element\n */\nexport default function setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","import getScrollParent from ''./getScrollParent'';\nimport
    getWindow from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName ===
    ''BODY'';\n  const target = isBody ? scrollParent.ownerDocument.defaultView :
    scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if
    (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    computeAutoPlacement from ''./computeAutoPlacement'';\nimport debounce from ''./debounce'';\nimport
    findIndex from ''./findIndex'';\nimport getBordersSize from ''./getBordersSize'';\nimport
    getBoundaries from ''./getBoundaries'';\nimport getBoundingClientRect from ''./getBoundingClientRect'';\nimport
    getClientRect from ''./getClientRect'';\nimport getOffsetParent from ''./getOffsetParent'';\nimport
    getOffsetRect from ''./getOffsetRect'';\nimport getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getOuterSizes from ''./getOuterSizes'';\nimport
    getParentNode from ''./getParentNode'';\nimport getPopperOffsets from ''./getPopperOffsets'';\nimport
    getReferenceOffsets from ''./getReferenceOffsets'';\nimport getScroll from ''./getScroll'';\nimport
    getScrollParent from ''./getScrollParent'';\nimport getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getSupportedPropertyName from ''./getSupportedPropertyName'';\nimport
    getWindowSizes from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport
    isFunction from ''./isFunction'';\nimport isModifierEnabled from ''./isModifierEnabled'';\nimport
    isModifierRequired from ''./isModifierRequired'';\nimport isNumeric from ''./isNumeric'';\nimport
    removeEventListeners from ''./removeEventListeners'';\nimport runModifiers from
    ''./runModifiers'';\nimport setAttributes from ''./setAttributes'';\nimport setStyles
    from ''./setStyles'';\nimport setupEventListeners from ''./setupEventListeners'';\n\n/**
    @namespace Popper.Utils */\nexport {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n\n//
    This is here just for backward compatibility with versions lower than v1.10.3\n//
    you should import the utilities using named exports, if you want them all use:\n//
    ```\n// import * as PopperUtils from ''popper-utils'';\n// ```\n// The default
    export will be removed in the next major version.\nexport default {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n"],"names":["getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","overflow","overflowX","overflowY","test","getReferenceNode","reference","referenceNode","navigator","isIE11","isBrowser","MSInputMethodContext","documentMode","isIE10","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","parseInt","getWindowSizes","getClientRect","offsets","width","height","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","isPaddingNumber","getArea","computeAutoPlacement","placement","refRect","rects","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","length","variation","split","timeoutDuration","longerTimeoutBrowsers","i","microtaskDebounce","fn","called","Promise","resolve","then","taskDebounce","scheduled","supportsMicroTasks","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","getOffsetRect","elementRect","offsetLeft","offsetTop","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","state","commonOffsetParent","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","isFunction","functionToCheck","getType","toString","call","isModifierEnabled","modifiers","modifierName","some","name","enabled","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","warn","isNumeric","n","isNaN","isFinite","getWindow","removeEventListeners","removeEventListener","updateBound","scrollParents","forEach","target","scrollElement","eventsEnabled","runModifiers","data","ends","modifiersToRun","undefined","setAttributes","attributes","setAttribute","removeAttribute","setStyles","unit","attachToScrollParents","event","callback","isBody","addEventListener","passive","push","setupEventListeners","options"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-popper-utils.min.js: |
    /*
     Copyright (C) Federico Zivolo 2020
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */function a(a,b){if(1!==a.nodeType)return[];const c=a.ownerDocument.defaultView,d=c.getComputedStyle(a,null);return b?d[b]:d}function b(a){return'HTML'===a.nodeName?a:a.parentNode||a.host}function c(d){if(!d)return document.body;switch(d.nodeName){case'HTML':case'BODY':return d.ownerDocument.body;case'#document':return d.body;}const{overflow:e,overflowX:f,overflowY:g}=a(d);return /(auto|scroll|overlay)/.test(e+g+f)?d:c(b(d))}function d(a){return a&&a.referenceNode?a.referenceNode:a}var e='undefined'!=typeof window&&'undefined'!=typeof document&&'undefined'!=typeof navigator;const f=e&&!!(window.MSInputMethodContext&&document.documentMode),g=e&&/MSIE 10/.test(navigator.userAgent);function h(a){return 11===a?f:10===a?g:f||g}function i(b){if(!b)return document.documentElement;const c=h(10)?document.body:null;let d=b.offsetParent||null;for(;d===c&&b.nextElementSibling;)d=(b=b.nextElementSibling).offsetParent;const e=d&&d.nodeName;return e&&'BODY'!==e&&'HTML'!==e?-1!==['TH','TD','TABLE'].indexOf(d.nodeName)&&'static'===a(d,'position')?i(d):d:b?b.ownerDocument.documentElement:document.documentElement}function j(a){const{nodeName:b}=a;return'BODY'!==b&&('HTML'===b||i(a.firstElementChild)===a)}function k(a){return null===a.parentNode?a:k(a.parentNode)}function l(a,b){if(!a||!a.nodeType||!b||!b.nodeType)return document.documentElement;const c=a.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_FOLLOWING,d=c?a:b,e=c?b:a,f=document.createRange();f.setStart(d,0),f.setEnd(e,0);const{commonAncestorContainer:g}=f;if(a!==g&&b!==g||d.contains(e))return j(g)?g:i(g);const h=k(a);return h.host?l(h.host,b):l(a,k(b).host)}function m(a,b='top'){const c='top'===b?'scrollTop':'scrollLeft',d=a.nodeName;if('BODY'===d||'HTML'===d){const b=a.ownerDocument.documentElement,d=a.ownerDocument.scrollingElement||b;return d[c]}return a[c]}function n(a,b,c=!1){const d=m(b,'top'),e=m(b,'left'),f=c?-1:1;return a.top+=d*f,a.bottom+=d*f,a.left+=e*f,a.right+=e*f,a}function o(a,b){const c='x'===b?'Left':'Top',d='Left'==c?'Right':'Bottom';return parseFloat(a[`border${c}Width`])+parseFloat(a[`border${d}Width`])}function p(a,b,c,d){return Math.max(b[`offset${a}`],b[`scroll${a}`],c[`client${a}`],c[`offset${a}`],c[`scroll${a}`],h(10)?parseInt(c[`offset${a}`])+parseInt(d[`margin${'Height'===a?'Top':'Left'}`])+parseInt(d[`margin${'Height'===a?'Bottom':'Right'}`]):0)}function q(a){const b=a.body,c=a.documentElement,d=h(10)&&getComputedStyle(c);return{height:p('Height',b,c,d),width:p('Width',b,c,d)}}var r=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a};function s(a){return r({},a,{right:a.left+a.width,bottom:a.top+a.height})}function t(b){let c={};try{if(h(10)){c=b.getBoundingClientRect();const a=m(b,'top'),d=m(b,'left');c.top+=a,c.left+=d,c.bottom+=a,c.right+=d}else c=b.getBoundingClientRect()}catch(a){}const d={left:c.left,top:c.top,width:c.right-c.left,height:c.bottom-c.top},e='HTML'===b.nodeName?q(b.ownerDocument):{},f=e.width||b.clientWidth||d.width,g=e.height||b.clientHeight||d.height;let i=b.offsetWidth-f,j=b.offsetHeight-g;if(i||j){const c=a(b);i-=o(c,'x'),j-=o(c,'y'),d.width-=i,d.height-=j}return s(d)}function u(b,d,e=!1){var f=Math.max;const g=h(10),i='HTML'===d.nodeName,j=t(b),k=t(d),l=c(b),m=a(d),o=parseFloat(m.borderTopWidth),p=parseFloat(m.borderLeftWidth);e&&i&&(k.top=f(k.top,0),k.left=f(k.left,0));let q=s({top:j.top-k.top-o,left:j.left-k.left-p,width:j.width,height:j.height});if(q.marginTop=0,q.marginLeft=0,!g&&i){const a=parseFloat(m.marginTop),b=parseFloat(m.marginLeft);q.top-=o-a,q.bottom-=o-a,q.left-=p-b,q.right-=p-b,q.marginTop=a,q.marginLeft=b}return(g&&!e?d.contains(l):d===l&&'BODY'!==l.nodeName)&&(q=n(q,d)),q}function v(a,b=!1){var c=Math.max;const d=a.ownerDocument.documentElement,e=u(a,d),f=c(d.clientWidth,window.innerWidth||0),g=c(d.clientHeight,window.innerHeight||0),h=b?0:m(d),i=b?0:m(d,'left'),j={top:h-e.top+e.marginTop,left:i-e.left+e.marginLeft,width:f,height:g};return s(j)}function w(c){const d=c.nodeName;if('BODY'===d||'HTML'===d)return!1;if('fixed'===a(c,'position'))return!0;const e=b(c);return!!e&&w(e)}function x(b){if(!b||!b.parentElement||h())return document.documentElement;let c=b.parentElement;for(;c&&'none'===a(c,'transform');)c=c.parentElement;return c||document.documentElement}function y(a,e,f,g,h=!1){let i={top:0,left:0};const j=h?x(a):l(a,d(e));if('viewport'===g)i=v(j,h);else{let d;'scrollParent'===g?(d=c(b(e)),'BODY'===d.nodeName&&(d=a.ownerDocument.documentElement)):'window'===g?d=a.ownerDocument.documentElement:d=g;const f=u(d,j,h);if('HTML'===d.nodeName&&!w(j)){const{height:b,width:c}=q(a.ownerDocument);i.top+=f.top-f.marginTop,i.bottom=b+f.top,i.left+=f.left-f.marginLeft,i.right=c+f.left}else i=f}f=f||0;const k='number'==typeof f;return i.left+=k?f:f.left||0,i.top+=k?f:f.top||0,i.right-=k?f:f.right||0,i.bottom-=k?f:f.bottom||0,i}function z({width:a,height:b}){return a*b}function A(a,b,c,d,e,f=0){if(-1===a.indexOf('auto'))return a;const g=y(c,d,f,e),h={top:{width:g.width,height:b.top-g.top},right:{width:g.right-b.right,height:g.height},bottom:{width:g.width,height:g.bottom-b.bottom},left:{width:b.left-g.left,height:g.height}},i=Object.keys(h).map((a)=>r({key:a},h[a],{area:z(h[a])})).sort((c,a)=>a.area-c.area),j=i.filter(({width:a,height:b})=>a>=c.clientWidth&&b>=c.clientHeight),k=0<j.length?j[0].key:i[0].key,l=a.split('-')[1];return k+(l?`-${l}`:'')}const B=function(){const a=['Edge','Trident','Firefox'];for(let b=0;b<a.length;b+=1)if(e&&0<=navigator.userAgent.indexOf(a[b]))return 1;return 0}();function C(a){let b=!1;return()=>{b||(b=!0,window.Promise.resolve().then(()=>{b=!1,a()}))}}function D(a){let b=!1;return()=>{b||(b=!0,setTimeout(()=>{b=!1,a()},B))}}const E=e&&window.Promise;var F=E?C:D;function G(a,b){return Array.prototype.find?a.find(b):a.filter(b)[0]}function H(a,b,c){if(Array.prototype.findIndex)return a.findIndex((a)=>a[b]===c);const d=G(a,(a)=>a[b]===c);return a.indexOf(d)}function I(a){let b;if('HTML'===a.nodeName){const{width:c,height:d}=q(a.ownerDocument);b={width:c,height:d,left:0,top:0}}else b={width:a.offsetWidth,height:a.offsetHeight,left:a.offsetLeft,top:a.offsetTop};return s(b)}function J(a){const b=a.ownerDocument.defaultView,c=b.getComputedStyle(a),d=parseFloat(c.marginTop||0)+parseFloat(c.marginBottom||0),e=parseFloat(c.marginLeft||0)+parseFloat(c.marginRight||0),f={width:a.offsetWidth+e,height:a.offsetHeight+d};return f}function K(a){const b={left:'right',right:'left',bottom:'top',top:'bottom'};return a.replace(/left|right|bottom|top/g,(a)=>b[a])}function L(a,b,c){c=c.split('-')[0];const d=J(a),e={width:d.width,height:d.height},f=-1!==['right','left'].indexOf(c),g=f?'top':'left',h=f?'left':'top',i=f?'height':'width',j=f?'width':'height';return e[g]=b[g]+b[i]/2-d[i]/2,e[h]=c===h?b[h]-d[j]:b[K(h)],e}function M(a,b,c,e=null){const f=e?x(b):l(b,d(c));return u(c,f,e)}function N(a){const b=[!1,'ms','Webkit','Moz','O'],c=a.charAt(0).toUpperCase()+a.slice(1);for(let d=0;d<b.length;d++){const e=b[d],f=e?`${e}${c}`:a;if('undefined'!=typeof document.body.style[f])return f}return null}function O(a){return a&&'[object Function]'==={}.toString.call(a)}function P(a,b){return a.some(({name:a,enabled:c})=>c&&a===b)}function Q(a,b,c){const d=G(a,({name:a})=>a===b),e=!!d&&a.some((a)=>a.name===c&&a.enabled&&a.order<d.order);if(!e){const a=`\`${b}\``,d=`\`${c}\``;console.warn(`${d} modifier is required by ${a} modifier in order to work, be sure to include it before ${a}!`)}return e}function R(a){return''!==a&&!isNaN(parseFloat(a))&&isFinite(a)}function S(a){const b=a.ownerDocument;return b?b.defaultView:window}function T(a,b){return S(a).removeEventListener('resize',b.updateBound),b.scrollParents.forEach((a)=>{a.removeEventListener('scroll',b.updateBound)}),b.updateBound=null,b.scrollParents=[],b.scrollElement=null,b.eventsEnabled=!1,b}function U(a,b,c){const d=void 0===c?a:a.slice(0,H(a,'name',c));return d.forEach((a)=>{a['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');const c=a['function']||a.fn;a.enabled&&O(c)&&(b.offsets.popper=s(b.offsets.popper),b.offsets.reference=s(b.offsets.reference),b=c(b,a))}),b}function V(a,b){Object.keys(b).forEach(function(c){const d=b[c];!1===d?a.removeAttribute(c):a.setAttribute(c,b[c])})}function W(a,b){Object.keys(b).forEach((c)=>{let d='';-1!==['width','height','top','right','bottom','left'].indexOf(c)&&R(b[c])&&(d='px'),a.style[c]=b[c]+d})}function X(a,b,d,e){const f='BODY'===a.nodeName,g=f?a.ownerDocument.defaultView:a;g.addEventListener(b,d,{passive:!0}),f||X(c(g.parentNode),b,d,e),e.push(g)}function Y(a,b,d,e){d.updateBound=e,S(a).addEventListener('resize',d.updateBound,{passive:!0});const f=c(a);return X(f,'scroll',d.updateBound,d.scrollParents),d.scrollElement=f,d.eventsEnabled=!0,d}var Z={computeAutoPlacement:A,debounce:F,findIndex:H,getBordersSize:o,getBoundaries:y,getBoundingClientRect:t,getClientRect:s,getOffsetParent:i,getOffsetRect:I,getOffsetRectRelativeToArbitraryNode:u,getOuterSizes:J,getParentNode:b,getPopperOffsets:L,getReferenceOffsets:M,getScroll:m,getScrollParent:c,getStyleComputedProperty:a,getSupportedPropertyName:N,getWindowSizes:q,isFixed:w,isFunction:O,isModifierEnabled:P,isModifierRequired:Q,isNumeric:R,removeEventListeners:T,runModifiers:U,setAttributes:V,setStyles:W,setupEventListeners:Y};export{A as computeAutoPlacement,F as debounce,H as findIndex,o as getBordersSize,y as getBoundaries,t as getBoundingClientRect,s as getClientRect,i as getOffsetParent,I as getOffsetRect,u as getOffsetRectRelativeToArbitraryNode,J as getOuterSizes,b as getParentNode,L as getPopperOffsets,M as getReferenceOffsets,m as getScroll,c as getScrollParent,a as getStyleComputedProperty,N as getSupportedPropertyName,q as getWindowSizes,w as isFixed,O as isFunction,P as isModifierEnabled,Q as isModifierRequired,R as isNumeric,T as removeEventListeners,U as runModifiers,V as setAttributes,W as setStyles,Y as setupEventListeners};export default Z;
    //# sourceMappingURL=popper-utils.min.js.map
  admin-Public-Admin-plugins-popper-popper-utils.min.js.map: '{"version":3,"file":"popper-utils.min.js","sources":["../src/utils/getStyleComputedProperty.js","../src/utils/getParentNode.js","../src/utils/getScrollParent.js","../src/utils/getReferenceNode.js","../src/utils/isBrowser.js","../src/utils/isIE.js","../src/utils/getOffsetParent.js","../src/utils/isOffsetContainer.js","../src/utils/getRoot.js","../src/utils/findCommonOffsetParent.js","../src/utils/getScroll.js","../src/utils/includeScroll.js","../src/utils/getBordersSize.js","../src/utils/getWindowSizes.js","../src/utils/getClientRect.js","../src/utils/getBoundingClientRect.js","../src/utils/getOffsetRectRelativeToArbitraryNode.js","../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../src/utils/isFixed.js","../src/utils/getFixedPositionOffsetParent.js","../src/utils/getBoundaries.js","../src/utils/computeAutoPlacement.js","../src/utils/debounce.js","../src/utils/find.js","../src/utils/findIndex.js","../src/utils/getOffsetRect.js","../src/utils/getOuterSizes.js","../src/utils/getOppositePlacement.js","../src/utils/getPopperOffsets.js","../src/utils/getReferenceOffsets.js","../src/utils/getSupportedPropertyName.js","../src/utils/isFunction.js","../src/utils/isModifierEnabled.js","../src/utils/isModifierRequired.js","../src/utils/isNumeric.js","../src/utils/getWindow.js","../src/utils/removeEventListeners.js","../src/utils/runModifiers.js","../src/utils/setAttributes.js","../src/utils/setStyles.js","../src/utils/setupEventListeners.js","../src/utils/index.js"],"sourcesContent":["/**\n
    * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Eement} element\n * @argument {String} property\n */\nexport default
    function getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window =
    element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element,
    null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode
    or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element\n * @returns {Element} parent\n */\nexport default function
    getParentNode(element) {\n  if (element.nodeName === ''HTML'') {\n    return element;\n  }\n  return
    element.parentNode || element.host;\n}\n","import getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getParentNode from ''./getParentNode'';\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll`
    will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return
    document.body\n  }\n\n  switch (element.nodeName) {\n    case ''HTML'':\n    case
    ''BODY'':\n      return element.ownerDocument.body\n    case ''#document'':\n      return
    element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as
    well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if
    (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines
    if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n *
    @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n *
    @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nexport default function find(arr, check) {\n  // use native find if
    supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  //
    use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import
    find from ''./find'';\n\n/**\n * Return the index of the matching object\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop,
    value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex)
    {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find`
    + `indexOf` if `findIndex` isn''t supported\n  const match = find(arr, obj =>
    obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import getWindowSizes
    from ''./getWindowSizes'';\nimport getClientRect from ''./getClientRect'';\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nexport default function
    getOffsetRect(element) {\n  let elementRect;\n  if (element.nodeName === ''HTML'')
    {\n    const { width, height } = getWindowSizes(element.ownerDocument);\n    elementRect
    = {\n      width,\n      height,\n      left: 0,\n      top: 0,\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left:
    element.offsetLeft,\n      top: element.offsetTop,\n    };\n  }\n\n  // position\n  return
    getClientRect(elementRect);\n}\n","/**\n * Get the outer sizes of the given element
    (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Object} object containing width and height properties\n
    */\nexport default function getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const
    styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  const result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport
    default function getOppositePlacement(placement) {\n  const hash = { left: ''right'',
    right: ''left'', bottom: ''top'', top: ''bottom'' };\n  return placement.replace(/left|right|bottom|top/g,
    matched => hash[matched]);\n}\n","import getOuterSizes from ''./getOuterSizes'';\nimport
    getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n * Get offsets to
    the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split(''-'')[0];\n\n  //
    Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add
    position, width and height to our offsets object\n  const popperOffsets = {\n    width:
    popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the
    popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","/**\n * Check if the given variable
    is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck
    - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport
    default function isFunction(functionToCheck) {\n  const getType = {};\n  return
    (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === ''[object
    Function]''\n  );\n}\n","/**\n * Helper used to know if the given modifier is
    enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport
    default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({
    name, enabled }) => enabled && name === modifierName\n  );\n}\n","import find
    from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n *
    Get the window associated with the element\n * @argument {Element} element\n *
    @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getWindow from ''./getWindow'';\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nexport default function removeEventListeners(reference, state)
    {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import isFunction
    from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport getClientRect
    from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list of modifiers
    and run them in order,\n * each of them will then edit the data object.\n * @method\n
    * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n
    * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n
    */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun
    = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers,
    ''name'', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier[''function''])
    { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the attributes
    to\n * @argument {Object} styles\n * Object with a list of properties and values
    which will be applied to the element\n */\nexport default function setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","import getScrollParent from ''./getScrollParent'';\nimport
    getWindow from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName ===
    ''BODY'';\n  const target = isBody ? scrollParent.ownerDocument.defaultView :
    scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if
    (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    computeAutoPlacement from ''./computeAutoPlacement'';\nimport debounce from ''./debounce'';\nimport
    findIndex from ''./findIndex'';\nimport getBordersSize from ''./getBordersSize'';\nimport
    getBoundaries from ''./getBoundaries'';\nimport getBoundingClientRect from ''./getBoundingClientRect'';\nimport
    getClientRect from ''./getClientRect'';\nimport getOffsetParent from ''./getOffsetParent'';\nimport
    getOffsetRect from ''./getOffsetRect'';\nimport getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getOuterSizes from ''./getOuterSizes'';\nimport
    getParentNode from ''./getParentNode'';\nimport getPopperOffsets from ''./getPopperOffsets'';\nimport
    getReferenceOffsets from ''./getReferenceOffsets'';\nimport getScroll from ''./getScroll'';\nimport
    getScrollParent from ''./getScrollParent'';\nimport getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getSupportedPropertyName from ''./getSupportedPropertyName'';\nimport
    getWindowSizes from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport
    isFunction from ''./isFunction'';\nimport isModifierEnabled from ''./isModifierEnabled'';\nimport
    isModifierRequired from ''./isModifierRequired'';\nimport isNumeric from ''./isNumeric'';\nimport
    removeEventListeners from ''./removeEventListeners'';\nimport runModifiers from
    ''./runModifiers'';\nimport setAttributes from ''./setAttributes'';\nimport setStyles
    from ''./setStyles'';\nimport setupEventListeners from ''./setupEventListeners'';\n\n/**
    @namespace Popper.Utils */\nexport {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n\n//
    This is here just for backward compatibility with versions lower than v1.10.3\n//
    you should import the utilities using named exports, if you want them all use:\n//
    ```\n// import * as PopperUtils from ''popper-utils'';\n// ```\n// The default
    export will be removed in the next major version.\nexport default {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n"],"names":["element","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","property","nodeName","parentNode","host","document","body","overflow","overflowX","overflowY","getStyleComputedProperty","test","getScrollParent","getParentNode","reference","referenceNode","navigator","isIE10","isBrowser","userAgent","version","isIE11","documentElement","noOffsetParent","isIE","offsetParent","nextElementSibling","indexOf","getOffsetParent","firstElementChild","node","getRoot","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","scrollingElement","subtract","scrollTop","getScroll","scrollLeft","modifier","top","bottom","left","right","sideA","axis","sideB","parseFloat","styles","Math","max","parseInt","computedStyle","getSize","offsets","width","height","rect","getBoundingClientRect","result","sizes","getWindowSizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getBordersSize","getClientRect","fixedPosition","runIsIE","isHTML","parent","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","excludeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","innerWidth","innerHeight","offset","isFixed","parentElement","el","boundaries","getFixedPositionOffsetParent","getReferenceNode","boundariesElement","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","popper","padding","isPaddingNumber","placement","getBoundaries","rects","refRect","sortedAreas","Object","keys","map","key","getArea","sort","b","area","a","filteredAreas","filter","computedPlacement","length","variation","split","timeoutDuration","longerTimeoutBrowsers","i","called","Promise","resolve","then","scheduled","supportsMicroTasks","Array","prototype","find","arr","findIndex","cur","match","obj","elementRect","offsetLeft","offsetTop","x","marginBottom","y","marginRight","hash","replace","matched","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","commonOffsetParent","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","functionToCheck","getType","toString","call","modifiers","some","name","enabled","requesting","isRequired","requested","warn","n","isNaN","isFinite","removeEventListener","state","updateBound","scrollParents","forEach","target","scrollElement","eventsEnabled","modifiersToRun","ends","fn","isFunction","data","value","attributes","removeAttribute","setAttribute","prop","unit","isNumeric","isBody","addEventListener","passive","push"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-popper.js: |
    /**!
     * @fileOverview Kickass library to create and place poppers near their reference elements.
     * @version 1.16.1
     * @license
     * Copyright (c) 2016 Federico Zivolo and contributors
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

    const timeoutDuration = function () {
      const longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
      for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
          return 1;
        }
      }
      return 0;
    }();

    function microtaskDebounce(fn) {
      let called = false;
      return () => {
        if (called) {
          return;
        }
        called = true;
        window.Promise.resolve().then(() => {
          called = false;
          fn();
        });
      };
    }

    function taskDebounce(fn) {
      let scheduled = false;
      return () => {
        if (!scheduled) {
          scheduled = true;
          setTimeout(() => {
            scheduled = false;
            fn();
          }, timeoutDuration);
        }
      };
    }

    const supportsMicroTasks = isBrowser && window.Promise;

    /**
    * Create a debounced version of a method, that's asynchronously deferred
    * but called in the minimum time possible.
    *
    * @method
    * @memberof Popper.Utils
    * @argument {Function} fn
    * @returns {Function}
    */
    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

    /**
     * Check if the given variable is a function
     * @method
     * @memberof Popper.Utils
     * @argument {Any} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
      const getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get CSS computed property of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
      if (element.nodeType !== 1) {
        return [];
      }
      // NOTE: 1 DOM access here
      const window = element.ownerDocument.defaultView;
      const css = window.getComputedStyle(element, null);
      return property ? css[property] : css;
    }

    /**
     * Returns the parentNode or the host of the element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} parent
     */
    function getParentNode(element) {
      if (element.nodeName === 'HTML') {
        return element;
      }
      return element.parentNode || element.host;
    }

    /**
     * Returns the scrolling parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} scroll parent
     */
    function getScrollParent(element) {
      // Return body, `getScroll` will take care to get the correct `scrollTop` from it
      if (!element) {
        return document.body;
      }

      switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
          return element.ownerDocument.body;
        case '#document':
          return element.body;
      }

      // Firefox want us to check `-x` and `-y` variations as well
      const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);
      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
      }

      return getScrollParent(getParentNode(element));
    }

    /**
     * Returns the reference node of the reference object, or the reference object itself.
     * @method
     * @memberof Popper.Utils
     * @param {Element|Object} reference - the reference element (the popper will be relative to this)
     * @returns {Element} parent
     */
    function getReferenceNode(reference) {
      return reference && reference.referenceNode ? reference.referenceNode : reference;
    }

    const isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    const isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

    /**
     * Determines if the browser is Internet Explorer
     * @method
     * @memberof Popper.Utils
     * @param {Number} version to check
     * @returns {Boolean} isIE
     */
    function isIE(version) {
      if (version === 11) {
        return isIE11;
      }
      if (version === 10) {
        return isIE10;
      }
      return isIE11 || isIE10;
    }

    /**
     * Returns the offset parent of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
      if (!element) {
        return document.documentElement;
      }

      const noOffsetParent = isIE(10) ? document.body : null;

      // NOTE: 1 DOM access here
      let offsetParent = element.offsetParent || null;
      // Skip hidden elements which don't have an offsetParent
      while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
      }

      const nodeName = offsetParent && offsetParent.nodeName;

      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
      }

      // .offsetParent will return the closest TH, TD or TABLE in case
      // no offsetParent is present, I hate this job...
      if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
      }

      return offsetParent;
    }

    function isOffsetContainer(element) {
      const { nodeName } = element;
      if (nodeName === 'BODY') {
        return false;
      }
      return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
    }

    /**
     * Finds the root node (document, shadowDOM root) of the given element
     * @method
     * @memberof Popper.Utils
     * @argument {Element} node
     * @returns {Element} root node
     */
    function getRoot(node) {
      if (node.parentNode !== null) {
        return getRoot(node.parentNode);
      }

      return node;
    }

    /**
     * Finds the offset parent common to the two provided nodes
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element1
     * @argument {Element} element2
     * @returns {Element} common offset parent
     */
    function findCommonOffsetParent(element1, element2) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
      }

      // Here we make sure to give as "start" the element that comes first in the DOM
      const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
      const start = order ? element1 : element2;
      const end = order ? element2 : element1;

      // Get common ancestor container
      const range = document.createRange();
      range.setStart(start, 0);
      range.setEnd(end, 0);
      const { commonAncestorContainer } = range;

      // Both nodes are inside #document
      if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
          return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
      }

      // one of the nodes is inside shadowDOM, find which one
      const element1root = getRoot(element1);
      if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
      } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
      }
    }

    /**
     * Gets the scroll value of the given element in the given side (top and left)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {String} side `top` or `left`
     * @returns {number} amount of scrolled pixels
     */
    function getScroll(element, side = 'top') {
      const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
      const nodeName = element.nodeName;

      if (nodeName === 'BODY' || nodeName === 'HTML') {
        const html = element.ownerDocument.documentElement;
        const scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
      }

      return element[upperSide];
    }

    /*
     * Sum or subtract the element scroll values (left and top) from a given rect object
     * @method
     * @memberof Popper.Utils
     * @param {Object} rect - Rect object you want to change
     * @param {HTMLElement} element - The element from the function reads the scroll values
     * @param {Boolean} subtract - set to true if you want to subtract the scroll values
     * @return {Object} rect - The modifier rect object
     */
    function includeScroll(rect, element, subtract = false) {
      const scrollTop = getScroll(element, 'top');
      const scrollLeft = getScroll(element, 'left');
      const modifier = subtract ? -1 : 1;
      rect.top += scrollTop * modifier;
      rect.bottom += scrollTop * modifier;
      rect.left += scrollLeft * modifier;
      rect.right += scrollLeft * modifier;
      return rect;
    }

    /*
     * Helper to detect borders of a given element
     * @method
     * @memberof Popper.Utils
     * @param {CSSStyleDeclaration} styles
     * Result of `getStyleComputedProperty` on the given element
     * @param {String} axis - `x` or `y`
     * @return {number} borders - The borders size of the given axis
     */

    function getBordersSize(styles, axis) {
      const sideA = axis === 'x' ? 'Left' : 'Top';
      const sideB = sideA === 'Left' ? 'Right' : 'Bottom';

      return parseFloat(styles[`border${sideA}Width`]) + parseFloat(styles[`border${sideB}Width`]);
    }

    function getSize(axis, body, html, computedStyle) {
      return Math.max(body[`offset${axis}`], body[`scroll${axis}`], html[`client${axis}`], html[`offset${axis}`], html[`scroll${axis}`], isIE(10) ? parseInt(html[`offset${axis}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`]) : 0);
    }

    function getWindowSizes(document) {
      const body = document.body;
      const html = document.documentElement;
      const computedStyle = isIE(10) && getComputedStyle(html);

      return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
      };
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * Given element offsets, generate an output similar to getBoundingClientRect
     * @method
     * @memberof Popper.Utils
     * @argument {Object} offsets
     * @returns {Object} ClientRect like output
     */
    function getClientRect(offsets) {
      return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
      });
    }

    /**
     * Get bounding client rect of given element
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
      let rect = {};

      // IE10 10 FIX: Please, don't ask, the element isn't
      // considered in DOM in some circumstances...
      // This isn't reproducible in IE10 compatibility mode of IE11
      try {
        if (isIE(10)) {
          rect = element.getBoundingClientRect();
          const scrollTop = getScroll(element, 'top');
          const scrollLeft = getScroll(element, 'left');
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom += scrollTop;
          rect.right += scrollLeft;
        } else {
          rect = element.getBoundingClientRect();
        }
      } catch (e) {}

      const result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };

      // subtract scrollbar size from sizes
      const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
      const width = sizes.width || element.clientWidth || result.width;
      const height = sizes.height || element.clientHeight || result.height;

      let horizScrollbar = element.offsetWidth - width;
      let vertScrollbar = element.offsetHeight - height;

      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
      // we make this check conditional for performance reasons
      if (horizScrollbar || vertScrollbar) {
        const styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
      }

      return getClientRect(result);
    }

    function getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {
      const isIE10 = isIE(10);
      const isHTML = parent.nodeName === 'HTML';
      const childrenRect = getBoundingClientRect(children);
      const parentRect = getBoundingClientRect(parent);
      const scrollParent = getScrollParent(children);

      const styles = getStyleComputedProperty(parent);
      const borderTopWidth = parseFloat(styles.borderTopWidth);
      const borderLeftWidth = parseFloat(styles.borderLeftWidth);

      // In cases where the parent is fixed, we must ignore negative scroll in offset calc
      if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
      }
      let offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
      });
      offsets.marginTop = 0;
      offsets.marginLeft = 0;

      // Subtract margins of documentElement in case it's being used as parent
      // we do this only on HTML because it's the only element that behaves
      // differently when margins are applied to it. The margins are included in
      // the box of the documentElement, in the other cases not.
      if (!isIE10 && isHTML) {
        const marginTop = parseFloat(styles.marginTop);
        const marginLeft = parseFloat(styles.marginLeft);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
      }

      if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
      }

      return offsets;
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {
      const html = element.ownerDocument.documentElement;
      const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
      const width = Math.max(html.clientWidth, window.innerWidth || 0);
      const height = Math.max(html.clientHeight, window.innerHeight || 0);

      const scrollTop = !excludeScroll ? getScroll(html) : 0;
      const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

      const offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width,
        height
      };

      return getClientRect(offset);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
      const nodeName = element.nodeName;
      if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
      }
      if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
      }
      const parentNode = getParentNode(element);
      if (!parentNode) {
        return false;
      }
      return isFixed(parentNode);
    }

    /**
     * Finds the first parent of an element that has a transformed property defined
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Element} first transformed parent or documentElement
     */

    function getFixedPositionOffsetParent(element) {
      // This check is needed to avoid errors in case one of the elements isn't defined for any reason
      if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
      }
      let el = element.parentElement;
      while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
      }
      return el || document.documentElement;
    }

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper.Utils
     * @param {HTMLElement} popper
     * @param {HTMLElement} reference
     * @param {number} padding
     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
     * @param {Boolean} fixedPosition - Is in fixed position mode
     * @returns {Object} Coordinates of the boundaries
     */
    function getBoundaries(popper, reference, padding, boundariesElement, fixedPosition = false) {
      // NOTE: 1 DOM access here

      let boundaries = { top: 0, left: 0 };
      const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

      // Handle viewport case
      if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
      } else {
        // Handle other cases based on DOM element used as boundaries
        let boundariesNode;
        if (boundariesElement === 'scrollParent') {
          boundariesNode = getScrollParent(getParentNode(reference));
          if (boundariesNode.nodeName === 'BODY') {
            boundariesNode = popper.ownerDocument.documentElement;
          }
        } else if (boundariesElement === 'window') {
          boundariesNode = popper.ownerDocument.documentElement;
        } else {
          boundariesNode = boundariesElement;
        }

        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
          const { height, width } = getWindowSizes(popper.ownerDocument);
          boundaries.top += offsets.top - offsets.marginTop;
          boundaries.bottom = height + offsets.top;
          boundaries.left += offsets.left - offsets.marginLeft;
          boundaries.right = width + offsets.left;
        } else {
          // for all the other DOM elements, this one is good
          boundaries = offsets;
        }
      }

      // Add paddings
      padding = padding || 0;
      const isPaddingNumber = typeof padding === 'number';
      boundaries.left += isPaddingNumber ? padding : padding.left || 0;
      boundaries.top += isPaddingNumber ? padding : padding.top || 0;
      boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
      boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

      return boundaries;
    }

    function getArea({ width, height }) {
      return width * height;
    }

    /**
     * Utility used to transform the `auto` placement to the placement with more
     * available space.
     * @method
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement, padding = 0) {
      if (placement.indexOf('auto') === -1) {
        return placement;
      }

      const boundaries = getBoundaries(popper, reference, padding, boundariesElement);

      const rects = {
        top: {
          width: boundaries.width,
          height: refRect.top - boundaries.top
        },
        right: {
          width: boundaries.right - refRect.right,
          height: boundaries.height
        },
        bottom: {
          width: boundaries.width,
          height: boundaries.bottom - refRect.bottom
        },
        left: {
          width: refRect.left - boundaries.left,
          height: boundaries.height
        }
      };

      const sortedAreas = Object.keys(rects).map(key => _extends({
        key
      }, rects[key], {
        area: getArea(rects[key])
      })).sort((a, b) => b.area - a.area);

      const filteredAreas = sortedAreas.filter(({ width, height }) => width >= popper.clientWidth && height >= popper.clientHeight);

      const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

      const variation = placement.split('-')[1];

      return computedPlacement + (variation ? `-${variation}` : '');
    }

    /**
     * Get offsets to the reference element
     * @method
     * @memberof Popper.Utils
     * @param {Object} state
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @param {Element} fixedPosition - is in fixed position mode
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    function getReferenceOffsets(state, popper, reference, fixedPosition = null) {
      const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
      return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
    }

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
      const window = element.ownerDocument.defaultView;
      const styles = window.getComputedStyle(element);
      const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
      const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
      const result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
      };
      return result;
    }

    /**
     * Get the opposite placement of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
      const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
      return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);
    }

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper.Utils
     * @param {Object} position - CSS position the Popper will get applied
     * @param {HTMLElement} popper - the popper element
     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
     * @param {String} placement - one of the valid placement options
     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
      placement = placement.split('-')[0];

      // Get popper node sizes
      const popperRect = getOuterSizes(popper);

      // Add position, width and height to our offsets object
      const popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
      };

      // depending by the popper placement we have to compute its offsets slightly differently
      const isHoriz = ['right', 'left'].indexOf(placement) !== -1;
      const mainSide = isHoriz ? 'top' : 'left';
      const secondarySide = isHoriz ? 'left' : 'top';
      const measurement = isHoriz ? 'height' : 'width';
      const secondaryMeasurement = !isHoriz ? 'height' : 'width';

      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
      if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
      } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
      }

      return popperOffsets;
    }

    /**
     * Mimics the `find` method of Array
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function find(arr, check) {
      // use native find if supported
      if (Array.prototype.find) {
        return arr.find(check);
      }

      // use `filter` to obtain the same behavior of `find`
      return arr.filter(check)[0];
    }

    /**
     * Return the index of the matching object
     * @method
     * @memberof Popper.Utils
     * @argument {Array} arr
     * @argument prop
     * @argument value
     * @returns index or -1
     */
    function findIndex(arr, prop, value) {
      // use native findIndex if supported
      if (Array.prototype.findIndex) {
        return arr.findIndex(cur => cur[prop] === value);
      }

      // use `find` + `indexOf` if `findIndex` isn't supported
      const match = find(arr, obj => obj[prop] === value);
      return arr.indexOf(match);
    }

    /**
     * Loop trough the list of modifiers and run them in order,
     * each of them will then edit the data object.
     * @method
     * @memberof Popper.Utils
     * @param {dataObject} data
     * @param {Array} modifiers
     * @param {String} ends - Optional modifier name used as stopper
     * @returns {dataObject}
     */
    function runModifiers(modifiers, data, ends) {
      const modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

      modifiersToRun.forEach(modifier => {
        if (modifier['function']) {
          // eslint-disable-line dot-notation
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        const fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction(fn)) {
          // Add properties to offsets to make them a complete clientRect object
          // we do this before each modifier to make sure the previous one doesn't
          // mess with these values
          data.offsets.popper = getClientRect(data.offsets.popper);
          data.offsets.reference = getClientRect(data.offsets.reference);

          data = fn(data, modifier);
        }
      });

      return data;
    }

    /**
     * Updates the position of the popper, computing the new offsets and applying
     * the new style.<br />
     * Prefer `scheduleUpdate` over `update` because of performance reasons.
     * @method
     * @memberof Popper
     */
    function update() {
      // if popper is destroyed, don't perform any further update
      if (this.state.isDestroyed) {
        return;
      }

      let data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
      };

      // compute reference element offsets
      data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

      // store the computed placement inside `originalPlacement`
      data.originalPlacement = data.placement;

      data.positionFixed = this.options.positionFixed;

      // compute the popper offsets
      data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

      data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

      // run the modifiers
      data = runModifiers(this.modifiers, data);

      // the first `update` will call `onCreate` callback
      // the other ones will call `onUpdate` callback
      if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
      } else {
        this.options.onUpdate(data);
      }
    }

    /**
     * Helper used to know if the given modifier is enabled.
     * @method
     * @memberof Popper.Utils
     * @returns {Boolean}
     */
    function isModifierEnabled(modifiers, modifierName) {
      return modifiers.some(({ name, enabled }) => enabled && name === modifierName);
    }

    /**
     * Get the prefixed supported property name
     * @method
     * @memberof Popper.Utils
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
     */
    function getSupportedPropertyName(property) {
      const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
      const upperProp = property.charAt(0).toUpperCase() + property.slice(1);

      for (let i = 0; i < prefixes.length; i++) {
        const prefix = prefixes[i];
        const toCheck = prefix ? `${prefix}${upperProp}` : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
          return toCheck;
        }
      }
      return null;
    }

    /**
     * Destroys the popper.
     * @method
     * @memberof Popper
     */
    function destroy() {
      this.state.isDestroyed = true;

      // touch DOM only if `applyStyle` modifier is enabled
      if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
      }

      this.disableEventListeners();

      // remove the popper if user explicitly asked for the deletion on destroy
      // do not use `remove` because IE11 doesn't support it
      if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
      }
      return this;
    }

    /**
     * Get the window associated with the element
     * @argument {Element} element
     * @returns {Window}
     */
    function getWindow(element) {
      const ownerDocument = element.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
      const isBody = scrollParent.nodeName === 'BODY';
      const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
      target.addEventListener(event, callback, { passive: true });

      if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
      }
      scrollParents.push(target);
    }

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function setupEventListeners(reference, options, state, updateBound) {
      // Resize event listener on window
      state.updateBound = updateBound;
      getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

      // Scroll event listener on scroll parents
      const scrollElement = getScrollParent(reference);
      attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
      state.scrollElement = scrollElement;
      state.eventsEnabled = true;

      return state;
    }

    /**
     * It will add resize/scroll events and start recalculating
     * position of the popper element when they are triggered.
     * @method
     * @memberof Popper
     */
    function enableEventListeners() {
      if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
      }
    }

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper.Utils
     * @private
     */
    function removeEventListeners(reference, state) {
      // Remove resize event listener on window
      getWindow(reference).removeEventListener('resize', state.updateBound);

      // Remove scroll event listener on scroll parents
      state.scrollParents.forEach(target => {
        target.removeEventListener('scroll', state.updateBound);
      });

      // Reset state
      state.updateBound = null;
      state.scrollParents = [];
      state.scrollElement = null;
      state.eventsEnabled = false;
      return state;
    }

    /**
     * It will remove resize/scroll events and won't recalculate popper position
     * when they are triggered. It also won't trigger `onUpdate` callback anymore,
     * unless you call `update` method manually.
     * @method
     * @memberof Popper
     */
    function disableEventListeners() {
      if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
      }
    }

    /**
     * Tells if a given input is a number
     * @method
     * @memberof Popper.Utils
     * @param {*} input to check
     * @return {Boolean}
     */
    function isNumeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Set the style to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setStyles(element, styles) {
      Object.keys(styles).forEach(prop => {
        let unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
          unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
      });
    }

    /**
     * Set the attributes to the given popper
     * @method
     * @memberof Popper.Utils
     * @argument {Element} element - Element to apply the attributes to
     * @argument {Object} styles
     * Object with a list of properties and values which will be applied to the element
     */
    function setAttributes(element, attributes) {
      Object.keys(attributes).forEach(function (prop) {
        const value = attributes[prop];
        if (value !== false) {
          element.setAttribute(prop, attributes[prop]);
        } else {
          element.removeAttribute(prop);
        }
      });
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} data.styles - List of style properties - values to apply to popper element
     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The same data object
     */
    function applyStyle(data) {
      // any property present in `data.styles` will be applied to the popper,
      // in this way we can make the 3rd party modifiers add custom styles to it
      // Be aware, modifiers could override the properties defined in the previous
      // lines of this modifier!
      setStyles(data.instance.popper, data.styles);

      // any property present in `data.attributes` will be applied to the popper,
      // they will be set as HTML attributes of the element
      setAttributes(data.instance.popper, data.attributes);

      // if arrowElement is defined and arrowStyles has some properties
      if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
      }

      return data;
    }

    /**
     * Set the x-placement attribute before everything else because it could be used
     * to add margins to the popper margins needs to be calculated to get the
     * correct popper offsets.
     * @method
     * @memberof Popper.modifiers
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper
     * @param {Object} options - Popper.js options
     */
    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
      // compute reference element offsets
      const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

      // compute auto placement, store placement inside the data object,
      // modifiers will be able to edit `placement` if needed
      // and refer to originalPlacement to know the original value
      const placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

      popper.setAttribute('x-placement', placement);

      // Apply `position` to popper before anything else because
      // without the position applied we can't guarantee correct computations
      setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

      return options;
    }

    /**
     * @function
     * @memberof Popper.Utils
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Boolean} shouldRound - If the offsets should be rounded at all
     * @returns {Object} The popper's position offsets rounded
     *
     * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
     * good as it can be within reason.
     * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
     *
     * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
     * as well on High DPI screens).
     *
     * Firefox prefers no rounding for positioning and does not have blurriness on
     * high DPI screens.
     *
     * Only horizontal placement and left/right values need to be considered.
     */
    function getRoundedOffsets(data, shouldRound) {
      const { popper, reference } = data.offsets;
      const { round, floor } = Math;
      const noRound = v => v;

      const referenceWidth = round(reference.width);
      const popperWidth = round(popper.width);

      const isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
      const isVariation = data.placement.indexOf('-') !== -1;
      const sameWidthParity = referenceWidth % 2 === popperWidth % 2;
      const bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

      const horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
      const verticalToInteger = !shouldRound ? noRound : round;

      return {
        left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
        top: verticalToInteger(popper.top),
        bottom: verticalToInteger(popper.bottom),
        right: horizontalToInteger(popper.right)
      };
    }

    const isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function computeStyle(data, options) {
      const { x, y } = options;
      const { popper } = data.offsets;

      // Remove this legacy support in Popper.js v2
      const legacyGpuAccelerationOption = find(data.instance.modifiers, modifier => modifier.name === 'applyStyle').gpuAcceleration;
      if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
      }
      const gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

      const offsetParent = getOffsetParent(data.instance.popper);
      const offsetParentRect = getBoundingClientRect(offsetParent);

      // Styles
      const styles = {
        position: popper.position
      };

      const offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

      const sideA = x === 'bottom' ? 'top' : 'bottom';
      const sideB = y === 'right' ? 'left' : 'right';

      // if gpuAcceleration is set to `true` and transform is supported,
      //  we use `translate3d` to apply the position to the popper we
      // automatically use the supported prefixed version if needed
      const prefixedProperty = getSupportedPropertyName('transform');

      // now, let's make a step back and look at this code closely (wtf?)
      // If the content of the popper grows once it's been positioned, it
      // may happen that the popper gets misplaced because of the new content
      // overflowing its reference element
      // To avoid this problem, we provide two options (x and y), which allow
      // the consumer to define the offset origin.
      // If we position a popper on top of a reference element, we can set
      // `x` to `top` to make the popper grow towards its top instead of
      // its bottom.
      let left, top;
      if (sideA === 'bottom') {
        // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
        // and not the bottom of the html element
        if (offsetParent.nodeName === 'HTML') {
          top = -offsetParent.clientHeight + offsets.bottom;
        } else {
          top = -offsetParentRect.height + offsets.bottom;
        }
      } else {
        top = offsets.top;
      }
      if (sideB === 'right') {
        if (offsetParent.nodeName === 'HTML') {
          left = -offsetParent.clientWidth + offsets.right;
        } else {
          left = -offsetParentRect.width + offsets.right;
        }
      } else {
        left = offsets.left;
      }
      if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`;
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
      } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        const invertTop = sideA === 'bottom' ? -1 : 1;
        const invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = `${sideA}, ${sideB}`;
      }

      // Attributes
      const attributes = {
        'x-placement': data.placement
      };

      // Update `data` attributes, styles and arrowStyles
      data.attributes = _extends({}, attributes, data.attributes);
      data.styles = _extends({}, styles, data.styles);
      data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

      return data;
    }

    /**
     * Helper used to know if the given modifier depends from another one.<br />
     * It checks if the needed modifier is listed and enabled.
     * @method
     * @memberof Popper.Utils
     * @param {Array} modifiers - list of modifiers
     * @param {String} requestingName - name of requesting modifier
     * @param {String} requestedName - name of requested modifier
     * @returns {Boolean}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
      const requesting = find(modifiers, ({ name }) => name === requestingName);

      const isRequired = !!requesting && modifiers.some(modifier => {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
      });

      if (!isRequired) {
        const requesting = `\`${requestingName}\``;
        const requested = `\`${requestedName}\``;
        console.warn(`${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!`);
      }
      return isRequired;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function arrow(data, options) {
      // arrow depends on keepTogether in order to work
      if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
      }

      let arrowElement = options.element;

      // if arrowElement is a string, suppose it's a CSS selector
      if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
          return data;
        }
      } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
          console.warn('WARNING: `arrow.element` must be child of its popper element!');
          return data;
        }
      }

      const placement = data.placement.split('-')[0];
      const { popper, reference } = data.offsets;
      const isVertical = ['left', 'right'].indexOf(placement) !== -1;

      const len = isVertical ? 'height' : 'width';
      const sideCapitalized = isVertical ? 'Top' : 'Left';
      const side = sideCapitalized.toLowerCase();
      const altSide = isVertical ? 'left' : 'top';
      const opSide = isVertical ? 'bottom' : 'right';
      const arrowElementSize = getOuterSizes(arrowElement)[len];

      //
      // extends keepTogether behavior making sure the popper and its
      // reference have enough pixels in conjunction
      //

      // top/left side
      if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
      }
      // bottom/right side
      if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
      }
      data.offsets.popper = getClientRect(data.offsets.popper);

      // compute center of the popper
      const center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

      // Compute the sideValue using the updated popper offsets
      // take popper margin in account because we don't have this info available
      const css = getStyleComputedProperty(data.instance.popper);
      const popperMarginSide = parseFloat(css[`margin${sideCapitalized}`]);
      const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);
      let sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

      // prevent arrowElement from being placed not contiguously to its popper
      sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

      data.arrowElement = arrowElement;
      data.offsets.arrow = {
        [side]: Math.round(sideValue),
        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node
      };

      return data;
    }

    /**
     * Get the opposite placement variation of the given one
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement variation
     * @returns {String} flipped placement variation
     */
    function getOppositeVariation(variation) {
      if (variation === 'end') {
        return 'start';
      } else if (variation === 'start') {
        return 'end';
      }
      return variation;
    }

    /**
     * List of accepted placements to use as values of the `placement` option.<br />
     * Valid placements are:
     * - `auto`
     * - `top`
     * - `right`
     * - `bottom`
     * - `left`
     *
     * Each placement can have a variation from this list:
     * - `-start`
     * - `-end`
     *
     * Variations are interpreted easily if you think of them as the left to right
     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
     * is right.<br />
     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
     *
     * Some valid examples are:
     * - `top-end` (on top of reference, right aligned)
     * - `right-start` (on right of reference, top aligned)
     * - `bottom` (on bottom, centered)
     * - `auto-end` (on the side with more space available, alignment depends by placement)
     *
     * @static
     * @type {Array}
     * @enum {String}
     * @readonly
     * @method placements
     * @memberof Popper
     */
    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

    // Get rid of `auto` `auto-start` and `auto-end`
    const validPlacements = placements.slice(3);

    /**
     * Given an initial placement, returns all the subsequent placements
     * clockwise (or counter-clockwise).
     *
     * @method
     * @memberof Popper.Utils
     * @argument {String} placement - A valid placement (it accepts variations)
     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
     * @returns {Array} placements including their variations
     */
    function clockwise(placement, counter = false) {
      const index = validPlacements.indexOf(placement);
      const arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
      return counter ? arr.reverse() : arr;
    }

    const BEHAVIORS = {
      FLIP: 'flip',
      CLOCKWISE: 'clockwise',
      COUNTERCLOCKWISE: 'counterclockwise'
    };

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function flip(data, options) {
      // if `inner` modifier is enabled, we can't use the `flip` modifier
      if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
      }

      if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
      }

      const boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

      let placement = data.placement.split('-')[0];
      let placementOpposite = getOppositePlacement(placement);
      let variation = data.placement.split('-')[1] || '';

      let flipOrder = [];

      switch (options.behavior) {
        case BEHAVIORS.FLIP:
          flipOrder = [placement, placementOpposite];
          break;
        case BEHAVIORS.CLOCKWISE:
          flipOrder = clockwise(placement);
          break;
        case BEHAVIORS.COUNTERCLOCKWISE:
          flipOrder = clockwise(placement, true);
          break;
        default:
          flipOrder = options.behavior;
      }

      flipOrder.forEach((step, index) => {
        if (placement !== step || flipOrder.length === index + 1) {
          return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        const popperOffsets = data.offsets.popper;
        const refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        const floor = Math.floor;
        const overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        const overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        const overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

        // flips variation if reference element overflows boundaries
        const flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        // flips variation if popper content overflows boundaries
        const flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

        const flippedVariation = flippedVariationByRef || flippedVariationByContent;

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
          // this boolean to detect any flip loop
          data.flipped = true;

          if (overlapsRef || overflowsBoundaries) {
            placement = flipOrder[index + 1];
          }

          if (flippedVariation) {
            variation = getOppositeVariation(variation);
          }

          data.placement = placement + (variation ? '-' + variation : '');

          // this object contains `position`, we want to preserve it along with
          // any additional property we may add in the future
          data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

          data = runModifiers(data.instance.modifiers, data, 'flip');
        }
      });
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function keepTogether(data) {
      const { popper, reference } = data.offsets;
      const placement = data.placement.split('-')[0];
      const floor = Math.floor;
      const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      const side = isVertical ? 'right' : 'bottom';
      const opSide = isVertical ? 'left' : 'top';
      const measurement = isVertical ? 'width' : 'height';

      if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
      }
      if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
      }

      return data;
    }

    /**
     * Converts a string containing value + unit into a px value number
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} str - Value + unit string
     * @argument {String} measurement - `height` or `width`
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @returns {Number|String}
     * Value in pixels, or original string if no values were extracted
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
      // separate value from unit
      const split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
      const value = +split[1];
      const unit = split[2];

      // If it's not a number it's an operator, I guess
      if (!value) {
        return str;
      }

      if (unit.indexOf('%') === 0) {
        let element;
        switch (unit) {
          case '%p':
            element = popperOffsets;
            break;
          case '%':
          case '%r':
          default:
            element = referenceOffsets;
        }

        const rect = getClientRect(element);
        return rect[measurement] / 100 * value;
      } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        let size;
        if (unit === 'vh') {
          size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
          size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
      } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
      }
    }

    /**
     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
     * @function
     * @memberof {modifiers~offset}
     * @private
     * @argument {String} offset
     * @argument {Object} popperOffsets
     * @argument {Object} referenceOffsets
     * @argument {String} basePlacement
     * @returns {Array} a two cells array with x and y offsets in numbers
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
      const offsets = [0, 0];

      // Use height if placement is left or right and index is 0 otherwise use width
      // in this way the first offset will use an axis and the second one
      // will use the other one
      const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

      // Split the offset string to obtain a list of values and operands
      // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
      const fragments = offset.split(/(\+|\-)/).map(frag => frag.trim());

      // Detect if the offset string contains a pair of values or a single one
      // they could be separated by comma or space
      const divider = fragments.indexOf(find(fragments, frag => frag.search(/,|\s/) !== -1));

      if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
      }

      // If divider is found, we divide the list of values and operands to divide
      // them by ofset X and Y.
      const splitRegex = /\s*,\s*|\s+/;
      let ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

      // Convert the values with units to absolute pixels to allow our computations
      ops = ops.map((op, index) => {
        // Most of the units rely on the orientation of the popper
        const measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        let mergeWithPrevious = false;
        return op
        // This aggregates any `+` or `-` sign that aren't considered operators
        // e.g.: 10 + +5 => [10, +, +5]
        .reduce((a, b) => {
          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
            a[a.length - 1] = b;
            mergeWithPrevious = true;
            return a;
          } else if (mergeWithPrevious) {
            a[a.length - 1] += b;
            mergeWithPrevious = false;
            return a;
          } else {
            return a.concat(b);
          }
        }, [])
        // Here we convert the string values into number values (in px)
        .map(str => toValue(str, measurement, popperOffsets, referenceOffsets));
      });

      // Loop trough the offsets arrays and execute the operations
      ops.forEach((op, index) => {
        op.forEach((frag, index2) => {
          if (isNumeric(frag)) {
            offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
          }
        });
      });
      return offsets;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @argument {Number|String} options.offset=0
     * The offset value as described in the modifier description
     * @returns {Object} The data object, properly modified
     */
    function offset(data, { offset }) {
      const { placement, offsets: { popper, reference } } = data;
      const basePlacement = placement.split('-')[0];

      let offsets;
      if (isNumeric(+offset)) {
        offsets = [+offset, 0];
      } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
      }

      if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
      } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
      } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
      } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
      }

      data.popper = popper;
      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function preventOverflow(data, options) {
      let boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

      // If offsetParent is the reference element, we really want to
      // go one step up and use the next offsetParent as reference to
      // avoid to make this modifier completely useless and look like broken
      if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
      }

      // NOTE: DOM access here
      // resets the popper's position so that the document size can be calculated excluding
      // the size of the popper element itself
      const transformProp = getSupportedPropertyName('transform');
      const popperStyles = data.instance.popper.style; // assignment to help minification
      const { top, left, [transformProp]: transform } = popperStyles;
      popperStyles.top = '';
      popperStyles.left = '';
      popperStyles[transformProp] = '';

      const boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

      // NOTE: DOM access here
      // restores the original style properties after the offsets have been computed
      popperStyles.top = top;
      popperStyles.left = left;
      popperStyles[transformProp] = transform;

      options.boundaries = boundaries;

      const order = options.priority;
      let popper = data.offsets.popper;

      const check = {
        primary(placement) {
          let value = popper[placement];
          if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
            value = Math.max(popper[placement], boundaries[placement]);
          }
          return { [placement]: value };
        },
        secondary(placement) {
          const mainSide = placement === 'right' ? 'left' : 'top';
          let value = popper[mainSide];
          if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
            value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
          }
          return { [mainSide]: value };
        }
      };

      order.forEach(placement => {
        const side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends({}, popper, check[side](placement));
      });

      data.offsets.popper = popper;

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function shift(data) {
      const placement = data.placement;
      const basePlacement = placement.split('-')[0];
      const shiftvariation = placement.split('-')[1];

      // if shift shiftvariation is specified, run the modifier
      if (shiftvariation) {
        const { reference, popper } = data.offsets;
        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        const side = isVertical ? 'left' : 'top';
        const measurement = isVertical ? 'width' : 'height';

        const shiftOffsets = {
          start: { [side]: reference[side] },
          end: {
            [side]: reference[side] + reference[measurement] - popper[measurement]
          }
        };

        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by update method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function hide(data) {
      if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
      }

      const refRect = data.offsets.reference;
      const bound = find(data.instance.modifiers, modifier => modifier.name === 'preventOverflow').boundaries;

      if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
          return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
      } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
          return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
      }

      return data;
    }

    /**
     * @function
     * @memberof Modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {Object} The data object, properly modified
     */
    function inner(data) {
      const placement = data.placement;
      const basePlacement = placement.split('-')[0];
      const { popper, reference } = data.offsets;
      const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

      const subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

      popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

      data.placement = getOppositePlacement(placement);
      data.offsets.popper = getClientRect(popper);

      return data;
    }

    /**
     * Modifier function, each modifier can have a function of this type assigned
     * to its `fn` property.<br />
     * These functions will be called on each update, this means that you must
     * make sure they are performant enough to avoid performance bottlenecks.
     *
     * @function ModifierFn
     * @argument {dataObject} data - The data object generated by `update` method
     * @argument {Object} options - Modifiers configuration and options
     * @returns {dataObject} The data object, properly modified
     */

    /**
     * Modifiers are plugins used to alter the behavior of your poppers.<br />
     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
     * needed by the library.
     *
     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
     * All the other properties are configurations that could be tweaked.
     * @namespace modifiers
     */
    var modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },

      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unit-less, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the `height`.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },

      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * A scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries" — or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
      },

      /**
       * Modifier used to make sure the reference and its popper stay near each other
       * without leaving any gap between the two. Especially useful when the arrow is
       * enabled and you want to ensure that it points to its reference element.
       * It cares only about the first axis. You can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },

      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjunction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
      },

      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: 'viewport',
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
      },

      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },

      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },

      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
      },

      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define your own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: undefined
      }
    };

    /**
     * The `dataObject` is an object containing all the information used by Popper.js.
     * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
     * @name dataObject
     * @property {Object} data.instance The Popper.js instance
     * @property {String} data.placement Placement applied to popper
     * @property {String} data.originalPlacement Placement originally defined on init
     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
     * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
     * @property {Object} data.boundaries Offsets of the popper boundaries
     * @property {Object} data.offsets The measurements of popper, reference and arrow elements
     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
     */

    /**
     * Default options provided to Popper.js constructor.<br />
     * These can be overridden using the `options` argument of Popper.js.<br />
     * To override an option, simply pass an object with the same
     * structure of the `options` object, as the 3rd argument. For example:
     * ```
     * new Popper(ref, pop, {
     *   modifiers: {
     *     preventOverflow: { enabled: false }
     *   }
     * })
     * ```
     * @type {Object}
     * @static
     * @memberof Popper
     */
    var Defaults = {
      /**
       * Popper's placement.
       * @prop {Popper.placements} placement='bottom'
       */
      placement: 'bottom',

      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,

      /**
       * Whether events (resize, scroll) are initially enabled.
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,

      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,

      /**
       * Callback called when the popper is created.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: () => {},

      /**
       * Callback called when the popper is updated. This callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: () => {},

      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js.
       * @prop {modifiers}
       */
      modifiers
    };

    /**
     * @callback onCreate
     * @param {dataObject} data
     */

    /**
     * @callback onUpdate
     * @param {dataObject} data
     */

    // Utils
    // Methods
    class Popper {
      /**
       * Creates a new Popper.js instance.
       * @class Popper
       * @param {Element|referenceObject} reference - The reference element used to position the popper
       * @param {Element} popper - The HTML / XML element used as the popper
       * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
       * @return {Object} instance - The generated Popper.js instance
       */
      constructor(reference, popper, options = {}) {
        this.scheduleUpdate = () => requestAnimationFrame(this.update);

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends({}, Popper.Defaults, options);

        // init state
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(name => {
          this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(name => _extends({
          name
        }, this.options.modifiers[name]))
        // sort the modifiers by order
        .sort((a, b) => a.order - b.order);

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(modifierOptions => {
          if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
            modifierOptions.onLoad(this.reference, this.popper, this.options, modifierOptions, this.state);
          }
        });

        // fire the first update to position the popper in the right place
        this.update();

        const eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          // setup event listeners, they will take care of update the position in specific situations
          this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
      }

      // We can't use class properties because they don't get listed in the
      // class prototype and break stuff like Sinon stubs
      update() {
        return update.call(this);
      }
      destroy() {
        return destroy.call(this);
      }
      enableEventListeners() {
        return enableEventListeners.call(this);
      }
      disableEventListeners() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */


      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */
    }

    /**
     * The `referenceObject` is an object that provides an interface compatible with Popper.js
     * and lets you use it as replacement of a real DOM node.<br />
     * You can use this method to position a popper relatively to a set of coordinates
     * in case you don't have a DOM node to use as reference.
     *
     * ```
     * new Popper(referenceObject, popperNode);
     * ```
     *
     * NB: This feature isn't supported in Internet Explorer 10.
     * @name referenceObject
     * @property {Function} data.getBoundingClientRect
     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
     * @property {number} data.clientWidth
     * An ES6 getter that will return the width of the virtual reference element.
     * @property {number} data.clientHeight
     * An ES6 getter that will return the height of the virtual reference element.
     */

    Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;

    export default Popper;
    //# sourceMappingURL=popper.js.map
  admin-Public-Admin-plugins-popper-popper.js.map: '{"version":3,"file":"popper.js","sources":["../src/utils/isBrowser.js","../src/utils/debounce.js","../src/utils/isFunction.js","../src/utils/getStyleComputedProperty.js","../src/utils/getParentNode.js","../src/utils/getScrollParent.js","../src/utils/getReferenceNode.js","../src/utils/isIE.js","../src/utils/getOffsetParent.js","../src/utils/isOffsetContainer.js","../src/utils/getRoot.js","../src/utils/findCommonOffsetParent.js","../src/utils/getScroll.js","../src/utils/includeScroll.js","../src/utils/getBordersSize.js","../src/utils/getWindowSizes.js","../src/utils/getClientRect.js","../src/utils/getBoundingClientRect.js","../src/utils/getOffsetRectRelativeToArbitraryNode.js","../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../src/utils/isFixed.js","../src/utils/getFixedPositionOffsetParent.js","../src/utils/getBoundaries.js","../src/utils/computeAutoPlacement.js","../src/utils/getReferenceOffsets.js","../src/utils/getOuterSizes.js","../src/utils/getOppositePlacement.js","../src/utils/getPopperOffsets.js","../src/utils/find.js","../src/utils/findIndex.js","../src/utils/runModifiers.js","../src/methods/update.js","../src/utils/isModifierEnabled.js","../src/utils/getSupportedPropertyName.js","../src/methods/destroy.js","../src/utils/getWindow.js","../src/utils/setupEventListeners.js","../src/methods/enableEventListeners.js","../src/utils/removeEventListeners.js","../src/methods/disableEventListeners.js","../src/utils/isNumeric.js","../src/utils/setStyles.js","../src/utils/setAttributes.js","../src/modifiers/applyStyle.js","../src/utils/getRoundedOffsets.js","../src/modifiers/computeStyle.js","../src/utils/isModifierRequired.js","../src/modifiers/arrow.js","../src/utils/getOppositeVariation.js","../src/methods/placements.js","../src/utils/clockwise.js","../src/modifiers/flip.js","../src/modifiers/keepTogether.js","../src/modifiers/offset.js","../src/modifiers/preventOverflow.js","../src/modifiers/shift.js","../src/modifiers/hide.js","../src/modifiers/inner.js","../src/modifiers/index.js","../src/methods/defaults.js","../src/index.js"],"sourcesContent":["export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n
    * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer
    to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const
    getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck)
    === ''[object Function]''\n  );\n}\n","/**\n * Get CSS computed property of the
    given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n
    * @argument {String} property\n */\nexport default function getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const
    css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName
    === ''HTML'') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getParentNode
    from ''./getParentNode'';\n\n/**\n * Returns the scrolling parent of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n
    * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element)
    {\n  // Return body, `getScroll` will take care to get the correct `scrollTop`
    from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName)
    {\n    case ''HTML'':\n    case ''BODY'':\n      return element.ownerDocument.body\n    case
    ''#document'':\n      return element.body\n  }\n\n  // Firefox want us to check
    `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } =
    getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow
    + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nexport default function getOuterSizes(element)
    {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const
    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const
    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  const
    result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the
    given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement)
    {\n  const hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom''
    };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import
    getOuterSizes from ''./getOuterSizes'';\nimport getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n
    * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param
    {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement}
    popper - the popper element\n * @param {Object} referenceOffsets - the reference
    offsets (the popper will be relative to this)\n * @param {String} placement -
    one of the valid placement options\n * @returns {Object} popperOffsets - An object
    containing the offsets which will be applied to the popper\n */\nexport default
    function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement
    = placement.split(''-'')[0];\n\n  // Get popper node sizes\n  const popperRect
    = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets
    object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  //
    depending by the popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function find(arr, check)
    {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    isFunction from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport
    getClientRect from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list
    of modifiers and run them in order,\n * each of them will then edit the data object.\n
    * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array}
    modifiers\n * @param {String} ends - Optional modifier name used as stopper\n
    * @returns {dataObject}\n */\nexport default function runModifiers(modifiers,
    data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    :
    modifiers.slice(0, findIndex(modifiers, ''name'', ends));\n\n  modifiersToRun.forEach(modifier
    => {\n    if (modifier[''function'']) { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","import computeAutoPlacement from ''../utils/computeAutoPlacement'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\n\n/**\n
    * Updates the position of the popper, computing the new offsets and applying\n
    * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance
    reasons.\n * @method\n * @memberof Popper\n */\nexport default function update()
    {\n  // if popper is destroyed, don''t perform any further update\n  if (this.state.isDestroyed)
    {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles:
    {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  //
    compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  //
    compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  //
    store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position
    = this.options.positionFixed\n    ? ''fixed''\n    : ''absolute'';\n\n  // run
    the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first
    `update` will call `onCreate` callback\n  // the other ones will call `onUpdate`
    callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  }
    else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know
    if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns
    {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName)
    {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from ''../utils/isModifierEnabled'';\nimport
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * Destroys the popper.\n * @method\n * @memberof Popper\n */\nexport default function
    destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle`
    modifier is enabled\n  if (isModifierEnabled(this.modifiers, ''applyStyle''))
    {\n    this.popper.removeAttribute(''x-placement'');\n    this.popper.style.position
    = '''';\n    this.popper.style.top = '''';\n    this.popper.style.left = '''';\n    this.popper.style.right
    = '''';\n    this.popper.style.bottom = '''';\n    this.popper.style.willChange
    = '''';\n    this.popper.style[getSupportedPropertyName(''transform'')] = '''';\n  }\n\n  this.disableEventListeners();\n\n  //
    remove the popper if user explicitly asked for the deletion on destroy\n  // do
    not use `remove` because IE11 doesn''t support it\n  if (this.options.removeOnDestroy)
    {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n
    * Get the window associated with the element\n * @argument {Element} element\n
    * @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getScrollParent from ''./getScrollParent'';\nimport getWindow
    from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  const isBody = scrollParent.nodeName === ''BODY'';\n  const
    target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    setupEventListeners from ''../utils/setupEventListeners'';\n\n/**\n * It will
    add resize/scroll events and start recalculating\n * position of the popper element
    when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default
    function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state
    = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import
    getWindow from ''./getWindow'';\n\n/**\n * Remove event listeners used to update
    the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport
    default function removeEventListeners(reference, state) {\n  // Remove resize
    event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners
    from ''../utils/removeEventListeners'';\n\n/**\n * It will remove resize/scroll
    events and won''t recalculate popper position\n * when they are triggered. It
    also won''t trigger `onUpdate` callback anymore,\n * unless you call `update`
    method manually.\n * @method\n * @memberof Popper\n */\nexport default function
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state
    = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nexport default
    function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop)
    {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    setStyles from ''../utils/setStyles'';\nimport setAttributes from ''../utils/setAttributes'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport computeAutoPlacement
    from ''../utils/computeAutoPlacement'';\n\n/**\n * @function\n * @memberof Modifiers\n
    * @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} data.styles - List of style properties - values to apply to popper element\n
    * @argument {Object} data.attributes - List of attribute properties - values to
    apply to popper element\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The same data object\n */\nexport default function
    applyStyle(data) {\n  // any property present in `data.styles` will be applied
    to the popper,\n  // in this way we can make the 3rd party modifiers add custom
    styles to it\n  // Be aware, modifiers could override the properties defined in
    the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper,
    data.styles);\n\n  // any property present in `data.attributes` will be applied
    to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper,
    data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some
    properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement,
    data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute
    before everything else because it could be used\n * to add margins to the popper
    margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n
    * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference
    element used to position the popper\n * @param {HTMLElement} popper - The HTML
    element used as popper\n * @param {Object} options - Popper.js options\n */\nexport
    function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n)
    {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state,
    popper, reference, options.positionFixed);\n\n  // compute auto placement, store
    placement inside the data object,\n  // modifiers will be able to edit `placement`
    if needed\n  // and refer to originalPlacement to know the original value\n  const
    placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute(''x-placement'',
    placement);\n\n  // Apply `position` to popper before anything else because\n  //
    without the position applied we can''t guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? ''fixed'' : ''absolute'' });\n\n  return options;\n}\n","/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper''s position
    offsets rounded\n *\n * The tale of pixel-perfect positioning. It''s still not
    100% perfect, but as\n * good as it can be within reason.\n * Discussion here:
    https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause
    a popper to be blurry if not using full pixels (Safari\n * as well on High DPI
    screens).\n *\n * Firefox prefers no rounding for positioning and does not have
    blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right
    values need to be considered.\n */\nexport default function getRoundedOffsets(data,
    shouldRound) {\n  const { popper, reference } = data.offsets;\n  const { round,
    floor } = Math;\n  const noRound = v => v;\n  \n  const referenceWidth = round(reference.width);\n  const
    popperWidth = round(popper.width);\n  \n  const isVertical = [''left'', ''right''].indexOf(data.placement)
    !== -1;\n  const isVariation = data.placement.indexOf(''-'') !== -1;\n  const
    sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  const bothOddWidth
    = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  const horizontalToInteger
    = !shouldRound\n    ? noRound\n    : isVertical || isVariation || sameWidthParity\n    ?
    round\n    : floor;\n  const verticalToInteger = !shouldRound ? noRound : round;\n\n  return
    {\n    left: horizontalToInteger(\n      bothOddWidth && !isVariation && shouldRound\n        ?
    popper.left - 1\n        : popper.left\n    ),\n    top: verticalToInteger(popper.top),\n    bottom:
    verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right),\n  };\n}\n","import
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\nimport find
    from ''../utils/find'';\nimport getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundingClientRect from ''../utils/getBoundingClientRect'';\nimport getRoundedOffsets
    from ''../utils/getRoundedOffsets'';\nimport isBrowser from ''../utils/isBrowser'';\n\nconst
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeStyle(data, options) {\n  const { x, y } = options;\n  const
    { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const
    legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''applyStyle''\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption
    !== undefined) {\n    console.warn(\n      ''WARNING: `gpuAcceleration` option
    moved to `computeStyle` modifier and will not be supported in future versions
    of Popper.js!''\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption
    !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const
    offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position:
    popper.position,\n  };\n\n  const offsets = getRoundedOffsets(\n    data,\n    window.devicePixelRatio
    < 2 || !isFirefox\n  );\n\n  const sideA = x === ''bottom'' ? ''top'' : ''bottom'';\n  const
    sideB = y === ''right'' ? ''left'' : ''right'';\n\n  // if gpuAcceleration is
    set to `true` and transform is supported,\n  //  we use `translate3d` to apply
    the position to the popper we\n  // automatically use the supported prefixed version
    if needed\n  const prefixedProperty = getSupportedPropertyName(''transform'');\n\n  //
    now, let''s make a step back and look at this code closely (wtf?)\n  // If the
    content of the popper grows once it''s been positioned, it\n  // may happen that
    the popper gets misplaced because of the new content\n  // overflowing its reference
    element\n  // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA ===
    ''bottom'') {\n    // when offsetParent is <html> the positioning is relative
    to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom
    of the html element\n    if (offsetParent.nodeName === ''HTML'') {\n      top
    = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height
    + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB
    === ''right'') {\n    if (offsetParent.nodeName === ''HTML'') {\n      left =
    -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width
    + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration
    && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px,
    ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange
    = ''transform'';\n  } else {\n    // othwerise, we use the standard `top`, `left`,
    `bottom` and `right` properties\n    const invertTop = sideA === ''bottom'' ?
    -1 : 1;\n    const invertLeft = sideB === ''right'' ? -1 : 1;\n    styles[sideA]
    = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange
    = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    ''x-placement'':
    data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles
    };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return
    data;\n}\n","import find from ''./find'';\n\n/**\n * Helper used to know if the
    given modifier depends from another one.<br />\n * It checks if the needed modifier
    is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array}
    modifiers - list of modifiers\n * @param {String} requestingName - name of requesting
    modifier\n * @param {String} requestedName - name of requested modifier\n * @returns
    {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","import getClientRect
    from ''../utils/getClientRect'';\nimport getOuterSizes from ''../utils/getOuterSizes'';\nimport
    isModifierRequired from ''../utils/isModifierRequired'';\nimport getStyleComputedProperty
    from ''../utils/getStyleComputedProperty'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by update method\n
    * @argument {Object} options - Modifiers configuration and options\n * @returns
    {Object} The data object, properly modified\n */\nexport default function arrow(data,
    options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers,
    ''arrow'', ''keepTogether'')) {\n    return data;\n  }\n\n  let arrowElement =
    options.element;\n\n  // if arrowElement is a string, suppose it''s a CSS selector\n  if
    (typeof arrowElement === ''string'') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    //
    if arrowElement is not found, don''t run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn''t a
    query selector we must check that the\n    // provided DOM node is child of its
    popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        ''WARNING:
    `arrow.element` must be child of its popper element!''\n      );\n      return
    data;\n    }\n  }\n\n  const placement = data.placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isVertical = [''left'', ''right''].indexOf(placement)
    !== -1;\n\n  const len = isVertical ? ''height'' : ''width'';\n  const sideCapitalized
    = isVertical ? ''Top'' : ''Left'';\n  const side = sideCapitalized.toLowerCase();\n  const
    altSide = isVertical ? ''left'' : ''top'';\n  const opSide = isVertical ? ''bottom''
    : ''right'';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  //
    extends keepTogether behavior making sure the popper and its\n  // reference have
    enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide]
    - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side]
    - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side]
    + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side]
    + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  //
    compute center of the popper\n  const center = reference[side] + reference[len]
    / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper
    offsets\n  // take popper margin in account because we don''t have this info available\n  const
    css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide
    = parseFloat(css[`margin${sideCapitalized}`]);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let
    sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  //
    prevent arrowElement from being placed not contiguously to its popper\n  sideValue
    = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement
    = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]:
    '''', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return
    data;\n}\n","/**\n * Get the opposite placement variation of the given one\n *
    @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n
    * @returns {String} flipped placement variation\n */\nexport default function
    getOppositeVariation(variation) {\n  if (variation === ''end'') {\n    return
    ''start'';\n  } else if (variation === ''start'') {\n    return ''end'';\n  }\n  return
    variation;\n}\n","/**\n * List of accepted placements to use as values of the
    `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n
    * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation
    from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted
    easily if you think of them as the left to right\n * written languages. Horizontally
    (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically
    (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples
    are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start`
    (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n *
    - `auto-end` (on the side with more space available, alignment depends by placement)\n
    *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n
    * @memberof Popper\n */\nexport default [\n  ''auto-start'',\n  ''auto'',\n  ''auto-end'',\n  ''top-start'',\n  ''top'',\n  ''top-end'',\n  ''right-start'',\n  ''right'',\n  ''right-end'',\n  ''bottom-end'',\n  ''bottom'',\n  ''bottom-start'',\n  ''left-end'',\n  ''left'',\n  ''left-start'',\n];\n","import
    placements from ''../methods/placements'';\n\n// Get rid of `auto` `auto-start`
    and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given
    an initial placement, returns all the subsequent placements\n * clockwise (or
    counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String}
    placement - A valid placement (it accepts variations)\n * @argument {Boolean}
    counter - Set to true to walk the placements counterclockwise\n * @returns {Array}
    placements including their variations\n */\nexport default function clockwise(placement,
    counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const
    arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0,
    index));\n  return counter ? arr.reverse() : arr;\n}\n","import getOppositePlacement
    from ''../utils/getOppositePlacement'';\nimport getOppositeVariation from ''../utils/getOppositeVariation'';\nimport
    getPopperOffsets from ''../utils/getPopperOffsets'';\nimport runModifiers from
    ''../utils/runModifiers'';\nimport getBoundaries from ''../utils/getBoundaries'';\nimport
    isModifierEnabled from ''../utils/isModifierEnabled'';\nimport clockwise from
    ''../utils/clockwise'';\n\nconst BEHAVIORS = {\n  FLIP: ''flip'',\n  CLOCKWISE:
    ''clockwise'',\n  COUNTERCLOCKWISE: ''counterclockwise'',\n};\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by update method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function flip(data, options) {\n  // if `inner` modifier is enabled, we
    can''t use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    ''inner'')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there''s not enough space on any of the flippable sides\n    return data;\n  }\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let
    placement = data.placement.split(''-'')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let
    variation = data.placement.split(''-'')[1] || '''';\n\n  let flipOrder = [];\n\n  switch
    (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder
    = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step,
    index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return
    data;\n    }\n\n    placement = data.placement.split(''-'')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const
    refOffsets = data.offsets.reference;\n\n    // using floor because the reference
    offsets may contain decimals we are not going to consider here\n    const floor
    = Math.floor;\n    const overlapsRef =\n      (placement === ''left'' &&\n        floor(popperOffsets.right)
    > floor(refOffsets.left)) ||\n      (placement === ''right'' &&\n        floor(popperOffsets.left)
    < floor(refOffsets.right)) ||\n      (placement === ''top'' &&\n        floor(popperOffsets.bottom)
    > floor(refOffsets.top)) ||\n      (placement === ''bottom'' &&\n        floor(popperOffsets.top)
    < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top)
    < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement
    === ''left'' && overflowsLeft) ||\n      (placement === ''right'' && overflowsRight)
    ||\n      (placement === ''top'' && overflowsTop) ||\n      (placement === ''bottom''
    && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical
    = [''top'', ''bottom''].indexOf(placement) !== -1;\n\n    // flips variation if
    reference element overflows boundaries\n    const flippedVariationByRef =\n      !!options.flipVariations
    &&\n      ((isVertical && variation === ''start'' && overflowsLeft) ||\n        (isVertical
    && variation === ''end'' && overflowsRight) ||\n        (!isVertical && variation
    === ''start'' && overflowsTop) ||\n        (!isVertical && variation === ''end''
    && overflowsBottom));\n\n    // flips variation if popper content overflows boundaries\n    const
    flippedVariationByContent =\n      !!options.flipVariationsByContent &&\n      ((isVertical
    && variation === ''start'' && overflowsRight) ||\n        (isVertical && variation
    === ''end'' && overflowsLeft) ||\n        (!isVertical && variation === ''start''
    && overflowsBottom) ||\n        (!isVertical && variation === ''end'' && overflowsTop));\n\n    const
    flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if
    (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean
    to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef ||
    overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if
    (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? ''-'' + variation : '''');\n\n      // this object
    contains `position`, we want to preserve it along with\n      // any additional
    property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data
    = runModifiers(data.instance.modifiers, data, ''flip'');\n    }\n  });\n  return
    data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nexport default function keepTogether(data) {\n  const { popper,
    reference } = data.offsets;\n  const placement = data.placement.split(''-'')[0];\n  const
    floor = Math.floor;\n  const isVertical = [''top'', ''bottom''].indexOf(placement)
    !== -1;\n  const side = isVertical ? ''right'' : ''bottom'';\n  const opSide =
    isVertical ? ''left'' : ''top'';\n  const measurement = isVertical ? ''width''
    : ''height'';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide]
    =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide]
    > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return
    data;\n}\n","import isNumeric from ''../utils/isNumeric'';\nimport getClientRect
    from ''../utils/getClientRect'';\nimport find from ''../utils/find'';\n\n/**\n
    * Converts a string containing value + unit into a px value number\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value
    + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument
    {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n
    * Value in pixels, or original string if no values were extracted\n */\nexport
    function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate
    value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const
    value = +split[1];\n  const unit = split[2];\n\n  // If it''s not a number it''s
    an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf(''%'')
    === 0) {\n    let element;\n    switch (unit) {\n      case ''%p'':\n        element
    = popperOffsets;\n        break;\n      case ''%'':\n      case ''%r'':\n      default:\n        element
    = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return
    rect[measurement] / 100 * value;\n  } else if (unit === ''vh'' || unit === ''vw'')
    {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let
    size;\n    if (unit === ''vh'') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight
    || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth
    || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is
    an explicit pixel unit, we get rid of the unit and keep the value\n    // if is
    an implicit unit, it''s px, and we return just the value\n    return value;\n  }\n}\n\n/**\n
    * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n *
    @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument
    {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets
    in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n)
    {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right
    and index is 0 otherwise use width\n  // in this way the first offset will use
    an axis and the second one\n  // will use the other one\n  const useHeight = [''right'',
    ''left''].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain
    a list of values and operands\n  // The regex addresses values with the plus or
    minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag
    => frag.trim());\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  const divider
    = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if
    (fragments[divider] && fragments[divider].indexOf('','') === -1) {\n    console.warn(\n      ''Offsets
    separated by white space(s) are deprecated, use a comma (,) instead.''\n    );\n  }\n\n  //
    If divider is found, we divide the list of values and operands to divide\n  //
    them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider
    !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider
    + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with
    units to absolute pixels to allow our computations\n  ops = ops.map((op, index)
    => {\n    // Most of the units rely on the orientation of the popper\n    const
    measurement = (index === 1 ? !useHeight : useHeight)\n      ? ''height''\n      :
    ''width'';\n    let mergeWithPrevious = false;\n    return (\n      op\n        //
    This aggregates any `+` or `-` sign that aren''t considered operators\n        //
    e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length
    - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {\n            a[a.length -
    1] = b;\n            mergeWithPrevious = true;\n            return a;\n          }
    else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious
    = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        },
    [])\n        // Here we convert the string values into number values (in px)\n        .map(str
    => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  //
    Loop trough the offsets arrays and execute the operations\n  ops.forEach((op,
    index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index]
    += frag * (op[index2 - 1] === ''-'' ? -1 : 1);\n      }\n    });\n  });\n  return
    offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n
    * The offset value as described in the modifier description\n * @returns {Object}
    The data object, properly modified\n */\nexport default function offset(data,
    { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const
    basePlacement = placement.split(''-'')[0];\n\n  let offsets;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === ''left'') {\n    popper.top
    += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement ===
    ''right'') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  }
    else if (basePlacement === ''top'') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === ''bottom'') {\n    popper.left
    += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n","import getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundaries from ''../utils/getBoundaries'';\nimport getSupportedPropertyName
    from ''../utils/getSupportedPropertyName'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by `update`
    method\n * @argument {Object} options - Modifiers configuration and options\n
    * @returns {Object} The data object, properly modified\n */\nexport default function
    preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement
    || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference
    element, we really want to\n  // go one step up and use the next offsetParent
    as reference to\n  // avoid to make this modifier completely useless and look
    like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement
    = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  //
    resets the popper''s position so that the document size can be calculated excluding\n  //
    the size of the popper element itself\n  const transformProp = getSupportedPropertyName(''transform'');\n  const
    popperStyles = data.instance.popper.style; // assignment to help minification\n  const
    { top, left, [transformProp]: transform } = popperStyles;\n  popperStyles.top
    = '''';\n  popperStyles.left = '''';\n  popperStyles[transformProp] = '''';\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement,\n    data.positionFixed\n  );\n\n  //
    NOTE: DOM access here\n  // restores the original style properties after the offsets
    have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp]
    = transform;\n\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let
    popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let
    value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement)
    {\n      const mainSide = placement === ''right'' ? ''left'' : ''top'';\n      let
    value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement]
    -\n            (placement === ''right'' ? popper.width : popper.height)\n        );\n      }\n      return
    { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const
    side =\n      [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ''secondary'';\n    popper
    = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper =
    popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function shift(data) {\n  const
    placement = data.placement;\n  const basePlacement = placement.split(''-'')[0];\n  const
    shiftvariation = placement.split(''-'')[1];\n\n  // if shift shiftvariation is
    specified, run the modifier\n  if (shiftvariation) {\n    const { reference, popper
    } = data.offsets;\n    const isVertical = [''bottom'', ''top''].indexOf(basePlacement)
    !== -1;\n    const side = isVertical ? ''left'' : ''top'';\n    const measurement
    = isVertical ? ''width'' : ''height'';\n\n    const shiftOffsets = {\n      start:
    { [side]: reference[side] },\n      end: {\n        [side]: reference[side] +
    reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper
    = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import
    isModifierRequired from ''../utils/isModifierRequired'';\nimport find from ''../utils/find'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function hide(data) {\n  if (!isModifierRequired(data.instance.modifiers,
    ''hide'', ''preventOverflow'')) {\n    return data;\n  }\n\n  const refRect =
    data.offsets.reference;\n  const bound = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''preventOverflow''\n  ).boundaries;\n\n  if (\n    refRect.bottom
    < bound.top ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom
    ||\n    refRect.right < bound.left\n  ) {\n    // Avoid unnecessary DOM access
    if visibility hasn''t changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide
    = true;\n    data.attributes[''x-out-of-boundaries''] = '''';\n  } else {\n    //
    Avoid unnecessary DOM access if visibility hasn''t changed\n    if (data.hide
    === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes[''x-out-of-boundaries'']
    = false;\n  }\n\n  return data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport
    getOppositePlacement from ''../utils/getOppositePlacement'';\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function inner(data) {\n  const placement = data.placement;\n  const basePlacement
    = placement.split(''-'')[0];\n  const { popper, reference } = data.offsets;\n  const
    isHoriz = [''left'', ''right''].indexOf(basePlacement) !== -1;\n\n  const subtractLength
    = [''top'', ''left''].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? ''left''
    : ''top''] =\n    reference[basePlacement] -\n    (subtractLength ? popper[isHoriz
    ? ''width'' : ''height''] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper
    = getClientRect(popper);\n\n  return data;\n}\n","import applyStyle, { applyStyleOnLoad
    } from ''./applyStyle'';\nimport computeStyle from ''./computeStyle'';\nimport
    arrow from ''./arrow'';\nimport flip from ''./flip'';\nimport keepTogether from
    ''./keepTogether'';\nimport offset from ''./offset'';\nimport preventOverflow
    from ''./preventOverflow'';\nimport shift from ''./shift'';\nimport hide from
    ''./hide'';\nimport inner from ''./inner'';\n\n/**\n * Modifier function, each
    modifier can have a function of this type assigned\n * to its `fn` property.<br
    />\n * These functions will be called on each update, this means that you must\n
    * make sure they are performant enough to avoid performance bottlenecks.\n *\n
    * @function ModifierFn\n * @argument {dataObject} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n
    * Modifiers are plugins used to alter the behavior of your poppers.<br />\n *
    Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n
    * needed by the library.\n *\n * Usually you don''t want to override the `order`,
    `fn` and `onLoad` props.\n * All the other properties are configurations that
    could be tweaked.\n * @namespace modifiers\n */\nexport default {\n  /**\n   *
    Modifier used to shift the popper on the start or end of its reference\n   * element.<br
    />\n   * It will read the variation of the `placement` property.<br />\n   * It
    can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift:
    {\n    /** @prop {number} order=100 - Index used to define the order of execution
    */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier
    is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn:
    shift,\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both
    its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less,
    interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of
    the reference element\n   * - `%p`, percentage relative to the length of the popper
    element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height
    unit\n   *\n   * For length is intended the main axis relative to the placement
    of the popper.<br />\n   * This means that if the placement is `top` or `bottom`,
    the length will be the\n   * `width`. In case of `left` or `right`, it will be
    the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`),
    or a pair of values\n   * as `String` divided by a comma or one (or more) white
    spaces.<br />\n   * The latter is a deprecated method because it leads to confusion
    and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions
    and subtractions between different units.\n   * Note that multiplications and
    divisions aren''t supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   *
    ''10%''\n   * ''10, 10''\n   * ''10%, 10''\n   * ''10 + 10%''\n   * ''10 - 5vh
    + 3%''\n   * ''-10px + 5vh, 5px - 6%''\n   * ```\n   * > **NB**: If you desire
    to apply offsets to your poppers in a way that may make them overlap\n   * > with
    their reference element, unfortunately, you will have to disable the `flip` modifier.\n   *
    > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200
    - Index used to define the order of execution */\n    order: 200,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String}
    offset=0\n     * The offset value as described in the modifier description\n     */\n    offset:
    0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned
    outside the boundary.\n   *\n   * A scenario exists where the reference itself
    is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"
    — or just \"escaped\".<br />\n   * In this case we need to decide whether the
    popper should either:\n   *\n   * - detach from the reference and remain \"trapped\"
    in the boundaries, or\n   * - if it should ignore the boundary and \"escape with
    its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference
    is completely\n   * outside its boundaries, the popper will overflow (or completely
    leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number}
    order=300 - Index used to define the order of execution */\n    order: 300,\n    /**
    @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]\n     * Popper
    will try to prevent overflow following these priorities by default,\n     * then,
    it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    [''left'', ''right'', ''top'', ''bottom''],\n    /**\n     * @prop {number} padding=5\n     *
    Amount of pixel used to define a minimum distance between the boundaries\n     *
    and the popper. This makes sure the popper always has a little padding\n     *
    between the edges of its container\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''scrollParent''\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: ''scrollParent'',\n  },\n\n  /**\n   *
    Modifier used to make sure the reference and its popper stay near each other\n   *
    without leaving any gap between the two. Especially useful when the arrow is\n   *
    enabled and you want to ensure that it points to its reference element.\n   *
    It cares only about the first axis. You can still have poppers with margin\n   *
    between the popper and its reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used
    to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier
    is used to move the `arrowElement` of the popper to make\n   * sure it is positioned
    between the reference element and its popper element.\n   * It will read the outer
    size of the `arrowElement` node to detect how many\n   * pixels of conjunction
    are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   *
    @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500
    - Index used to define the order of execution */\n    order: 500,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement}
    element=''[x-arrow]'' - Selector or node used as arrow */\n    element: ''[x-arrow]'',\n  },\n\n  /**\n   *
    Modifier used to flip the popper''s placement when it starts to overlap its\n   *
    reference element.\n   *\n   * Requires the `preventOverflow` modifier before
    it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current
    update cycle and will\n   * restart it if it detects the need to flip the placement.\n   *
    @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600
    - Index used to define the order of execution */\n    order: 600,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array}
    behavior=''flip''\n     * The behavior used to change the popper''s placement.
    It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with
    a list of valid\n     * placements (with optional variations)\n     */\n    behavior:
    ''flip'',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip
    if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''viewport''\n     * The element
    which will define the boundaries of the popper position.\n     * The popper will
    never be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: ''viewport'',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariations:
    false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     *
    The popper will switch placement variation between `-start` and `-end` when\n     *
    the popper element overlaps its reference boundaries.\n     *\n     * The original
    placement should have a set variation.\n     */\n    flipVariationsByContent:
    false,\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define
    the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false
    - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop
    {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the
    popper when its reference element is outside of the\n   * popper boundaries. It
    will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with
    a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   *
    Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof
    modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index
    used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that
    will be applied to the popper element to gets\n   * properly positioned.\n   *\n   *
    Note that this modifier will not touch the DOM, it just prepares the styles\n   *
    so that `applyStyle` modifier can apply it. This separation is useful\n   * in
    case you need to replace `applyStyle` with a custom implementation.\n   *\n   *
    This modifier has `850` as `order` value to maintain backward compatibility\n   *
    with previous versions of Popper.js. Expect the modifiers ordering method\n   *
    to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used
    to define the order of execution */\n    order: 850,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean}
    gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position
    the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    true,\n    /**\n     * @prop {string} [x=''bottom'']\n     * Where to anchor the
    X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper
    should grow in a direction different from `bottom`\n     */\n    x: ''bottom'',\n    /**\n     *
    @prop {string} [x=''left'']\n     * Where to anchor the Y axis (`left` or `right`).
    AKA Y offset origin.\n     * Change this if your popper should grow in a direction
    different from `right`\n     */\n    y: ''right'',\n  },\n\n  /**\n   * Applies
    the computed styles to the popper element.\n   *\n   * All the DOM manipulations
    are limited to this modifier. This is useful in case\n   * you want to integrate
    Popper.js inside a framework or view library and you\n   * want to delegate all
    the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier,
    you must make sure the popper element\n   * has its position set to `absolute`
    before Popper.js can do its work!\n   *\n   * Just disable this modifier and define
    your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used
    to define the order of execution */\n    order: 900,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad:
    applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property
    moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     *
    If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n
    * The `dataObject` is an object containing all the information used by Popper.js.\n
    * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n
    * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n
    * @property {String} data.placement Placement applied to popper\n * @property
    {String} data.originalPlacement Placement originally defined on init\n * @property
    {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property
    {Boolean} data.hide True if the reference element is out of boundaries, useful
    to know when to hide the popper\n * @property {HTMLElement} data.arrowElement
    Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS
    property defined here will be applied to the popper. It expects the JavaScript
    nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any
    CSS property defined here will be applied to the popper arrow. It expects the
    JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n","import
    modifiers from ''../modifiers/index'';\n\n/**\n * Default options provided to
    Popper.js constructor.<br />\n * These can be overridden using the `options` argument
    of Popper.js.<br />\n * To override an option, simply pass an object with the
    same\n * structure of the `options` object, as the 3rd argument. For example:\n
    * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: {
    enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof
    Popper\n */\nexport default {\n  /**\n   * Popper''s placement.\n   * @prop {Popper.placements}
    placement=''bottom''\n   */\n  placement: ''bottom'',\n\n  /**\n   * Set this
    to true if you want popper to position it self in ''fixed'' mode\n   * @prop {Boolean}
    positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events
    (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled:
    true,\n\n  /**\n   * Set to true if you want to automatically remove the popper
    when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called
    when the popper is updated. This callback is not called\n   * on the initialization/creation
    of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it
    is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers
    used to modify the offsets before they are applied to the popper.\n   * They provide
    most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n
    * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n
    * @param {dataObject} data\n */\n","// Utils\nimport debounce from ''./utils/debounce'';\nimport
    isFunction from ''./utils/isFunction'';\n\n// Methods\nimport update from ''./methods/update'';\nimport
    destroy from ''./methods/destroy'';\nimport enableEventListeners from ''./methods/enableEventListeners'';\nimport
    disableEventListeners from ''./methods/disableEventListeners'';\nimport Defaults
    from ''./methods/defaults'';\nimport placements from ''./methods/placements'';\n\nexport
    default class Popper {\n  /**\n   * Creates a new Popper.js instance.\n   * @class
    Popper\n   * @param {Element|referenceObject} reference - The reference element
    used to position the popper\n   * @param {Element} popper - The HTML / XML element
    used as the popper\n   * @param {Object} options - Your custom options to override
    the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The
    generated Popper.js instance\n   */\n  constructor(reference, popper, options
    = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update
    = debounce(this.update.bind(this));\n\n    // with {} we create a new object with
    the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    //
    init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents:
    [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference
    = reference && reference.jquery ? reference[0] : reference;\n    this.popper =
    popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name
    => {\n      this.options.modifiers[name] = {\n        // If it''s a built-in modifier,
    use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        //
    If there are custom options, override and merge with default ones\n        ...(options.modifiers
    ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers''
    list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name
    => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      //
    sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    //
    modifiers have the ability to execute arbitrary code when Popper.js get inited\n    //
    such code is executed in the same order of its modifier\n    // they could add
    new properties to their options configuration\n    // BE AWARE: don''t add options
    to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions
    => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad))
    {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    //
    fire the first update to position the popper in the right place\n    this.update();\n\n    const
    eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      //
    setup event listeners, they will take care of update the position in specific
    situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can''t use class properties because they don''t
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update()
    {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners()
    {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners()
    {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedules
    an update. It will run on the next UI update available.\n   * @method scheduleUpdate\n   *
    @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   *
    Collection of utilities useful when writing custom modifiers.\n   * Starting from
    version 1.7, this method is available only if you\n   * include `popper-utils.js`
    before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils
    is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly
    instead.\n   * Due to the high instability of the methods contained in Utils,
    we can''t\n   * guarantee them to follow semver. Use them at your own risk!\n   *
    @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   *
    @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !==
    ''undefined'' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static
    Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides
    an interface compatible with Popper.js\n * and lets you use it as replacement
    of a real DOM node.<br />\n * You can use this method to position a popper relatively
    to a set of coordinates\n * in case you don''t have a DOM node to use as reference.\n
    *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This
    feature isn''t supported in Internet Explorer 10.\n * @name referenceObject\n
    * @property {Function} data.getBoundingClientRect\n * A function that returns
    a set of coordinates compatible with the native `getBoundingClientRect` method.\n
    * @property {number} data.clientWidth\n * An ES6 getter that will return the width
    of the virtual reference element.\n * @property {number} data.clientHeight\n *
    An ES6 getter that will return the height of the virtual reference element.\n
    */\n"],"names":["window","document","navigator","timeoutDuration","longerTimeoutBrowsers","i","length","isBrowser","userAgent","indexOf","microtaskDebounce","fn","called","Promise","resolve","then","taskDebounce","scheduled","supportsMicroTasks","isFunction","functionToCheck","getType","toString","call","getStyleComputedProperty","element","property","nodeType","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","body","overflow","overflowX","overflowY","test","getReferenceNode","reference","referenceNode","isIE11","MSInputMethodContext","documentMode","isIE10","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","parseInt","getWindowSizes","getClientRect","offsets","width","height","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","isPaddingNumber","getArea","computeAutoPlacement","placement","refRect","rects","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","variation","split","getReferenceOffsets","state","commonOffsetParent","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","runModifiers","modifiers","data","ends","modifiersToRun","undefined","slice","forEach","warn","enabled","update","isDestroyed","options","positionFixed","flip","originalPlacement","position","isCreated","onCreate","onUpdate","isModifierEnabled","modifierName","some","name","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","prefix","toCheck","style","destroy","removeAttribute","willChange","disableEventListeners","removeOnDestroy","removeChild","getWindow","attachToScrollParents","event","callback","scrollParents","isBody","target","addEventListener","passive","push","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","removeEventListener","isNumeric","n","isNaN","isFinite","setStyles","unit","setAttributes","attributes","setAttribute","applyStyle","instance","arrowElement","arrowStyles","applyStyleOnLoad","modifierOptions","getRoundedOffsets","shouldRound","round","floor","noRound","v","referenceWidth","popperWidth","isVertical","isVariation","sameWidthParity","bothOddWidth","horizontalToInteger","verticalToInteger","isFirefox","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","devicePixelRatio","prefixedProperty","invertTop","invertLeft","arrow","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","querySelector","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","getOppositeVariation","validPlacements","placements","clockwise","counter","index","concat","reverse","BEHAVIORS","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariationByRef","flipVariations","flippedVariationByContent","flipVariationsByContent","flippedVariation","keepTogether","toValue","str","size","parseOffset","basePlacement","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","transformProp","popperStyles","transform","priority","escapeWithReference","shift","shiftvariation","shiftOffsets","hide","bound","inner","subtractLength","Popper","requestAnimationFrame","debounce","bind","Defaults","jquery","onLoad","Utils","global","PopperUtils"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-popper.min.js: |
    /*
     Copyright (C) Federico Zivolo 2020
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */var e='undefined'!=typeof window&&'undefined'!=typeof document&&'undefined'!=typeof navigator;const t=function(){const t=['Edge','Trident','Firefox'];for(let o=0;o<t.length;o+=1)if(e&&0<=navigator.userAgent.indexOf(t[o]))return 1;return 0}();function o(e){let t=!1;return()=>{t||(t=!0,window.Promise.resolve().then(()=>{t=!1,e()}))}}function n(e){let o=!1;return()=>{o||(o=!0,setTimeout(()=>{o=!1,e()},t))}}const i=e&&window.Promise;var r=i?o:n;function p(e){return e&&'[object Function]'==={}.toString.call(e)}function d(e,t){if(1!==e.nodeType)return[];const o=e.ownerDocument.defaultView,n=o.getComputedStyle(e,null);return t?n[t]:n}function s(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function f(e){if(!e)return document.body;switch(e.nodeName){case'HTML':case'BODY':return e.ownerDocument.body;case'#document':return e.body;}const{overflow:t,overflowX:o,overflowY:n}=d(e);return /(auto|scroll|overlay)/.test(t+n+o)?e:f(s(e))}function a(e){return e&&e.referenceNode?e.referenceNode:e}const l=e&&!!(window.MSInputMethodContext&&document.documentMode),m=e&&/MSIE 10/.test(navigator.userAgent);function h(e){return 11===e?l:10===e?m:l||m}function c(e){if(!e)return document.documentElement;const t=h(10)?document.body:null;let o=e.offsetParent||null;for(;o===t&&e.nextElementSibling;)o=(e=e.nextElementSibling).offsetParent;const n=o&&o.nodeName;return n&&'BODY'!==n&&'HTML'!==n?-1!==['TH','TD','TABLE'].indexOf(o.nodeName)&&'static'===d(o,'position')?c(o):o:e?e.ownerDocument.documentElement:document.documentElement}function u(e){const{nodeName:t}=e;return'BODY'!==t&&('HTML'===t||c(e.firstElementChild)===e)}function g(e){return null===e.parentNode?e:g(e.parentNode)}function b(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return document.documentElement;const o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,n=o?e:t,i=o?t:e,r=document.createRange();r.setStart(n,0),r.setEnd(i,0);const{commonAncestorContainer:p}=r;if(e!==p&&t!==p||n.contains(i))return u(p)?p:c(p);const d=g(e);return d.host?b(d.host,t):b(e,g(t).host)}function w(e,t='top'){const o='top'===t?'scrollTop':'scrollLeft',n=e.nodeName;if('BODY'===n||'HTML'===n){const t=e.ownerDocument.documentElement,n=e.ownerDocument.scrollingElement||t;return n[o]}return e[o]}function y(e,t,o=!1){const n=w(t,'top'),i=w(t,'left'),r=o?-1:1;return e.top+=n*r,e.bottom+=n*r,e.left+=i*r,e.right+=i*r,e}function E(e,t){const o='x'===t?'Left':'Top',n='Left'==o?'Right':'Bottom';return parseFloat(e[`border${o}Width`])+parseFloat(e[`border${n}Width`])}function x(e,t,o,n){return Math.max(t[`offset${e}`],t[`scroll${e}`],o[`client${e}`],o[`offset${e}`],o[`scroll${e}`],h(10)?parseInt(o[`offset${e}`])+parseInt(n[`margin${'Height'===e?'Top':'Left'}`])+parseInt(n[`margin${'Height'===e?'Bottom':'Right'}`]):0)}function v(e){const t=e.body,o=e.documentElement,n=h(10)&&getComputedStyle(o);return{height:x('Height',t,o,n),width:x('Width',t,o,n)}}var O=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e};function L(e){return O({},e,{right:e.left+e.width,bottom:e.top+e.height})}function S(e){let t={};try{if(h(10)){t=e.getBoundingClientRect();const o=w(e,'top'),n=w(e,'left');t.top+=o,t.left+=n,t.bottom+=o,t.right+=n}else t=e.getBoundingClientRect()}catch(t){}const o={left:t.left,top:t.top,width:t.right-t.left,height:t.bottom-t.top},n='HTML'===e.nodeName?v(e.ownerDocument):{},i=n.width||e.clientWidth||o.width,r=n.height||e.clientHeight||o.height;let p=e.offsetWidth-i,s=e.offsetHeight-r;if(p||s){const t=d(e);p-=E(t,'x'),s-=E(t,'y'),o.width-=p,o.height-=s}return L(o)}function T(e,t,o=!1){var n=Math.max;const i=h(10),r='HTML'===t.nodeName,p=S(e),s=S(t),a=f(e),l=d(t),m=parseFloat(l.borderTopWidth),c=parseFloat(l.borderLeftWidth);o&&r&&(s.top=n(s.top,0),s.left=n(s.left,0));let u=L({top:p.top-s.top-m,left:p.left-s.left-c,width:p.width,height:p.height});if(u.marginTop=0,u.marginLeft=0,!i&&r){const e=parseFloat(l.marginTop),t=parseFloat(l.marginLeft);u.top-=m-e,u.bottom-=m-e,u.left-=c-t,u.right-=c-t,u.marginTop=e,u.marginLeft=t}return(i&&!o?t.contains(a):t===a&&'BODY'!==a.nodeName)&&(u=y(u,t)),u}function D(e,t=!1){var o=Math.max;const n=e.ownerDocument.documentElement,i=T(e,n),r=o(n.clientWidth,window.innerWidth||0),p=o(n.clientHeight,window.innerHeight||0),d=t?0:w(n),s=t?0:w(n,'left'),f={top:d-i.top+i.marginTop,left:s-i.left+i.marginLeft,width:r,height:p};return L(f)}function C(e){const t=e.nodeName;if('BODY'===t||'HTML'===t)return!1;if('fixed'===d(e,'position'))return!0;const o=s(e);return!!o&&C(o)}function N(e){if(!e||!e.parentElement||h())return document.documentElement;let t=e.parentElement;for(;t&&'none'===d(t,'transform');)t=t.parentElement;return t||document.documentElement}function P(e,t,o,n,i=!1){let r={top:0,left:0};const p=i?N(e):b(e,a(t));if('viewport'===n)r=D(p,i);else{let o;'scrollParent'===n?(o=f(s(t)),'BODY'===o.nodeName&&(o=e.ownerDocument.documentElement)):'window'===n?o=e.ownerDocument.documentElement:o=n;const d=T(o,p,i);if('HTML'===o.nodeName&&!C(p)){const{height:t,width:o}=v(e.ownerDocument);r.top+=d.top-d.marginTop,r.bottom=t+d.top,r.left+=d.left-d.marginLeft,r.right=o+d.left}else r=d}o=o||0;const d='number'==typeof o;return r.left+=d?o:o.left||0,r.top+=d?o:o.top||0,r.right-=d?o:o.right||0,r.bottom-=d?o:o.bottom||0,r}function B({width:e,height:t}){return e*t}function H(e,t,o,n,i,r=0){if(-1===e.indexOf('auto'))return e;const p=P(o,n,r,i),d={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},s=Object.keys(d).map((e)=>O({key:e},d[e],{area:B(d[e])})).sort((e,t)=>t.area-e.area),f=s.filter(({width:e,height:t})=>e>=o.clientWidth&&t>=o.clientHeight),a=0<f.length?f[0].key:s[0].key,l=e.split('-')[1];return a+(l?`-${l}`:'')}function W(e,t,o,n=null){const i=n?N(t):b(t,a(o));return T(o,i,n)}function k(e){const t=e.ownerDocument.defaultView,o=t.getComputedStyle(e),n=parseFloat(o.marginTop||0)+parseFloat(o.marginBottom||0),i=parseFloat(o.marginLeft||0)+parseFloat(o.marginRight||0),r={width:e.offsetWidth+i,height:e.offsetHeight+n};return r}function A(e){const t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,(e)=>t[e])}function M(e,t,o){o=o.split('-')[0];const n=k(e),i={width:n.width,height:n.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',d=r?'left':'top',s=r?'height':'width',f=r?'width':'height';return i[p]=t[p]+t[s]/2-n[s]/2,i[d]=o===d?t[d]-n[f]:t[A(d)],i}function F(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function I(e,t,o){if(Array.prototype.findIndex)return e.findIndex((e)=>e[t]===o);const n=F(e,(e)=>e[t]===o);return e.indexOf(n)}function R(e,t,o){const n=void 0===o?e:e.slice(0,I(e,'name',o));return n.forEach((e)=>{e['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');const o=e['function']||e.fn;e.enabled&&p(o)&&(t.offsets.popper=L(t.offsets.popper),t.offsets.reference=L(t.offsets.reference),t=o(t,e))}),t}function U(){if(this.state.isDestroyed)return;let e={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=W(this.state,this.popper,this.reference,this.options.positionFixed),e.placement=H(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.positionFixed=this.options.positionFixed,e.offsets.popper=M(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position=this.options.positionFixed?'fixed':'absolute',e=R(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}function Y(e,t){return e.some(({name:e,enabled:o})=>o&&e===t)}function V(e){const t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1);for(let n=0;n<t.length;n++){const i=t[n],r=i?`${i}${o}`:e;if('undefined'!=typeof document.body.style[r])return r}return null}function j(){return this.state.isDestroyed=!0,Y(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.position='',this.popper.style.top='',this.popper.style.left='',this.popper.style.right='',this.popper.style.bottom='',this.popper.style.willChange='',this.popper.style[V('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function K(e){const t=e.ownerDocument;return t?t.defaultView:window}function q(e,t,o,n){const i='BODY'===e.nodeName,r=i?e.ownerDocument.defaultView:e;r.addEventListener(t,o,{passive:!0}),i||q(f(r.parentNode),t,o,n),n.push(r)}function z(e,t,o,n){o.updateBound=n,K(e).addEventListener('resize',o.updateBound,{passive:!0});const i=f(e);return q(i,'scroll',o.updateBound,o.scrollParents),o.scrollElement=i,o.eventsEnabled=!0,o}function G(){this.state.eventsEnabled||(this.state=z(this.reference,this.options,this.state,this.scheduleUpdate))}function _(e,t){return K(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach((e)=>{e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function X(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=_(this.reference,this.state))}function J(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function Q(e,t){Object.keys(t).forEach((o)=>{let n='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&J(t[o])&&(n='px'),e.style[o]=t[o]+n})}function Z(e,t){Object.keys(t).forEach(function(o){const n=t[o];!1===n?e.removeAttribute(o):e.setAttribute(o,t[o])})}function $(e){return Q(e.instance.popper,e.styles),Z(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&Q(e.arrowElement,e.arrowStyles),e}function ee(e,t,o,n,i){const r=W(i,t,e,o.positionFixed),p=H(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),Q(t,{position:o.positionFixed?'fixed':'absolute'}),o}function te(e,t){const{popper:o,reference:n}=e.offsets,{round:i,floor:r}=Math,p=(e)=>e,d=i(n.width),s=i(o.width),f=-1!==['left','right'].indexOf(e.placement),a=-1!==e.placement.indexOf('-'),l=t?f||a||d%2==s%2?i:r:p,m=t?i:p;return{left:l(1==d%2&&1==s%2&&!a&&t?o.left-1:o.left),top:m(o.top),bottom:m(o.bottom),right:l(o.right)}}const oe=e&&/Firefox/i.test(navigator.userAgent);function ne(e,t){const{x:o,y:n}=t,{popper:i}=e.offsets,r=F(e.instance.modifiers,(e)=>'applyStyle'===e.name).gpuAcceleration;void 0!==r&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');const p=void 0===r?t.gpuAcceleration:r,d=c(e.instance.popper),s=S(d),f={position:i.position},a=te(e,2>window.devicePixelRatio||!oe),l='bottom'===o?'top':'bottom',m='right'===n?'left':'right',h=V('transform');let u,g;if(g='bottom'==l?'HTML'===d.nodeName?-d.clientHeight+a.bottom:-s.height+a.bottom:a.top,u='right'==m?'HTML'===d.nodeName?-d.clientWidth+a.right:-s.width+a.right:a.left,p&&h)f[h]=`translate3d(${u}px, ${g}px, 0)`,f[l]=0,f[m]=0,f.willChange='transform';else{const e='bottom'==l?-1:1,t='right'==m?-1:1;f[l]=g*e,f[m]=u*t,f.willChange=`${l}, ${m}`}const b={"x-placement":e.placement};return e.attributes=O({},b,e.attributes),e.styles=O({},f,e.styles),e.arrowStyles=O({},e.offsets.arrow,e.arrowStyles),e}function ie(e,t,o){const n=F(e,({name:e})=>e===t),i=!!n&&e.some((e)=>e.name===o&&e.enabled&&e.order<n.order);if(!i){const e=`\`${t}\``,n=`\`${o}\``;console.warn(`${n} modifier is required by ${e} modifier in order to work, be sure to include it before ${e}!`)}return i}function re(e,t){if(!ie(e.instance.modifiers,'arrow','keepTogether'))return e;let o=t.element;if('string'==typeof o){if(o=e.instance.popper.querySelector(o),!o)return e;}else if(!e.instance.popper.contains(o))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;const n=e.placement.split('-')[0],{popper:i,reference:r}=e.offsets,p=-1!==['left','right'].indexOf(n),s=p?'height':'width',f=p?'Top':'Left',a=f.toLowerCase(),l=p?'left':'top',m=p?'bottom':'right',h=k(o)[s];r[m]-h<i[a]&&(e.offsets.popper[a]-=i[a]-(r[m]-h)),r[a]+h>i[m]&&(e.offsets.popper[a]+=r[a]+h-i[m]),e.offsets.popper=L(e.offsets.popper);const c=r[a]+r[s]/2-h/2,u=d(e.instance.popper),g=parseFloat(u[`margin${f}`]),b=parseFloat(u[`border${f}Width`]);let w=c-e.offsets.popper[a]-g-b;return w=Math.max(Math.min(i[s]-h,w),0),e.arrowElement=o,e.offsets.arrow={[a]:Math.round(w),[l]:''},e}function pe(e){if('end'===e)return'start';return'start'===e?'end':e}var de=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'];const se=de.slice(3);function fe(e,t=!1){const o=se.indexOf(e),n=se.slice(o+1).concat(se.slice(0,o));return t?n.reverse():n}const ae={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'};function le(e,t){if(Y(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;const o=P(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement,e.positionFixed);let n=e.placement.split('-')[0],i=A(n),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case ae.FLIP:p=[n,i];break;case ae.CLOCKWISE:p=fe(n);break;case ae.COUNTERCLOCKWISE:p=fe(n,!0);break;default:p=t.behavior;}return p.forEach((d,s)=>{if(n!==d||p.length===s+1)return e;n=e.placement.split('-')[0],i=A(n);const f=e.offsets.popper,a=e.offsets.reference,l=Math.floor,m='left'===n&&l(f.right)>l(a.left)||'right'===n&&l(f.left)<l(a.right)||'top'===n&&l(f.bottom)>l(a.top)||'bottom'===n&&l(f.top)<l(a.bottom),h=l(f.left)<l(o.left),c=l(f.right)>l(o.right),u=l(f.top)<l(o.top),g=l(f.bottom)>l(o.bottom),b='left'===n&&h||'right'===n&&c||'top'===n&&u||'bottom'===n&&g,w=-1!==['top','bottom'].indexOf(n),y=!!t.flipVariations&&(w&&'start'===r&&h||w&&'end'===r&&c||!w&&'start'===r&&u||!w&&'end'===r&&g),E=!!t.flipVariationsByContent&&(w&&'start'===r&&c||w&&'end'===r&&h||!w&&'start'===r&&g||!w&&'end'===r&&u),x=y||E;(m||b||x)&&(e.flipped=!0,(m||b)&&(n=p[s+1]),x&&(r=pe(r)),e.placement=n+(r?'-'+r:''),e.offsets.popper=O({},e.offsets.popper,M(e.instance.popper,e.offsets.reference,e.placement)),e=R(e.instance.modifiers,e,'flip'))}),e}function me(e){const{popper:t,reference:o}=e.offsets,n=e.placement.split('-')[0],i=Math.floor,r=-1!==['top','bottom'].indexOf(n),p=r?'right':'bottom',d=r?'left':'top',s=r?'width':'height';return t[p]<i(o[d])&&(e.offsets.popper[d]=i(o[d])-t[s]),t[d]>i(o[p])&&(e.offsets.popper[d]=i(o[p])),e}function he(e,t,o,n){var i=Math.max;const r=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),p=+r[1],d=r[2];if(!p)return e;if(0===d.indexOf('%')){let e;switch(d){case'%p':e=o;break;case'%':case'%r':default:e=n;}const i=L(e);return i[t]/100*p}if('vh'===d||'vw'===d){let e;return e='vh'===d?i(document.documentElement.clientHeight,window.innerHeight||0):i(document.documentElement.clientWidth,window.innerWidth||0),e/100*p}return p}function ce(e,t,o,n){const i=[0,0],r=-1!==['right','left'].indexOf(n),p=e.split(/(\+|\-)/).map((e)=>e.trim()),d=p.indexOf(F(p,(e)=>-1!==e.search(/,|\s/)));p[d]&&-1===p[d].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');const s=/\s*,\s*|\s+/;let f=-1===d?[p]:[p.slice(0,d).concat([p[d].split(s)[0]]),[p[d].split(s)[1]].concat(p.slice(d+1))];return f=f.map((e,n)=>{const i=(1===n?!r:r)?'height':'width';let p=!1;return e.reduce((e,t)=>''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t),[]).map((e)=>he(e,i,t,o))}),f.forEach((e,t)=>{e.forEach((o,n)=>{J(o)&&(i[t]+=o*('-'===e[n-1]?-1:1))})}),i}function ue(e,{offset:t}){const{placement:o,offsets:{popper:n,reference:i}}=e,r=o.split('-')[0];let p;return p=J(+t)?[+t,0]:ce(t,n,i,r),'left'===r?(n.top+=p[0],n.left-=p[1]):'right'===r?(n.top+=p[0],n.left+=p[1]):'top'===r?(n.left+=p[0],n.top-=p[1]):'bottom'===r&&(n.left+=p[0],n.top+=p[1]),e.popper=n,e}function ge(e,t){let o=t.boundariesElement||c(e.instance.popper);e.instance.reference===o&&(o=c(o));const n=V('transform'),i=e.instance.popper.style,{top:r,left:p,[n]:d}=i;i.top='',i.left='',i[n]='';const s=P(e.instance.popper,e.instance.reference,t.padding,o,e.positionFixed);i.top=r,i.left=p,i[n]=d,t.boundaries=s;const f=t.priority;let a=e.offsets.popper;const l={primary(e){let o=a[e];return a[e]<s[e]&&!t.escapeWithReference&&(o=Math.max(a[e],s[e])),{[e]:o}},secondary(e){const o='right'===e?'left':'top';let n=a[o];return a[e]>s[e]&&!t.escapeWithReference&&(n=Math.min(a[o],s[e]-('right'===e?a.width:a.height))),{[o]:n}}};return f.forEach((e)=>{const t=-1===['left','top'].indexOf(e)?'secondary':'primary';a=O({},a,l[t](e))}),e.offsets.popper=a,e}function be(e){const t=e.placement,o=t.split('-')[0],n=t.split('-')[1];if(n){const{reference:t,popper:i}=e.offsets,r=-1!==['bottom','top'].indexOf(o),p=r?'left':'top',d=r?'width':'height',s={start:{[p]:t[p]},end:{[p]:t[p]+t[d]-i[d]}};e.offsets.popper=O({},i,s[n])}return e}function we(e){if(!ie(e.instance.modifiers,'hide','preventOverflow'))return e;const t=e.offsets.reference,o=F(e.instance.modifiers,(e)=>'preventOverflow'===e.name).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}function ye(e){const t=e.placement,o=t.split('-')[0],{popper:n,reference:i}=e.offsets,r=-1!==['left','right'].indexOf(o),p=-1===['top','left'].indexOf(o);return n[r?'left':'top']=i[o]-(p?n[r?'width':'height']:0),e.placement=A(t),e.offsets.popper=L(n),e}var Ee={shift:{order:100,enabled:!0,fn:be},offset:{order:200,enabled:!0,fn:ue,offset:0},preventOverflow:{order:300,enabled:!0,fn:ge,priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:me},arrow:{order:500,enabled:!0,fn:re,element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:le,behavior:'flip',padding:5,boundariesElement:'viewport',flipVariations:!1,flipVariationsByContent:!1},inner:{order:700,enabled:!1,fn:ye},hide:{order:800,enabled:!0,fn:we},computeStyle:{order:850,enabled:!0,fn:ne,gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:$,onLoad:ee,gpuAcceleration:void 0}},xe={placement:'bottom',positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:()=>{},onUpdate:()=>{},modifiers:Ee};class ve{constructor(e,t,o={}){this.scheduleUpdate=()=>requestAnimationFrame(this.update),this.update=r(this.update.bind(this)),this.options=O({},ve.Defaults,o),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=e&&e.jquery?e[0]:e,this.popper=t&&t.jquery?t[0]:t,this.options.modifiers={},Object.keys(O({},ve.Defaults.modifiers,o.modifiers)).forEach((e)=>{this.options.modifiers[e]=O({},ve.Defaults.modifiers[e]||{},o.modifiers?o.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map((e)=>O({name:e},this.options.modifiers[e])).sort((e,t)=>e.order-t.order),this.modifiers.forEach((e)=>{e.enabled&&p(e.onLoad)&&e.onLoad(this.reference,this.popper,this.options,e,this.state)}),this.update();const n=this.options.eventsEnabled;n&&this.enableEventListeners(),this.state.eventsEnabled=n}update(){return U.call(this)}destroy(){return j.call(this)}enableEventListeners(){return G.call(this)}disableEventListeners(){return X.call(this)}}ve.Utils=('undefined'==typeof window?global:window).PopperUtils,ve.placements=de,ve.Defaults=xe;export default ve;
    //# sourceMappingURL=popper.min.js.map
  admin-Public-Admin-plugins-popper-popper.min.js.map: '{"version":3,"file":"popper.min.js","sources":["../src/utils/isBrowser.js","../src/utils/debounce.js","../src/utils/isFunction.js","../src/utils/getStyleComputedProperty.js","../src/utils/getParentNode.js","../src/utils/getScrollParent.js","../src/utils/getReferenceNode.js","../src/utils/isIE.js","../src/utils/getOffsetParent.js","../src/utils/isOffsetContainer.js","../src/utils/getRoot.js","../src/utils/findCommonOffsetParent.js","../src/utils/getScroll.js","../src/utils/includeScroll.js","../src/utils/getBordersSize.js","../src/utils/getWindowSizes.js","../src/utils/getClientRect.js","../src/utils/getBoundingClientRect.js","../src/utils/getOffsetRectRelativeToArbitraryNode.js","../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../src/utils/isFixed.js","../src/utils/getFixedPositionOffsetParent.js","../src/utils/getBoundaries.js","../src/utils/computeAutoPlacement.js","../src/utils/getReferenceOffsets.js","../src/utils/getOuterSizes.js","../src/utils/getOppositePlacement.js","../src/utils/getPopperOffsets.js","../src/utils/find.js","../src/utils/findIndex.js","../src/utils/runModifiers.js","../src/methods/update.js","../src/utils/isModifierEnabled.js","../src/utils/getSupportedPropertyName.js","../src/methods/destroy.js","../src/utils/getWindow.js","../src/utils/setupEventListeners.js","../src/methods/enableEventListeners.js","../src/utils/removeEventListeners.js","../src/methods/disableEventListeners.js","../src/utils/isNumeric.js","../src/utils/setStyles.js","../src/utils/setAttributes.js","../src/modifiers/applyStyle.js","../src/utils/getRoundedOffsets.js","../src/modifiers/computeStyle.js","../src/utils/isModifierRequired.js","../src/modifiers/arrow.js","../src/utils/getOppositeVariation.js","../src/methods/placements.js","../src/utils/clockwise.js","../src/modifiers/flip.js","../src/modifiers/keepTogether.js","../src/modifiers/offset.js","../src/modifiers/preventOverflow.js","../src/modifiers/shift.js","../src/modifiers/hide.js","../src/modifiers/inner.js","../src/modifiers/index.js","../src/methods/defaults.js","../src/index.js"],"sourcesContent":["export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n
    * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer
    to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const
    getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck)
    === ''[object Function]''\n  );\n}\n","/**\n * Get CSS computed property of the
    given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n
    * @argument {String} property\n */\nexport default function getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const
    css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName
    === ''HTML'') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getParentNode
    from ''./getParentNode'';\n\n/**\n * Returns the scrolling parent of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n
    * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element)
    {\n  // Return body, `getScroll` will take care to get the correct `scrollTop`
    from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName)
    {\n    case ''HTML'':\n    case ''BODY'':\n      return element.ownerDocument.body\n    case
    ''#document'':\n      return element.body\n  }\n\n  // Firefox want us to check
    `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } =
    getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow
    + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nexport default function getOuterSizes(element)
    {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const
    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const
    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  const
    result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the
    given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement)
    {\n  const hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom''
    };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import
    getOuterSizes from ''./getOuterSizes'';\nimport getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n
    * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param
    {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement}
    popper - the popper element\n * @param {Object} referenceOffsets - the reference
    offsets (the popper will be relative to this)\n * @param {String} placement -
    one of the valid placement options\n * @returns {Object} popperOffsets - An object
    containing the offsets which will be applied to the popper\n */\nexport default
    function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement
    = placement.split(''-'')[0];\n\n  // Get popper node sizes\n  const popperRect
    = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets
    object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  //
    depending by the popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function find(arr, check)
    {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    isFunction from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport
    getClientRect from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list
    of modifiers and run them in order,\n * each of them will then edit the data object.\n
    * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array}
    modifiers\n * @param {String} ends - Optional modifier name used as stopper\n
    * @returns {dataObject}\n */\nexport default function runModifiers(modifiers,
    data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    :
    modifiers.slice(0, findIndex(modifiers, ''name'', ends));\n\n  modifiersToRun.forEach(modifier
    => {\n    if (modifier[''function'']) { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","import computeAutoPlacement from ''../utils/computeAutoPlacement'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\n\n/**\n
    * Updates the position of the popper, computing the new offsets and applying\n
    * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance
    reasons.\n * @method\n * @memberof Popper\n */\nexport default function update()
    {\n  // if popper is destroyed, don''t perform any further update\n  if (this.state.isDestroyed)
    {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles:
    {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  //
    compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  //
    compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  //
    store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position
    = this.options.positionFixed\n    ? ''fixed''\n    : ''absolute'';\n\n  // run
    the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first
    `update` will call `onCreate` callback\n  // the other ones will call `onUpdate`
    callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  }
    else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know
    if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns
    {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName)
    {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from ''../utils/isModifierEnabled'';\nimport
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * Destroys the popper.\n * @method\n * @memberof Popper\n */\nexport default function
    destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle`
    modifier is enabled\n  if (isModifierEnabled(this.modifiers, ''applyStyle''))
    {\n    this.popper.removeAttribute(''x-placement'');\n    this.popper.style.position
    = '''';\n    this.popper.style.top = '''';\n    this.popper.style.left = '''';\n    this.popper.style.right
    = '''';\n    this.popper.style.bottom = '''';\n    this.popper.style.willChange
    = '''';\n    this.popper.style[getSupportedPropertyName(''transform'')] = '''';\n  }\n\n  this.disableEventListeners();\n\n  //
    remove the popper if user explicitly asked for the deletion on destroy\n  // do
    not use `remove` because IE11 doesn''t support it\n  if (this.options.removeOnDestroy)
    {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n
    * Get the window associated with the element\n * @argument {Element} element\n
    * @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getScrollParent from ''./getScrollParent'';\nimport getWindow
    from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  const isBody = scrollParent.nodeName === ''BODY'';\n  const
    target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    setupEventListeners from ''../utils/setupEventListeners'';\n\n/**\n * It will
    add resize/scroll events and start recalculating\n * position of the popper element
    when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default
    function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state
    = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import
    getWindow from ''./getWindow'';\n\n/**\n * Remove event listeners used to update
    the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport
    default function removeEventListeners(reference, state) {\n  // Remove resize
    event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners
    from ''../utils/removeEventListeners'';\n\n/**\n * It will remove resize/scroll
    events and won''t recalculate popper position\n * when they are triggered. It
    also won''t trigger `onUpdate` callback anymore,\n * unless you call `update`
    method manually.\n * @method\n * @memberof Popper\n */\nexport default function
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state
    = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nexport default
    function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop)
    {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    setStyles from ''../utils/setStyles'';\nimport setAttributes from ''../utils/setAttributes'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport computeAutoPlacement
    from ''../utils/computeAutoPlacement'';\n\n/**\n * @function\n * @memberof Modifiers\n
    * @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} data.styles - List of style properties - values to apply to popper element\n
    * @argument {Object} data.attributes - List of attribute properties - values to
    apply to popper element\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The same data object\n */\nexport default function
    applyStyle(data) {\n  // any property present in `data.styles` will be applied
    to the popper,\n  // in this way we can make the 3rd party modifiers add custom
    styles to it\n  // Be aware, modifiers could override the properties defined in
    the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper,
    data.styles);\n\n  // any property present in `data.attributes` will be applied
    to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper,
    data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some
    properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement,
    data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute
    before everything else because it could be used\n * to add margins to the popper
    margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n
    * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference
    element used to position the popper\n * @param {HTMLElement} popper - The HTML
    element used as popper\n * @param {Object} options - Popper.js options\n */\nexport
    function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n)
    {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state,
    popper, reference, options.positionFixed);\n\n  // compute auto placement, store
    placement inside the data object,\n  // modifiers will be able to edit `placement`
    if needed\n  // and refer to originalPlacement to know the original value\n  const
    placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute(''x-placement'',
    placement);\n\n  // Apply `position` to popper before anything else because\n  //
    without the position applied we can''t guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? ''fixed'' : ''absolute'' });\n\n  return options;\n}\n","/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper''s position
    offsets rounded\n *\n * The tale of pixel-perfect positioning. It''s still not
    100% perfect, but as\n * good as it can be within reason.\n * Discussion here:
    https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause
    a popper to be blurry if not using full pixels (Safari\n * as well on High DPI
    screens).\n *\n * Firefox prefers no rounding for positioning and does not have
    blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right
    values need to be considered.\n */\nexport default function getRoundedOffsets(data,
    shouldRound) {\n  const { popper, reference } = data.offsets;\n  const { round,
    floor } = Math;\n  const noRound = v => v;\n  \n  const referenceWidth = round(reference.width);\n  const
    popperWidth = round(popper.width);\n  \n  const isVertical = [''left'', ''right''].indexOf(data.placement)
    !== -1;\n  const isVariation = data.placement.indexOf(''-'') !== -1;\n  const
    sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  const bothOddWidth
    = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  const horizontalToInteger
    = !shouldRound\n    ? noRound\n    : isVertical || isVariation || sameWidthParity\n    ?
    round\n    : floor;\n  const verticalToInteger = !shouldRound ? noRound : round;\n\n  return
    {\n    left: horizontalToInteger(\n      bothOddWidth && !isVariation && shouldRound\n        ?
    popper.left - 1\n        : popper.left\n    ),\n    top: verticalToInteger(popper.top),\n    bottom:
    verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right),\n  };\n}\n","import
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\nimport find
    from ''../utils/find'';\nimport getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundingClientRect from ''../utils/getBoundingClientRect'';\nimport getRoundedOffsets
    from ''../utils/getRoundedOffsets'';\nimport isBrowser from ''../utils/isBrowser'';\n\nconst
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeStyle(data, options) {\n  const { x, y } = options;\n  const
    { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const
    legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''applyStyle''\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption
    !== undefined) {\n    console.warn(\n      ''WARNING: `gpuAcceleration` option
    moved to `computeStyle` modifier and will not be supported in future versions
    of Popper.js!''\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption
    !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const
    offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position:
    popper.position,\n  };\n\n  const offsets = getRoundedOffsets(\n    data,\n    window.devicePixelRatio
    < 2 || !isFirefox\n  );\n\n  const sideA = x === ''bottom'' ? ''top'' : ''bottom'';\n  const
    sideB = y === ''right'' ? ''left'' : ''right'';\n\n  // if gpuAcceleration is
    set to `true` and transform is supported,\n  //  we use `translate3d` to apply
    the position to the popper we\n  // automatically use the supported prefixed version
    if needed\n  const prefixedProperty = getSupportedPropertyName(''transform'');\n\n  //
    now, let''s make a step back and look at this code closely (wtf?)\n  // If the
    content of the popper grows once it''s been positioned, it\n  // may happen that
    the popper gets misplaced because of the new content\n  // overflowing its reference
    element\n  // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA ===
    ''bottom'') {\n    // when offsetParent is <html> the positioning is relative
    to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom
    of the html element\n    if (offsetParent.nodeName === ''HTML'') {\n      top
    = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height
    + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB
    === ''right'') {\n    if (offsetParent.nodeName === ''HTML'') {\n      left =
    -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width
    + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration
    && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px,
    ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange
    = ''transform'';\n  } else {\n    // othwerise, we use the standard `top`, `left`,
    `bottom` and `right` properties\n    const invertTop = sideA === ''bottom'' ?
    -1 : 1;\n    const invertLeft = sideB === ''right'' ? -1 : 1;\n    styles[sideA]
    = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange
    = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    ''x-placement'':
    data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles
    };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return
    data;\n}\n","import find from ''./find'';\n\n/**\n * Helper used to know if the
    given modifier depends from another one.<br />\n * It checks if the needed modifier
    is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array}
    modifiers - list of modifiers\n * @param {String} requestingName - name of requesting
    modifier\n * @param {String} requestedName - name of requested modifier\n * @returns
    {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","import getClientRect
    from ''../utils/getClientRect'';\nimport getOuterSizes from ''../utils/getOuterSizes'';\nimport
    isModifierRequired from ''../utils/isModifierRequired'';\nimport getStyleComputedProperty
    from ''../utils/getStyleComputedProperty'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by update method\n
    * @argument {Object} options - Modifiers configuration and options\n * @returns
    {Object} The data object, properly modified\n */\nexport default function arrow(data,
    options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers,
    ''arrow'', ''keepTogether'')) {\n    return data;\n  }\n\n  let arrowElement =
    options.element;\n\n  // if arrowElement is a string, suppose it''s a CSS selector\n  if
    (typeof arrowElement === ''string'') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    //
    if arrowElement is not found, don''t run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn''t a
    query selector we must check that the\n    // provided DOM node is child of its
    popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        ''WARNING:
    `arrow.element` must be child of its popper element!''\n      );\n      return
    data;\n    }\n  }\n\n  const placement = data.placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isVertical = [''left'', ''right''].indexOf(placement)
    !== -1;\n\n  const len = isVertical ? ''height'' : ''width'';\n  const sideCapitalized
    = isVertical ? ''Top'' : ''Left'';\n  const side = sideCapitalized.toLowerCase();\n  const
    altSide = isVertical ? ''left'' : ''top'';\n  const opSide = isVertical ? ''bottom''
    : ''right'';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  //
    extends keepTogether behavior making sure the popper and its\n  // reference have
    enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide]
    - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side]
    - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side]
    + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side]
    + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  //
    compute center of the popper\n  const center = reference[side] + reference[len]
    / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper
    offsets\n  // take popper margin in account because we don''t have this info available\n  const
    css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide
    = parseFloat(css[`margin${sideCapitalized}`]);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let
    sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  //
    prevent arrowElement from being placed not contiguously to its popper\n  sideValue
    = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement
    = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]:
    '''', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return
    data;\n}\n","/**\n * Get the opposite placement variation of the given one\n *
    @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n
    * @returns {String} flipped placement variation\n */\nexport default function
    getOppositeVariation(variation) {\n  if (variation === ''end'') {\n    return
    ''start'';\n  } else if (variation === ''start'') {\n    return ''end'';\n  }\n  return
    variation;\n}\n","/**\n * List of accepted placements to use as values of the
    `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n
    * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation
    from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted
    easily if you think of them as the left to right\n * written languages. Horizontally
    (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically
    (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples
    are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start`
    (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n *
    - `auto-end` (on the side with more space available, alignment depends by placement)\n
    *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n
    * @memberof Popper\n */\nexport default [\n  ''auto-start'',\n  ''auto'',\n  ''auto-end'',\n  ''top-start'',\n  ''top'',\n  ''top-end'',\n  ''right-start'',\n  ''right'',\n  ''right-end'',\n  ''bottom-end'',\n  ''bottom'',\n  ''bottom-start'',\n  ''left-end'',\n  ''left'',\n  ''left-start'',\n];\n","import
    placements from ''../methods/placements'';\n\n// Get rid of `auto` `auto-start`
    and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given
    an initial placement, returns all the subsequent placements\n * clockwise (or
    counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String}
    placement - A valid placement (it accepts variations)\n * @argument {Boolean}
    counter - Set to true to walk the placements counterclockwise\n * @returns {Array}
    placements including their variations\n */\nexport default function clockwise(placement,
    counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const
    arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0,
    index));\n  return counter ? arr.reverse() : arr;\n}\n","import getOppositePlacement
    from ''../utils/getOppositePlacement'';\nimport getOppositeVariation from ''../utils/getOppositeVariation'';\nimport
    getPopperOffsets from ''../utils/getPopperOffsets'';\nimport runModifiers from
    ''../utils/runModifiers'';\nimport getBoundaries from ''../utils/getBoundaries'';\nimport
    isModifierEnabled from ''../utils/isModifierEnabled'';\nimport clockwise from
    ''../utils/clockwise'';\n\nconst BEHAVIORS = {\n  FLIP: ''flip'',\n  CLOCKWISE:
    ''clockwise'',\n  COUNTERCLOCKWISE: ''counterclockwise'',\n};\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by update method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function flip(data, options) {\n  // if `inner` modifier is enabled, we
    can''t use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    ''inner'')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there''s not enough space on any of the flippable sides\n    return data;\n  }\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let
    placement = data.placement.split(''-'')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let
    variation = data.placement.split(''-'')[1] || '''';\n\n  let flipOrder = [];\n\n  switch
    (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder
    = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step,
    index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return
    data;\n    }\n\n    placement = data.placement.split(''-'')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const
    refOffsets = data.offsets.reference;\n\n    // using floor because the reference
    offsets may contain decimals we are not going to consider here\n    const floor
    = Math.floor;\n    const overlapsRef =\n      (placement === ''left'' &&\n        floor(popperOffsets.right)
    > floor(refOffsets.left)) ||\n      (placement === ''right'' &&\n        floor(popperOffsets.left)
    < floor(refOffsets.right)) ||\n      (placement === ''top'' &&\n        floor(popperOffsets.bottom)
    > floor(refOffsets.top)) ||\n      (placement === ''bottom'' &&\n        floor(popperOffsets.top)
    < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top)
    < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement
    === ''left'' && overflowsLeft) ||\n      (placement === ''right'' && overflowsRight)
    ||\n      (placement === ''top'' && overflowsTop) ||\n      (placement === ''bottom''
    && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical
    = [''top'', ''bottom''].indexOf(placement) !== -1;\n\n    // flips variation if
    reference element overflows boundaries\n    const flippedVariationByRef =\n      !!options.flipVariations
    &&\n      ((isVertical && variation === ''start'' && overflowsLeft) ||\n        (isVertical
    && variation === ''end'' && overflowsRight) ||\n        (!isVertical && variation
    === ''start'' && overflowsTop) ||\n        (!isVertical && variation === ''end''
    && overflowsBottom));\n\n    // flips variation if popper content overflows boundaries\n    const
    flippedVariationByContent =\n      !!options.flipVariationsByContent &&\n      ((isVertical
    && variation === ''start'' && overflowsRight) ||\n        (isVertical && variation
    === ''end'' && overflowsLeft) ||\n        (!isVertical && variation === ''start''
    && overflowsBottom) ||\n        (!isVertical && variation === ''end'' && overflowsTop));\n\n    const
    flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if
    (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean
    to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef ||
    overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if
    (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? ''-'' + variation : '''');\n\n      // this object
    contains `position`, we want to preserve it along with\n      // any additional
    property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data
    = runModifiers(data.instance.modifiers, data, ''flip'');\n    }\n  });\n  return
    data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nexport default function keepTogether(data) {\n  const { popper,
    reference } = data.offsets;\n  const placement = data.placement.split(''-'')[0];\n  const
    floor = Math.floor;\n  const isVertical = [''top'', ''bottom''].indexOf(placement)
    !== -1;\n  const side = isVertical ? ''right'' : ''bottom'';\n  const opSide =
    isVertical ? ''left'' : ''top'';\n  const measurement = isVertical ? ''width''
    : ''height'';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide]
    =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide]
    > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return
    data;\n}\n","import isNumeric from ''../utils/isNumeric'';\nimport getClientRect
    from ''../utils/getClientRect'';\nimport find from ''../utils/find'';\n\n/**\n
    * Converts a string containing value + unit into a px value number\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value
    + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument
    {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n
    * Value in pixels, or original string if no values were extracted\n */\nexport
    function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate
    value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const
    value = +split[1];\n  const unit = split[2];\n\n  // If it''s not a number it''s
    an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf(''%'')
    === 0) {\n    let element;\n    switch (unit) {\n      case ''%p'':\n        element
    = popperOffsets;\n        break;\n      case ''%'':\n      case ''%r'':\n      default:\n        element
    = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return
    rect[measurement] / 100 * value;\n  } else if (unit === ''vh'' || unit === ''vw'')
    {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let
    size;\n    if (unit === ''vh'') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight
    || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth
    || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is
    an explicit pixel unit, we get rid of the unit and keep the value\n    // if is
    an implicit unit, it''s px, and we return just the value\n    return value;\n  }\n}\n\n/**\n
    * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n *
    @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument
    {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets
    in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n)
    {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right
    and index is 0 otherwise use width\n  // in this way the first offset will use
    an axis and the second one\n  // will use the other one\n  const useHeight = [''right'',
    ''left''].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain
    a list of values and operands\n  // The regex addresses values with the plus or
    minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag
    => frag.trim());\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  const divider
    = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if
    (fragments[divider] && fragments[divider].indexOf('','') === -1) {\n    console.warn(\n      ''Offsets
    separated by white space(s) are deprecated, use a comma (,) instead.''\n    );\n  }\n\n  //
    If divider is found, we divide the list of values and operands to divide\n  //
    them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider
    !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider
    + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with
    units to absolute pixels to allow our computations\n  ops = ops.map((op, index)
    => {\n    // Most of the units rely on the orientation of the popper\n    const
    measurement = (index === 1 ? !useHeight : useHeight)\n      ? ''height''\n      :
    ''width'';\n    let mergeWithPrevious = false;\n    return (\n      op\n        //
    This aggregates any `+` or `-` sign that aren''t considered operators\n        //
    e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length
    - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {\n            a[a.length -
    1] = b;\n            mergeWithPrevious = true;\n            return a;\n          }
    else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious
    = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        },
    [])\n        // Here we convert the string values into number values (in px)\n        .map(str
    => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  //
    Loop trough the offsets arrays and execute the operations\n  ops.forEach((op,
    index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index]
    += frag * (op[index2 - 1] === ''-'' ? -1 : 1);\n      }\n    });\n  });\n  return
    offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n
    * The offset value as described in the modifier description\n * @returns {Object}
    The data object, properly modified\n */\nexport default function offset(data,
    { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const
    basePlacement = placement.split(''-'')[0];\n\n  let offsets;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === ''left'') {\n    popper.top
    += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement ===
    ''right'') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  }
    else if (basePlacement === ''top'') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === ''bottom'') {\n    popper.left
    += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n","import getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundaries from ''../utils/getBoundaries'';\nimport getSupportedPropertyName
    from ''../utils/getSupportedPropertyName'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by `update`
    method\n * @argument {Object} options - Modifiers configuration and options\n
    * @returns {Object} The data object, properly modified\n */\nexport default function
    preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement
    || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference
    element, we really want to\n  // go one step up and use the next offsetParent
    as reference to\n  // avoid to make this modifier completely useless and look
    like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement
    = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  //
    resets the popper''s position so that the document size can be calculated excluding\n  //
    the size of the popper element itself\n  const transformProp = getSupportedPropertyName(''transform'');\n  const
    popperStyles = data.instance.popper.style; // assignment to help minification\n  const
    { top, left, [transformProp]: transform } = popperStyles;\n  popperStyles.top
    = '''';\n  popperStyles.left = '''';\n  popperStyles[transformProp] = '''';\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement,\n    data.positionFixed\n  );\n\n  //
    NOTE: DOM access here\n  // restores the original style properties after the offsets
    have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp]
    = transform;\n\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let
    popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let
    value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement)
    {\n      const mainSide = placement === ''right'' ? ''left'' : ''top'';\n      let
    value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement]
    -\n            (placement === ''right'' ? popper.width : popper.height)\n        );\n      }\n      return
    { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const
    side =\n      [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ''secondary'';\n    popper
    = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper =
    popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function shift(data) {\n  const
    placement = data.placement;\n  const basePlacement = placement.split(''-'')[0];\n  const
    shiftvariation = placement.split(''-'')[1];\n\n  // if shift shiftvariation is
    specified, run the modifier\n  if (shiftvariation) {\n    const { reference, popper
    } = data.offsets;\n    const isVertical = [''bottom'', ''top''].indexOf(basePlacement)
    !== -1;\n    const side = isVertical ? ''left'' : ''top'';\n    const measurement
    = isVertical ? ''width'' : ''height'';\n\n    const shiftOffsets = {\n      start:
    { [side]: reference[side] },\n      end: {\n        [side]: reference[side] +
    reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper
    = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import
    isModifierRequired from ''../utils/isModifierRequired'';\nimport find from ''../utils/find'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function hide(data) {\n  if (!isModifierRequired(data.instance.modifiers,
    ''hide'', ''preventOverflow'')) {\n    return data;\n  }\n\n  const refRect =
    data.offsets.reference;\n  const bound = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''preventOverflow''\n  ).boundaries;\n\n  if (\n    refRect.bottom
    < bound.top ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom
    ||\n    refRect.right < bound.left\n  ) {\n    // Avoid unnecessary DOM access
    if visibility hasn''t changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide
    = true;\n    data.attributes[''x-out-of-boundaries''] = '''';\n  } else {\n    //
    Avoid unnecessary DOM access if visibility hasn''t changed\n    if (data.hide
    === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes[''x-out-of-boundaries'']
    = false;\n  }\n\n  return data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport
    getOppositePlacement from ''../utils/getOppositePlacement'';\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function inner(data) {\n  const placement = data.placement;\n  const basePlacement
    = placement.split(''-'')[0];\n  const { popper, reference } = data.offsets;\n  const
    isHoriz = [''left'', ''right''].indexOf(basePlacement) !== -1;\n\n  const subtractLength
    = [''top'', ''left''].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? ''left''
    : ''top''] =\n    reference[basePlacement] -\n    (subtractLength ? popper[isHoriz
    ? ''width'' : ''height''] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper
    = getClientRect(popper);\n\n  return data;\n}\n","import applyStyle, { applyStyleOnLoad
    } from ''./applyStyle'';\nimport computeStyle from ''./computeStyle'';\nimport
    arrow from ''./arrow'';\nimport flip from ''./flip'';\nimport keepTogether from
    ''./keepTogether'';\nimport offset from ''./offset'';\nimport preventOverflow
    from ''./preventOverflow'';\nimport shift from ''./shift'';\nimport hide from
    ''./hide'';\nimport inner from ''./inner'';\n\n/**\n * Modifier function, each
    modifier can have a function of this type assigned\n * to its `fn` property.<br
    />\n * These functions will be called on each update, this means that you must\n
    * make sure they are performant enough to avoid performance bottlenecks.\n *\n
    * @function ModifierFn\n * @argument {dataObject} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n
    * Modifiers are plugins used to alter the behavior of your poppers.<br />\n *
    Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n
    * needed by the library.\n *\n * Usually you don''t want to override the `order`,
    `fn` and `onLoad` props.\n * All the other properties are configurations that
    could be tweaked.\n * @namespace modifiers\n */\nexport default {\n  /**\n   *
    Modifier used to shift the popper on the start or end of its reference\n   * element.<br
    />\n   * It will read the variation of the `placement` property.<br />\n   * It
    can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift:
    {\n    /** @prop {number} order=100 - Index used to define the order of execution
    */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier
    is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn:
    shift,\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both
    its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less,
    interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of
    the reference element\n   * - `%p`, percentage relative to the length of the popper
    element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height
    unit\n   *\n   * For length is intended the main axis relative to the placement
    of the popper.<br />\n   * This means that if the placement is `top` or `bottom`,
    the length will be the\n   * `width`. In case of `left` or `right`, it will be
    the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`),
    or a pair of values\n   * as `String` divided by a comma or one (or more) white
    spaces.<br />\n   * The latter is a deprecated method because it leads to confusion
    and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions
    and subtractions between different units.\n   * Note that multiplications and
    divisions aren''t supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   *
    ''10%''\n   * ''10, 10''\n   * ''10%, 10''\n   * ''10 + 10%''\n   * ''10 - 5vh
    + 3%''\n   * ''-10px + 5vh, 5px - 6%''\n   * ```\n   * > **NB**: If you desire
    to apply offsets to your poppers in a way that may make them overlap\n   * > with
    their reference element, unfortunately, you will have to disable the `flip` modifier.\n   *
    > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200
    - Index used to define the order of execution */\n    order: 200,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String}
    offset=0\n     * The offset value as described in the modifier description\n     */\n    offset:
    0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned
    outside the boundary.\n   *\n   * A scenario exists where the reference itself
    is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"
    — or just \"escaped\".<br />\n   * In this case we need to decide whether the
    popper should either:\n   *\n   * - detach from the reference and remain \"trapped\"
    in the boundaries, or\n   * - if it should ignore the boundary and \"escape with
    its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference
    is completely\n   * outside its boundaries, the popper will overflow (or completely
    leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number}
    order=300 - Index used to define the order of execution */\n    order: 300,\n    /**
    @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]\n     * Popper
    will try to prevent overflow following these priorities by default,\n     * then,
    it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    [''left'', ''right'', ''top'', ''bottom''],\n    /**\n     * @prop {number} padding=5\n     *
    Amount of pixel used to define a minimum distance between the boundaries\n     *
    and the popper. This makes sure the popper always has a little padding\n     *
    between the edges of its container\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''scrollParent''\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: ''scrollParent'',\n  },\n\n  /**\n   *
    Modifier used to make sure the reference and its popper stay near each other\n   *
    without leaving any gap between the two. Especially useful when the arrow is\n   *
    enabled and you want to ensure that it points to its reference element.\n   *
    It cares only about the first axis. You can still have poppers with margin\n   *
    between the popper and its reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used
    to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier
    is used to move the `arrowElement` of the popper to make\n   * sure it is positioned
    between the reference element and its popper element.\n   * It will read the outer
    size of the `arrowElement` node to detect how many\n   * pixels of conjunction
    are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   *
    @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500
    - Index used to define the order of execution */\n    order: 500,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement}
    element=''[x-arrow]'' - Selector or node used as arrow */\n    element: ''[x-arrow]'',\n  },\n\n  /**\n   *
    Modifier used to flip the popper''s placement when it starts to overlap its\n   *
    reference element.\n   *\n   * Requires the `preventOverflow` modifier before
    it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current
    update cycle and will\n   * restart it if it detects the need to flip the placement.\n   *
    @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600
    - Index used to define the order of execution */\n    order: 600,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array}
    behavior=''flip''\n     * The behavior used to change the popper''s placement.
    It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with
    a list of valid\n     * placements (with optional variations)\n     */\n    behavior:
    ''flip'',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip
    if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''viewport''\n     * The element
    which will define the boundaries of the popper position.\n     * The popper will
    never be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: ''viewport'',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariations:
    false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     *
    The popper will switch placement variation between `-start` and `-end` when\n     *
    the popper element overlaps its reference boundaries.\n     *\n     * The original
    placement should have a set variation.\n     */\n    flipVariationsByContent:
    false,\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define
    the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false
    - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop
    {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the
    popper when its reference element is outside of the\n   * popper boundaries. It
    will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with
    a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   *
    Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof
    modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index
    used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that
    will be applied to the popper element to gets\n   * properly positioned.\n   *\n   *
    Note that this modifier will not touch the DOM, it just prepares the styles\n   *
    so that `applyStyle` modifier can apply it. This separation is useful\n   * in
    case you need to replace `applyStyle` with a custom implementation.\n   *\n   *
    This modifier has `850` as `order` value to maintain backward compatibility\n   *
    with previous versions of Popper.js. Expect the modifiers ordering method\n   *
    to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used
    to define the order of execution */\n    order: 850,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean}
    gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position
    the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    true,\n    /**\n     * @prop {string} [x=''bottom'']\n     * Where to anchor the
    X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper
    should grow in a direction different from `bottom`\n     */\n    x: ''bottom'',\n    /**\n     *
    @prop {string} [x=''left'']\n     * Where to anchor the Y axis (`left` or `right`).
    AKA Y offset origin.\n     * Change this if your popper should grow in a direction
    different from `right`\n     */\n    y: ''right'',\n  },\n\n  /**\n   * Applies
    the computed styles to the popper element.\n   *\n   * All the DOM manipulations
    are limited to this modifier. This is useful in case\n   * you want to integrate
    Popper.js inside a framework or view library and you\n   * want to delegate all
    the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier,
    you must make sure the popper element\n   * has its position set to `absolute`
    before Popper.js can do its work!\n   *\n   * Just disable this modifier and define
    your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used
    to define the order of execution */\n    order: 900,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad:
    applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property
    moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     *
    If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n
    * The `dataObject` is an object containing all the information used by Popper.js.\n
    * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n
    * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n
    * @property {String} data.placement Placement applied to popper\n * @property
    {String} data.originalPlacement Placement originally defined on init\n * @property
    {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property
    {Boolean} data.hide True if the reference element is out of boundaries, useful
    to know when to hide the popper\n * @property {HTMLElement} data.arrowElement
    Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS
    property defined here will be applied to the popper. It expects the JavaScript
    nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any
    CSS property defined here will be applied to the popper arrow. It expects the
    JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n","import
    modifiers from ''../modifiers/index'';\n\n/**\n * Default options provided to
    Popper.js constructor.<br />\n * These can be overridden using the `options` argument
    of Popper.js.<br />\n * To override an option, simply pass an object with the
    same\n * structure of the `options` object, as the 3rd argument. For example:\n
    * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: {
    enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof
    Popper\n */\nexport default {\n  /**\n   * Popper''s placement.\n   * @prop {Popper.placements}
    placement=''bottom''\n   */\n  placement: ''bottom'',\n\n  /**\n   * Set this
    to true if you want popper to position it self in ''fixed'' mode\n   * @prop {Boolean}
    positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events
    (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled:
    true,\n\n  /**\n   * Set to true if you want to automatically remove the popper
    when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called
    when the popper is updated. This callback is not called\n   * on the initialization/creation
    of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it
    is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers
    used to modify the offsets before they are applied to the popper.\n   * They provide
    most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n
    * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n
    * @param {dataObject} data\n */\n","// Utils\nimport debounce from ''./utils/debounce'';\nimport
    isFunction from ''./utils/isFunction'';\n\n// Methods\nimport update from ''./methods/update'';\nimport
    destroy from ''./methods/destroy'';\nimport enableEventListeners from ''./methods/enableEventListeners'';\nimport
    disableEventListeners from ''./methods/disableEventListeners'';\nimport Defaults
    from ''./methods/defaults'';\nimport placements from ''./methods/placements'';\n\nexport
    default class Popper {\n  /**\n   * Creates a new Popper.js instance.\n   * @class
    Popper\n   * @param {Element|referenceObject} reference - The reference element
    used to position the popper\n   * @param {Element} popper - The HTML / XML element
    used as the popper\n   * @param {Object} options - Your custom options to override
    the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The
    generated Popper.js instance\n   */\n  constructor(reference, popper, options
    = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update
    = debounce(this.update.bind(this));\n\n    // with {} we create a new object with
    the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    //
    init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents:
    [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference
    = reference && reference.jquery ? reference[0] : reference;\n    this.popper =
    popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name
    => {\n      this.options.modifiers[name] = {\n        // If it''s a built-in modifier,
    use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        //
    If there are custom options, override and merge with default ones\n        ...(options.modifiers
    ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers''
    list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name
    => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      //
    sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    //
    modifiers have the ability to execute arbitrary code when Popper.js get inited\n    //
    such code is executed in the same order of its modifier\n    // they could add
    new properties to their options configuration\n    // BE AWARE: don''t add options
    to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions
    => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad))
    {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    //
    fire the first update to position the popper in the right place\n    this.update();\n\n    const
    eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      //
    setup event listeners, they will take care of update the position in specific
    situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can''t use class properties because they don''t
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update()
    {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners()
    {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners()
    {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedules
    an update. It will run on the next UI update available.\n   * @method scheduleUpdate\n   *
    @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   *
    Collection of utilities useful when writing custom modifiers.\n   * Starting from
    version 1.7, this method is available only if you\n   * include `popper-utils.js`
    before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils
    is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly
    instead.\n   * Due to the high instability of the methods contained in Utils,
    we can''t\n   * guarantee them to follow semver. Use them at your own risk!\n   *
    @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   *
    @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !==
    ''undefined'' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static
    Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides
    an interface compatible with Popper.js\n * and lets you use it as replacement
    of a real DOM node.<br />\n * You can use this method to position a popper relatively
    to a set of coordinates\n * in case you don''t have a DOM node to use as reference.\n
    *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This
    feature isn''t supported in Internet Explorer 10.\n * @name referenceObject\n
    * @property {Function} data.getBoundingClientRect\n * A function that returns
    a set of coordinates compatible with the native `getBoundingClientRect` method.\n
    * @property {number} data.clientWidth\n * An ES6 getter that will return the width
    of the virtual reference element.\n * @property {number} data.clientHeight\n *
    An ES6 getter that will return the height of the virtual reference element.\n
    */\n"],"names":["window","document","navigator","longerTimeoutBrowsers","i","length","isBrowser","userAgent","indexOf","called","Promise","resolve","then","scheduled","supportsMicroTasks","functionToCheck","getType","toString","call","element","nodeType","ownerDocument","defaultView","css","getComputedStyle","property","nodeName","parentNode","host","body","overflow","overflowX","overflowY","getStyleComputedProperty","test","getScrollParent","getParentNode","reference","referenceNode","isIE11","MSInputMethodContext","documentMode","isIE10","version","documentElement","noOffsetParent","isIE","offsetParent","nextElementSibling","getOffsetParent","firstElementChild","node","getRoot","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","scrollingElement","subtract","scrollTop","getScroll","scrollLeft","modifier","top","bottom","left","right","sideA","axis","sideB","parseFloat","styles","Math","max","parseInt","computedStyle","getSize","offsets","width","height","rect","getBoundingClientRect","result","sizes","getWindowSizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getBordersSize","getClientRect","fixedPosition","runIsIE","isHTML","parent","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","excludeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","innerWidth","innerHeight","offset","isFixed","parentElement","el","boundaries","getFixedPositionOffsetParent","getReferenceNode","boundariesElement","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","popper","padding","isPaddingNumber","placement","getBoundaries","rects","refRect","sortedAreas","Object","keys","map","key","getArea","sort","b","area","a","filteredAreas","filter","computedPlacement","variation","split","commonOffsetParent","x","marginBottom","y","marginRight","hash","replace","matched","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","Array","prototype","find","arr","findIndex","cur","match","obj","modifiersToRun","ends","modifiers","slice","forEach","warn","fn","enabled","isFunction","data","state","isDestroyed","getReferenceOffsets","options","positionFixed","computeAutoPlacement","flip","originalPlacement","getPopperOffsets","position","runModifiers","isCreated","onUpdate","onCreate","some","name","prefixes","upperProp","charAt","toUpperCase","prefix","toCheck","style","isModifierEnabled","removeAttribute","willChange","getSupportedPropertyName","disableEventListeners","removeOnDestroy","removeChild","isBody","target","addEventListener","passive","push","updateBound","scrollElement","scrollParents","eventsEnabled","setupEventListeners","scheduleUpdate","removeEventListener","removeEventListeners","n","isNaN","isFinite","prop","unit","isNumeric","value","attributes","setAttribute","instance","arrowElement","arrowStyles","round","floor","noRound","v","referenceWidth","popperWidth","isVertical","isVariation","horizontalToInteger","verticalToInteger","bothOddWidth","isFirefox","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","getRoundedOffsets","devicePixelRatio","prefixedProperty","invertTop","invertLeft","arrow","requesting","isRequired","requested","isModifierRequired","querySelector","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","validPlacements","placements","counter","index","concat","reverse","BEHAVIORS","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","clockwise","COUNTERCLOCKWISE","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariationByRef","flipVariations","flippedVariationByContent","flipVariationsByContent","flippedVariation","getOppositeVariation","str","size","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","mergeWithPrevious","op","reduce","toValue","index2","basePlacement","parseOffset","transformProp","popperStyles","priority","check","escapeWithReference","shiftvariation","shiftOffsets","bound","hide","subtractLength","requestAnimationFrame","update","debounce","bind","Popper","Defaults","jquery","modifierOptions","onLoad","enableEventListeners","destroy","Utils","global","PopperUtils"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-umd-popper-utils.js: "/**!\n * @fileOverview Kickass
    library to create and place poppers near their reference elements.\n * @version
    1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n
    *\n * Permission is hereby granted, free of charge, to any person obtaining a
    copy\n * of this software and associated documentation files (the \"Software\"),
    to deal\n * in the Software without restriction, including without limitation
    the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell\n * copies of the Software, and to permit persons to whom the Software is\n
    * furnished to do so, subject to the following conditions:\n *\n * The above copyright
    notice and this permission notice shall be included in all\n * copies or substantial
    portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT
    WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE\n * SOFTWARE.\n */\n(function (global, factory) {\n\ttypeof exports
    === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define
    === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.PopperUtils
    = {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * Get CSS computed
    property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css
    = window.getComputedStyle(element, null);\n  return property ? css[property] :
    css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML')
    {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take
    care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n
    \ }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return
    element.ownerDocument.body;\n    case '#document':\n      return element.body;\n
    \ }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var
    _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n
    \     overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n
    \ if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode
    ? reference.referenceNode : reference;\n}\n\nvar isBrowser = typeof window !==
    'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines
    if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n *
    @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version)
    {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n
    \   return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the
    offset parent of the given element\n * @method\n * @memberof Popper.Utils\n *
    @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction
    getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n
    \ }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1
    DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip
    hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent
    && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n
    \ }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName
    || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n
    \ if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent,
    'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n
    \ return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName
    = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n
    \ return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) ===
    element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n
    * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode
    !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n
    * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n
    * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1,
    element2) {\n  // This check is needed to avoid errors in case one of the elements
    isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2
    || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  var
    order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n
    \ var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n
    \ // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n
    \ // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer
    && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer))
    {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n
    \ }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root
    = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host,
    element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n
    \ }\n}\n\n/**\n * Gets the scroll value of the given element in the given side
    (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @argument {String} side `top` or `left`\n * @returns {number} amount
    of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length
    > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide =
    side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n
    \ if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n
    \   var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n *
    Sum or subtract the element scroll values (left and top) from a given rect object\n
    * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you
    want to change\n * @param {HTMLElement} element - The element from the function
    reads the scroll values\n * @param {Boolean} subtract - set to true if you want
    to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n
    */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length
    > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop =
    getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var
    modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom
    += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right
    += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders
    of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration}
    styles\n * Result of `getStyleComputedProperty` on the given element\n * @param
    {String} axis - `x` or `y`\n * @return {number} borders - The borders size of
    the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA =
    axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n
    \ return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border'
    + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n
    \ return Math.max(body['offset' + axis], body['scroll' + axis], html['client'
    + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset'
    + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')])
    + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')])
    : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n
    \ var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n
    \ return {\n    height: getSize('Height', body, html, computedStyle),\n    width:
    getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar _extends = Object.assign
    || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var
    source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source,
    key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n
    * Given element offsets, generate an output similar to getBoundingClientRect\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns
    {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return
    _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom:
    offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of
    given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element)
    {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n
    \ // considered in DOM in some circumstances...\n  // This isn't reproducible
    in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect =
    element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n
    \     var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n
    \     rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right
    += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n
    \   }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n
    \   width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n
    \ // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML'
    ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth
    || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n
    \ var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's
    not a `border`\n  // we make this check conditional for performance reasons\n
    \ if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n
    \   horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles,
    'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n
    \ }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children,
    parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined
    ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName
    === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect
    = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n
    \ var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n
    \ var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where
    the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n
    \ // Subtract margins of documentElement in case it's being used as parent\n  //
    we do this only on HTML because it's the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var
    marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n
    \   offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth
    - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right
    -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because
    in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft
    = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent)
    : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets
    = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element)
    {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ?
    arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n
    \ var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n
    \ var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height
    = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left')
    : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n
    \   left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width:
    width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n
    * Check if the given element is fixed or is inside a fixed parent\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element}
    customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element)
    {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName ===
    'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position')
    === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n
    \ if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n
    * Finds the first parent of an element that has a transformed property defined\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns
    {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element)
    {\n  // This check is needed to avoid errors in case one of the elements isn't
    defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n
    \   return document.documentElement;\n  }\n  var el = element.parentElement;\n
    \ while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el
    = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n
    * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n
    * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number}
    padding\n * @param {HTMLElement} boundariesElement - Element used to define the
    boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n *
    @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper,
    reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length
    > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM
    access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n
    \ // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries
    = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n
    \ } else {\n    // Handle other cases based on DOM element used as boundaries\n
    \   var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent')
    {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if
    (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n
    \     }\n    } else if (boundariesElement === 'window') {\n      boundariesNode
    = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode =
    boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode,
    offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n
    \   if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var
    _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n
    \         width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top
    - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n
    \   } else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var
    isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n
    \ return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n
    \     height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility
    used to transform the `auto` placement to the placement with more\n * available
    space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The
    data object generated by update method\n * @argument {Object} options - Modifiers
    configuration and options\n * @returns {Object} The data object, properly modified\n
    */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement)
    {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5]
    : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n
    \ var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n
    \ var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n
    \     height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n
    \     height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width:
    refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n
    \ var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n
    \     key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n
    \ }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas
    = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height
    = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n
    \ });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key
    : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return
    computedPlacement + (variation ? '-' + variation : '');\n}\n\nvar timeoutDuration
    = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n
    \ for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser
    && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called
    = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called
    = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n
    \     fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled
    = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n
    \     setTimeout(function () {\n        scheduled = false;\n        fn();\n      },
    timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n*
    Create a debounced version of a method, that's asynchronously deferred\n* but
    called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n*
    @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks
    ? microtaskDebounce : taskDebounce;\n\n/**\n * Mimics the `find` method of Array\n
    * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n
    * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n
    \ // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n
    \ }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n
    * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n
    * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function
    (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` +
    `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj)
    {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nfunction getOffsetRect(element)
    {\n  var elementRect = void 0;\n  if (element.nodeName === 'HTML') {\n    var
    _getWindowSizes = getWindowSizes(element.ownerDocument),\n        width = _getWindowSizes.width,\n
    \       height = _getWindowSizes.height;\n\n    elementRect = {\n      width:
    width,\n      height: height,\n      left: 0,\n      top: 0\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n
    \     left: element.offsetLeft,\n      top: element.offsetTop\n    };\n  }\n\n
    \ // position\n  return getClientRect(elementRect);\n}\n\n/**\n * Get the outer
    sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @returns {Object} object containing width and
    height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n
    \ var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction
    getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left',
    bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g,
    function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets
    to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  //
    Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position,
    width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n
    \   height: popperRect.height\n  };\n\n  // depending by the popper placement
    we have to compute its offsets slightly differently\n  var isHoriz = ['right',
    'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n
    \ var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ?
    'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n
    \ popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement]
    / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide]
    = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else
    {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n
    \ }\n\n  return popperOffsets;\n}\n\n/**\n * Get offsets to the reference element\n
    * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element}
    popper - the popper element\n * @param {Element} reference - the reference element
    (the popper will be relative to this)\n * @param {Element} fixedPosition - is
    in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nfunction getReferenceOffsets(state,
    popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3]
    !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n
    \ return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property)
    {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var
    prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n
    \   if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n
    \   }\n  }\n  return null;\n}\n\n/**\n * Check if the given variable is a function\n
    * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable
    to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck)
    {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck)
    === '[object Function]';\n}\n\n/**\n * Helper used to know if the given modifier
    is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction
    isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function
    (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return
    enabled && name === modifierName;\n  });\n}\n\n/**\n * Helper used to know if
    the given modifier depends from another one.<br />\n * It checks if the needed
    modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param
    {Array} modifiers - list of modifiers\n * @param {String} requestingName - name
    of requesting modifier\n * @param {String} requestedName - name of requested modifier\n
    * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName,
    requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var
    name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired
    = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name
    === requestedName && modifier.enabled && modifier.order < requesting.order;\n
    \ });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n
    \   var requested = '`' + requestedName + '`';\n    console.warn(requested + '
    modifier is required by ' + _requesting + ' modifier in order to work, be sure
    to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n
    * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n
    * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n)
    {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Get
    the window associated with the element\n * @argument {Element} element\n * @returns
    {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n
    \ return ownerDocument ? ownerDocument.defaultView : window;\n}\n\n/**\n * Remove
    event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove
    resize event listener on window\n  getWindow(reference).removeEventListener('resize',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function
    (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n
    \ // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * Loop trough
    the list of modifiers and run them in order,\n * each of them will then edit the
    data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n
    * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used
    as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data,
    ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0,
    findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier)
    {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n
    \     console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n
    \   }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line
    dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties
    to offsets to make them a complete clientRect object\n      // we do this before
    each modifier to make sure the previous one doesn't\n      // mess with these
    values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n
    \   }\n  });\n\n  return data;\n}\n\n/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nfunction setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n
    \ });\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the style to\n
    * @argument {Object} styles\n * Object with a list of properties and values which
    will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function
    (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one
    of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop)
    !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n
    \ var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n
    \ target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody)
    {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback,
    scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed
    event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n
    \ getWindow(reference).addEventListener('resize', state.updateBound, { passive:
    true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement
    = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll',
    state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n
    \ state.eventsEnabled = true;\n\n  return state;\n}\n\n// This is here just for
    backward compatibility with versions lower than v1.10.3\n// you should import
    the utilities using named exports, if you want them all use:\n// ```\n// import
    * as PopperUtils from 'popper-utils';\n// ```\n// The default export will be removed
    in the next major version.\nvar index = {\n  computeAutoPlacement: computeAutoPlacement,\n
    \ debounce: debounce,\n  findIndex: findIndex,\n  getBordersSize: getBordersSize,\n
    \ getBoundaries: getBoundaries,\n  getBoundingClientRect: getBoundingClientRect,\n
    \ getClientRect: getClientRect,\n  getOffsetParent: getOffsetParent,\n  getOffsetRect:
    getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode: getOffsetRectRelativeToArbitraryNode,\n
    \ getOuterSizes: getOuterSizes,\n  getParentNode: getParentNode,\n  getPopperOffsets:
    getPopperOffsets,\n  getReferenceOffsets: getReferenceOffsets,\n  getScroll: getScroll,\n
    \ getScrollParent: getScrollParent,\n  getStyleComputedProperty: getStyleComputedProperty,\n
    \ getSupportedPropertyName: getSupportedPropertyName,\n  getWindowSizes: getWindowSizes,\n
    \ isFixed: isFixed,\n  isFunction: isFunction,\n  isModifierEnabled: isModifierEnabled,\n
    \ isModifierRequired: isModifierRequired,\n  isNumeric: isNumeric,\n  removeEventListeners:
    removeEventListeners,\n  runModifiers: runModifiers,\n  setAttributes: setAttributes,\n
    \ setStyles: setStyles,\n  setupEventListeners: setupEventListeners\n};\n\nexports.computeAutoPlacement
    = computeAutoPlacement;\nexports.debounce = debounce;\nexports.findIndex = findIndex;\nexports.getBordersSize
    = getBordersSize;\nexports.getBoundaries = getBoundaries;\nexports.getBoundingClientRect
    = getBoundingClientRect;\nexports.getClientRect = getClientRect;\nexports.getOffsetParent
    = getOffsetParent;\nexports.getOffsetRect = getOffsetRect;\nexports.getOffsetRectRelativeToArbitraryNode
    = getOffsetRectRelativeToArbitraryNode;\nexports.getOuterSizes = getOuterSizes;\nexports.getParentNode
    = getParentNode;\nexports.getPopperOffsets = getPopperOffsets;\nexports.getReferenceOffsets
    = getReferenceOffsets;\nexports.getScroll = getScroll;\nexports.getScrollParent
    = getScrollParent;\nexports.getStyleComputedProperty = getStyleComputedProperty;\nexports.getSupportedPropertyName
    = getSupportedPropertyName;\nexports.getWindowSizes = getWindowSizes;\nexports.isFixed
    = isFixed;\nexports.isFunction = isFunction;\nexports.isModifierEnabled = isModifierEnabled;\nexports.isModifierRequired
    = isModifierRequired;\nexports.isNumeric = isNumeric;\nexports.removeEventListeners
    = removeEventListeners;\nexports.runModifiers = runModifiers;\nexports.setAttributes
    = setAttributes;\nexports.setStyles = setStyles;\nexports.setupEventListeners
    = setupEventListeners;\nexports['default'] = index;\n\nObject.defineProperty(exports,
    '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=popper-utils.js.map\n"
  admin-Public-Admin-plugins-popper-umd-popper-utils.js.map: '{"version":3,"file":"popper-utils.js","sources":["../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isBrowser.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/debounce.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/getOffsetRect.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getSupportedPropertyName.js","../../src/utils/isFunction.js","../../src/utils/isModifierEnabled.js","../../src/utils/isModifierRequired.js","../../src/utils/isNumeric.js","../../src/utils/getWindow.js","../../src/utils/removeEventListeners.js","../../src/utils/runModifiers.js","../../src/utils/setAttributes.js","../../src/utils/setStyles.js","../../src/utils/setupEventListeners.js","../../src/utils/index.js"],"sourcesContent":["/**\n
    * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Eement} element\n * @argument {String} property\n */\nexport default
    function getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window =
    element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element,
    null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode
    or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element\n * @returns {Element} parent\n */\nexport default function
    getParentNode(element) {\n  if (element.nodeName === ''HTML'') {\n    return element;\n  }\n  return
    element.parentNode || element.host;\n}\n","import getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getParentNode from ''./getParentNode'';\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll`
    will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return
    document.body\n  }\n\n  switch (element.nodeName) {\n    case ''HTML'':\n    case
    ''BODY'':\n      return element.ownerDocument.body\n    case ''#document'':\n      return
    element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as
    well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if
    (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines
    if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n *
    @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n *
    @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nexport default function find(arr, check) {\n  // use native find if
    supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  //
    use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n","import
    find from ''./find'';\n\n/**\n * Return the index of the matching object\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop,
    value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex)
    {\n    return arr.findIndex(cur => cur[prop] === value);\n  }\n\n  // use `find`
    + `indexOf` if `findIndex` isn''t supported\n  const match = find(arr, obj =>
    obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import getWindowSizes
    from ''./getWindowSizes'';\nimport getClientRect from ''./getClientRect'';\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nexport default function
    getOffsetRect(element) {\n  let elementRect;\n  if (element.nodeName === ''HTML'')
    {\n    const { width, height } = getWindowSizes(element.ownerDocument);\n    elementRect
    = {\n      width,\n      height,\n      left: 0,\n      top: 0,\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left:
    element.offsetLeft,\n      top: element.offsetTop,\n    };\n  }\n\n  // position\n  return
    getClientRect(elementRect);\n}\n","/**\n * Get the outer sizes of the given element
    (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Object} object containing width and height properties\n
    */\nexport default function getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const
    styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  const result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport
    default function getOppositePlacement(placement) {\n  const hash = { left: ''right'',
    right: ''left'', bottom: ''top'', top: ''bottom'' };\n  return placement.replace(/left|right|bottom|top/g,
    matched => hash[matched]);\n}\n","import getOuterSizes from ''./getOuterSizes'';\nimport
    getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n * Get offsets to
    the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split(''-'')[0];\n\n  //
    Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add
    position, width and height to our offsets object\n  const popperOffsets = {\n    width:
    popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the
    popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","/**\n * Check if the given variable
    is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck
    - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport
    default function isFunction(functionToCheck) {\n  const getType = {};\n  return
    (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === ''[object
    Function]''\n  );\n}\n","/**\n * Helper used to know if the given modifier is
    enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport
    default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({
    name, enabled }) => enabled && name === modifierName\n  );\n}\n","import find
    from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n *
    Get the window associated with the element\n * @argument {Element} element\n *
    @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getWindow from ''./getWindow'';\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nexport default function removeEventListeners(reference, state)
    {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import isFunction
    from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport getClientRect
    from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list of modifiers
    and run them in order,\n * each of them will then edit the data object.\n * @method\n
    * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n
    * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n
    */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun
    = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers,
    ''name'', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier[''function''])
    { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the attributes
    to\n * @argument {Object} styles\n * Object with a list of properties and values
    which will be applied to the element\n */\nexport default function setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","import getScrollParent from ''./getScrollParent'';\nimport
    getWindow from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName ===
    ''BODY'';\n  const target = isBody ? scrollParent.ownerDocument.defaultView :
    scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if
    (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    computeAutoPlacement from ''./computeAutoPlacement'';\nimport debounce from ''./debounce'';\nimport
    findIndex from ''./findIndex'';\nimport getBordersSize from ''./getBordersSize'';\nimport
    getBoundaries from ''./getBoundaries'';\nimport getBoundingClientRect from ''./getBoundingClientRect'';\nimport
    getClientRect from ''./getClientRect'';\nimport getOffsetParent from ''./getOffsetParent'';\nimport
    getOffsetRect from ''./getOffsetRect'';\nimport getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getOuterSizes from ''./getOuterSizes'';\nimport
    getParentNode from ''./getParentNode'';\nimport getPopperOffsets from ''./getPopperOffsets'';\nimport
    getReferenceOffsets from ''./getReferenceOffsets'';\nimport getScroll from ''./getScroll'';\nimport
    getScrollParent from ''./getScrollParent'';\nimport getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getSupportedPropertyName from ''./getSupportedPropertyName'';\nimport
    getWindowSizes from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport
    isFunction from ''./isFunction'';\nimport isModifierEnabled from ''./isModifierEnabled'';\nimport
    isModifierRequired from ''./isModifierRequired'';\nimport isNumeric from ''./isNumeric'';\nimport
    removeEventListeners from ''./removeEventListeners'';\nimport runModifiers from
    ''./runModifiers'';\nimport setAttributes from ''./setAttributes'';\nimport setStyles
    from ''./setStyles'';\nimport setupEventListeners from ''./setupEventListeners'';\n\n/**
    @namespace Popper.Utils */\nexport {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n\n//
    This is here just for backward compatibility with versions lower than v1.10.3\n//
    you should import the utilities using named exports, if you want them all use:\n//
    ```\n// import * as PopperUtils from ''popper-utils'';\n// ```\n// The default
    export will be removed in the next major version.\nexport default {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n"],"names":["getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","overflow","overflowX","overflowY","test","getReferenceNode","reference","referenceNode","navigator","isIE11","isBrowser","MSInputMethodContext","documentMode","isIE10","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","parseInt","getWindowSizes","getClientRect","offsets","width","height","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","isPaddingNumber","getArea","computeAutoPlacement","placement","refRect","rects","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","length","variation","split","timeoutDuration","longerTimeoutBrowsers","i","microtaskDebounce","fn","called","Promise","resolve","then","taskDebounce","scheduled","supportsMicroTasks","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","getOffsetRect","elementRect","offsetLeft","offsetTop","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","state","commonOffsetParent","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","isFunction","functionToCheck","getType","toString","call","isModifierEnabled","modifiers","modifierName","some","name","enabled","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","warn","isNumeric","n","isNaN","isFinite","getWindow","removeEventListeners","removeEventListener","updateBound","scrollParents","forEach","scrollElement","eventsEnabled","runModifiers","data","ends","modifiersToRun","undefined","setAttributes","attributes","setAttribute","removeAttribute","setStyles","unit","attachToScrollParents","event","callback","isBody","target","addEventListener","passive","push","setupEventListeners","options"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-umd-popper-utils.min.js: |
    /*
     Copyright (C) Federico Zivolo 2020
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */(function(a,b){'object'==typeof exports&&'undefined'!=typeof module?b(exports):'function'==typeof define&&define.amd?define(['exports'],b):b(a.PopperUtils={})})(this,function(a){'use strict';function b(a,b){if(1!==a.nodeType)return[];var c=a.ownerDocument.defaultView,d=c.getComputedStyle(a,null);return b?d[b]:d}function c(a){return'HTML'===a.nodeName?a:a.parentNode||a.host}function d(a){if(!a)return document.body;switch(a.nodeName){case'HTML':case'BODY':return a.ownerDocument.body;case'#document':return a.body;}var e=b(a),f=e.overflow,g=e.overflowX,h=e.overflowY;return /(auto|scroll|overlay)/.test(f+h+g)?a:d(c(a))}function e(a){return a&&a.referenceNode?a.referenceNode:a}function f(a){return 11===a?T:10===a?U:T||U}function g(a){if(!a)return document.documentElement;for(var c=f(10)?document.body:null,d=a.offsetParent||null;d===c&&a.nextElementSibling;)d=(a=a.nextElementSibling).offsetParent;var e=d&&d.nodeName;return e&&'BODY'!==e&&'HTML'!==e?-1!==['TH','TD','TABLE'].indexOf(d.nodeName)&&'static'===b(d,'position')?g(d):d:a?a.ownerDocument.documentElement:document.documentElement}function h(a){var b=a.nodeName;return'BODY'!==b&&('HTML'===b||g(a.firstElementChild)===a)}function i(a){return null===a.parentNode?a:i(a.parentNode)}function j(a,b){if(!a||!a.nodeType||!b||!b.nodeType)return document.documentElement;var c=a.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_FOLLOWING,d=c?a:b,e=c?b:a,f=document.createRange();f.setStart(d,0),f.setEnd(e,0);var k=f.commonAncestorContainer;if(a!==k&&b!==k||d.contains(e))return h(k)?k:g(k);var l=i(a);return l.host?j(l.host,b):j(a,i(b).host)}function k(a){var b=1<arguments.length&&arguments[1]!==void 0?arguments[1]:'top',c='top'===b?'scrollTop':'scrollLeft',d=a.nodeName;if('BODY'===d||'HTML'===d){var e=a.ownerDocument.documentElement,f=a.ownerDocument.scrollingElement||e;return f[c]}return a[c]}function l(a,b){var c=2<arguments.length&&void 0!==arguments[2]&&arguments[2],d=k(b,'top'),e=k(b,'left'),f=c?-1:1;return a.top+=d*f,a.bottom+=d*f,a.left+=e*f,a.right+=e*f,a}function m(a,b){var c='x'===b?'Left':'Top',d='Left'==c?'Right':'Bottom';return parseFloat(a['border'+c+'Width'])+parseFloat(a['border'+d+'Width'])}function n(a,b,c,d){return R(b['offset'+a],b['scroll'+a],c['client'+a],c['offset'+a],c['scroll'+a],f(10)?parseInt(c['offset'+a])+parseInt(d['margin'+('Height'===a?'Top':'Left')])+parseInt(d['margin'+('Height'===a?'Bottom':'Right')]):0)}function o(a){var b=a.body,c=a.documentElement,d=f(10)&&getComputedStyle(c);return{height:n('Height',b,c,d),width:n('Width',b,c,d)}}function p(a){return V({},a,{right:a.left+a.width,bottom:a.top+a.height})}function q(a){var c={};try{if(f(10)){c=a.getBoundingClientRect();var d=k(a,'top'),e=k(a,'left');c.top+=d,c.left+=e,c.bottom+=d,c.right+=e}else c=a.getBoundingClientRect()}catch(a){}var g={left:c.left,top:c.top,width:c.right-c.left,height:c.bottom-c.top},h='HTML'===a.nodeName?o(a.ownerDocument):{},i=h.width||a.clientWidth||g.width,j=h.height||a.clientHeight||g.height,l=a.offsetWidth-i,n=a.offsetHeight-j;if(l||n){var q=b(a);l-=m(q,'x'),n-=m(q,'y'),g.width-=l,g.height-=n}return p(g)}function r(a,c){var e=2<arguments.length&&void 0!==arguments[2]&&arguments[2],g=f(10),h='HTML'===c.nodeName,i=q(a),j=q(c),k=d(a),m=b(c),n=parseFloat(m.borderTopWidth),o=parseFloat(m.borderLeftWidth);e&&h&&(j.top=R(j.top,0),j.left=R(j.left,0));var r=p({top:i.top-j.top-n,left:i.left-j.left-o,width:i.width,height:i.height});if(r.marginTop=0,r.marginLeft=0,!g&&h){var s=parseFloat(m.marginTop),t=parseFloat(m.marginLeft);r.top-=n-s,r.bottom-=n-s,r.left-=o-t,r.right-=o-t,r.marginTop=s,r.marginLeft=t}return(g&&!e?c.contains(k):c===k&&'BODY'!==k.nodeName)&&(r=l(r,c)),r}function s(a){var b=1<arguments.length&&arguments[1]!==void 0&&arguments[1],c=a.ownerDocument.documentElement,d=r(a,c),e=R(c.clientWidth,window.innerWidth||0),f=R(c.clientHeight,window.innerHeight||0),g=b?0:k(c),h=b?0:k(c,'left'),i={top:g-d.top+d.marginTop,left:h-d.left+d.marginLeft,width:e,height:f};return p(i)}function t(a){var d=a.nodeName;if('BODY'===d||'HTML'===d)return!1;if('fixed'===b(a,'position'))return!0;var e=c(a);return!!e&&t(e)}function u(a){if(!a||!a.parentElement||f())return document.documentElement;for(var c=a.parentElement;c&&'none'===b(c,'transform');)c=c.parentElement;return c||document.documentElement}function v(a,b,f,g){var h=4<arguments.length&&void 0!==arguments[4]&&arguments[4],i={top:0,left:0},k=h?u(a):j(a,e(b));if('viewport'===g)i=s(k,h);else{var l;'scrollParent'===g?(l=d(c(b)),'BODY'===l.nodeName&&(l=a.ownerDocument.documentElement)):'window'===g?l=a.ownerDocument.documentElement:l=g;var m=r(l,k,h);if('HTML'===l.nodeName&&!t(k)){var n=o(a.ownerDocument),p=n.height,q=n.width;i.top+=m.top-m.marginTop,i.bottom=p+m.top,i.left+=m.left-m.marginLeft,i.right=q+m.left}else i=m}f=f||0;var v='number'==typeof f;return i.left+=v?f:f.left||0,i.top+=v?f:f.top||0,i.right-=v?f:f.right||0,i.bottom-=v?f:f.bottom||0,i}function w(a){var b=a.width,c=a.height;return b*c}function x(a,b,c,d,e){var f=5<arguments.length&&arguments[5]!==void 0?arguments[5]:0;if(-1===a.indexOf('auto'))return a;var g=v(c,d,f,e),h={top:{width:g.width,height:b.top-g.top},right:{width:g.right-b.right,height:g.height},bottom:{width:g.width,height:g.bottom-b.bottom},left:{width:b.left-g.left,height:g.height}},i=Object.keys(h).map(function(a){return V({key:a},h[a],{area:w(h[a])})}).sort(function(c,a){return a.area-c.area}),j=i.filter(function(a){var b=a.width,d=a.height;return b>=c.clientWidth&&d>=c.clientHeight}),k=0<j.length?j[0].key:i[0].key,l=a.split('-')[1];return k+(l?'-'+l:'')}function y(a,b){return Array.prototype.find?a.find(b):a.filter(b)[0]}function z(a,b,c){if(Array.prototype.findIndex)return a.findIndex(function(a){return a[b]===c});var d=y(a,function(a){return a[b]===c});return a.indexOf(d)}function A(a){var b;if('HTML'===a.nodeName){var c=o(a.ownerDocument),d=c.width,e=c.height;b={width:d,height:e,left:0,top:0}}else b={width:a.offsetWidth,height:a.offsetHeight,left:a.offsetLeft,top:a.offsetTop};return p(b)}function B(a){var b=a.ownerDocument.defaultView,c=b.getComputedStyle(a),d=parseFloat(c.marginTop||0)+parseFloat(c.marginBottom||0),e=parseFloat(c.marginLeft||0)+parseFloat(c.marginRight||0),f={width:a.offsetWidth+e,height:a.offsetHeight+d};return f}function C(a){var b={left:'right',right:'left',bottom:'top',top:'bottom'};return a.replace(/left|right|bottom|top/g,function(a){return b[a]})}function D(a,b,c){c=c.split('-')[0];var d=B(a),e={width:d.width,height:d.height},f=-1!==['right','left'].indexOf(c),g=f?'top':'left',h=f?'left':'top',i=f?'height':'width',j=f?'width':'height';return e[g]=b[g]+b[i]/2-d[i]/2,e[h]=c===h?b[h]-d[j]:b[C(h)],e}function E(a,b,c){var d=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,f=d?u(b):j(b,e(c));return r(c,f,d)}function F(a){for(var b=[!1,'ms','Webkit','Moz','O'],c=a.charAt(0).toUpperCase()+a.slice(1),d=0;d<b.length;d++){var e=b[d],f=e?''+e+c:a;if('undefined'!=typeof document.body.style[f])return f}return null}function G(a){return a&&'[object Function]'==={}.toString.call(a)}function H(a,b){return a.some(function(a){var c=a.name,d=a.enabled;return d&&c===b})}function I(a,b,c){var d=y(a,function(a){var c=a.name;return c===b}),e=!!d&&a.some(function(a){return a.name===c&&a.enabled&&a.order<d.order});if(!e){var f='`'+b+'`';console.warn('`'+c+'`'+' modifier is required by '+f+' modifier in order to work, be sure to include it before '+f+'!')}return e}function J(a){return''!==a&&!isNaN(parseFloat(a))&&isFinite(a)}function K(a){var b=a.ownerDocument;return b?b.defaultView:window}function L(a,b){return K(a).removeEventListener('resize',b.updateBound),b.scrollParents.forEach(function(a){a.removeEventListener('scroll',b.updateBound)}),b.updateBound=null,b.scrollParents=[],b.scrollElement=null,b.eventsEnabled=!1,b}function M(a,b,c){var d=void 0===c?a:a.slice(0,z(a,'name',c));return d.forEach(function(a){a['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var c=a['function']||a.fn;a.enabled&&G(c)&&(b.offsets.popper=p(b.offsets.popper),b.offsets.reference=p(b.offsets.reference),b=c(b,a))}),b}function N(a,b){Object.keys(b).forEach(function(c){var d=b[c];!1===d?a.removeAttribute(c):a.setAttribute(c,b[c])})}function O(a,b){Object.keys(b).forEach(function(c){var d='';-1!==['width','height','top','right','bottom','left'].indexOf(c)&&J(b[c])&&(d='px'),a.style[c]=b[c]+d})}function P(a,b,c,e){var f='BODY'===a.nodeName,g=f?a.ownerDocument.defaultView:a;g.addEventListener(b,c,{passive:!0}),f||P(d(g.parentNode),b,c,e),e.push(g)}function Q(a,b,c,e){c.updateBound=e,K(a).addEventListener('resize',c.updateBound,{passive:!0});var f=d(a);return P(f,'scroll',c.updateBound,c.scrollParents),c.scrollElement=f,c.eventsEnabled=!0,c}var R=Math.max,S='undefined'!=typeof window&&'undefined'!=typeof document&&'undefined'!=typeof navigator,T=S&&!!(window.MSInputMethodContext&&document.documentMode),U=S&&/MSIE 10/.test(navigator.userAgent),V=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},W=function(){for(var a=['Edge','Trident','Firefox'],b=0;b<a.length;b+=1)if(S&&0<=navigator.userAgent.indexOf(a[b]))return 1;return 0}(),X=S&&window.Promise,Y=X?function(a){var b=!1;return function(){b||(b=!0,window.Promise.resolve().then(function(){b=!1,a()}))}}:function(a){var b=!1;return function(){b||(b=!0,setTimeout(function(){b=!1,a()},W))}};a.computeAutoPlacement=x,a.debounce=Y,a.findIndex=z,a.getBordersSize=m,a.getBoundaries=v,a.getBoundingClientRect=q,a.getClientRect=p,a.getOffsetParent=g,a.getOffsetRect=A,a.getOffsetRectRelativeToArbitraryNode=r,a.getOuterSizes=B,a.getParentNode=c,a.getPopperOffsets=D,a.getReferenceOffsets=E,a.getScroll=k,a.getScrollParent=d,a.getStyleComputedProperty=b,a.getSupportedPropertyName=F,a.getWindowSizes=o,a.isFixed=t,a.isFunction=G,a.isModifierEnabled=H,a.isModifierRequired=I,a.isNumeric=J,a.removeEventListeners=L,a.runModifiers=M,a.setAttributes=N,a.setStyles=O,a.setupEventListeners=Q,a['default']={computeAutoPlacement:x,debounce:Y,findIndex:z,getBordersSize:m,getBoundaries:v,getBoundingClientRect:q,getClientRect:p,getOffsetParent:g,getOffsetRect:A,getOffsetRectRelativeToArbitraryNode:r,getOuterSizes:B,getParentNode:c,getPopperOffsets:D,getReferenceOffsets:E,getScroll:k,getScrollParent:d,getStyleComputedProperty:b,getSupportedPropertyName:F,getWindowSizes:o,isFixed:t,isFunction:G,isModifierEnabled:H,isModifierRequired:I,isNumeric:J,removeEventListeners:L,runModifiers:M,setAttributes:N,setStyles:O,setupEventListeners:Q},Object.defineProperty(a,'__esModule',{value:!0})});
    //# sourceMappingURL=popper-utils.min.js.map
  admin-Public-Admin-plugins-popper-umd-popper-utils.min.js.map: '{"version":3,"file":"popper-utils.min.js","sources":["../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/getOffsetRect.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getSupportedPropertyName.js","../../src/utils/isFunction.js","../../src/utils/isModifierEnabled.js","../../src/utils/isModifierRequired.js","../../src/utils/isNumeric.js","../../src/utils/getWindow.js","../../src/utils/removeEventListeners.js","../../src/utils/runModifiers.js","../../src/utils/setAttributes.js","../../src/utils/setStyles.js","../../src/utils/setupEventListeners.js","../../src/utils/isBrowser.js","../../src/utils/debounce.js","../../src/utils/index.js"],"sourcesContent":["/**\n
    * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Eement} element\n * @argument {String} property\n */\nexport default
    function getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window =
    element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element,
    null);\n  return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode
    or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element\n * @returns {Element} parent\n */\nexport default function
    getParentNode(element) {\n  if (element.nodeName === ''HTML'') {\n    return element;\n  }\n  return
    element.parentNode || element.host;\n}\n","import getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getParentNode from ''./getParentNode'';\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nexport default function getScrollParent(element) {\n  // Return body, `getScroll`
    will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return
    document.body\n  }\n\n  switch (element.nodeName) {\n    case ''HTML'':\n    case
    ''BODY'':\n      return element.ownerDocument.body\n    case ''#document'':\n      return
    element.body\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as
    well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if
    (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","/**\n * Mimics the `find` method of Array\n
    * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n
    * @argument value\n * @returns index or -1\n */\nexport default function find(arr,
    check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    getWindowSizes from ''./getWindowSizes'';\nimport getClientRect from ''./getClientRect'';\n\n/**\n
    * Get the position of the given element, relative to its offset parent\n * @method\n
    * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position
    - Coordinates of the element and its `scrollTop`\n */\nexport default function
    getOffsetRect(element) {\n  let elementRect;\n  if (element.nodeName === ''HTML'')
    {\n    const { width, height } = getWindowSizes(element.ownerDocument);\n    elementRect
    = {\n      width,\n      height,\n      left: 0,\n      top: 0,\n    };\n  } else
    {\n    elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left:
    element.offsetLeft,\n      top: element.offsetTop,\n    };\n  }\n\n  // position\n  return
    getClientRect(elementRect);\n}\n","/**\n * Get the outer sizes of the given element
    (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Object} object containing width and height properties\n
    */\nexport default function getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const
    styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop
    || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft
    || 0) + parseFloat(styles.marginRight || 0);\n  const result = {\n    width: element.offsetWidth
    + y,\n    height: element.offsetHeight + x,\n  };\n  return result;\n}\n","/**\n
    * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport
    default function getOppositePlacement(placement) {\n  const hash = { left: ''right'',
    right: ''left'', bottom: ''top'', top: ''bottom'' };\n  return placement.replace(/left|right|bottom|top/g,
    matched => hash[matched]);\n}\n","import getOuterSizes from ''./getOuterSizes'';\nimport
    getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n * Get offsets to
    the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position
    - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the
    popper element\n * @param {Object} referenceOffsets - the reference offsets (the
    popper will be relative to this)\n * @param {String} placement - one of the valid
    placement options\n * @returns {Object} popperOffsets - An object containing the
    offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(popper,
    referenceOffsets, placement) {\n  placement = placement.split(''-'')[0];\n\n  //
    Get popper node sizes\n  const popperRect = getOuterSizes(popper);\n\n  // Add
    position, width and height to our offsets object\n  const popperOffsets = {\n    width:
    popperRect.width,\n    height: popperRect.height,\n  };\n\n  // depending by the
    popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","/**\n * Check if the given variable
    is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck
    - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nexport
    default function isFunction(functionToCheck) {\n  const getType = {};\n  return
    (\n    functionToCheck &&\n    getType.toString.call(functionToCheck) === ''[object
    Function]''\n  );\n}\n","/**\n * Helper used to know if the given modifier is
    enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport
    default function isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(\n    ({
    name, enabled }) => enabled && name === modifierName\n  );\n}\n","import find
    from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n *
    Get the window associated with the element\n * @argument {Element} element\n *
    @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getWindow from ''./getWindow'';\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nexport default function removeEventListeners(reference, state)
    {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import isFunction
    from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport getClientRect
    from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list of modifiers
    and run them in order,\n * each of them will then edit the data object.\n * @method\n
    * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n
    * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n
    */\nexport default function runModifiers(modifiers, data, ends) {\n  const modifiersToRun
    = ends === undefined\n    ? modifiers\n    : modifiers.slice(0, findIndex(modifiers,
    ''name'', ends));\n\n  modifiersToRun.forEach(modifier => {\n    if (modifier[''function''])
    { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element - Element to apply the attributes
    to\n * @argument {Object} styles\n * Object with a list of properties and values
    which will be applied to the element\n */\nexport default function setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function(prop) {\n    const value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","import getScrollParent from ''./getScrollParent'';\nimport
    getWindow from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent,
    event, callback, scrollParents) {\n  const isBody = scrollParent.nodeName ===
    ''BODY'';\n  const target = isBody ? scrollParent.ownerDocument.defaultView :
    scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if
    (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","import
    computeAutoPlacement from ''./computeAutoPlacement'';\nimport debounce from ''./debounce'';\nimport
    findIndex from ''./findIndex'';\nimport getBordersSize from ''./getBordersSize'';\nimport
    getBoundaries from ''./getBoundaries'';\nimport getBoundingClientRect from ''./getBoundingClientRect'';\nimport
    getClientRect from ''./getClientRect'';\nimport getOffsetParent from ''./getOffsetParent'';\nimport
    getOffsetRect from ''./getOffsetRect'';\nimport getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getOuterSizes from ''./getOuterSizes'';\nimport
    getParentNode from ''./getParentNode'';\nimport getPopperOffsets from ''./getPopperOffsets'';\nimport
    getReferenceOffsets from ''./getReferenceOffsets'';\nimport getScroll from ''./getScroll'';\nimport
    getScrollParent from ''./getScrollParent'';\nimport getStyleComputedProperty from
    ''./getStyleComputedProperty'';\nimport getSupportedPropertyName from ''./getSupportedPropertyName'';\nimport
    getWindowSizes from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport
    isFunction from ''./isFunction'';\nimport isModifierEnabled from ''./isModifierEnabled'';\nimport
    isModifierRequired from ''./isModifierRequired'';\nimport isNumeric from ''./isNumeric'';\nimport
    removeEventListeners from ''./removeEventListeners'';\nimport runModifiers from
    ''./runModifiers'';\nimport setAttributes from ''./setAttributes'';\nimport setStyles
    from ''./setStyles'';\nimport setupEventListeners from ''./setupEventListeners'';\n\n/**
    @namespace Popper.Utils */\nexport {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n\n//
    This is here just for backward compatibility with versions lower than v1.10.3\n//
    you should import the utilities using named exports, if you want them all use:\n//
    ```\n// import * as PopperUtils from ''popper-utils'';\n// ```\n// The default
    export will be removed in the next major version.\nexport default {\n  computeAutoPlacement,\n  debounce,\n  findIndex,\n  getBordersSize,\n  getBoundaries,\n  getBoundingClientRect,\n  getClientRect,\n  getOffsetParent,\n  getOffsetRect,\n  getOffsetRectRelativeToArbitraryNode,\n  getOuterSizes,\n  getParentNode,\n  getPopperOffsets,\n  getReferenceOffsets,\n  getScroll,\n  getScrollParent,\n  getStyleComputedProperty,\n  getSupportedPropertyName,\n  getWindowSizes,\n  isFixed,\n  isFunction,\n  isModifierEnabled,\n  isModifierRequired,\n  isNumeric,\n  removeEventListeners,\n  runModifiers,\n  setAttributes,\n  setStyles,\n  setupEventListeners,\n};\n"],"names":["element","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","property","nodeName","parentNode","host","document","body","getStyleComputedProperty","overflow","overflowX","overflowY","test","getScrollParent","getParentNode","reference","referenceNode","version","isIE11","documentElement","noOffsetParent","isIE","offsetParent","nextElementSibling","indexOf","getOffsetParent","firstElementChild","node","getRoot","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","scrollingElement","subtract","scrollTop","getScroll","scrollLeft","modifier","top","bottom","left","right","sideA","axis","sideB","parseFloat","styles","Math","parseInt","computedStyle","getSize","offsets","width","height","rect","getBoundingClientRect","result","sizes","getWindowSizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getBordersSize","getClientRect","fixedPosition","isIE10","runIsIE","isHTML","parent","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","excludeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","innerWidth","innerHeight","offset","isFixed","parentElement","el","boundaries","getFixedPositionOffsetParent","getReferenceNode","boundariesElement","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","popper","padding","isPaddingNumber","placement","getBoundaries","rects","refRect","sortedAreas","Object","keys","map","getArea","sort","b","area","a","filteredAreas","filter","computedPlacement","length","key","variation","split","Array","prototype","find","arr","findIndex","cur","match","obj","elementRect","offsetLeft","offsetTop","x","marginBottom","y","marginRight","hash","replace","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","commonOffsetParent","prefixes","upperProp","charAt","toUpperCase","slice","i","prefix","toCheck","style","functionToCheck","getType","toString","call","modifiers","some","name","enabled","requesting","isRequired","warn","requested","n","isNaN","isFinite","removeEventListener","state","updateBound","scrollParents","forEach","scrollElement","eventsEnabled","modifiersToRun","ends","fn","isFunction","data","value","attributes","removeAttribute","setAttribute","unit","isNumeric","isBody","target","addEventListener","passive","push","max","navigator","isBrowser","userAgent","timeoutDuration","longerTimeoutBrowsers","supportsMicroTasks","Promise","called","resolve","then","scheduled"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-umd-popper.js: "/**!\n * @fileOverview Kickass
    library to create and place poppers near their reference elements.\n * @version
    1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n
    *\n * Permission is hereby granted, free of charge, to any person obtaining a
    copy\n * of this software and associated documentation files (the \"Software\"),
    to deal\n * in the Software without restriction, including without limitation
    the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell\n * copies of the Software, and to permit persons to whom the Software is\n
    * furnished to do so, subject to the following conditions:\n *\n * The above copyright
    notice and this permission notice shall be included in all\n * copies or substantial
    portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT
    WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE\n * SOFTWARE.\n */\n(function (global, factory) {\n\ttypeof exports
    === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof
    define === 'function' && define.amd ? define(factory) :\n\t(global.Popper = factory());\n}(this,
    (function () { 'use strict';\n\nvar isBrowser = typeof window !== 'undefined'
    && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar
    timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident',
    'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n
    \     return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn)
    {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n
    \   }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called
    = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var
    scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled
    = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n
    \     }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser
    && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously
    deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof
    Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce
    = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the
    given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument
    {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is
    a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n
    \ return functionToCheck && getType.toString.call(functionToCheck) === '[object
    Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String}
    property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType
    !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n
    \ var css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML')
    {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n
    * Returns the scrolling parent of the given element\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n
    */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take
    care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n
    \ }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return
    element.ownerDocument.body;\n    case '#document':\n      return element.body;\n
    \ }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var
    _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n
    \     overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n
    \ if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return
    element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode
    ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction
    isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version
    === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns
    the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction
    getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n
    \ }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1
    DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip
    hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent
    && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n
    \ }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName
    || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n
    \ if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent,
    'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n
    \ return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName
    = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n
    \ return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) ===
    element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n
    * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode
    !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n
    * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof
    Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n
    * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1,
    element2) {\n  // This check is needed to avoid errors in case one of the elements
    isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2
    || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  var
    order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n
    \ var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n
    \ // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n
    \ // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer
    && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer))
    {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n
    \ }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root
    = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host,
    element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n
    \ }\n}\n\n/**\n * Gets the scroll value of the given element in the given side
    (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @argument {String} side `top` or `left`\n * @returns {number} amount
    of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length
    > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide =
    side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n
    \ if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n
    \   var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n *
    Sum or subtract the element scroll values (left and top) from a given rect object\n
    * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you
    want to change\n * @param {HTMLElement} element - The element from the function
    reads the scroll values\n * @param {Boolean} subtract - set to true if you want
    to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n
    */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length
    > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop =
    getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var
    modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom
    += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right
    += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders
    of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration}
    styles\n * Result of `getStyleComputedProperty` on the given element\n * @param
    {String} axis - `x` or `y`\n * @return {number} borders - The borders size of
    the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA =
    axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n
    \ return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border'
    + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n
    \ return Math.max(body['offset' + axis], body['scroll' + axis], html['client'
    + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset'
    + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')])
    + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')])
    : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n
    \ var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n
    \ return {\n    height: getSize('Height', body, html, computedStyle),\n    width:
    getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function
    (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw
    new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass
    = function () {\n  function defineProperties(target, props) {\n    for (var i
    = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable
    = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if
    (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target,
    descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps,
    staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n
    \   if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n
    \ };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if
    (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable:
    true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n
    \   obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign
    || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var
    source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source,
    key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n
    * Given element offsets, generate an output similar to getBoundingClientRect\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns
    {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return
    _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom:
    offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of
    given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element)
    {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n
    \ // considered in DOM in some circumstances...\n  // This isn't reproducible
    in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect =
    element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n
    \     var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n
    \     rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right
    += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n
    \   }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n
    \   width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n
    \ // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML'
    ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth
    || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n
    \ var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's
    not a `border`\n  // we make this check conditional for performance reasons\n
    \ if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n
    \   horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles,
    'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n
    \ }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children,
    parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined
    ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName
    === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect
    = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n
    \ var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n
    \ var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where
    the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n
    \ // Subtract margins of documentElement in case it's being used as parent\n  //
    we do this only on HTML because it's the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var
    marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n
    \   offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth
    - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right
    -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because
    in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft
    = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent)
    : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets
    = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element)
    {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ?
    arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n
    \ var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n
    \ var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height
    = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left')
    : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n
    \   left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width:
    width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n
    * Check if the given element is fixed or is inside a fixed parent\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element}
    customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element)
    {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName ===
    'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position')
    === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n
    \ if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n
    * Finds the first parent of an element that has a transformed property defined\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns
    {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element)
    {\n  // This check is needed to avoid errors in case one of the elements isn't
    defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n
    \   return document.documentElement;\n  }\n  var el = element.parentElement;\n
    \ while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el
    = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n
    * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n
    * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number}
    padding\n * @param {HTMLElement} boundariesElement - Element used to define the
    boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n *
    @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper,
    reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length
    > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM
    access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n
    \ // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries
    = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n
    \ } else {\n    // Handle other cases based on DOM element used as boundaries\n
    \   var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent')
    {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if
    (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n
    \     }\n    } else if (boundariesElement === 'window') {\n      boundariesNode
    = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode =
    boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode,
    offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n
    \   if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var
    _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n
    \         width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top
    - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n
    \   } else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var
    isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n
    \ return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n
    \     height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility
    used to transform the `auto` placement to the placement with more\n * available
    space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The
    data object generated by update method\n * @argument {Object} options - Modifiers
    configuration and options\n * @returns {Object} The data object, properly modified\n
    */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement)
    {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5]
    : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n
    \ var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n
    \ var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n
    \     height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n
    \     height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width:
    refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n
    \ var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n
    \     key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n
    \ }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas
    = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height
    = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n
    \ });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key
    : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return
    computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets
    to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object}
    state\n * @param {Element} popper - the popper element\n * @param {Element} reference
    - the reference element (the popper will be relative to this)\n * @param {Element}
    fixedPosition - is in fixed position mode\n * @returns {Object} An object containing
    the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state,
    popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3]
    !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n
    \ return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nfunction getOuterSizes(element)
    {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n
    \ var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom ||
    0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight
    || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given
    one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement)
    {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n
    \ return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return
    hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n *
    @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper
    will get applied\n * @param {HTMLElement} popper - the popper element\n * @param
    {Object} referenceOffsets - the reference offsets (the popper will be relative
    to this)\n * @param {String} placement - one of the valid placement options\n
    * @returns {Object} popperOffsets - An object containing the offsets which will
    be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets,
    placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n
    \ var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height
    to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n
    \   height: popperRect.height\n  };\n\n  // depending by the popper placement
    we have to compute its offsets slightly differently\n  var isHoriz = ['right',
    'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n
    \ var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ?
    'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n
    \ popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement]
    / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide]
    = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else
    {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n
    \ }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n
    * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n
    * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n
    \ // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n
    \ }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n
    * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n
    * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index
    or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function
    (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` +
    `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj)
    {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n
    * Loop trough the list of modifiers and run them in order,\n * each of them will
    then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject}
    data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier
    name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers,
    data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0,
    findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier)
    {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n
    \     console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n
    \   }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line
    dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties
    to offsets to make them a complete clientRect object\n      // we do this before
    each modifier to make sure the previous one doesn't\n      // mess with these
    values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n
    \   }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper,
    computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate`
    over `update` because of performance reasons.\n * @method\n * @memberof Popper\n
    */\nfunction update() {\n  // if popper is destroyed, don't perform any further
    update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n
    \   instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n
    \   flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n
    \ data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference,
    this.options.positionFixed);\n\n  // compute auto placement, store placement inside
    the data object,\n  // modifiers will be able to edit `placement` if needed\n
    \ // and refer to originalPlacement to know the original value\n  data.placement
    = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper,
    this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n
    \ // store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper,
    data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed
    ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers,
    data);\n\n  // the first `update` will call `onCreate` callback\n  // the other
    ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated
    = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n
    \ }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n
    * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers,
    modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n
    \       enabled = _ref.enabled;\n    return enabled && name === modifierName;\n
    \ });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof
    Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String}
    prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n
    */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms',
    'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n
    \ for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n
    \   var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof
    document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n
    \ }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof
    Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch
    DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers,
    'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position
    = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right
    = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange =
    '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n
    \ this.disableEventListeners();\n\n  // remove the popper if user explicitly asked
    for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support
    it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n
    \ }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n
    * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element)
    {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target
    = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode),
    event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference,
    options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound
    = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound,
    { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement
    = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll',
    state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n
    \ state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll
    events and start recalculating\n * position of the popper element when they are
    triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners()
    {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference,
    this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event
    listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n
    * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove
    resize event listener on window\n  getWindow(reference).removeEventListener('resize',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function
    (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n
    \ // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will
    remove resize/scroll events and won't recalculate popper position\n * when they
    are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you
    call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n
    \   this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n
    * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n
    * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n)
    {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set
    the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element - Element to apply the style to\n * @argument {Object} styles\n
    * Object with a list of properties and values which will be applied to the element\n
    */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function
    (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one
    of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop)
    !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nfunction setAttributes(element,
    attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value
    = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n
    \ });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data
    - The data object generated by `update` method\n * @argument {Object} data.styles
    - List of style properties - values to apply to popper element\n * @argument {Object}
    data.attributes - List of attribute properties - values to apply to popper element\n
    * @argument {Object} options - Modifiers configuration and options\n * @returns
    {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property
    present in `data.styles` will be applied to the popper,\n  // in this way we can
    make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers
    could override the properties defined in the previous\n  // lines of this modifier!\n
    \ setStyles(data.instance.popper, data.styles);\n\n  // any property present in
    `data.attributes` will be applied to the popper,\n  // they will be set as HTML
    attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n
    \ // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement
    && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n
    \ }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything
    else because it could be used\n * to add margins to the popper margins needs to
    be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof
    Popper.modifiers\n * @param {HTMLElement} reference - The reference element used
    to position the popper\n * @param {HTMLElement} popper - The HTML element used
    as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference,
    popper, options, modifierOptions, state) {\n  // compute reference element offsets\n
    \ var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n
    \ // compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  var placement = computeAutoPlacement(options.placement,
    referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement,
    options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n
    \ // Apply `position` to popper before anything else because\n  // without the
    position applied we can't guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper's position offsets
    rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect,
    but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n
    *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n
    * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning
    and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal
    placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data,
    shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n
    \     reference = _data$offsets.reference;\n  var round = Math.round,\n      floor
    = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n
    \ var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n
    \ var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation
    = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth
    % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth
    % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical
    || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger =
    !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth
    && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n
    \   bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n
    \ };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by `update` method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nfunction
    computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var
    popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js
    v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function
    (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n
    \ if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING:
    `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported
    in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption
    !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var
    offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position:
    popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio
    < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var
    sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to
    `true` and transform is supported,\n  //  we use `translate3d` to apply the position
    to the popper we\n  // automatically use the supported prefixed version if needed\n
    \ var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's
    make a step back and look at this code closely (wtf?)\n  // If the content of
    the popper grows once it's been positioned, it\n  // may happen that the popper
    gets misplaced because of the new content\n  // overflowing its reference element\n
    \ // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top
    = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the
    positioning is relative to the bottom of the screen (excluding the scrollbar)\n
    \   // and not the bottom of the html element\n    if (offsetParent.nodeName ===
    'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else
    {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n
    \   top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName
    === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    }
    else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else
    {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n
    \   styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n
    \   styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n
    \ } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and
    `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var
    invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n
    \   styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' +
    sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n
    \ };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles,
    data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n
    \ return data;\n}\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction
    isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting
    = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name
    === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function
    (modifier) {\n    return modifier.name === requestedName && modifier.enabled &&
    modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting
    = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n
    \   console.warn(requested + ' modifier is required by ' + _requesting + ' modifier
    in order to work, be sure to include it before ' + _requesting + '!');\n  }\n
    \ return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument
    {Object} data - The data object generated by update method\n * @argument {Object}
    options - Modifiers configuration and options\n * @returns {Object} The data object,
    properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n
    \ // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers,
    'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n
    \ // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement
    === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n
    \   // if arrowElement is not found, don't run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query
    selector we must check that the\n    // provided DOM node is child of its popper
    node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING:
    `arrow.element` must be child of its popper element!');\n      return data;\n
    \   }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets
    = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n
    \ var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len =
    isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' :
    'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical
    ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize
    = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior
    making sure the popper and its\n  // reference have enough pixels in conjunction\n
    \ //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side])
    {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n
    \ }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide])
    {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n
    \ }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute
    center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize
    / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take
    popper margin in account because we don't have this info available\n  var css
    = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin'
    + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized
    + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide
    - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously
    to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize,
    sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow =
    (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)),
    defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return
    data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n *
    @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n
    * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation)
    {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation ===
    'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of
    accepted placements to use as values of the `placement` option.<br />\n * Valid
    placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n
    *\n * Each placement can have a variation from this list:\n * - `-start`\n * -
    `-end`\n *\n * Variations are interpreted easily if you think of them as the left
    to right\n * written languages. Horizontally (`top` and `bottom`), `start` is
    left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start`
    is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on
    top of reference, right aligned)\n * - `right-start` (on right of reference, top
    aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with
    more space available, alignment depends by placement)\n *\n * @static\n * @type
    {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof
    Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start',
    'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom',
    'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start`
    and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an
    initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n
    *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A
    valid placement (it accepts variations)\n * @argument {Boolean} counter - Set
    to true to walk the placements counterclockwise\n * @returns {Array} placements
    including their variations\n */\nfunction clockwise(placement) {\n  var counter
    = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n
    \ var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index
    + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse()
    : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE:
    'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument
    {Object} data - The data object generated by update method\n * @argument {Object}
    options - Modifiers configuration and options\n * @returns {Object} The data object,
    properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier
    is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there's not enough space on any of the flippable sides\n    return data;\n  }\n\n
    \ var boundaries = getBoundaries(data.instance.popper, data.instance.reference,
    options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement
    = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n
    \ var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n
    \ switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n
    \     flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder
    = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if
    (placement !== step || flipOrder.length === index + 1) {\n      return data;\n
    \   }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n
    \   var refOffsets = data.offsets.reference;\n\n    // using floor because the
    reference offsets may contain decimals we are not going to consider here\n    var
    floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right)
    > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left)
    < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom)
    > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top)
    < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) <
    floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left'
    && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top'
    && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the
    variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement)
    !== -1;\n\n    // flips variation if reference element overflows boundaries\n
    \   var flippedVariationByRef = !!options.flipVariations && (isVertical && variation
    === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight
    || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation
    === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows
    boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent
    && (isVertical && variation === 'start' && overflowsRight || isVertical && variation
    === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom
    || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation
    = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef ||
    overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any
    flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries)
    {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation)
    {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? '-' + variation : '');\n\n      // this object contains
    `position`, we want to preserve it along with\n      // any additional property
    we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper,
    getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n
    \     data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n
    \ return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n
    \     popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n
    \ var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var
    isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical
    ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement
    = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide]))
    {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n
    \ }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide]
    = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string
    containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n
    * @private\n * @argument {String} str - Value + unit string\n * @argument {String}
    measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument
    {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or
    original string if no values were extracted\n */\nfunction toValue(str, measurement,
    popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split
    = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var
    unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if
    (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var
    element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n
    \       break;\n      case '%':\n      case '%r':\n      default:\n        element
    = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return
    rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw')
    {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var
    size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight,
    window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth,
    window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n
    \   // if is an explicit pixel unit, we get rid of the unit and keep the value\n
    \   // if is an implicit unit, it's px, and we return just the value\n    return
    value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y`
    numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n
    * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument
    {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array}
    a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset,
    popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n
    \ // Use height if placement is left or right and index is 0 otherwise use width\n
    \ // in this way the first offset will use an axis and the second one\n  // will
    use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement)
    !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n
    \ // The regex addresses values with the plus or minus sign in front (+10, -20,
    etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return
    frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  var divider
    = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/)
    !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',')
    === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated,
    use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list
    of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex
    = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]),
    [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))]
    : [fragments];\n\n  // Convert the values with units to absolute pixels to allow
    our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units
    rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight
    : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return
    op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n
    \   // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length
    - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n
    \       mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious)
    {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return
    a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here
    we convert the string values into number values (in px)\n    .map(function (str)
    {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n
    \   });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n
    \ ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n
    \     if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1]
    === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by update method\n * @argument {Object} options - Modifiers configuration and
    options\n * @argument {Number|String} options.offset=0\n * The offset value as
    described in the modifier description\n * @returns {Object} The data object, properly
    modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var
    placement = data.placement,\n      _data$offsets = data.offsets,\n      popper
    = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement
    = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n
    \   popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement
    === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n
    \ } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left +=
    offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data
    - The data object generated by `update` method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement
    = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  //
    If offsetParent is the reference element, we really want to\n  // go one step
    up and use the next offsetParent as reference to\n  // avoid to make this modifier
    completely useless and look like broken\n  if (data.instance.reference === boundariesElement)
    {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE:
    DOM access here\n  // resets the popper's position so that the document size can
    be calculated excluding\n  // the size of the popper element itself\n  var transformProp
    = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style;
    // assignment to help minification\n  var top = popperStyles.top,\n      left
    = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top
    = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var
    boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding,
    boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores
    the original style properties after the offsets have been computed\n  popperStyles.top
    = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n
    \ options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper
    = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement)
    {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement]
    && !options.escapeWithReference) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n
    \   },\n    secondary: function secondary(placement) {\n      var mainSide = placement
    === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement]
    > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide],
    boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n
    \     }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function
    (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary'
    : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n
    \ data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n *
    @memberof Modifiers\n * @argument {Object} data - The data object generated by
    `update` method\n * @argument {Object} options - Modifiers configuration and options\n
    * @returns {Object} The data object, properly modified\n */\nfunction shift(data)
    {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n
    \ var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation
    is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets
    = data.offsets,\n        reference = _data$offsets.reference,\n        popper
    = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement)
    !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical
    ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({},
    side, reference[side]),\n      end: defineProperty({}, side, reference[side] +
    reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper
    = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nfunction
    hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow'))
    {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound
    = find(data.instance.modifiers, function (modifier) {\n    return modifier.name
    === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top ||
    refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left)
    {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide
    === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries']
    = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n
    \   if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n
    \   data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by `update` method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nfunction
    inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n
    \ var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference
    = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement)
    !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n
    \ popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength
    ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n
    \ data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n *
    Modifier function, each modifier can have a function of this type assigned\n *
    to its `fn` property.<br />\n * These functions will be called on each update,
    this means that you must\n * make sure they are performant enough to avoid performance
    bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The
    data object generated by `update` method\n * @argument {Object} options - Modifiers
    configuration and options\n * @returns {dataObject} The data object, properly
    modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your
    poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic
    functionalities\n * needed by the library.\n *\n * Usually you don't want to override
    the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations
    that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n
    \  * Modifier used to shift the popper on the start or end of its reference\n
    \  * element.<br />\n   * It will read the variation of the `placement` property.<br
    />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n
    \  * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used
    to define the order of execution */\n    order: 100,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n
    \   /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset`
    modifier can shift your popper on both its axis.\n   *\n   * It accepts the following
    units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage
    relative to the length of the reference element\n   * - `%p`, percentage relative
    to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   *
    - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis
    relative to the placement of the popper.<br />\n   * This means that if the placement
    is `top` or `bottom`, the length will be the\n   * `width`. In case of `left`
    or `right`, it will be the `height`.\n   *\n   * You can provide a single value
    (as `Number` or `String`), or a pair of values\n   * as `String` divided by a
    comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method
    because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally,
    it accepts additions and subtractions between different units.\n   * Note that
    multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n
    \  * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n
    \  * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If
    you desire to apply offsets to your poppers in a way that may make them overlap\n
    \  * > with their reference element, unfortunately, you will have to disable the
    `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n
    \  *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop
    {number} order=200 - Index used to define the order of execution */\n    order:
    200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or
    not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /**
    @prop {Number|String} offset=0\n     * The offset value as described in the modifier
    description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent
    the popper from being positioned outside the boundary.\n   *\n   * A scenario
    exists where the reference itself is not within the boundaries.<br />\n   * We
    can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In
    this case we need to decide whether the popper should either:\n   *\n   * - detach
    from the reference and remain \"trapped\" in the boundaries, or\n   * - if it
    should ignore the boundary and \"escape with its reference\"\n   *\n   * When
    `escapeWithReference` is set to`true` and reference is completely\n   * outside
    its boundaries, the popper will overflow (or completely leave)\n   * the boundaries
    in order to remain attached to the edge of the reference.\n   *\n   * @memberof
    modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300
    - Index used to define the order of execution */\n    order: 300,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try
    to prevent overflow following these priorities by default,\n     * then, it could
    overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n
    \    * Amount of pixel used to define a minimum distance between the boundaries\n
    \    * and the popper. This makes sure the popper always has a little padding\n
    \    * between the edges of its container\n     */\n    padding: 5,\n    /**\n
    \    * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n
    \  * Modifier used to make sure the reference and its popper stay near each other\n
    \  * without leaving any gap between the two. Especially useful when the arrow
    is\n   * enabled and you want to ensure that it points to its reference element.\n
    \  * It cares only about the first axis. You can still have poppers with margin\n
    \  * between the popper and its reference element.\n   * @memberof modifiers\n
    \  * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index
    used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n
    \   /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This
    modifier is used to move the `arrowElement` of the popper to make\n   * sure it
    is positioned between the reference element and its popper element.\n   * It will
    read the outer size of the `arrowElement` node to detect how many\n   * pixels
    of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is
    provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop
    {number} order=500 - Index used to define the order of execution */\n    order:
    500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or
    not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /**
    @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow
    */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's
    placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires
    the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:**
    this modifier will interrupt the current update cycle and will\n   * restart it
    if it detects the need to flip the placement.\n   * @memberof modifiers\n   *
    @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define
    the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true
    - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop
    {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n
    \    * The behavior used to change the popper's placement. It can be one of\n
    \    * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n
    \    * placements (with optional variations)\n     */\n    behavior: 'flip',\n
    \   /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits
    the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which
    will define the boundaries of the popper position.\n     * The popper will never
    be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n
    \    *\n     * The original placement should have a set variation.\n     */\n
    \   flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n
    \    * The popper will switch placement variation between `-start` and `-end`
    when\n     * the popper element overlaps its reference boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariationsByContent:
    false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n
    \  * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used
    to define the order of execution */\n    order: 700,\n    /** @prop {Boolean}
    enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n
    \   /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used
    to hide the popper when its reference element is outside of the\n   * popper boundaries.
    It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide
    with a CSS selector the popper when its reference is\n   * out of boundaries.\n
    \  *\n   * Requires the `preventOverflow` modifier before it in order to work.\n
    \  * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number}
    order=800 - Index used to define the order of execution */\n    order: 800,\n
    \   /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not
    */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n
    \ /**\n   * Computes the style that will be applied to the popper element to gets\n
    \  * properly positioned.\n   *\n   * Note that this modifier will not touch the
    DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply
    it. This separation is useful\n   * in case you need to replace `applyStyle` with
    a custom implementation.\n   *\n   * This modifier has `850` as `order` value
    to maintain backward compatibility\n   * with previous versions of Popper.js.
    Expect the modifiers ordering method\n   * to change in future major versions
    of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle:
    {\n    /** @prop {number} order=850 - Index used to define the order of execution
    */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier
    is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn:
    computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If
    true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n
    \   /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis
    (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should
    grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n
    \    * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or
    `right`). AKA Y offset origin.\n     * Change this if your popper should grow
    in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n
    \  * Applies the computed styles to the popper element.\n   *\n   * All the DOM
    manipulations are limited to this modifier. This is useful in case\n   * you want
    to integrate Popper.js inside a framework or view library and you\n   * want to
    delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable
    this modifier, you must make sure the popper element\n   * has its position set
    to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this
    modifier and define your own to achieve the desired effect.\n   *\n   * @memberof
    modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900
    - Index used to define the order of execution */\n    order: 900,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function}
    */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0,
    the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n
    \    * If true, it uses the CSS 3D transformation to position the popper.\n     *
    Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the
    information used by Popper.js.\n * This object is passed to modifiers and to the
    `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object}
    data.instance The Popper.js instance\n * @property {String} data.placement Placement
    applied to popper\n * @property {String} data.originalPlacement Placement originally
    defined on init\n * @property {Boolean} data.flipped True if popper has been flipped
    by flip modifier\n * @property {Boolean} data.hide True if the reference element
    is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement}
    data.arrowElement Node used as arrow by arrow modifier\n * @property {Object}
    data.styles Any CSS property defined here will be applied to the popper. It expects
    the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles
    Any CSS property defined here will be applied to the popper arrow. It expects
    the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n
    * Default options provided to Popper.js constructor.<br />\n * These can be overridden
    using the `options` argument of Popper.js.<br />\n * To override an option, simply
    pass an object with the same\n * structure of the `options` object, as the 3rd
    argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n
    *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n
    * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n
    \  * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n
    \ /**\n   * Set this to true if you want popper to position it self in 'fixed'
    mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n
    \ /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop
    {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set
    to true if you want to automatically remove the popper when\n   * you call the
    `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n
    \  * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   *
    Callback called when the popper is updated. This callback is not called\n   *
    on the initialization/creation of the popper, but only on subsequent\n   * updates.<br
    />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance
    with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate()
    {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are
    applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n
    \  * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback
    onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param
    {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n
    \  * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject}
    reference - The reference element used to position the popper\n   * @param {Element}
    popper - The HTML / XML element used as the popper\n   * @param {Object} options
    - Your custom options to override the ones defined in [Defaults](#defaults)\n
    \  * @return {Object} instance - The generated Popper.js instance\n   */\n  function
    Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length
    > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this,
    Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n
    \   };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n
    \   this.update = debounce(this.update.bind(this));\n\n    // with {} we create
    a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults,
    options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n
    \     isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference
    and popper elements (allow jQuery wrappers)\n    this.reference = reference &&
    reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery
    ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function
    (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name]
    || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring
    modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function
    (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n
    \   })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return
    a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary
    code when Popper.js get inited\n    // such code is executed in the same order
    of its modifier\n    // they could add new properties to their options configuration\n
    \   // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n
    \   this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled
    && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference,
    _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n
    \   // fire the first update to position the popper in the right place\n    this.update();\n\n
    \   var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n
    \     // setup event listeners, they will take care of update the position in
    specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n
    \ createClass(Popper, [{\n    key: 'update',\n    value: function update$$1()
    {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value:
    function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key:
    'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return
    enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n
    \   value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n
    \   }\n\n    /**\n     * Schedules an update. It will run on the next UI update
    available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n
    \   /**\n     * Collection of utilities useful when writing custom modifiers.\n
    \    * Starting from version 1.7, this method is available only if you\n     *
    include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**:
    This way to access PopperUtils is deprecated\n     * and will be removed in v2!
    Use the PopperUtils module directly instead.\n     * Due to the high instability
    of the methods contained in Utils, we can't\n     * guarantee them to follow semver.
    Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n
    \    * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n
    \    */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is
    an object that provides an interface compatible with Popper.js\n * and lets you
    use it as replacement of a real DOM node.<br />\n * You can use this method to
    position a popper relatively to a set of coordinates\n * in case you don't have
    a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n
    * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name
    referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function
    that returns a set of coordinates compatible with the native `getBoundingClientRect`
    method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return
    the width of the virtual reference element.\n * @property {number} data.clientHeight\n
    * An ES6 getter that will return the height of the virtual reference element.\n
    */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements
    = placements;\nPopper.Defaults = Defaults;\n\nreturn Popper;\n\n})));\n//# sourceMappingURL=popper.js.map\n"
  admin-Public-Admin-plugins-popper-umd-popper.js.flow: |
    // @flow

    export type Position = 'top' | 'right' | 'bottom' | 'left';

    export type Placement =
      | 'auto-start'
      | 'auto'
      | 'auto-end'
      | 'top-start'
      | 'top'
      | 'top-end'
      | 'right-start'
      | 'right'
      | 'right-end'
      | 'bottom-end'
      | 'bottom'
      | 'bottom-start'
      | 'left-end'
      | 'left'
      | 'left-start';

    export type Offset = {
      top: number,
      left: number,
      width: number,
      height: number,
      position: Position,
    };

    export type Boundary = 'scrollParent' | 'viewport' | 'window';

    export type Behavior = 'flip' | 'clockwise' | 'counterclockwise';

    export type Data = {
      instance: Popper,
      placement: Placement,
      originalPlacement: Placement,
      flipped: boolean,
      hide: boolean,
      arrowElement: Element,
      styles: CSSStyleDeclaration,
      arrowStyles: CSSStyleDeclaration,
      boundaries: Object,
      offsets: {
        popper: Offset,
        reference: Offset,
        arrow: {
          top: number,
          left: number,
        },
      },
    };

    export type ModifierFn = (data: Data, options: Object) => Data;

    export type Padding = {
      top?: number,
      bottom?: number,
      left?: number,
      right?: number,
    };

    export type BaseModifier = {
      order?: number,
      enabled?: boolean,
      fn?: ModifierFn,
    };

    export type Modifiers = {
      shift?: BaseModifier,
      offset?: BaseModifier & {
        offset?: number | string,
      },
      preventOverflow?: BaseModifier & {
        priority?: Position[],
        padding?: number | Padding,
        boundariesElement?: Boundary | Element,
        escapeWithReference?: boolean,
      },
      keepTogether?: BaseModifier,
      arrow?: BaseModifier & {
        element?: string | Element | null,
      },
      flip?: BaseModifier & {
        behavior?: Behavior | Position[],
        padding?: number | Padding,
        boundariesElement?: Boundary | Element,
        flipVariations?: boolean,
        flipVariationsByContent?: boolean,
      },
      inner?: BaseModifier,
      hide?: BaseModifier,
      applyStyle?: BaseModifier & {
        onLoad?: Function,
        gpuAcceleration?: boolean,
      },
      computeStyle?: BaseModifier & {
        gpuAcceleration?: boolean,
        x?: 'bottom' | 'top',
        y?: 'left' | 'right',
      },

      [name: string]: (BaseModifier & { [string]: * }) | null,
    };

    export type Options = {
      placement?: Placement,
      positionFixed?: boolean,
      eventsEnabled?: boolean,
      modifiers?: Modifiers,
      removeOnDestroy?: boolean,

      onCreate?: (data: Data) => void,

      onUpdate?: (data: Data) => void,
    };

    export type ReferenceObject = {
      +clientHeight: number,
      +clientWidth: number,
      +referenceNode?: Node,

      getBoundingClientRect():
        | ClientRect
        | {
            width: number,
            height: number,
            top: number,
            right: number,
            bottom: number,
            left: number,
          },
    };

    export type Instance = {
      destroy: () => void,
      scheduleUpdate: () => void,
      update: () => void,
      enableEventListeners: () => void,
      disableEventListeners: () => void,
    };

    declare class Popper {
      static placements: Placement;

      popper: Element;
      reference: Element | ReferenceObject;

      constructor(
        reference: Element | ReferenceObject,
        popper: Element,
        options?: Options
      ): Instance;
    }

    declare export default typeof Popper;
  admin-Public-Admin-plugins-popper-umd-popper.js.map: '{"version":3,"file":"popper.js","sources":["../../src/utils/isBrowser.js","../../src/utils/debounce.js","../../src/utils/isFunction.js","../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/runModifiers.js","../../src/methods/update.js","../../src/utils/isModifierEnabled.js","../../src/utils/getSupportedPropertyName.js","../../src/methods/destroy.js","../../src/utils/getWindow.js","../../src/utils/setupEventListeners.js","../../src/methods/enableEventListeners.js","../../src/utils/removeEventListeners.js","../../src/methods/disableEventListeners.js","../../src/utils/isNumeric.js","../../src/utils/setStyles.js","../../src/utils/setAttributes.js","../../src/modifiers/applyStyle.js","../../src/utils/getRoundedOffsets.js","../../src/modifiers/computeStyle.js","../../src/utils/isModifierRequired.js","../../src/modifiers/arrow.js","../../src/utils/getOppositeVariation.js","../../src/methods/placements.js","../../src/utils/clockwise.js","../../src/modifiers/flip.js","../../src/modifiers/keepTogether.js","../../src/modifiers/offset.js","../../src/modifiers/preventOverflow.js","../../src/modifiers/shift.js","../../src/modifiers/hide.js","../../src/modifiers/inner.js","../../src/modifiers/index.js","../../src/methods/defaults.js","../../src/index.js"],"sourcesContent":["export
    default typeof window !== ''undefined'' && typeof document !== ''undefined'' &&
    typeof navigator !== ''undefined'';\n","import isBrowser from ''./isBrowser'';\n\nconst
    timeoutDuration = (function(){\n  const longerTimeoutBrowsers = [''Edge'', ''Trident'',
    ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if
    (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return
    1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn) {\n  let
    called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","/**\n
    * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n
    * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer
    to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const
    getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck)
    === ''[object Function]''\n  );\n}\n","/**\n * Get CSS computed property of the
    given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n
    * @argument {String} property\n */\nexport default function getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const
    css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName
    === ''HTML'') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getParentNode
    from ''./getParentNode'';\n\n/**\n * Returns the scrolling parent of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n
    * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element)
    {\n  // Return body, `getScroll` will take care to get the correct `scrollTop`
    from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName)
    {\n    case ''HTML'':\n    case ''BODY'':\n      return element.ownerDocument.body\n    case
    ''#document'':\n      return element.body\n  }\n\n  // Firefox want us to check
    `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } =
    getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow
    + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nexport default function getOuterSizes(element)
    {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const
    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const
    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  const
    result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the
    given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement)
    {\n  const hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom''
    };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import
    getOuterSizes from ''./getOuterSizes'';\nimport getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n
    * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param
    {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement}
    popper - the popper element\n * @param {Object} referenceOffsets - the reference
    offsets (the popper will be relative to this)\n * @param {String} placement -
    one of the valid placement options\n * @returns {Object} popperOffsets - An object
    containing the offsets which will be applied to the popper\n */\nexport default
    function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement
    = placement.split(''-'')[0];\n\n  // Get popper node sizes\n  const popperRect
    = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets
    object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  //
    depending by the popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function find(arr, check)
    {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    isFunction from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport
    getClientRect from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list
    of modifiers and run them in order,\n * each of them will then edit the data object.\n
    * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array}
    modifiers\n * @param {String} ends - Optional modifier name used as stopper\n
    * @returns {dataObject}\n */\nexport default function runModifiers(modifiers,
    data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    :
    modifiers.slice(0, findIndex(modifiers, ''name'', ends));\n\n  modifiersToRun.forEach(modifier
    => {\n    if (modifier[''function'']) { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","import computeAutoPlacement from ''../utils/computeAutoPlacement'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\n\n/**\n
    * Updates the position of the popper, computing the new offsets and applying\n
    * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance
    reasons.\n * @method\n * @memberof Popper\n */\nexport default function update()
    {\n  // if popper is destroyed, don''t perform any further update\n  if (this.state.isDestroyed)
    {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles:
    {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  //
    compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  //
    compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  //
    store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position
    = this.options.positionFixed\n    ? ''fixed''\n    : ''absolute'';\n\n  // run
    the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first
    `update` will call `onCreate` callback\n  // the other ones will call `onUpdate`
    callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  }
    else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know
    if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns
    {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName)
    {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from ''../utils/isModifierEnabled'';\nimport
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * Destroys the popper.\n * @method\n * @memberof Popper\n */\nexport default function
    destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle`
    modifier is enabled\n  if (isModifierEnabled(this.modifiers, ''applyStyle''))
    {\n    this.popper.removeAttribute(''x-placement'');\n    this.popper.style.position
    = '''';\n    this.popper.style.top = '''';\n    this.popper.style.left = '''';\n    this.popper.style.right
    = '''';\n    this.popper.style.bottom = '''';\n    this.popper.style.willChange
    = '''';\n    this.popper.style[getSupportedPropertyName(''transform'')] = '''';\n  }\n\n  this.disableEventListeners();\n\n  //
    remove the popper if user explicitly asked for the deletion on destroy\n  // do
    not use `remove` because IE11 doesn''t support it\n  if (this.options.removeOnDestroy)
    {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n
    * Get the window associated with the element\n * @argument {Element} element\n
    * @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getScrollParent from ''./getScrollParent'';\nimport getWindow
    from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  const isBody = scrollParent.nodeName === ''BODY'';\n  const
    target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    setupEventListeners from ''../utils/setupEventListeners'';\n\n/**\n * It will
    add resize/scroll events and start recalculating\n * position of the popper element
    when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default
    function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state
    = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import
    getWindow from ''./getWindow'';\n\n/**\n * Remove event listeners used to update
    the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport
    default function removeEventListeners(reference, state) {\n  // Remove resize
    event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners
    from ''../utils/removeEventListeners'';\n\n/**\n * It will remove resize/scroll
    events and won''t recalculate popper position\n * when they are triggered. It
    also won''t trigger `onUpdate` callback anymore,\n * unless you call `update`
    method manually.\n * @method\n * @memberof Popper\n */\nexport default function
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state
    = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nexport default
    function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop)
    {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","import
    setStyles from ''../utils/setStyles'';\nimport setAttributes from ''../utils/setAttributes'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport computeAutoPlacement
    from ''../utils/computeAutoPlacement'';\n\n/**\n * @function\n * @memberof Modifiers\n
    * @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} data.styles - List of style properties - values to apply to popper element\n
    * @argument {Object} data.attributes - List of attribute properties - values to
    apply to popper element\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The same data object\n */\nexport default function
    applyStyle(data) {\n  // any property present in `data.styles` will be applied
    to the popper,\n  // in this way we can make the 3rd party modifiers add custom
    styles to it\n  // Be aware, modifiers could override the properties defined in
    the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper,
    data.styles);\n\n  // any property present in `data.attributes` will be applied
    to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper,
    data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some
    properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement,
    data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute
    before everything else because it could be used\n * to add margins to the popper
    margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n
    * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference
    element used to position the popper\n * @param {HTMLElement} popper - The HTML
    element used as popper\n * @param {Object} options - Popper.js options\n */\nexport
    function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n)
    {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state,
    popper, reference, options.positionFixed);\n\n  // compute auto placement, store
    placement inside the data object,\n  // modifiers will be able to edit `placement`
    if needed\n  // and refer to originalPlacement to know the original value\n  const
    placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute(''x-placement'',
    placement);\n\n  // Apply `position` to popper before anything else because\n  //
    without the position applied we can''t guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? ''fixed'' : ''absolute'' });\n\n  return options;\n}\n","/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper''s position
    offsets rounded\n *\n * The tale of pixel-perfect positioning. It''s still not
    100% perfect, but as\n * good as it can be within reason.\n * Discussion here:
    https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause
    a popper to be blurry if not using full pixels (Safari\n * as well on High DPI
    screens).\n *\n * Firefox prefers no rounding for positioning and does not have
    blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right
    values need to be considered.\n */\nexport default function getRoundedOffsets(data,
    shouldRound) {\n  const { popper, reference } = data.offsets;\n  const { round,
    floor } = Math;\n  const noRound = v => v;\n  \n  const referenceWidth = round(reference.width);\n  const
    popperWidth = round(popper.width);\n  \n  const isVertical = [''left'', ''right''].indexOf(data.placement)
    !== -1;\n  const isVariation = data.placement.indexOf(''-'') !== -1;\n  const
    sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  const bothOddWidth
    = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  const horizontalToInteger
    = !shouldRound\n    ? noRound\n    : isVertical || isVariation || sameWidthParity\n    ?
    round\n    : floor;\n  const verticalToInteger = !shouldRound ? noRound : round;\n\n  return
    {\n    left: horizontalToInteger(\n      bothOddWidth && !isVariation && shouldRound\n        ?
    popper.left - 1\n        : popper.left\n    ),\n    top: verticalToInteger(popper.top),\n    bottom:
    verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right),\n  };\n}\n","import
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\nimport find
    from ''../utils/find'';\nimport getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundingClientRect from ''../utils/getBoundingClientRect'';\nimport getRoundedOffsets
    from ''../utils/getRoundedOffsets'';\nimport isBrowser from ''../utils/isBrowser'';\n\nconst
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeStyle(data, options) {\n  const { x, y } = options;\n  const
    { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const
    legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''applyStyle''\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption
    !== undefined) {\n    console.warn(\n      ''WARNING: `gpuAcceleration` option
    moved to `computeStyle` modifier and will not be supported in future versions
    of Popper.js!''\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption
    !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const
    offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position:
    popper.position,\n  };\n\n  const offsets = getRoundedOffsets(\n    data,\n    window.devicePixelRatio
    < 2 || !isFirefox\n  );\n\n  const sideA = x === ''bottom'' ? ''top'' : ''bottom'';\n  const
    sideB = y === ''right'' ? ''left'' : ''right'';\n\n  // if gpuAcceleration is
    set to `true` and transform is supported,\n  //  we use `translate3d` to apply
    the position to the popper we\n  // automatically use the supported prefixed version
    if needed\n  const prefixedProperty = getSupportedPropertyName(''transform'');\n\n  //
    now, let''s make a step back and look at this code closely (wtf?)\n  // If the
    content of the popper grows once it''s been positioned, it\n  // may happen that
    the popper gets misplaced because of the new content\n  // overflowing its reference
    element\n  // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA ===
    ''bottom'') {\n    // when offsetParent is <html> the positioning is relative
    to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom
    of the html element\n    if (offsetParent.nodeName === ''HTML'') {\n      top
    = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height
    + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB
    === ''right'') {\n    if (offsetParent.nodeName === ''HTML'') {\n      left =
    -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width
    + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration
    && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px,
    ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange
    = ''transform'';\n  } else {\n    // othwerise, we use the standard `top`, `left`,
    `bottom` and `right` properties\n    const invertTop = sideA === ''bottom'' ?
    -1 : 1;\n    const invertLeft = sideB === ''right'' ? -1 : 1;\n    styles[sideA]
    = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange
    = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    ''x-placement'':
    data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles
    };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return
    data;\n}\n","import find from ''./find'';\n\n/**\n * Helper used to know if the
    given modifier depends from another one.<br />\n * It checks if the needed modifier
    is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array}
    modifiers - list of modifiers\n * @param {String} requestingName - name of requesting
    modifier\n * @param {String} requestedName - name of requested modifier\n * @returns
    {Boolean}\n */\nexport default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","import getClientRect
    from ''../utils/getClientRect'';\nimport getOuterSizes from ''../utils/getOuterSizes'';\nimport
    isModifierRequired from ''../utils/isModifierRequired'';\nimport getStyleComputedProperty
    from ''../utils/getStyleComputedProperty'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by update method\n
    * @argument {Object} options - Modifiers configuration and options\n * @returns
    {Object} The data object, properly modified\n */\nexport default function arrow(data,
    options) {\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers,
    ''arrow'', ''keepTogether'')) {\n    return data;\n  }\n\n  let arrowElement =
    options.element;\n\n  // if arrowElement is a string, suppose it''s a CSS selector\n  if
    (typeof arrowElement === ''string'') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    //
    if arrowElement is not found, don''t run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn''t a
    query selector we must check that the\n    // provided DOM node is child of its
    popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        ''WARNING:
    `arrow.element` must be child of its popper element!''\n      );\n      return
    data;\n    }\n  }\n\n  const placement = data.placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isVertical = [''left'', ''right''].indexOf(placement)
    !== -1;\n\n  const len = isVertical ? ''height'' : ''width'';\n  const sideCapitalized
    = isVertical ? ''Top'' : ''Left'';\n  const side = sideCapitalized.toLowerCase();\n  const
    altSide = isVertical ? ''left'' : ''top'';\n  const opSide = isVertical ? ''bottom''
    : ''right'';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  //
    extends keepTogether behavior making sure the popper and its\n  // reference have
    enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide]
    - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side]
    - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side]
    + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side]
    + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  //
    compute center of the popper\n  const center = reference[side] + reference[len]
    / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper
    offsets\n  // take popper margin in account because we don''t have this info available\n  const
    css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide
    = parseFloat(css[`margin${sideCapitalized}`]);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let
    sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  //
    prevent arrowElement from being placed not contiguously to its popper\n  sideValue
    = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement
    = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]:
    '''', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return
    data;\n}\n","/**\n * Get the opposite placement variation of the given one\n *
    @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n
    * @returns {String} flipped placement variation\n */\nexport default function
    getOppositeVariation(variation) {\n  if (variation === ''end'') {\n    return
    ''start'';\n  } else if (variation === ''start'') {\n    return ''end'';\n  }\n  return
    variation;\n}\n","/**\n * List of accepted placements to use as values of the
    `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n
    * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation
    from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted
    easily if you think of them as the left to right\n * written languages. Horizontally
    (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically
    (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples
    are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start`
    (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n *
    - `auto-end` (on the side with more space available, alignment depends by placement)\n
    *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n
    * @memberof Popper\n */\nexport default [\n  ''auto-start'',\n  ''auto'',\n  ''auto-end'',\n  ''top-start'',\n  ''top'',\n  ''top-end'',\n  ''right-start'',\n  ''right'',\n  ''right-end'',\n  ''bottom-end'',\n  ''bottom'',\n  ''bottom-start'',\n  ''left-end'',\n  ''left'',\n  ''left-start'',\n];\n","import
    placements from ''../methods/placements'';\n\n// Get rid of `auto` `auto-start`
    and `auto-end`\nconst validPlacements = placements.slice(3);\n\n/**\n * Given
    an initial placement, returns all the subsequent placements\n * clockwise (or
    counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String}
    placement - A valid placement (it accepts variations)\n * @argument {Boolean}
    counter - Set to true to walk the placements counterclockwise\n * @returns {Array}
    placements including their variations\n */\nexport default function clockwise(placement,
    counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const
    arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0,
    index));\n  return counter ? arr.reverse() : arr;\n}\n","import getOppositePlacement
    from ''../utils/getOppositePlacement'';\nimport getOppositeVariation from ''../utils/getOppositeVariation'';\nimport
    getPopperOffsets from ''../utils/getPopperOffsets'';\nimport runModifiers from
    ''../utils/runModifiers'';\nimport getBoundaries from ''../utils/getBoundaries'';\nimport
    isModifierEnabled from ''../utils/isModifierEnabled'';\nimport clockwise from
    ''../utils/clockwise'';\n\nconst BEHAVIORS = {\n  FLIP: ''flip'',\n  CLOCKWISE:
    ''clockwise'',\n  COUNTERCLOCKWISE: ''counterclockwise'',\n};\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by update method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function flip(data, options) {\n  // if `inner` modifier is enabled, we
    can''t use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    ''inner'')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there''s not enough space on any of the flippable sides\n    return data;\n  }\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let
    placement = data.placement.split(''-'')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let
    variation = data.placement.split(''-'')[1] || '''';\n\n  let flipOrder = [];\n\n  switch
    (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder
    = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step,
    index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return
    data;\n    }\n\n    placement = data.placement.split(''-'')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const
    refOffsets = data.offsets.reference;\n\n    // using floor because the reference
    offsets may contain decimals we are not going to consider here\n    const floor
    = Math.floor;\n    const overlapsRef =\n      (placement === ''left'' &&\n        floor(popperOffsets.right)
    > floor(refOffsets.left)) ||\n      (placement === ''right'' &&\n        floor(popperOffsets.left)
    < floor(refOffsets.right)) ||\n      (placement === ''top'' &&\n        floor(popperOffsets.bottom)
    > floor(refOffsets.top)) ||\n      (placement === ''bottom'' &&\n        floor(popperOffsets.top)
    < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top)
    < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement
    === ''left'' && overflowsLeft) ||\n      (placement === ''right'' && overflowsRight)
    ||\n      (placement === ''top'' && overflowsTop) ||\n      (placement === ''bottom''
    && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical
    = [''top'', ''bottom''].indexOf(placement) !== -1;\n\n    // flips variation if
    reference element overflows boundaries\n    const flippedVariationByRef =\n      !!options.flipVariations
    &&\n      ((isVertical && variation === ''start'' && overflowsLeft) ||\n        (isVertical
    && variation === ''end'' && overflowsRight) ||\n        (!isVertical && variation
    === ''start'' && overflowsTop) ||\n        (!isVertical && variation === ''end''
    && overflowsBottom));\n\n    // flips variation if popper content overflows boundaries\n    const
    flippedVariationByContent =\n      !!options.flipVariationsByContent &&\n      ((isVertical
    && variation === ''start'' && overflowsRight) ||\n        (isVertical && variation
    === ''end'' && overflowsLeft) ||\n        (!isVertical && variation === ''start''
    && overflowsBottom) ||\n        (!isVertical && variation === ''end'' && overflowsTop));\n\n    const
    flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if
    (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean
    to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef ||
    overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if
    (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? ''-'' + variation : '''');\n\n      // this object
    contains `position`, we want to preserve it along with\n      // any additional
    property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data
    = runModifiers(data.instance.modifiers, data, ''flip'');\n    }\n  });\n  return
    data;\n}\n","/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @returns {Object} The data object, properly
    modified\n */\nexport default function keepTogether(data) {\n  const { popper,
    reference } = data.offsets;\n  const placement = data.placement.split(''-'')[0];\n  const
    floor = Math.floor;\n  const isVertical = [''top'', ''bottom''].indexOf(placement)
    !== -1;\n  const side = isVertical ? ''right'' : ''bottom'';\n  const opSide =
    isVertical ? ''left'' : ''top'';\n  const measurement = isVertical ? ''width''
    : ''height'';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide]
    =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide]
    > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return
    data;\n}\n","import isNumeric from ''../utils/isNumeric'';\nimport getClientRect
    from ''../utils/getClientRect'';\nimport find from ''../utils/find'';\n\n/**\n
    * Converts a string containing value + unit into a px value number\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value
    + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument
    {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n
    * Value in pixels, or original string if no values were extracted\n */\nexport
    function toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate
    value from unit\n  const split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const
    value = +split[1];\n  const unit = split[2];\n\n  // If it''s not a number it''s
    an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf(''%'')
    === 0) {\n    let element;\n    switch (unit) {\n      case ''%p'':\n        element
    = popperOffsets;\n        break;\n      case ''%'':\n      case ''%r'':\n      default:\n        element
    = referenceOffsets;\n    }\n\n    const rect = getClientRect(element);\n    return
    rect[measurement] / 100 * value;\n  } else if (unit === ''vh'' || unit === ''vw'')
    {\n    // if is a vh or vw, we calculate the size based on the viewport\n    let
    size;\n    if (unit === ''vh'') {\n      size = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight
    || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth
    || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is
    an explicit pixel unit, we get rid of the unit and keep the value\n    // if is
    an implicit unit, it''s px, and we return just the value\n    return value;\n  }\n}\n\n/**\n
    * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n *
    @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument
    {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets
    in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n)
    {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right
    and index is 0 otherwise use width\n  // in this way the first offset will use
    an axis and the second one\n  // will use the other one\n  const useHeight = [''right'',
    ''left''].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain
    a list of values and operands\n  // The regex addresses values with the plus or
    minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag
    => frag.trim());\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  const divider
    = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if
    (fragments[divider] && fragments[divider].indexOf('','') === -1) {\n    console.warn(\n      ''Offsets
    separated by white space(s) are deprecated, use a comma (,) instead.''\n    );\n  }\n\n  //
    If divider is found, we divide the list of values and operands to divide\n  //
    them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider
    !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider
    + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with
    units to absolute pixels to allow our computations\n  ops = ops.map((op, index)
    => {\n    // Most of the units rely on the orientation of the popper\n    const
    measurement = (index === 1 ? !useHeight : useHeight)\n      ? ''height''\n      :
    ''width'';\n    let mergeWithPrevious = false;\n    return (\n      op\n        //
    This aggregates any `+` or `-` sign that aren''t considered operators\n        //
    e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length
    - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {\n            a[a.length -
    1] = b;\n            mergeWithPrevious = true;\n            return a;\n          }
    else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious
    = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        },
    [])\n        // Here we convert the string values into number values (in px)\n        .map(str
    => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  //
    Loop trough the offsets arrays and execute the operations\n  ops.forEach((op,
    index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index]
    += frag * (op[index2 - 1] === ''-'' ? -1 : 1);\n      }\n    });\n  });\n  return
    offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n
    * The offset value as described in the modifier description\n * @returns {Object}
    The data object, properly modified\n */\nexport default function offset(data,
    { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const
    basePlacement = placement.split(''-'')[0];\n\n  let offsets;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === ''left'') {\n    popper.top
    += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement ===
    ''right'') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  }
    else if (basePlacement === ''top'') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === ''bottom'') {\n    popper.left
    += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n","import getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundaries from ''../utils/getBoundaries'';\nimport getSupportedPropertyName
    from ''../utils/getSupportedPropertyName'';\n\n/**\n * @function\n * @memberof
    Modifiers\n * @argument {Object} data - The data object generated by `update`
    method\n * @argument {Object} options - Modifiers configuration and options\n
    * @returns {Object} The data object, properly modified\n */\nexport default function
    preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement
    || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference
    element, we really want to\n  // go one step up and use the next offsetParent
    as reference to\n  // avoid to make this modifier completely useless and look
    like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement
    = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  //
    resets the popper''s position so that the document size can be calculated excluding\n  //
    the size of the popper element itself\n  const transformProp = getSupportedPropertyName(''transform'');\n  const
    popperStyles = data.instance.popper.style; // assignment to help minification\n  const
    { top, left, [transformProp]: transform } = popperStyles;\n  popperStyles.top
    = '''';\n  popperStyles.left = '''';\n  popperStyles[transformProp] = '''';\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement,\n    data.positionFixed\n  );\n\n  //
    NOTE: DOM access here\n  // restores the original style properties after the offsets
    have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp]
    = transform;\n\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let
    popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let
    value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement)
    {\n      const mainSide = placement === ''right'' ? ''left'' : ''top'';\n      let
    value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement]
    -\n            (placement === ''right'' ? popper.width : popper.height)\n        );\n      }\n      return
    { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const
    side =\n      [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ''secondary'';\n    popper
    = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper =
    popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function shift(data) {\n  const
    placement = data.placement;\n  const basePlacement = placement.split(''-'')[0];\n  const
    shiftvariation = placement.split(''-'')[1];\n\n  // if shift shiftvariation is
    specified, run the modifier\n  if (shiftvariation) {\n    const { reference, popper
    } = data.offsets;\n    const isVertical = [''bottom'', ''top''].indexOf(basePlacement)
    !== -1;\n    const side = isVertical ? ''left'' : ''top'';\n    const measurement
    = isVertical ? ''width'' : ''height'';\n\n    const shiftOffsets = {\n      start:
    { [side]: reference[side] },\n      end: {\n        [side]: reference[side] +
    reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper
    = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import
    isModifierRequired from ''../utils/isModifierRequired'';\nimport find from ''../utils/find'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function hide(data) {\n  if (!isModifierRequired(data.instance.modifiers,
    ''hide'', ''preventOverflow'')) {\n    return data;\n  }\n\n  const refRect =
    data.offsets.reference;\n  const bound = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''preventOverflow''\n  ).boundaries;\n\n  if (\n    refRect.bottom
    < bound.top ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom
    ||\n    refRect.right < bound.left\n  ) {\n    // Avoid unnecessary DOM access
    if visibility hasn''t changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide
    = true;\n    data.attributes[''x-out-of-boundaries''] = '''';\n  } else {\n    //
    Avoid unnecessary DOM access if visibility hasn''t changed\n    if (data.hide
    === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes[''x-out-of-boundaries'']
    = false;\n  }\n\n  return data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport
    getOppositePlacement from ''../utils/getOppositePlacement'';\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function inner(data) {\n  const placement = data.placement;\n  const basePlacement
    = placement.split(''-'')[0];\n  const { popper, reference } = data.offsets;\n  const
    isHoriz = [''left'', ''right''].indexOf(basePlacement) !== -1;\n\n  const subtractLength
    = [''top'', ''left''].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? ''left''
    : ''top''] =\n    reference[basePlacement] -\n    (subtractLength ? popper[isHoriz
    ? ''width'' : ''height''] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper
    = getClientRect(popper);\n\n  return data;\n}\n","import applyStyle, { applyStyleOnLoad
    } from ''./applyStyle'';\nimport computeStyle from ''./computeStyle'';\nimport
    arrow from ''./arrow'';\nimport flip from ''./flip'';\nimport keepTogether from
    ''./keepTogether'';\nimport offset from ''./offset'';\nimport preventOverflow
    from ''./preventOverflow'';\nimport shift from ''./shift'';\nimport hide from
    ''./hide'';\nimport inner from ''./inner'';\n\n/**\n * Modifier function, each
    modifier can have a function of this type assigned\n * to its `fn` property.<br
    />\n * These functions will be called on each update, this means that you must\n
    * make sure they are performant enough to avoid performance bottlenecks.\n *\n
    * @function ModifierFn\n * @argument {dataObject} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n
    * Modifiers are plugins used to alter the behavior of your poppers.<br />\n *
    Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n
    * needed by the library.\n *\n * Usually you don''t want to override the `order`,
    `fn` and `onLoad` props.\n * All the other properties are configurations that
    could be tweaked.\n * @namespace modifiers\n */\nexport default {\n  /**\n   *
    Modifier used to shift the popper on the start or end of its reference\n   * element.<br
    />\n   * It will read the variation of the `placement` property.<br />\n   * It
    can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift:
    {\n    /** @prop {number} order=100 - Index used to define the order of execution
    */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier
    is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn:
    shift,\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both
    its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less,
    interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of
    the reference element\n   * - `%p`, percentage relative to the length of the popper
    element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height
    unit\n   *\n   * For length is intended the main axis relative to the placement
    of the popper.<br />\n   * This means that if the placement is `top` or `bottom`,
    the length will be the\n   * `width`. In case of `left` or `right`, it will be
    the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`),
    or a pair of values\n   * as `String` divided by a comma or one (or more) white
    spaces.<br />\n   * The latter is a deprecated method because it leads to confusion
    and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions
    and subtractions between different units.\n   * Note that multiplications and
    divisions aren''t supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   *
    ''10%''\n   * ''10, 10''\n   * ''10%, 10''\n   * ''10 + 10%''\n   * ''10 - 5vh
    + 3%''\n   * ''-10px + 5vh, 5px - 6%''\n   * ```\n   * > **NB**: If you desire
    to apply offsets to your poppers in a way that may make them overlap\n   * > with
    their reference element, unfortunately, you will have to disable the `flip` modifier.\n   *
    > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200
    - Index used to define the order of execution */\n    order: 200,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String}
    offset=0\n     * The offset value as described in the modifier description\n     */\n    offset:
    0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned
    outside the boundary.\n   *\n   * A scenario exists where the reference itself
    is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"
    — or just \"escaped\".<br />\n   * In this case we need to decide whether the
    popper should either:\n   *\n   * - detach from the reference and remain \"trapped\"
    in the boundaries, or\n   * - if it should ignore the boundary and \"escape with
    its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference
    is completely\n   * outside its boundaries, the popper will overflow (or completely
    leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number}
    order=300 - Index used to define the order of execution */\n    order: 300,\n    /**
    @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]\n     * Popper
    will try to prevent overflow following these priorities by default,\n     * then,
    it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    [''left'', ''right'', ''top'', ''bottom''],\n    /**\n     * @prop {number} padding=5\n     *
    Amount of pixel used to define a minimum distance between the boundaries\n     *
    and the popper. This makes sure the popper always has a little padding\n     *
    between the edges of its container\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''scrollParent''\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: ''scrollParent'',\n  },\n\n  /**\n   *
    Modifier used to make sure the reference and its popper stay near each other\n   *
    without leaving any gap between the two. Especially useful when the arrow is\n   *
    enabled and you want to ensure that it points to its reference element.\n   *
    It cares only about the first axis. You can still have poppers with margin\n   *
    between the popper and its reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used
    to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier
    is used to move the `arrowElement` of the popper to make\n   * sure it is positioned
    between the reference element and its popper element.\n   * It will read the outer
    size of the `arrowElement` node to detect how many\n   * pixels of conjunction
    are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   *
    @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500
    - Index used to define the order of execution */\n    order: 500,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement}
    element=''[x-arrow]'' - Selector or node used as arrow */\n    element: ''[x-arrow]'',\n  },\n\n  /**\n   *
    Modifier used to flip the popper''s placement when it starts to overlap its\n   *
    reference element.\n   *\n   * Requires the `preventOverflow` modifier before
    it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current
    update cycle and will\n   * restart it if it detects the need to flip the placement.\n   *
    @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600
    - Index used to define the order of execution */\n    order: 600,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array}
    behavior=''flip''\n     * The behavior used to change the popper''s placement.
    It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with
    a list of valid\n     * placements (with optional variations)\n     */\n    behavior:
    ''flip'',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip
    if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''viewport''\n     * The element
    which will define the boundaries of the popper position.\n     * The popper will
    never be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: ''viewport'',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariations:
    false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     *
    The popper will switch placement variation between `-start` and `-end` when\n     *
    the popper element overlaps its reference boundaries.\n     *\n     * The original
    placement should have a set variation.\n     */\n    flipVariationsByContent:
    false,\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define
    the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false
    - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop
    {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the
    popper when its reference element is outside of the\n   * popper boundaries. It
    will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with
    a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   *
    Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof
    modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index
    used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that
    will be applied to the popper element to gets\n   * properly positioned.\n   *\n   *
    Note that this modifier will not touch the DOM, it just prepares the styles\n   *
    so that `applyStyle` modifier can apply it. This separation is useful\n   * in
    case you need to replace `applyStyle` with a custom implementation.\n   *\n   *
    This modifier has `850` as `order` value to maintain backward compatibility\n   *
    with previous versions of Popper.js. Expect the modifiers ordering method\n   *
    to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used
    to define the order of execution */\n    order: 850,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean}
    gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position
    the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    true,\n    /**\n     * @prop {string} [x=''bottom'']\n     * Where to anchor the
    X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper
    should grow in a direction different from `bottom`\n     */\n    x: ''bottom'',\n    /**\n     *
    @prop {string} [x=''left'']\n     * Where to anchor the Y axis (`left` or `right`).
    AKA Y offset origin.\n     * Change this if your popper should grow in a direction
    different from `right`\n     */\n    y: ''right'',\n  },\n\n  /**\n   * Applies
    the computed styles to the popper element.\n   *\n   * All the DOM manipulations
    are limited to this modifier. This is useful in case\n   * you want to integrate
    Popper.js inside a framework or view library and you\n   * want to delegate all
    the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier,
    you must make sure the popper element\n   * has its position set to `absolute`
    before Popper.js can do its work!\n   *\n   * Just disable this modifier and define
    your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used
    to define the order of execution */\n    order: 900,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad:
    applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property
    moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     *
    If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n
    * The `dataObject` is an object containing all the information used by Popper.js.\n
    * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n
    * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n
    * @property {String} data.placement Placement applied to popper\n * @property
    {String} data.originalPlacement Placement originally defined on init\n * @property
    {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property
    {Boolean} data.hide True if the reference element is out of boundaries, useful
    to know when to hide the popper\n * @property {HTMLElement} data.arrowElement
    Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS
    property defined here will be applied to the popper. It expects the JavaScript
    nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any
    CSS property defined here will be applied to the popper arrow. It expects the
    JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n","import
    modifiers from ''../modifiers/index'';\n\n/**\n * Default options provided to
    Popper.js constructor.<br />\n * These can be overridden using the `options` argument
    of Popper.js.<br />\n * To override an option, simply pass an object with the
    same\n * structure of the `options` object, as the 3rd argument. For example:\n
    * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: {
    enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof
    Popper\n */\nexport default {\n  /**\n   * Popper''s placement.\n   * @prop {Popper.placements}
    placement=''bottom''\n   */\n  placement: ''bottom'',\n\n  /**\n   * Set this
    to true if you want popper to position it self in ''fixed'' mode\n   * @prop {Boolean}
    positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events
    (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled:
    true,\n\n  /**\n   * Set to true if you want to automatically remove the popper
    when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called
    when the popper is updated. This callback is not called\n   * on the initialization/creation
    of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it
    is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers
    used to modify the offsets before they are applied to the popper.\n   * They provide
    most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n
    * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n
    * @param {dataObject} data\n */\n","// Utils\nimport debounce from ''./utils/debounce'';\nimport
    isFunction from ''./utils/isFunction'';\n\n// Methods\nimport update from ''./methods/update'';\nimport
    destroy from ''./methods/destroy'';\nimport enableEventListeners from ''./methods/enableEventListeners'';\nimport
    disableEventListeners from ''./methods/disableEventListeners'';\nimport Defaults
    from ''./methods/defaults'';\nimport placements from ''./methods/placements'';\n\nexport
    default class Popper {\n  /**\n   * Creates a new Popper.js instance.\n   * @class
    Popper\n   * @param {Element|referenceObject} reference - The reference element
    used to position the popper\n   * @param {Element} popper - The HTML / XML element
    used as the popper\n   * @param {Object} options - Your custom options to override
    the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The
    generated Popper.js instance\n   */\n  constructor(reference, popper, options
    = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update
    = debounce(this.update.bind(this));\n\n    // with {} we create a new object with
    the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    //
    init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents:
    [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference
    = reference && reference.jquery ? reference[0] : reference;\n    this.popper =
    popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name
    => {\n      this.options.modifiers[name] = {\n        // If it''s a built-in modifier,
    use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        //
    If there are custom options, override and merge with default ones\n        ...(options.modifiers
    ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers''
    list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name
    => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      //
    sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    //
    modifiers have the ability to execute arbitrary code when Popper.js get inited\n    //
    such code is executed in the same order of its modifier\n    // they could add
    new properties to their options configuration\n    // BE AWARE: don''t add options
    to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions
    => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad))
    {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    //
    fire the first update to position the popper in the right place\n    this.update();\n\n    const
    eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      //
    setup event listeners, they will take care of update the position in specific
    situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can''t use class properties because they don''t
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update()
    {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners()
    {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners()
    {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedules
    an update. It will run on the next UI update available.\n   * @method scheduleUpdate\n   *
    @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   *
    Collection of utilities useful when writing custom modifiers.\n   * Starting from
    version 1.7, this method is available only if you\n   * include `popper-utils.js`
    before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils
    is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly
    instead.\n   * Due to the high instability of the methods contained in Utils,
    we can''t\n   * guarantee them to follow semver. Use them at your own risk!\n   *
    @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   *
    @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !==
    ''undefined'' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static
    Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides
    an interface compatible with Popper.js\n * and lets you use it as replacement
    of a real DOM node.<br />\n * You can use this method to position a popper relatively
    to a set of coordinates\n * in case you don''t have a DOM node to use as reference.\n
    *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This
    feature isn''t supported in Internet Explorer 10.\n * @name referenceObject\n
    * @property {Function} data.getBoundingClientRect\n * A function that returns
    a set of coordinates compatible with the native `getBoundingClientRect` method.\n
    * @property {number} data.clientWidth\n * An ES6 getter that will return the width
    of the virtual reference element.\n * @property {number} data.clientHeight\n *
    An ES6 getter that will return the height of the virtual reference element.\n
    */\n"],"names":["window","document","navigator","timeoutDuration","longerTimeoutBrowsers","i","length","isBrowser","userAgent","indexOf","microtaskDebounce","fn","called","Promise","resolve","then","taskDebounce","scheduled","supportsMicroTasks","isFunction","functionToCheck","getType","toString","call","getStyleComputedProperty","element","property","nodeType","ownerDocument","defaultView","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","body","overflow","overflowX","overflowY","test","getReferenceNode","reference","referenceNode","isIE11","MSInputMethodContext","documentMode","isIE10","isIE","version","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","parseInt","getWindowSizes","getClientRect","offsets","width","height","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","isPaddingNumber","getArea","computeAutoPlacement","placement","refRect","rects","sortedAreas","Object","keys","map","key","sort","a","b","area","filteredAreas","filter","computedPlacement","variation","split","getReferenceOffsets","state","commonOffsetParent","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","find","arr","check","Array","prototype","findIndex","prop","value","cur","match","obj","runModifiers","modifiers","data","ends","modifiersToRun","undefined","slice","forEach","warn","enabled","update","isDestroyed","options","positionFixed","flip","originalPlacement","position","isCreated","onCreate","onUpdate","isModifierEnabled","modifierName","some","name","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","prefix","toCheck","style","destroy","removeAttribute","willChange","disableEventListeners","removeOnDestroy","removeChild","getWindow","attachToScrollParents","event","callback","scrollParents","isBody","target","addEventListener","passive","push","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","removeEventListener","isNumeric","n","isNaN","isFinite","setStyles","unit","setAttributes","attributes","setAttribute","applyStyle","instance","arrowElement","arrowStyles","applyStyleOnLoad","modifierOptions","getRoundedOffsets","shouldRound","round","floor","noRound","v","referenceWidth","popperWidth","isVertical","isVariation","sameWidthParity","bothOddWidth","horizontalToInteger","verticalToInteger","isFirefox","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","devicePixelRatio","prefixedProperty","invertTop","invertLeft","arrow","isModifierRequired","requestingName","requestedName","requesting","isRequired","requested","querySelector","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","getOppositeVariation","validPlacements","placements","clockwise","counter","index","concat","reverse","BEHAVIORS","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariationByRef","flipVariations","flippedVariationByContent","flipVariationsByContent","flippedVariation","keepTogether","toValue","str","size","parseOffset","basePlacement","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","transformProp","popperStyles","transform","priority","escapeWithReference","shift","shiftvariation","shiftOffsets","hide","bound","inner","subtractLength","Popper","requestAnimationFrame","debounce","bind","Defaults","jquery","onLoad","Utils","global","PopperUtils"],"mappings":"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"}'
  admin-Public-Admin-plugins-popper-umd-popper.min.js: |
    /*
     Copyright (C) Federico Zivolo 2020
     Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
     */(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.Popper=t()})(this,function(){'use strict';function e(e){return e&&'[object Function]'==={}.toString.call(e)}function t(e,t){if(1!==e.nodeType)return[];var o=e.ownerDocument.defaultView,n=o.getComputedStyle(e,null);return t?n[t]:n}function o(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function n(e){if(!e)return document.body;switch(e.nodeName){case'HTML':case'BODY':return e.ownerDocument.body;case'#document':return e.body;}var i=t(e),r=i.overflow,p=i.overflowX,s=i.overflowY;return /(auto|scroll|overlay)/.test(r+s+p)?e:n(o(e))}function i(e){return e&&e.referenceNode?e.referenceNode:e}function r(e){return 11===e?re:10===e?pe:re||pe}function p(e){if(!e)return document.documentElement;for(var o=r(10)?document.body:null,n=e.offsetParent||null;n===o&&e.nextElementSibling;)n=(e=e.nextElementSibling).offsetParent;var i=n&&n.nodeName;return i&&'BODY'!==i&&'HTML'!==i?-1!==['TH','TD','TABLE'].indexOf(n.nodeName)&&'static'===t(n,'position')?p(n):n:e?e.ownerDocument.documentElement:document.documentElement}function s(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||p(e.firstElementChild)===e)}function d(e){return null===e.parentNode?e:d(e.parentNode)}function a(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,n=o?e:t,i=o?t:e,r=document.createRange();r.setStart(n,0),r.setEnd(i,0);var l=r.commonAncestorContainer;if(e!==l&&t!==l||n.contains(i))return s(l)?l:p(l);var f=d(e);return f.host?a(f.host,t):a(e,d(t).host)}function l(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',n=e.nodeName;if('BODY'===n||'HTML'===n){var i=e.ownerDocument.documentElement,r=e.ownerDocument.scrollingElement||i;return r[o]}return e[o]}function f(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],n=l(t,'top'),i=l(t,'left'),r=o?-1:1;return e.top+=n*r,e.bottom+=n*r,e.left+=i*r,e.right+=i*r,e}function m(e,t){var o='x'===t?'Left':'Top',n='Left'==o?'Right':'Bottom';return parseFloat(e['border'+o+'Width'])+parseFloat(e['border'+n+'Width'])}function h(e,t,o,n){return ee(t['offset'+e],t['scroll'+e],o['client'+e],o['offset'+e],o['scroll'+e],r(10)?parseInt(o['offset'+e])+parseInt(n['margin'+('Height'===e?'Top':'Left')])+parseInt(n['margin'+('Height'===e?'Bottom':'Right')]):0)}function c(e){var t=e.body,o=e.documentElement,n=r(10)&&getComputedStyle(o);return{height:h('Height',t,o,n),width:h('Width',t,o,n)}}function g(e){return le({},e,{right:e.left+e.width,bottom:e.top+e.height})}function u(e){var o={};try{if(r(10)){o=e.getBoundingClientRect();var n=l(e,'top'),i=l(e,'left');o.top+=n,o.left+=i,o.bottom+=n,o.right+=i}else o=e.getBoundingClientRect()}catch(t){}var p={left:o.left,top:o.top,width:o.right-o.left,height:o.bottom-o.top},s='HTML'===e.nodeName?c(e.ownerDocument):{},d=s.width||e.clientWidth||p.width,a=s.height||e.clientHeight||p.height,f=e.offsetWidth-d,h=e.offsetHeight-a;if(f||h){var u=t(e);f-=m(u,'x'),h-=m(u,'y'),p.width-=f,p.height-=h}return g(p)}function b(e,o){var i=2<arguments.length&&void 0!==arguments[2]&&arguments[2],p=r(10),s='HTML'===o.nodeName,d=u(e),a=u(o),l=n(e),m=t(o),h=parseFloat(m.borderTopWidth),c=parseFloat(m.borderLeftWidth);i&&s&&(a.top=ee(a.top,0),a.left=ee(a.left,0));var b=g({top:d.top-a.top-h,left:d.left-a.left-c,width:d.width,height:d.height});if(b.marginTop=0,b.marginLeft=0,!p&&s){var w=parseFloat(m.marginTop),y=parseFloat(m.marginLeft);b.top-=h-w,b.bottom-=h-w,b.left-=c-y,b.right-=c-y,b.marginTop=w,b.marginLeft=y}return(p&&!i?o.contains(l):o===l&&'BODY'!==l.nodeName)&&(b=f(b,o)),b}function w(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=e.ownerDocument.documentElement,n=b(e,o),i=ee(o.clientWidth,window.innerWidth||0),r=ee(o.clientHeight,window.innerHeight||0),p=t?0:l(o),s=t?0:l(o,'left'),d={top:p-n.top+n.marginTop,left:s-n.left+n.marginLeft,width:i,height:r};return g(d)}function y(e){var n=e.nodeName;if('BODY'===n||'HTML'===n)return!1;if('fixed'===t(e,'position'))return!0;var i=o(e);return!!i&&y(i)}function E(e){if(!e||!e.parentElement||r())return document.documentElement;for(var o=e.parentElement;o&&'none'===t(o,'transform');)o=o.parentElement;return o||document.documentElement}function v(e,t,r,p){var s=4<arguments.length&&void 0!==arguments[4]&&arguments[4],d={top:0,left:0},l=s?E(e):a(e,i(t));if('viewport'===p)d=w(l,s);else{var f;'scrollParent'===p?(f=n(o(t)),'BODY'===f.nodeName&&(f=e.ownerDocument.documentElement)):'window'===p?f=e.ownerDocument.documentElement:f=p;var m=b(f,l,s);if('HTML'===f.nodeName&&!y(l)){var h=c(e.ownerDocument),g=h.height,u=h.width;d.top+=m.top-m.marginTop,d.bottom=g+m.top,d.left+=m.left-m.marginLeft,d.right=u+m.left}else d=m}r=r||0;var v='number'==typeof r;return d.left+=v?r:r.left||0,d.top+=v?r:r.top||0,d.right-=v?r:r.right||0,d.bottom-=v?r:r.bottom||0,d}function x(e){var t=e.width,o=e.height;return t*o}function O(e,t,o,n,i){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=v(o,n,r,i),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return le({key:e},s[e],{area:x(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,n=e.height;return t>=o.clientWidth&&n>=o.clientHeight}),l=0<a.length?a[0].key:d[0].key,f=e.split('-')[1];return l+(f?'-'+f:'')}function L(e,t,o){var n=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null,r=n?E(t):a(t,i(o));return b(o,r,n)}function S(e){var t=e.ownerDocument.defaultView,o=t.getComputedStyle(e),n=parseFloat(o.marginTop||0)+parseFloat(o.marginBottom||0),i=parseFloat(o.marginLeft||0)+parseFloat(o.marginRight||0),r={width:e.offsetWidth+i,height:e.offsetHeight+n};return r}function T(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function C(e,t,o){o=o.split('-')[0];var n=S(e),i={width:n.width,height:n.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return i[p]=t[p]+t[d]/2-n[d]/2,i[s]=o===s?t[s]-n[a]:t[T(s)],i}function D(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function N(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var n=D(e,function(e){return e[t]===o});return e.indexOf(n)}function P(t,o,n){var i=void 0===n?t:t.slice(0,N(t,'name',n));return i.forEach(function(t){t['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var n=t['function']||t.fn;t.enabled&&e(n)&&(o.offsets.popper=g(o.offsets.popper),o.offsets.reference=g(o.offsets.reference),o=n(o,t))}),o}function k(){if(!this.state.isDestroyed){var e={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=L(this.state,this.popper,this.reference,this.options.positionFixed),e.placement=O(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.positionFixed=this.options.positionFixed,e.offsets.popper=C(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position=this.options.positionFixed?'fixed':'absolute',e=P(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function W(e,t){return e.some(function(e){var o=e.name,n=e.enabled;return n&&o===t})}function B(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof document.body.style[r])return r}return null}function H(){return this.state.isDestroyed=!0,W(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.position='',this.popper.style.top='',this.popper.style.left='',this.popper.style.right='',this.popper.style.bottom='',this.popper.style.willChange='',this.popper.style[B('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function A(e){var t=e.ownerDocument;return t?t.defaultView:window}function M(e,t,o,i){var r='BODY'===e.nodeName,p=r?e.ownerDocument.defaultView:e;p.addEventListener(t,o,{passive:!0}),r||M(n(p.parentNode),t,o,i),i.push(p)}function F(e,t,o,i){o.updateBound=i,A(e).addEventListener('resize',o.updateBound,{passive:!0});var r=n(e);return M(r,'scroll',o.updateBound,o.scrollParents),o.scrollElement=r,o.eventsEnabled=!0,o}function I(){this.state.eventsEnabled||(this.state=F(this.reference,this.options,this.state,this.scheduleUpdate))}function R(e,t){return A(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function U(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=R(this.reference,this.state))}function Y(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function V(e,t){Object.keys(t).forEach(function(o){var n='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&Y(t[o])&&(n='px'),e.style[o]=t[o]+n})}function j(e,t){Object.keys(t).forEach(function(o){var n=t[o];!1===n?e.removeAttribute(o):e.setAttribute(o,t[o])})}function q(e,t){var o=e.offsets,n=o.popper,i=o.reference,r=$,p=function(e){return e},s=r(i.width),d=r(n.width),a=-1!==['left','right'].indexOf(e.placement),l=-1!==e.placement.indexOf('-'),f=t?a||l||s%2==d%2?r:Z:p,m=t?r:p;return{left:f(1==s%2&&1==d%2&&!l&&t?n.left-1:n.left),top:m(n.top),bottom:m(n.bottom),right:f(n.right)}}function K(e,t,o){var n=D(e,function(e){var o=e.name;return o===t}),i=!!n&&e.some(function(e){return e.name===o&&e.enabled&&e.order<n.order});if(!i){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return i}function z(e){return'end'===e?'start':'start'===e?'end':e}function G(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=he.indexOf(e),n=he.slice(o+1).concat(he.slice(0,o));return t?n.reverse():n}function _(e,t,o,n){var i=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+i[1],p=i[2];if(!r)return e;if(0===p.indexOf('%')){var s;switch(p){case'%p':s=o;break;case'%':case'%r':default:s=n;}var d=g(s);return d[t]/100*r}if('vh'===p||'vw'===p){var a;return a='vh'===p?ee(document.documentElement.clientHeight,window.innerHeight||0):ee(document.documentElement.clientWidth,window.innerWidth||0),a/100*r}return r}function X(e,t,o,n){var i=[0,0],r=-1!==['right','left'].indexOf(n),p=e.split(/(\+|\-)/).map(function(e){return e.trim()}),s=p.indexOf(D(p,function(e){return-1!==e.search(/,|\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\s*,\s*|\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,n){var i=(1===n?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return _(e,i,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,n){Y(o)&&(i[t]+=o*('-'===e[n-1]?-1:1))})}),i}function J(e,t){var o,n=t.offset,i=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=i.split('-')[0];return o=Y(+n)?[+n,0]:X(n,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e}var Q=Math.min,Z=Math.floor,$=Math.round,ee=Math.max,te='undefined'!=typeof window&&'undefined'!=typeof document&&'undefined'!=typeof navigator,oe=function(){for(var e=['Edge','Trident','Firefox'],t=0;t<e.length;t+=1)if(te&&0<=navigator.userAgent.indexOf(e[t]))return 1;return 0}(),ne=te&&window.Promise,ie=ne?function(e){var t=!1;return function(){t||(t=!0,window.Promise.resolve().then(function(){t=!1,e()}))}}:function(e){var t=!1;return function(){t||(t=!0,setTimeout(function(){t=!1,e()},oe))}},re=te&&!!(window.MSInputMethodContext&&document.documentMode),pe=te&&/MSIE 10/.test(navigator.userAgent),se=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},de=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,n){return o&&e(t.prototype,o),n&&e(t,n),t}}(),ae=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},le=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},fe=te&&/Firefox/i.test(navigator.userAgent),me=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],he=me.slice(3),ce={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},ge=function(){function t(o,n){var i=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};se(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(i.update)},this.update=ie(this.update.bind(this)),this.options=le({},t.Defaults,r),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=o&&o.jquery?o[0]:o,this.popper=n&&n.jquery?n[0]:n,this.options.modifiers={},Object.keys(le({},t.Defaults.modifiers,r.modifiers)).forEach(function(e){i.options.modifiers[e]=le({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return le({name:e},i.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(i.reference,i.popper,i.options,t,i.state)}),this.update();var p=this.options.eventsEnabled;p&&this.enableEventListeners(),this.state.eventsEnabled=p}return de(t,[{key:'update',value:function(){return k.call(this)}},{key:'destroy',value:function(){return H.call(this)}},{key:'enableEventListeners',value:function(){return I.call(this)}},{key:'disableEventListeners',value:function(){return U.call(this)}}]),t}();return ge.Utils=('undefined'==typeof window?global:window).PopperUtils,ge.placements=me,ge.Defaults={placement:'bottom',positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t.split('-')[0],n=t.split('-')[1];if(n){var i=e.offsets,r=i.reference,p=i.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',l={start:ae({},d,r[d]),end:ae({},d,r[d]+r[a]-p[a])};e.offsets.popper=le({},p,l[n])}return e}},offset:{order:200,enabled:!0,fn:J,offset:0},preventOverflow:{order:300,enabled:!0,fn:function(e,t){var o=t.boundariesElement||p(e.instance.popper);e.instance.reference===o&&(o=p(o));var n=B('transform'),i=e.instance.popper.style,r=i.top,s=i.left,d=i[n];i.top='',i.left='',i[n]='';var a=v(e.instance.popper,e.instance.reference,t.padding,o,e.positionFixed);i.top=r,i.left=s,i[n]=d,t.boundaries=a;var l=t.priority,f=e.offsets.popper,m={primary:function(e){var o=f[e];return f[e]<a[e]&&!t.escapeWithReference&&(o=ee(f[e],a[e])),ae({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=f[o];return f[e]>a[e]&&!t.escapeWithReference&&(n=Q(f[o],a[e]-('right'===e?f.width:f.height))),ae({},o,n)}};return l.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';f=le({},f,m[t](e))}),e.offsets.popper=f,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,n=t.reference,i=e.placement.split('-')[0],r=Z,p=-1!==['top','bottom'].indexOf(i),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(n[d])&&(e.offsets.popper[d]=r(n[d])-o[a]),o[d]>r(n[s])&&(e.offsets.popper[d]=r(n[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,o){var n;if(!K(e.instance.modifiers,'arrow','keepTogether'))return e;var i=o.element;if('string'==typeof i){if(i=e.instance.popper.querySelector(i),!i)return e;}else if(!e.instance.popper.contains(i))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var r=e.placement.split('-')[0],p=e.offsets,s=p.popper,d=p.reference,a=-1!==['left','right'].indexOf(r),l=a?'height':'width',f=a?'Top':'Left',m=f.toLowerCase(),h=a?'left':'top',c=a?'bottom':'right',u=S(i)[l];d[c]-u<s[m]&&(e.offsets.popper[m]-=s[m]-(d[c]-u)),d[m]+u>s[c]&&(e.offsets.popper[m]+=d[m]+u-s[c]),e.offsets.popper=g(e.offsets.popper);var b=d[m]+d[l]/2-u/2,w=t(e.instance.popper),y=parseFloat(w['margin'+f]),E=parseFloat(w['border'+f+'Width']),v=b-e.offsets.popper[m]-y-E;return v=ee(Q(s[l]-u,v),0),e.arrowElement=i,e.offsets.arrow=(n={},ae(n,m,$(v)),ae(n,h,''),n),e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(W(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=v(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement,e.positionFixed),n=e.placement.split('-')[0],i=T(n),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case ce.FLIP:p=[n,i];break;case ce.CLOCKWISE:p=G(n);break;case ce.COUNTERCLOCKWISE:p=G(n,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(n!==s||p.length===d+1)return e;n=e.placement.split('-')[0],i=T(n);var a=e.offsets.popper,l=e.offsets.reference,f=Z,m='left'===n&&f(a.right)>f(l.left)||'right'===n&&f(a.left)<f(l.right)||'top'===n&&f(a.bottom)>f(l.top)||'bottom'===n&&f(a.top)<f(l.bottom),h=f(a.left)<f(o.left),c=f(a.right)>f(o.right),g=f(a.top)<f(o.top),u=f(a.bottom)>f(o.bottom),b='left'===n&&h||'right'===n&&c||'top'===n&&g||'bottom'===n&&u,w=-1!==['top','bottom'].indexOf(n),y=!!t.flipVariations&&(w&&'start'===r&&h||w&&'end'===r&&c||!w&&'start'===r&&g||!w&&'end'===r&&u),E=!!t.flipVariationsByContent&&(w&&'start'===r&&c||w&&'end'===r&&h||!w&&'start'===r&&u||!w&&'end'===r&&g),v=y||E;(m||b||v)&&(e.flipped=!0,(m||b)&&(n=p[d+1]),v&&(r=z(r)),e.placement=n+(r?'-'+r:''),e.offsets.popper=le({},e.offsets.popper,C(e.instance.popper,e.offsets.reference,e.placement)),e=P(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport',flipVariations:!1,flipVariationsByContent:!1},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],n=e.offsets,i=n.popper,r=n.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return i[p?'left':'top']=r[o]-(s?i[p?'width':'height']:0),e.placement=T(t),e.offsets.popper=g(i),e}},hide:{order:800,enabled:!0,fn:function(e){if(!K(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=D(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,n=t.y,i=e.offsets.popper,r=D(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==r&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===r?t.gpuAcceleration:r,l=p(e.instance.popper),f=u(l),m={position:i.position},h=q(e,2>window.devicePixelRatio||!fe),c='bottom'===o?'top':'bottom',g='right'===n?'left':'right',b=B('transform');if(d='bottom'==c?'HTML'===l.nodeName?-l.clientHeight+h.bottom:-f.height+h.bottom:h.top,s='right'==g?'HTML'===l.nodeName?-l.clientWidth+h.right:-f.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[g]=0,m.willChange='transform';else{var w='bottom'==c?-1:1,y='right'==g?-1:1;m[c]=d*w,m[g]=s*y,m.willChange=c+', '+g}var E={"x-placement":e.placement};return e.attributes=le({},E,e.attributes),e.styles=le({},m,e.styles),e.arrowStyles=le({},e.offsets.arrow,e.arrowStyles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return V(e.instance.popper,e.styles),j(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&V(e.arrowElement,e.arrowStyles),e},onLoad:function(e,t,o,n,i){var r=L(i,t,e,o.positionFixed),p=O(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),V(t,{position:o.positionFixed?'fixed':'absolute'}),o},gpuAcceleration:void 0}}},ge});
    //# sourceMappingURL=popper.min.js.map
  admin-Public-Admin-plugins-popper-umd-popper.min.js.map: '{"version":3,"file":"popper.min.js","sources":["../../src/utils/isFunction.js","../../src/utils/getStyleComputedProperty.js","../../src/utils/getParentNode.js","../../src/utils/getScrollParent.js","../../src/utils/getReferenceNode.js","../../src/utils/isIE.js","../../src/utils/getOffsetParent.js","../../src/utils/isOffsetContainer.js","../../src/utils/getRoot.js","../../src/utils/findCommonOffsetParent.js","../../src/utils/getScroll.js","../../src/utils/includeScroll.js","../../src/utils/getBordersSize.js","../../src/utils/getWindowSizes.js","../../src/utils/getClientRect.js","../../src/utils/getBoundingClientRect.js","../../src/utils/getOffsetRectRelativeToArbitraryNode.js","../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js","../../src/utils/isFixed.js","../../src/utils/getFixedPositionOffsetParent.js","../../src/utils/getBoundaries.js","../../src/utils/computeAutoPlacement.js","../../src/utils/getReferenceOffsets.js","../../src/utils/getOuterSizes.js","../../src/utils/getOppositePlacement.js","../../src/utils/getPopperOffsets.js","../../src/utils/find.js","../../src/utils/findIndex.js","../../src/utils/runModifiers.js","../../src/methods/update.js","../../src/utils/isModifierEnabled.js","../../src/utils/getSupportedPropertyName.js","../../src/methods/destroy.js","../../src/utils/getWindow.js","../../src/utils/setupEventListeners.js","../../src/methods/enableEventListeners.js","../../src/utils/removeEventListeners.js","../../src/methods/disableEventListeners.js","../../src/utils/isNumeric.js","../../src/utils/setStyles.js","../../src/utils/setAttributes.js","../../src/utils/getRoundedOffsets.js","../../src/utils/isModifierRequired.js","../../src/utils/getOppositeVariation.js","../../src/utils/clockwise.js","../../src/modifiers/offset.js","../../src/modifiers/arrow.js","../../src/utils/isBrowser.js","../../src/utils/debounce.js","../../src/modifiers/computeStyle.js","../../src/modifiers/flip.js","../../src/index.js","../../src/methods/defaults.js","../../src/modifiers/index.js","../../src/modifiers/shift.js","../../src/modifiers/preventOverflow.js","../../src/modifiers/keepTogether.js","../../src/modifiers/inner.js","../../src/modifiers/hide.js","../../src/modifiers/applyStyle.js"],"sourcesContent":["/**\n
    * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n
    * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer
    to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n  const
    getType = {};\n  return (\n    functionToCheck &&\n    getType.toString.call(functionToCheck)
    === ''[object Function]''\n  );\n}\n","/**\n * Get CSS computed property of the
    given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n
    * @argument {String} property\n */\nexport default function getStyleComputedProperty(element,
    property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE:
    1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const
    css = window.getComputedStyle(element, null);\n  return property ? css[property]
    : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    parent\n */\nexport default function getParentNode(element) {\n  if (element.nodeName
    === ''HTML'') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getParentNode
    from ''./getParentNode'';\n\n/**\n * Returns the scrolling parent of the given
    element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n
    * @returns {Element} scroll parent\n */\nexport default function getScrollParent(element)
    {\n  // Return body, `getScroll` will take care to get the correct `scrollTop`
    from it\n  if (!element) {\n    return document.body\n  }\n\n  switch (element.nodeName)
    {\n    case ''HTML'':\n    case ''BODY'':\n      return element.ownerDocument.body\n    case
    ''#document'':\n      return element.body\n  }\n\n  // Firefox want us to check
    `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } =
    getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(overflow
    + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","/**\n
    * Returns the reference node of the reference object, or the reference object
    itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference
    - the reference element (the popper will be relative to this)\n * @returns {Element}
    parent\n */\nexport default function getReferenceNode(reference) {\n  return reference
    && reference.referenceNode ? reference.referenceNode : reference;\n}\n","import
    isBrowser from ''./isBrowser'';\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext
    && document.documentMode);\nconst isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n
    * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n
    * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nexport default
    function isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if
    (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Returns the offset parent of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element}
    offset parent\n */\nexport default function getOffsetParent(element) {\n  if (!element)
    {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10)
    ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent =
    element.offsetParent || null;\n  // Skip hidden elements which don''t have an
    offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling)
    {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  const
    nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName
    === ''BODY'' || nodeName === ''HTML'') {\n    return element ? element.ownerDocument.documentElement
    : document.documentElement;\n  }\n\n  // .offsetParent will return the closest
    TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if
    (\n    [''TH'', ''TD'', ''TABLE''].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent,
    ''position'') === ''static''\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return
    offsetParent;\n}\n","import getOffsetParent from ''./getOffsetParent'';\n\nexport
    default function isOffsetContainer(element) {\n  const { nodeName } = element;\n  if
    (nodeName === ''BODY'') {\n    return false;\n  }\n  return (\n    nodeName ===
    ''HTML'' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n
    * Finds the root node (document, shadowDOM root) of the given element\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root
    node\n */\nexport default function getRoot(node) {\n  if (node.parentNode !==
    null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","import
    isOffsetContainer from ''./isOffsetContainer'';\nimport getRoot from ''./getRoot'';\nimport
    getOffsetParent from ''./getOffsetParent'';\n\n/**\n * Finds the offset parent
    common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument
    {Element} element1\n * @argument {Element} element2\n * @returns {Element} common
    offset parent\n */\nexport default function findCommonOffsetParent(element1, element2)
    {\n  // This check is needed to avoid errors in case one of the elements isn''t
    defined for any reason\n  if (!element1 || !element1.nodeType || !element2 ||
    !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here
    we make sure to give as \"start\" the element that comes first in the DOM\n  const
    order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const
    start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  //
    Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start,
    0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  //
    Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer
    &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  )
    {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return
    getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside
    shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host)
    {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return
    findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n *
    Gets the scroll value of the given element in the given side (top and left)\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument
    {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n
    */\nexport default function getScroll(element, side = ''top'') {\n  const upperSide
    = side === ''top'' ? ''scrollTop'' : ''scrollLeft'';\n  const nodeName = element.nodeName;\n\n  if
    (nodeName === ''BODY'' || nodeName === ''HTML'') {\n    const html = element.ownerDocument.documentElement;\n    const
    scrollingElement = element.ownerDocument.scrollingElement || html;\n    return
    scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","import
    getScroll from ''./getScroll'';\n\n/*\n * Sum or subtract the element scroll values
    (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n
    * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement}
    element - The element from the function reads the scroll values\n * @param {Boolean}
    subtract - set to true if you want to subtract the scroll values\n * @return {Object}
    rect - The modifier rect object\n */\nexport default function includeScroll(rect,
    element, subtract = false) {\n  const scrollTop = getScroll(element, ''top'');\n  const
    scrollLeft = getScroll(element, ''left'');\n  const modifier = subtract ? -1 :
    1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left
    += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n","/*\n
    * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n
    * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty`
    on the given element\n * @param {String} axis - `x` or `y`\n * @return {number}
    borders - The borders size of the given axis\n */\n\nexport default function getBordersSize(styles,
    axis) {\n  const sideA = axis === ''x'' ? ''Left'' : ''Top'';\n  const sideB =
    sideA === ''Left'' ? ''Right'' : ''Bottom'';\n\n  return (\n    parseFloat(styles[`border${sideA}Width`])
    +\n    parseFloat(styles[`border${sideB}Width`])\n  );\n}\n","import isIE from
    ''./isIE'';\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n    body[`offset${axis}`],\n    body[`scroll${axis}`],\n    html[`client${axis}`],\n    html[`offset${axis}`],\n    html[`scroll${axis}`],\n    isIE(10)\n      ?
    (parseInt(html[`offset${axis}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Top'' : ''Left''}`]) + \n      parseInt(computedStyle[`margin${axis
    === ''Height'' ? ''Bottom'' : ''Right''}`]))\n    : 0 \n  );\n}\n\nexport default
    function getWindowSizes(document) {\n  const body = document.body;\n  const html
    = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return
    {\n    height: getSize(''Height'', body, html, computedStyle),\n    width: getSize(''Width'',
    body, html, computedStyle),\n  };\n}\n","/**\n * Given element offsets, generate
    an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n
    * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nexport
    default function getClientRect(offsets) {\n  return {\n    ...offsets,\n    right:
    offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height,\n  };\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport getBordersSize
    from ''./getBordersSize'';\nimport getWindowSizes from ''./getWindowSizes'';\nimport
    getScroll from ''./getScroll'';\nimport getClientRect from ''./getClientRect'';\nimport
    isIE from ''./isIE'';\n\n/**\n * Get bounding client rect of given element\n *
    @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return
    {Object} client rect\n */\nexport default function getBoundingClientRect(element)
    {\n  let rect = {};\n\n  // IE10 10 FIX: Please, don''t ask, the element isn''t\n  //
    considered in DOM in some circumstances...\n  // This isn''t reproducible in IE10
    compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const
    scrollTop = getScroll(element, ''top'');\n      const scrollLeft = getScroll(element,
    ''left'');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom
    += scrollTop;\n      rect.right += scrollLeft;\n    }\n    else {\n      rect
    = element.getBoundingClientRect();\n    }\n  }\n  catch(e){}\n\n  const result
    = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height:
    rect.bottom - rect.top,\n  };\n\n  // subtract scrollbar size from sizes\n  const
    sizes = element.nodeName === ''HTML'' ? getWindowSizes(element.ownerDocument)
    : {};\n  const width =\n    sizes.width || element.clientWidth || result.width;\n  const
    height =\n    sizes.height || element.clientHeight || result.height;\n\n  let
    horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight
    - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it''s
    not a `border`\n  // we make this check conditional for performance reasons\n  if
    (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar
    -= getBordersSize(styles, ''x'');\n    vertScrollbar -= getBordersSize(styles,
    ''y'');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return
    getClientRect(result);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    includeScroll from ''./includeScroll'';\nimport getScrollParent from ''./getScrollParent'';\nimport
    getBoundingClientRect from ''./getBoundingClientRect'';\nimport runIsIE from ''./isIE'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getOffsetRectRelativeToArbitraryNode(children,
    parent, fixedPosition = false) {\n  const isIE10 = runIsIE(10);\n  const isHTML
    = parent.nodeName === ''HTML'';\n  const childrenRect = getBoundingClientRect(children);\n  const
    parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const
    styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const
    borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the
    parent is fixed, we must ignore negative scroll in offset calc\n  if(fixedPosition
    && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left
    = Math.max(parentRect.left, 0);\n  }\n  let offsets = getClientRect({\n    top:
    childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left
    - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height:
    childrenRect.height,\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft =
    0;\n\n  // Subtract margins of documentElement in case it''s being used as parent\n  //
    we do this only on HTML because it''s the only element that behaves\n  // differently
    when margins are applied to it. The margins are included in\n  // the box of the
    documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const
    marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top
    -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left
    -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    //
    Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop
    = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10
    && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent
    && scrollParent.nodeName !== ''BODY''\n  ) {\n    offsets = includeScroll(offsets,
    parent);\n  }\n\n  return offsets;\n}\n","import getOffsetRectRelativeToArbitraryNode
    from ''./getOffsetRectRelativeToArbitraryNode'';\nimport getScroll from ''./getScroll'';\nimport
    getClientRect from ''./getClientRect'';\n\nexport default function getViewportOffsetRectRelativeToArtbitraryNode(element,
    excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const
    relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const
    width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height =
    Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll
    ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html,
    ''left'') : 0;\n\n  const offset = {\n    top: scrollTop - relativeOffset.top
    + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width,\n    height,\n  };\n\n  return
    getClientRect(offset);\n}\n","import getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport
    getParentNode from ''./getParentNode'';\n\n/**\n * Check if the given element
    is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n
    * @argument {Element} element\n * @argument {Element} customContainer\n * @returns
    {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element)
    {\n  const nodeName = element.nodeName;\n  if (nodeName === ''BODY'' || nodeName
    === ''HTML'') {\n    return false;\n  }\n  if (getStyleComputedProperty(element,
    ''position'') === ''fixed'') {\n    return true;\n  }\n  const parentNode = getParentNode(element);\n  if
    (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n","import
    getStyleComputedProperty from ''./getStyleComputedProperty'';\nimport isIE from
    ''./isIE'';\n/**\n * Finds the first parent of an element that has a transformed
    property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element}
    element\n * @returns {Element} first transformed parent or documentElement\n */\n\nexport
    default function getFixedPositionOffsetParent(element) {\n  // This check is needed
    to avoid errors in case one of the elements isn''t defined for any reason\n   if
    (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let
    el = element.parentElement;\n  while (el && getStyleComputedProperty(el, ''transform'')
    === ''none'') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n\n}\n","import
    getScrollParent from ''./getScrollParent'';\nimport getParentNode from ''./getParentNode'';\nimport
    getReferenceNode from ''./getReferenceNode'';\nimport findCommonOffsetParent from
    ''./findCommonOffsetParent'';\nimport getOffsetRectRelativeToArbitraryNode from
    ''./getOffsetRectRelativeToArbitraryNode'';\nimport getViewportOffsetRectRelativeToArtbitraryNode
    from ''./getViewportOffsetRectRelativeToArtbitraryNode'';\nimport getWindowSizes
    from ''./getWindowSizes'';\nimport isFixed from ''./isFixed'';\nimport getFixedPositionOffsetParent
    from ''./getFixedPositionOffsetParent'';\n\n/**\n * Computed the boundaries limits
    and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement}
    popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param
    {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param
    {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates
    of the boundaries\n */\nexport default function getBoundaries(\n  popper,\n  reference,\n  padding,\n  boundariesElement,\n  fixedPosition
    = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries = { top: 0, left:
    0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper)
    : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle
    viewport case\n  if (boundariesElement === ''viewport'' ) {\n    boundaries =
    getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  }\n\n  else
    {\n    // Handle other cases based on DOM element used as boundaries\n    let
    boundariesNode;\n    if (boundariesElement === ''scrollParent'') {\n      boundariesNode
    = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName
    === ''BODY'') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    }
    else if (boundariesElement === ''window'') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    }
    else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets
    = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    //
    In case of HTML, we need a different computation\n    if (boundariesNode.nodeName
    === ''HTML'' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(popper.ownerDocument);\n      boundaries.top
    += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left
    += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    }
    else {\n      // for all the other DOM elements, this one is good\n      boundaries
    = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  const
    isPaddingNumber = typeof padding === ''number'';\n  boundaries.left += isPaddingNumber
    ? padding : padding.left || 0; \n  boundaries.top += isPaddingNumber ? padding
    : padding.top || 0; \n  boundaries.right -= isPaddingNumber ? padding : padding.right
    || 0; \n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    \n\n  return boundaries;\n}\n","import getBoundaries from ''../utils/getBoundaries'';\n\nfunction
    getArea({ width, height }) {\n  return width * height;\n}\n\n/**\n * Utility used
    to transform the `auto` placement to the placement with more\n * available space.\n
    * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeAutoPlacement(\n  placement,\n  refRect,\n  popper,\n  reference,\n  boundariesElement,\n  padding
    = 0\n) {\n  if (placement.indexOf(''auto'') === -1) {\n    return placement;\n  }\n\n  const
    boundaries = getBoundaries(\n    popper,\n    reference,\n    padding,\n    boundariesElement\n  );\n\n  const
    rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top
    - boundaries.top,\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height:
    boundaries.height,\n    },\n    bottom: {\n      width: boundaries.width,\n      height:
    boundaries.bottom - refRect.bottom,\n    },\n    left: {\n      width: refRect.left
    - boundaries.left,\n      height: boundaries.height,\n    },\n  };\n\n  const
    sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area:
    getArea(rects[key]),\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  const
    filteredAreas = sortedAreas.filter(\n    ({ width, height }) =>\n      width >=
    popper.clientWidth && height >= popper.clientHeight\n  );\n\n  const computedPlacement
    = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const
    variation = placement.split(''-'')[1];\n\n  return computedPlacement + (variation
    ? `-${variation}` : '''');\n}\n","import findCommonOffsetParent from ''./findCommonOffsetParent'';\nimport
    getOffsetRectRelativeToArbitraryNode from ''./getOffsetRectRelativeToArbitraryNode'';\nimport
    getFixedPositionOffsetParent from ''./getFixedPositionOffsetParent'';\nimport
    getReferenceNode from ''./getReferenceNode'';\n\n/**\n * Get offsets to the reference
    element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param
    {Element} popper - the popper element\n * @param {Element} reference - the reference
    element (the popper will be relative to this)\n * @param {Element} fixedPosition
    - is in fixed position mode\n * @returns {Object} An object containing the offsets
    which will be applied to the popper\n */\nexport default function getReferenceOffsets(state,
    popper, reference, fixedPosition = null) {\n  const commonOffsetParent = fixedPosition
    ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return
    getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n","/**\n
    * Get the outer sizes of the given element (offset size + margins)\n * @method\n
    * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object}
    object containing width and height properties\n */\nexport default function getOuterSizes(element)
    {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const
    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const
    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  const
    result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight
    + x,\n  };\n  return result;\n}\n","/**\n * Get the opposite placement of the
    given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n
    * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement)
    {\n  const hash = { left: ''right'', right: ''left'', bottom: ''top'', top: ''bottom''
    };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n","import
    getOuterSizes from ''./getOuterSizes'';\nimport getOppositePlacement from ''./getOppositePlacement'';\n\n/**\n
    * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param
    {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement}
    popper - the popper element\n * @param {Object} referenceOffsets - the reference
    offsets (the popper will be relative to this)\n * @param {String} placement -
    one of the valid placement options\n * @returns {Object} popperOffsets - An object
    containing the offsets which will be applied to the popper\n */\nexport default
    function getPopperOffsets(popper, referenceOffsets, placement) {\n  placement
    = placement.split(''-'')[0];\n\n  // Get popper node sizes\n  const popperRect
    = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets
    object\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height,\n  };\n\n  //
    depending by the popper placement we have to compute its offsets slightly differently\n  const
    isHoriz = [''right'', ''left''].indexOf(placement) !== -1;\n  const mainSide =
    isHoriz ? ''top'' : ''left'';\n  const secondarySide = isHoriz ? ''left'' : ''top'';\n  const
    measurement = isHoriz ? ''height'' : ''width'';\n  const secondaryMeasurement
    = !isHoriz ? ''height'' : ''width'';\n\n  popperOffsets[mainSide] =\n    referenceOffsets[mainSide]
    +\n    referenceOffsets[measurement] / 2 -\n    popperRect[measurement] / 2;\n  if
    (placement === secondarySide) {\n    popperOffsets[secondarySide] =\n      referenceOffsets[secondarySide]
    - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide]
    =\n      referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return
    popperOffsets;\n}\n","/**\n * Mimics the `find` method of Array\n * @method\n
    * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument
    value\n * @returns index or -1\n */\nexport default function find(arr, check)
    {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return
    arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return
    arr.filter(check)[0];\n}\n","import find from ''./find'';\n\n/**\n * Return the
    index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument
    {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n
    */\nexport default function findIndex(arr, prop, value) {\n  // use native findIndex
    if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(cur
    => cur[prop] === value);\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn''t
    supported\n  const match = find(arr, obj => obj[prop] === value);\n  return arr.indexOf(match);\n}\n","import
    isFunction from ''./isFunction'';\nimport findIndex from ''./findIndex'';\nimport
    getClientRect from ''../utils/getClientRect'';\n\n/**\n * Loop trough the list
    of modifiers and run them in order,\n * each of them will then edit the data object.\n
    * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array}
    modifiers\n * @param {String} ends - Optional modifier name used as stopper\n
    * @returns {dataObject}\n */\nexport default function runModifiers(modifiers,
    data, ends) {\n  const modifiersToRun = ends === undefined\n    ? modifiers\n    :
    modifiers.slice(0, findIndex(modifiers, ''name'', ends));\n\n  modifiersToRun.forEach(modifier
    => {\n    if (modifier[''function'']) { // eslint-disable-line dot-notation\n      console.warn(''`modifier.function`
    is deprecated, use `modifier.fn`!'');\n    }\n    const fn = modifier[''function'']
    || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled
    && isFunction(fn)) {\n      // Add properties to offsets to make them a complete
    clientRect object\n      // we do this before each modifier to make sure the previous
    one doesn''t\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference
    = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return
    data;\n}\n","import computeAutoPlacement from ''../utils/computeAutoPlacement'';\nimport
    getReferenceOffsets from ''../utils/getReferenceOffsets'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\n\n/**\n
    * Updates the position of the popper, computing the new offsets and applying\n
    * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance
    reasons.\n * @method\n * @memberof Popper\n */\nexport default function update()
    {\n  // if popper is destroyed, don''t perform any further update\n  if (this.state.isDestroyed)
    {\n    return;\n  }\n\n  let data = {\n    instance: this,\n    styles: {},\n    arrowStyles:
    {},\n    attributes: {},\n    flipped: false,\n    offsets: {},\n  };\n\n  //
    compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(\n    this.state,\n    this.popper,\n    this.reference,\n    this.options.positionFixed\n  );\n\n  //
    compute auto placement, store placement inside the data object,\n  // modifiers
    will be able to edit `placement` if needed\n  // and refer to originalPlacement
    to know the original value\n  data.placement = computeAutoPlacement(\n    this.options.placement,\n    data.offsets.reference,\n    this.popper,\n    this.reference,\n    this.options.modifiers.flip.boundariesElement,\n    this.options.modifiers.flip.padding\n  );\n\n  //
    store the computed placement inside `originalPlacement`\n  data.originalPlacement
    = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  //
    compute the popper offsets\n  data.offsets.popper = getPopperOffsets(\n    this.popper,\n    data.offsets.reference,\n    data.placement\n  );\n\n  data.offsets.popper.position
    = this.options.positionFixed\n    ? ''fixed''\n    : ''absolute'';\n\n  // run
    the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first
    `update` will call `onCreate` callback\n  // the other ones will call `onUpdate`
    callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  }
    else {\n    this.options.onUpdate(data);\n  }\n}\n","/**\n * Helper used to know
    if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns
    {Boolean}\n */\nexport default function isModifierEnabled(modifiers, modifierName)
    {\n  return modifiers.some(\n    ({ name, enabled }) => enabled && name === modifierName\n  );\n}\n","/**\n
    * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} property (camelCase)\n * @returns {String} prefixed property
    (camelCase or PascalCase, depending on the vendor prefix)\n */\nexport default
    function getSupportedPropertyName(property) {\n  const prefixes = [false, ''ms'',
    ''Webkit'', ''Moz'', ''O''];\n  const upperProp = property.charAt(0).toUpperCase()
    + property.slice(1);\n\n  for (let i = 0; i < prefixes.length; i++) {\n    const
    prefix = prefixes[i];\n    const toCheck = prefix ? `${prefix}${upperProp}` :
    property;\n    if (typeof document.body.style[toCheck] !== ''undefined'') {\n      return
    toCheck;\n    }\n  }\n  return null;\n}\n","import isModifierEnabled from ''../utils/isModifierEnabled'';\nimport
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * Destroys the popper.\n * @method\n * @memberof Popper\n */\nexport default function
    destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle`
    modifier is enabled\n  if (isModifierEnabled(this.modifiers, ''applyStyle''))
    {\n    this.popper.removeAttribute(''x-placement'');\n    this.popper.style.position
    = '''';\n    this.popper.style.top = '''';\n    this.popper.style.left = '''';\n    this.popper.style.right
    = '''';\n    this.popper.style.bottom = '''';\n    this.popper.style.willChange
    = '''';\n    this.popper.style[getSupportedPropertyName(''transform'')] = '''';\n  }\n\n  this.disableEventListeners();\n\n  //
    remove the popper if user explicitly asked for the deletion on destroy\n  // do
    not use `remove` because IE11 doesn''t support it\n  if (this.options.removeOnDestroy)
    {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n","/**\n
    * Get the window associated with the element\n * @argument {Element} element\n
    * @returns {Window}\n */\nexport default function getWindow(element) {\n  const
    ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView
    : window;\n}\n","import getScrollParent from ''./getScrollParent'';\nimport getWindow
    from ''./getWindow'';\n\nfunction attachToScrollParents(scrollParent, event, callback,
    scrollParents) {\n  const isBody = scrollParent.nodeName === ''BODY'';\n  const
    target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event,
    callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(\n      getScrollParent(target.parentNode),\n      event,\n      callback,\n      scrollParents\n    );\n  }\n  scrollParents.push(target);\n}\n\n/**\n
    * Setup needed event listeners used to update the popper position\n * @method\n
    * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(\n  reference,\n  options,\n  state,\n  updateBound\n)
    {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener(''resize'',
    state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll
    parents\n  const scrollElement = getScrollParent(reference);\n  attachToScrollParents(\n    scrollElement,\n    ''scroll'',\n    state.updateBound,\n    state.scrollParents\n  );\n  state.scrollElement
    = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n","import
    setupEventListeners from ''../utils/setupEventListeners'';\n\n/**\n * It will
    add resize/scroll events and start recalculating\n * position of the popper element
    when they are triggered.\n * @method\n * @memberof Popper\n */\nexport default
    function enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state
    = setupEventListeners(\n      this.reference,\n      this.options,\n      this.state,\n      this.scheduleUpdate\n    );\n  }\n}\n","import
    getWindow from ''./getWindow'';\n\n/**\n * Remove event listeners used to update
    the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport
    default function removeEventListeners(reference, state) {\n  // Remove resize
    event listener on window\n  getWindow(reference).removeEventListener(''resize'',
    state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(target
    => {\n    target.removeEventListener(''scroll'', state.updateBound);\n  });\n\n  //
    Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement
    = null;\n  state.eventsEnabled = false;\n  return state;\n}\n","import removeEventListeners
    from ''../utils/removeEventListeners'';\n\n/**\n * It will remove resize/scroll
    events and won''t recalculate popper position\n * when they are triggered. It
    also won''t trigger `onUpdate` callback anymore,\n * unless you call `update`
    method manually.\n * @method\n * @memberof Popper\n */\nexport default function
    disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state
    = removeEventListeners(this.reference, this.state);\n  }\n}\n","/**\n * Tells
    if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param
    {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n)
    {\n  return n !== '''' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","import
    isNumeric from ''./isNumeric'';\n\n/**\n * Set the style to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the style to\n * @argument {Object} styles\n * Object with a list of
    properties and values which will be applied to the element\n */\nexport default
    function setStyles(element, styles) {\n  Object.keys(styles).forEach(prop => {\n    let
    unit = '''';\n    // add unit if the value is numeric and is one of the following\n    if
    (\n      [''width'', ''height'', ''top'', ''right'', ''bottom'', ''left''].indexOf(prop)
    !==\n        -1 &&\n      isNumeric(styles[prop])\n    ) {\n      unit = ''px'';\n    }\n    element.style[prop]
    = styles[prop] + unit;\n  });\n}\n","/**\n * Set the attributes to the given popper\n
    * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element
    to apply the attributes to\n * @argument {Object} styles\n * Object with a list
    of properties and values which will be applied to the element\n */\nexport default
    function setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function(prop)
    {\n    const value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop,
    attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n","/**\n
    * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data
    object generated by `update` method\n * @argument {Boolean} shouldRound - If the
    offsets should be rounded at all\n * @returns {Object} The popper''s position
    offsets rounded\n *\n * The tale of pixel-perfect positioning. It''s still not
    100% perfect, but as\n * good as it can be within reason.\n * Discussion here:
    https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause
    a popper to be blurry if not using full pixels (Safari\n * as well on High DPI
    screens).\n *\n * Firefox prefers no rounding for positioning and does not have
    blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right
    values need to be considered.\n */\nexport default function getRoundedOffsets(data,
    shouldRound) {\n  const { popper, reference } = data.offsets;\n  const { round,
    floor } = Math;\n  const noRound = v => v;\n  \n  const referenceWidth = round(reference.width);\n  const
    popperWidth = round(popper.width);\n  \n  const isVertical = [''left'', ''right''].indexOf(data.placement)
    !== -1;\n  const isVariation = data.placement.indexOf(''-'') !== -1;\n  const
    sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  const bothOddWidth
    = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  const horizontalToInteger
    = !shouldRound\n    ? noRound\n    : isVertical || isVariation || sameWidthParity\n    ?
    round\n    : floor;\n  const verticalToInteger = !shouldRound ? noRound : round;\n\n  return
    {\n    left: horizontalToInteger(\n      bothOddWidth && !isVariation && shouldRound\n        ?
    popper.left - 1\n        : popper.left\n    ),\n    top: verticalToInteger(popper.top),\n    bottom:
    verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right),\n  };\n}\n","import
    find from ''./find'';\n\n/**\n * Helper used to know if the given modifier depends
    from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n
    * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n
    * @param {String} requestingName - name of requesting modifier\n * @param {String}
    requestedName - name of requested modifier\n * @returns {Boolean}\n */\nexport
    default function isModifierRequired(\n  modifiers,\n  requestingName,\n  requestedName\n)
    {\n  const requesting = find(modifiers, ({ name }) => name === requestingName);\n\n  const
    isRequired =\n    !!requesting &&\n    modifiers.some(modifier => {\n      return
    (\n        modifier.name === requestedName &&\n        modifier.enabled &&\n        modifier.order
    < requesting.order\n      );\n    });\n\n  if (!isRequired) {\n    const requesting
    = `\\`${requestingName}\\``;\n    const requested = `\\`${requestedName}\\``;\n    console.warn(\n      `${requested}
    modifier is required by ${requesting} modifier in order to work, be sure to include
    it before ${requesting}!`\n    );\n  }\n  return isRequired;\n}\n","/**\n * Get
    the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n
    * @argument {String} placement variation\n * @returns {String} flipped placement
    variation\n */\nexport default function getOppositeVariation(variation) {\n  if
    (variation === ''end'') {\n    return ''start'';\n  } else if (variation === ''start'')
    {\n    return ''end'';\n  }\n  return variation;\n}\n","import placements from
    ''../methods/placements'';\n\n// Get rid of `auto` `auto-start` and `auto-end`\nconst
    validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement,
    returns all the subsequent placements\n * clockwise (or counter-clockwise).\n
    *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A
    valid placement (it accepts variations)\n * @argument {Boolean} counter - Set
    to true to walk the placements counterclockwise\n * @returns {Array} placements
    including their variations\n */\nexport default function clockwise(placement,
    counter = false) {\n  const index = validPlacements.indexOf(placement);\n  const
    arr = validPlacements\n    .slice(index + 1)\n    .concat(validPlacements.slice(0,
    index));\n  return counter ? arr.reverse() : arr;\n}\n","import isNumeric from
    ''../utils/isNumeric'';\nimport getClientRect from ''../utils/getClientRect'';\nimport
    find from ''../utils/find'';\n\n/**\n * Converts a string containing value + unit
    into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n
    * @argument {String} str - Value + unit string\n * @argument {String} measurement
    - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object}
    referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original
    string if no values were extracted\n */\nexport function toValue(str, measurement,
    popperOffsets, referenceOffsets) {\n  // separate value from unit\n  const split
    = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  const value = +split[1];\n  const
    unit = split[2];\n\n  // If it''s not a number it''s an operator, I guess\n  if
    (!value) {\n    return str;\n  }\n\n  if (unit.indexOf(''%'') === 0) {\n    let
    element;\n    switch (unit) {\n      case ''%p'':\n        element = popperOffsets;\n        break;\n      case
    ''%'':\n      case ''%r'':\n      default:\n        element = referenceOffsets;\n    }\n\n    const
    rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  }
    else if (unit === ''vh'' || unit === ''vw'') {\n    // if is a vh or vw, we calculate
    the size based on the viewport\n    let size;\n    if (unit === ''vh'') {\n      size
    = Math.max(\n        document.documentElement.clientHeight,\n        window.innerHeight
    || 0\n      );\n    } else {\n      size = Math.max(\n        document.documentElement.clientWidth,\n        window.innerWidth
    || 0\n      );\n    }\n    return size / 100 * value;\n  } else {\n    // if is
    an explicit pixel unit, we get rid of the unit and keep the value\n    // if is
    an implicit unit, it''s px, and we return just the value\n    return value;\n  }\n}\n\n/**\n
    * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n
    * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n *
    @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument
    {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets
    in numbers\n */\nexport function parseOffset(\n  offset,\n  popperOffsets,\n  referenceOffsets,\n  basePlacement\n)
    {\n  const offsets = [0, 0];\n\n  // Use height if placement is left or right
    and index is 0 otherwise use width\n  // in this way the first offset will use
    an axis and the second one\n  // will use the other one\n  const useHeight = [''right'',
    ''left''].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain
    a list of values and operands\n  // The regex addresses values with the plus or
    minus sign in front (+10, -20, etc)\n  const fragments = offset.split(/(\\+|\\-)/).map(frag
    => frag.trim());\n\n  // Detect if the offset string contains a pair of values
    or a single one\n  // they could be separated by comma or space\n  const divider
    = fragments.indexOf(\n    find(fragments, frag => frag.search(/,|\\s/) !== -1)\n  );\n\n  if
    (fragments[divider] && fragments[divider].indexOf('','') === -1) {\n    console.warn(\n      ''Offsets
    separated by white space(s) are deprecated, use a comma (,) instead.''\n    );\n  }\n\n  //
    If divider is found, we divide the list of values and operands to divide\n  //
    them by ofset X and Y.\n  const splitRegex = /\\s*,\\s*|\\s+/;\n  let ops = divider
    !== -1\n    ? [\n        fragments\n          .slice(0, divider)\n          .concat([fragments[divider].split(splitRegex)[0]]),\n        [fragments[divider].split(splitRegex)[1]].concat(\n          fragments.slice(divider
    + 1)\n        ),\n      ]\n    : [fragments];\n\n  // Convert the values with
    units to absolute pixels to allow our computations\n  ops = ops.map((op, index)
    => {\n    // Most of the units rely on the orientation of the popper\n    const
    measurement = (index === 1 ? !useHeight : useHeight)\n      ? ''height''\n      :
    ''width'';\n    let mergeWithPrevious = false;\n    return (\n      op\n        //
    This aggregates any `+` or `-` sign that aren''t considered operators\n        //
    e.g.: 10 + +5 => [10, +, +5]\n        .reduce((a, b) => {\n          if (a[a.length
    - 1] === '''' && [''+'', ''-''].indexOf(b) !== -1) {\n            a[a.length -
    1] = b;\n            mergeWithPrevious = true;\n            return a;\n          }
    else if (mergeWithPrevious) {\n            a[a.length - 1] += b;\n            mergeWithPrevious
    = false;\n            return a;\n          } else {\n            return a.concat(b);\n          }\n        },
    [])\n        // Here we convert the string values into number values (in px)\n        .map(str
    => toValue(str, measurement, popperOffsets, referenceOffsets))\n    );\n  });\n\n  //
    Loop trough the offsets arrays and execute the operations\n  ops.forEach((op,
    index) => {\n    op.forEach((frag, index2) => {\n      if (isNumeric(frag)) {\n        offsets[index]
    += frag * (op[index2 - 1] === ''-'' ? -1 : 1);\n      }\n    });\n  });\n  return
    offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object}
    data - The data object generated by update method\n * @argument {Object} options
    - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n
    * The offset value as described in the modifier description\n * @returns {Object}
    The data object, properly modified\n */\nexport default function offset(data,
    { offset }) {\n  const { placement, offsets: { popper, reference } } = data;\n  const
    basePlacement = placement.split(''-'')[0];\n\n  let offsets;\n  if (isNumeric(+offset))
    {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset,
    popper, reference, basePlacement);\n  }\n\n  if (basePlacement === ''left'') {\n    popper.top
    += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement ===
    ''right'') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  }
    else if (basePlacement === ''top'') {\n    popper.left += offsets[0];\n    popper.top
    -= offsets[1];\n  } else if (basePlacement === ''bottom'') {\n    popper.left
    += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return
    data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport getOuterSizes
    from ''../utils/getOuterSizes'';\nimport isModifierRequired from ''../utils/isModifierRequired'';\nimport
    getStyleComputedProperty from ''../utils/getStyleComputedProperty'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by update method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function arrow(data, options) {\n  // arrow depends on keepTogether in
    order to work\n  if (!isModifierRequired(data.instance.modifiers, ''arrow'', ''keepTogether''))
    {\n    return data;\n  }\n\n  let arrowElement = options.element;\n\n  // if arrowElement
    is a string, suppose it''s a CSS selector\n  if (typeof arrowElement === ''string'')
    {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    //
    if arrowElement is not found, don''t run the modifier\n    if (!arrowElement)
    {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn''t a
    query selector we must check that the\n    // provided DOM node is child of its
    popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn(\n        ''WARNING:
    `arrow.element` must be child of its popper element!''\n      );\n      return
    data;\n    }\n  }\n\n  const placement = data.placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isVertical = [''left'', ''right''].indexOf(placement)
    !== -1;\n\n  const len = isVertical ? ''height'' : ''width'';\n  const sideCapitalized
    = isVertical ? ''Top'' : ''Left'';\n  const side = sideCapitalized.toLowerCase();\n  const
    altSide = isVertical ? ''left'' : ''top'';\n  const opSide = isVertical ? ''bottom''
    : ''right'';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  //
    extends keepTogether behavior making sure the popper and its\n  // reference have
    enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide]
    - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -=\n      popper[side]
    - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side]
    + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] +=\n      reference[side]
    + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  //
    compute center of the popper\n  const center = reference[side] + reference[len]
    / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper
    offsets\n  // take popper margin in account because we don''t have this info available\n  const
    css = getStyleComputedProperty(data.instance.popper);\n  const popperMarginSide
    = parseFloat(css[`margin${sideCapitalized}`]);\n  const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n  let
    sideValue =\n    center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  //
    prevent arrowElement from being placed not contiguously to its popper\n  sideValue
    = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement
    = arrowElement;\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]:
    '''', // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  return
    data;\n}\n","export default typeof window !== ''undefined'' && typeof document
    !== ''undefined'' && typeof navigator !== ''undefined'';\n","import isBrowser
    from ''./isBrowser'';\n\nconst timeoutDuration = (function(){\n  const longerTimeoutBrowsers
    = [''Edge'', ''Trident'', ''Firefox''];\n  for (let i = 0; i < longerTimeoutBrowsers.length;
    i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i])
    >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}());\n\nexport function microtaskDebounce(fn)
    {\n  let called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called
    = true\n    window.Promise.resolve().then(() => {\n      called = false\n      fn()\n    })\n  }\n}\n\nexport
    function taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if
    (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled
    = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nconst supportsMicroTasks
    = isBrowser && window.Promise\n\n\n/**\n* Create a debounced version of a method,
    that''s asynchronously deferred\n* but called in the minimum time possible.\n*\n*
    @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nexport
    default (supportsMicroTasks\n  ? microtaskDebounce\n  : taskDebounce);\n","import
    getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\nimport find
    from ''../utils/find'';\nimport getOffsetParent from ''../utils/getOffsetParent'';\nimport
    getBoundingClientRect from ''../utils/getBoundingClientRect'';\nimport getRoundedOffsets
    from ''../utils/getRoundedOffsets'';\nimport isBrowser from ''../utils/isBrowser'';\n\nconst
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n
    * @memberof Modifiers\n * @argument {Object} data - The data object generated
    by `update` method\n * @argument {Object} options - Modifiers configuration and
    options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function computeStyle(data, options) {\n  const { x, y } = options;\n  const
    { popper } = data.offsets;\n\n  // Remove this legacy support in Popper.js v2\n  const
    legacyGpuAccelerationOption = find(\n    data.instance.modifiers,\n    modifier
    => modifier.name === ''applyStyle''\n  ).gpuAcceleration;\n  if (legacyGpuAccelerationOption
    !== undefined) {\n    console.warn(\n      ''WARNING: `gpuAcceleration` option
    moved to `computeStyle` modifier and will not be supported in future versions
    of Popper.js!''\n    );\n  }\n  const gpuAcceleration =\n    legacyGpuAccelerationOption
    !== undefined\n      ? legacyGpuAccelerationOption\n      : options.gpuAcceleration;\n\n  const
    offsetParent = getOffsetParent(data.instance.popper);\n  const offsetParentRect
    = getBoundingClientRect(offsetParent);\n\n  // Styles\n  const styles = {\n    position:
    popper.position,\n  };\n\n  const offsets = getRoundedOffsets(\n    data,\n    window.devicePixelRatio
    < 2 || !isFirefox\n  );\n\n  const sideA = x === ''bottom'' ? ''top'' : ''bottom'';\n  const
    sideB = y === ''right'' ? ''left'' : ''right'';\n\n  // if gpuAcceleration is
    set to `true` and transform is supported,\n  //  we use `translate3d` to apply
    the position to the popper we\n  // automatically use the supported prefixed version
    if needed\n  const prefixedProperty = getSupportedPropertyName(''transform'');\n\n  //
    now, let''s make a step back and look at this code closely (wtf?)\n  // If the
    content of the popper grows once it''s been positioned, it\n  // may happen that
    the popper gets misplaced because of the new content\n  // overflowing its reference
    element\n  // To avoid this problem, we provide two options (x and y), which allow\n  //
    the consumer to define the offset origin.\n  // If we position a popper on top
    of a reference element, we can set\n  // `x` to `top` to make the popper grow
    towards its top instead of\n  // its bottom.\n  let left, top;\n  if (sideA ===
    ''bottom'') {\n    // when offsetParent is <html> the positioning is relative
    to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom
    of the html element\n    if (offsetParent.nodeName === ''HTML'') {\n      top
    = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height
    + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB
    === ''right'') {\n    if (offsetParent.nodeName === ''HTML'') {\n      left =
    -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width
    + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration
    && prefixedProperty) {\n    styles[prefixedProperty] = `translate3d(${left}px,
    ${top}px, 0)`;\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange
    = ''transform'';\n  } else {\n    // othwerise, we use the standard `top`, `left`,
    `bottom` and `right` properties\n    const invertTop = sideA === ''bottom'' ?
    -1 : 1;\n    const invertLeft = sideB === ''right'' ? -1 : 1;\n    styles[sideA]
    = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange
    = `${sideA}, ${sideB}`;\n  }\n\n  // Attributes\n  const attributes = {\n    ''x-placement'':
    data.placement,\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes
    = { ...attributes, ...data.attributes };\n  data.styles = { ...styles, ...data.styles
    };\n  data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles };\n\n  return
    data;\n}\n","import getOppositePlacement from ''../utils/getOppositePlacement'';\nimport
    getOppositeVariation from ''../utils/getOppositeVariation'';\nimport getPopperOffsets
    from ''../utils/getPopperOffsets'';\nimport runModifiers from ''../utils/runModifiers'';\nimport
    getBoundaries from ''../utils/getBoundaries'';\nimport isModifierEnabled from
    ''../utils/isModifierEnabled'';\nimport clockwise from ''../utils/clockwise'';\n\nconst
    BEHAVIORS = {\n  FLIP: ''flip'',\n  CLOCKWISE: ''clockwise'',\n  COUNTERCLOCKWISE:
    ''counterclockwise'',\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument
    {Object} data - The data object generated by update method\n * @argument {Object}
    options - Modifiers configuration and options\n * @returns {Object} The data object,
    properly modified\n */\nexport default function flip(data, options) {\n  // if
    `inner` modifier is enabled, we can''t use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers,
    ''inner'')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement ===
    data.originalPlacement) {\n    // seems like flip is trying to loop, probably
    there''s not enough space on any of the flippable sides\n    return data;\n  }\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    options.boundariesElement,\n    data.positionFixed\n  );\n\n  let
    placement = data.placement.split(''-'')[0];\n  let placementOpposite = getOppositePlacement(placement);\n  let
    variation = data.placement.split(''-'')[1] || '''';\n\n  let flipOrder = [];\n\n  switch
    (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement,
    placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder
    = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder
    = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach((step,
    index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return
    data;\n    }\n\n    placement = data.placement.split(''-'')[0];\n    placementOpposite
    = getOppositePlacement(placement);\n\n    const popperOffsets = data.offsets.popper;\n    const
    refOffsets = data.offsets.reference;\n\n    // using floor because the reference
    offsets may contain decimals we are not going to consider here\n    const floor
    = Math.floor;\n    const overlapsRef =\n      (placement === ''left'' &&\n        floor(popperOffsets.right)
    > floor(refOffsets.left)) ||\n      (placement === ''right'' &&\n        floor(popperOffsets.left)
    < floor(refOffsets.right)) ||\n      (placement === ''top'' &&\n        floor(popperOffsets.bottom)
    > floor(refOffsets.top)) ||\n      (placement === ''bottom'' &&\n        floor(popperOffsets.top)
    < floor(refOffsets.bottom));\n\n    const overflowsLeft = floor(popperOffsets.left)
    < floor(boundaries.left);\n    const overflowsRight = floor(popperOffsets.right)
    > floor(boundaries.right);\n    const overflowsTop = floor(popperOffsets.top)
    < floor(boundaries.top);\n    const overflowsBottom =\n      floor(popperOffsets.bottom)
    > floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement
    === ''left'' && overflowsLeft) ||\n      (placement === ''right'' && overflowsRight)
    ||\n      (placement === ''top'' && overflowsTop) ||\n      (placement === ''bottom''
    && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical
    = [''top'', ''bottom''].indexOf(placement) !== -1;\n\n    // flips variation if
    reference element overflows boundaries\n    const flippedVariationByRef =\n      !!options.flipVariations
    &&\n      ((isVertical && variation === ''start'' && overflowsLeft) ||\n        (isVertical
    && variation === ''end'' && overflowsRight) ||\n        (!isVertical && variation
    === ''start'' && overflowsTop) ||\n        (!isVertical && variation === ''end''
    && overflowsBottom));\n\n    // flips variation if popper content overflows boundaries\n    const
    flippedVariationByContent =\n      !!options.flipVariationsByContent &&\n      ((isVertical
    && variation === ''start'' && overflowsRight) ||\n        (isVertical && variation
    === ''end'' && overflowsLeft) ||\n        (!isVertical && variation === ''start''
    && overflowsBottom) ||\n        (!isVertical && variation === ''end'' && overflowsTop));\n\n    const
    flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if
    (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean
    to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef ||
    overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if
    (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement
    = placement + (variation ? ''-'' + variation : '''');\n\n      // this object
    contains `position`, we want to preserve it along with\n      // any additional
    property we may add in the future\n      data.offsets.popper = {\n        ...data.offsets.popper,\n        ...getPopperOffsets(\n          data.instance.popper,\n          data.offsets.reference,\n          data.placement\n        ),\n      };\n\n      data
    = runModifiers(data.instance.modifiers, data, ''flip'');\n    }\n  });\n  return
    data;\n}\n","// Utils\nimport debounce from ''./utils/debounce'';\nimport isFunction
    from ''./utils/isFunction'';\n\n// Methods\nimport update from ''./methods/update'';\nimport
    destroy from ''./methods/destroy'';\nimport enableEventListeners from ''./methods/enableEventListeners'';\nimport
    disableEventListeners from ''./methods/disableEventListeners'';\nimport Defaults
    from ''./methods/defaults'';\nimport placements from ''./methods/placements'';\n\nexport
    default class Popper {\n  /**\n   * Creates a new Popper.js instance.\n   * @class
    Popper\n   * @param {Element|referenceObject} reference - The reference element
    used to position the popper\n   * @param {Element} popper - The HTML / XML element
    used as the popper\n   * @param {Object} options - Your custom options to override
    the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The
    generated Popper.js instance\n   */\n  constructor(reference, popper, options
    = {}) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update
    = debounce(this.update.bind(this));\n\n    // with {} we create a new object with
    the options inside it\n    this.options = { ...Popper.Defaults, ...options };\n\n    //
    init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents:
    [],\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference
    = reference && reference.jquery ? reference[0] : reference;\n    this.popper =
    popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers
    = {};\n    Object.keys({\n      ...Popper.Defaults.modifiers,\n      ...options.modifiers,\n    }).forEach(name
    => {\n      this.options.modifiers[name] = {\n        // If it''s a built-in modifier,
    use it as base\n        ...(Popper.Defaults.modifiers[name] || {}),\n        //
    If there are custom options, override and merge with default ones\n        ...(options.modifiers
    ? options.modifiers[name] : {}),\n      };\n    });\n\n    // Refactoring modifiers''
    list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers)\n      .map(name
    => ({\n        name,\n        ...this.options.modifiers[name],\n      }))\n      //
    sort the modifiers by order\n      .sort((a, b) => a.order - b.order);\n\n    //
    modifiers have the ability to execute arbitrary code when Popper.js get inited\n    //
    such code is executed in the same order of its modifier\n    // they could add
    new properties to their options configuration\n    // BE AWARE: don''t add options
    to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(modifierOptions
    => {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad))
    {\n        modifierOptions.onLoad(\n          this.reference,\n          this.popper,\n          this.options,\n          modifierOptions,\n          this.state\n        );\n      }\n    });\n\n    //
    fire the first update to position the popper in the right place\n    this.update();\n\n    const
    eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      //
    setup event listeners, they will take care of update the position in specific
    situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled
    = eventsEnabled;\n  }\n\n  // We can''t use class properties because they don''t
    get listed in the\n  // class prototype and break stuff like Sinon stubs\n  update()
    {\n    return update.call(this);\n  }\n  destroy() {\n    return destroy.call(this);\n  }\n  enableEventListeners()
    {\n    return enableEventListeners.call(this);\n  }\n  disableEventListeners()
    {\n    return disableEventListeners.call(this);\n  }\n\n  /**\n   * Schedules
    an update. It will run on the next UI update available.\n   * @method scheduleUpdate\n   *
    @memberof Popper\n   */\n  scheduleUpdate = () => requestAnimationFrame(this.update);\n\n  /**\n   *
    Collection of utilities useful when writing custom modifiers.\n   * Starting from
    version 1.7, this method is available only if you\n   * include `popper-utils.js`
    before `popper.js`.\n   *\n   * **DEPRECATION**: This way to access PopperUtils
    is deprecated\n   * and will be removed in v2! Use the PopperUtils module directly
    instead.\n   * Due to the high instability of the methods contained in Utils,
    we can''t\n   * guarantee them to follow semver. Use them at your own risk!\n   *
    @static\n   * @private\n   * @type {Object}\n   * @deprecated since version 1.8\n   *
    @member Utils\n   * @memberof Popper\n   */\n  static Utils = (typeof window !==
    ''undefined'' ? window : global).PopperUtils;\n\n  static placements = placements;\n\n  static
    Defaults = Defaults;\n}\n\n/**\n * The `referenceObject` is an object that provides
    an interface compatible with Popper.js\n * and lets you use it as replacement
    of a real DOM node.<br />\n * You can use this method to position a popper relatively
    to a set of coordinates\n * in case you don''t have a DOM node to use as reference.\n
    *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This
    feature isn''t supported in Internet Explorer 10.\n * @name referenceObject\n
    * @property {Function} data.getBoundingClientRect\n * A function that returns
    a set of coordinates compatible with the native `getBoundingClientRect` method.\n
    * @property {number} data.clientWidth\n * An ES6 getter that will return the width
    of the virtual reference element.\n * @property {number} data.clientHeight\n *
    An ES6 getter that will return the height of the virtual reference element.\n
    */\n","import modifiers from ''../modifiers/index'';\n\n/**\n * Default options
    provided to Popper.js constructor.<br />\n * These can be overridden using the
    `options` argument of Popper.js.<br />\n * To override an option, simply pass
    an object with the same\n * structure of the `options` object, as the 3rd argument.
    For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow:
    { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof
    Popper\n */\nexport default {\n  /**\n   * Popper''s placement.\n   * @prop {Popper.placements}
    placement=''bottom''\n   */\n  placement: ''bottom'',\n\n  /**\n   * Set this
    to true if you want popper to position it self in ''fixed'' mode\n   * @prop {Boolean}
    positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events
    (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled:
    true,\n\n  /**\n   * Set to true if you want to automatically remove the popper
    when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy:
    false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   *
    By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onCreate}\n   */\n  onCreate: () => {},\n\n  /**\n   * Callback called
    when the popper is updated. This callback is not called\n   * on the initialization/creation
    of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it
    is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   *
    @prop {onUpdate}\n   */\n  onUpdate: () => {},\n\n  /**\n   * List of modifiers
    used to modify the offsets before they are applied to the popper.\n   * They provide
    most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers,\n};\n\n/**\n
    * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n
    * @param {dataObject} data\n */\n","import applyStyle, { applyStyleOnLoad } from
    ''./applyStyle'';\nimport computeStyle from ''./computeStyle'';\nimport arrow
    from ''./arrow'';\nimport flip from ''./flip'';\nimport keepTogether from ''./keepTogether'';\nimport
    offset from ''./offset'';\nimport preventOverflow from ''./preventOverflow'';\nimport
    shift from ''./shift'';\nimport hide from ''./hide'';\nimport inner from ''./inner'';\n\n/**\n
    * Modifier function, each modifier can have a function of this type assigned\n
    * to its `fn` property.<br />\n * These functions will be called on each update,
    this means that you must\n * make sure they are performant enough to avoid performance
    bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The
    data object generated by `update` method\n * @argument {Object} options - Modifiers
    configuration and options\n * @returns {dataObject} The data object, properly
    modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your
    poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic
    functionalities\n * needed by the library.\n *\n * Usually you don''t want to
    override the `order`, `fn` and `onLoad` props.\n * All the other properties are
    configurations that could be tweaked.\n * @namespace modifiers\n */\nexport default
    {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   *
    element.<br />\n   * It will read the variation of the `placement` property.<br
    />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   *
    @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define
    the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true
    - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop
    {ModifierFn} */\n    fn: shift,\n  },\n\n  /**\n   * The `offset` modifier can
    shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   *
    - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative
    to the length of the reference element\n   * - `%p`, percentage relative to the
    length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`,
    CSS viewport height unit\n   *\n   * For length is intended the main axis relative
    to the placement of the popper.<br />\n   * This means that if the placement is
    `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or
    `right`, it will be the `height`.\n   *\n   * You can provide a single value (as
    `Number` or `String`), or a pair of values\n   * as `String` divided by a comma
    or one (or more) white spaces.<br />\n   * The latter is a deprecated method because
    it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally,
    it accepts additions and subtractions between different units.\n   * Note that
    multiplications and divisions aren''t supported.\n   *\n   * Valid examples are:\n   *
    ```\n   * 10\n   * ''10%''\n   * ''10, 10''\n   * ''10%, 10''\n   * ''10 + 10%''\n   *
    ''10 - 5vh + 3%''\n   * ''-10px + 5vh, 5px - 6%''\n   * ```\n   * > **NB**: If
    you desire to apply offsets to your poppers in a way that may make them overlap\n   *
    > with their reference element, unfortunately, you will have to disable the `flip`
    modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200
    - Index used to define the order of execution */\n    order: 200,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String}
    offset=0\n     * The offset value as described in the modifier description\n     */\n    offset:
    0,\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned
    outside the boundary.\n   *\n   * A scenario exists where the reference itself
    is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"
    — or just \"escaped\".<br />\n   * In this case we need to decide whether the
    popper should either:\n   *\n   * - detach from the reference and remain \"trapped\"
    in the boundaries, or\n   * - if it should ignore the boundary and \"escape with
    its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference
    is completely\n   * outside its boundaries, the popper will overflow (or completely
    leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   *
    @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number}
    order=300 - Index used to define the order of execution */\n    order: 300,\n    /**
    @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     *
    @prop {Array} [priority=[''left'',''right'',''top'',''bottom'']]\n     * Popper
    will try to prevent overflow following these priorities by default,\n     * then,
    it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority:
    [''left'', ''right'', ''top'', ''bottom''],\n    /**\n     * @prop {number} padding=5\n     *
    Amount of pixel used to define a minimum distance between the boundaries\n     *
    and the popper. This makes sure the popper always has a little padding\n     *
    between the edges of its container\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''scrollParent''\n     * Boundaries
    used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any
    DOM element.\n     */\n    boundariesElement: ''scrollParent'',\n  },\n\n  /**\n   *
    Modifier used to make sure the reference and its popper stay near each other\n   *
    without leaving any gap between the two. Especially useful when the arrow is\n   *
    enabled and you want to ensure that it points to its reference element.\n   *
    It cares only about the first axis. You can still have poppers with margin\n   *
    between the popper and its reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used
    to define the order of execution */\n    order: 400,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: keepTogether,\n  },\n\n  /**\n   * This modifier
    is used to move the `arrowElement` of the popper to make\n   * sure it is positioned
    between the reference element and its popper element.\n   * It will read the outer
    size of the `arrowElement` node to detect how many\n   * pixels of conjunction
    are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   *
    @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500
    - Index used to define the order of execution */\n    order: 500,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement}
    element=''[x-arrow]'' - Selector or node used as arrow */\n    element: ''[x-arrow]'',\n  },\n\n  /**\n   *
    Modifier used to flip the popper''s placement when it starts to overlap its\n   *
    reference element.\n   *\n   * Requires the `preventOverflow` modifier before
    it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current
    update cycle and will\n   * restart it if it detects the need to flip the placement.\n   *
    @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600
    - Index used to define the order of execution */\n    order: 600,\n    /** @prop
    {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled:
    true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array}
    behavior=''flip''\n     * The behavior used to change the popper''s placement.
    It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with
    a list of valid\n     * placements (with optional variations)\n     */\n    behavior:
    ''flip'',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip
    if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     *
    @prop {String|HTMLElement} boundariesElement=''viewport''\n     * The element
    which will define the boundaries of the popper position.\n     * The popper will
    never be placed outside of the defined boundaries\n     * (except if `keepTogether`
    is enabled)\n     */\n    boundariesElement: ''viewport'',\n    /**\n     * @prop
    {Boolean} flipVariations=false\n     * The popper will switch placement variation
    between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     *
    The original placement should have a set variation.\n     */\n    flipVariations:
    false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     *
    The popper will switch placement variation between `-start` and `-end` when\n     *
    the popper element overlaps its reference boundaries.\n     *\n     * The original
    placement should have a set variation.\n     */\n    flipVariationsByContent:
    false,\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner
    of the reference element.\n   * By default, when this modifier is disabled, the
    popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   *
    @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define
    the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false
    - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop
    {ModifierFn} */\n    fn: inner,\n  },\n\n  /**\n   * Modifier used to hide the
    popper when its reference element is outside of the\n   * popper boundaries. It
    will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with
    a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   *
    Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof
    modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index
    used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: hide,\n  },\n\n  /**\n   * Computes the style that
    will be applied to the popper element to gets\n   * properly positioned.\n   *\n   *
    Note that this modifier will not touch the DOM, it just prepares the styles\n   *
    so that `applyStyle` modifier can apply it. This separation is useful\n   * in
    case you need to replace `applyStyle` with a custom implementation.\n   *\n   *
    This modifier has `850` as `order` value to maintain backward compatibility\n   *
    with previous versions of Popper.js. Expect the modifiers ordering method\n   *
    to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used
    to define the order of execution */\n    order: 850,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean}
    gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position
    the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration:
    true,\n    /**\n     * @prop {string} [x=''bottom'']\n     * Where to anchor the
    X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper
    should grow in a direction different from `bottom`\n     */\n    x: ''bottom'',\n    /**\n     *
    @prop {string} [x=''left'']\n     * Where to anchor the Y axis (`left` or `right`).
    AKA Y offset origin.\n     * Change this if your popper should grow in a direction
    different from `right`\n     */\n    y: ''right'',\n  },\n\n  /**\n   * Applies
    the computed styles to the popper element.\n   *\n   * All the DOM manipulations
    are limited to this modifier. This is useful in case\n   * you want to integrate
    Popper.js inside a framework or view library and you\n   * want to delegate all
    the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier,
    you must make sure the popper element\n   * has its position set to `absolute`
    before Popper.js can do its work!\n   *\n   * Just disable this modifier and define
    your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   *
    @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used
    to define the order of execution */\n    order: 900,\n    /** @prop {Boolean}
    enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /**
    @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad:
    applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property
    moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     *
    If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise,
    it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined,\n  },\n};\n\n/**\n
    * The `dataObject` is an object containing all the information used by Popper.js.\n
    * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n
    * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n
    * @property {String} data.placement Placement applied to popper\n * @property
    {String} data.originalPlacement Placement originally defined on init\n * @property
    {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property
    {Boolean} data.hide True if the reference element is out of boundaries, useful
    to know when to hide the popper\n * @property {HTMLElement} data.arrowElement
    Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS
    property defined here will be applied to the popper. It expects the JavaScript
    nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any
    CSS property defined here will be applied to the popper arrow. It expects the
    JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries
    Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements
    of popper, reference and arrow elements\n * @property {Object} data.offsets.popper
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference
    `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow]
    `top` and `left` offsets, only one of them will be different from 0\n */\n","/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by `update` method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function shift(data) {\n  const placement = data.placement;\n  const basePlacement
    = placement.split(''-'')[0];\n  const shiftvariation = placement.split(''-'')[1];\n\n  //
    if shift shiftvariation is specified, run the modifier\n  if (shiftvariation)
    {\n    const { reference, popper } = data.offsets;\n    const isVertical = [''bottom'',
    ''top''].indexOf(basePlacement) !== -1;\n    const side = isVertical ? ''left''
    : ''top'';\n    const measurement = isVertical ? ''width'' : ''height'';\n\n    const
    shiftOffsets = {\n      start: { [side]: reference[side] },\n      end: {\n        [side]:
    reference[side] + reference[measurement] - popper[measurement],\n      },\n    };\n\n    data.offsets.popper
    = { ...popper, ...shiftOffsets[shiftvariation] };\n  }\n\n  return data;\n}\n","import
    getOffsetParent from ''../utils/getOffsetParent'';\nimport getBoundaries from
    ''../utils/getBoundaries'';\nimport getSupportedPropertyName from ''../utils/getSupportedPropertyName'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by `update` method\n * @argument {Object} options - Modifiers configuration
    and options\n * @returns {Object} The data object, properly modified\n */\nexport
    default function preventOverflow(data, options) {\n  let boundariesElement =\n    options.boundariesElement
    || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference
    element, we really want to\n  // go one step up and use the next offsetParent
    as reference to\n  // avoid to make this modifier completely useless and look
    like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement
    = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  //
    resets the popper''s position so that the document size can be calculated excluding\n  //
    the size of the popper element itself\n  const transformProp = getSupportedPropertyName(''transform'');\n  const
    popperStyles = data.instance.popper.style; // assignment to help minification\n  const
    { top, left, [transformProp]: transform } = popperStyles;\n  popperStyles.top
    = '''';\n  popperStyles.left = '''';\n  popperStyles[transformProp] = '''';\n\n  const
    boundaries = getBoundaries(\n    data.instance.popper,\n    data.instance.reference,\n    options.padding,\n    boundariesElement,\n    data.positionFixed\n  );\n\n  //
    NOTE: DOM access here\n  // restores the original style properties after the offsets
    have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp]
    = transform;\n\n  options.boundaries = boundaries;\n\n  const order = options.priority;\n  let
    popper = data.offsets.popper;\n\n  const check = {\n    primary(placement) {\n      let
    value = popper[placement];\n      if (\n        popper[placement] < boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.max(popper[placement],
    boundaries[placement]);\n      }\n      return { [placement]: value };\n    },\n    secondary(placement)
    {\n      const mainSide = placement === ''right'' ? ''left'' : ''top'';\n      let
    value = popper[mainSide];\n      if (\n        popper[placement] > boundaries[placement]
    &&\n        !options.escapeWithReference\n      ) {\n        value = Math.min(\n          popper[mainSide],\n          boundaries[placement]
    -\n            (placement === ''right'' ? popper.width : popper.height)\n        );\n      }\n      return
    { [mainSide]: value };\n    },\n  };\n\n  order.forEach(placement => {\n    const
    side =\n      [''left'', ''top''].indexOf(placement) !== -1 ? ''primary'' : ''secondary'';\n    popper
    = { ...popper, ...check[side](placement) };\n  });\n\n  data.offsets.popper =
    popper;\n\n  return data;\n}\n","/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by update method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function keepTogether(data)
    {\n  const { popper, reference } = data.offsets;\n  const placement = data.placement.split(''-'')[0];\n  const
    floor = Math.floor;\n  const isVertical = [''top'', ''bottom''].indexOf(placement)
    !== -1;\n  const side = isVertical ? ''right'' : ''bottom'';\n  const opSide =
    isVertical ? ''left'' : ''top'';\n  const measurement = isVertical ? ''width''
    : ''height'';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide]
    =\n      floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide]
    > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return
    data;\n}\n","import getClientRect from ''../utils/getClientRect'';\nimport getOppositePlacement
    from ''../utils/getOppositePlacement'';\n\n/**\n * @function\n * @memberof Modifiers\n
    * @argument {Object} data - The data object generated by `update` method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function inner(data) {\n  const
    placement = data.placement;\n  const basePlacement = placement.split(''-'')[0];\n  const
    { popper, reference } = data.offsets;\n  const isHoriz = [''left'', ''right''].indexOf(basePlacement)
    !== -1;\n\n  const subtractLength = [''top'', ''left''].indexOf(basePlacement)
    === -1;\n\n  popper[isHoriz ? ''left'' : ''top''] =\n    reference[basePlacement]
    -\n    (subtractLength ? popper[isHoriz ? ''width'' : ''height''] : 0);\n\n  data.placement
    = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return
    data;\n}\n","import isModifierRequired from ''../utils/isModifierRequired'';\nimport
    find from ''../utils/find'';\n\n/**\n * @function\n * @memberof Modifiers\n *
    @argument {Object} data - The data object generated by update method\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    data object, properly modified\n */\nexport default function hide(data) {\n  if
    (!isModifierRequired(data.instance.modifiers, ''hide'', ''preventOverflow''))
    {\n    return data;\n  }\n\n  const refRect = data.offsets.reference;\n  const
    bound = find(\n    data.instance.modifiers,\n    modifier => modifier.name ===
    ''preventOverflow''\n  ).boundaries;\n\n  if (\n    refRect.bottom < bound.top
    ||\n    refRect.left > bound.right ||\n    refRect.top > bound.bottom ||\n    refRect.right
    < bound.left\n  ) {\n    // Avoid unnecessary DOM access if visibility hasn''t
    changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide
    = true;\n    data.attributes[''x-out-of-boundaries''] = '''';\n  } else {\n    //
    Avoid unnecessary DOM access if visibility hasn''t changed\n    if (data.hide
    === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes[''x-out-of-boundaries'']
    = false;\n  }\n\n  return data;\n}\n","import setStyles from ''../utils/setStyles'';\nimport
    setAttributes from ''../utils/setAttributes'';\nimport getReferenceOffsets from
    ''../utils/getReferenceOffsets'';\nimport computeAutoPlacement from ''../utils/computeAutoPlacement'';\n\n/**\n
    * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object
    generated by `update` method\n * @argument {Object} data.styles - List of style
    properties - values to apply to popper element\n * @argument {Object} data.attributes
    - List of attribute properties - values to apply to popper element\n * @argument
    {Object} options - Modifiers configuration and options\n * @returns {Object} The
    same data object\n */\nexport default function applyStyle(data) {\n  // any property
    present in `data.styles` will be applied to the popper,\n  // in this way we can
    make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers
    could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper,
    data.styles);\n\n  // any property present in `data.attributes` will be applied
    to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper,
    data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some
    properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement,
    data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute
    before everything else because it could be used\n * to add margins to the popper
    margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n
    * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference
    element used to position the popper\n * @param {HTMLElement} popper - The HTML
    element used as popper\n * @param {Object} options - Popper.js options\n */\nexport
    function applyStyleOnLoad(\n  reference,\n  popper,\n  options,\n  modifierOptions,\n  state\n)
    {\n  // compute reference element offsets\n  const referenceOffsets = getReferenceOffsets(state,
    popper, reference, options.positionFixed);\n\n  // compute auto placement, store
    placement inside the data object,\n  // modifiers will be able to edit `placement`
    if needed\n  // and refer to originalPlacement to know the original value\n  const
    placement = computeAutoPlacement(\n    options.placement,\n    referenceOffsets,\n    popper,\n    reference,\n    options.modifiers.flip.boundariesElement,\n    options.modifiers.flip.padding\n  );\n\n  popper.setAttribute(''x-placement'',
    placement);\n\n  // Apply `position` to popper before anything else because\n  //
    without the position applied we can''t guarantee correct computations\n  setStyles(popper,
    { position: options.positionFixed ? ''fixed'' : ''absolute'' });\n\n  return options;\n}\n"],"names":["functionToCheck","getType","toString","call","element","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","property","nodeName","parentNode","host","document","body","getStyleComputedProperty","overflow","overflowX","overflowY","test","getScrollParent","getParentNode","reference","referenceNode","version","isIE11","documentElement","noOffsetParent","isIE","offsetParent","nextElementSibling","indexOf","getOffsetParent","firstElementChild","node","getRoot","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","isOffsetContainer","element1root","findCommonOffsetParent","side","upperSide","html","scrollingElement","subtract","scrollTop","getScroll","scrollLeft","modifier","top","bottom","left","right","sideA","axis","sideB","parseFloat","styles","Math","parseInt","computedStyle","getSize","offsets","width","height","rect","getBoundingClientRect","result","sizes","getWindowSizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getBordersSize","getClientRect","fixedPosition","isIE10","runIsIE","isHTML","parent","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","includeScroll","excludeScroll","relativeOffset","getOffsetRectRelativeToArbitraryNode","innerWidth","innerHeight","offset","isFixed","parentElement","el","boundaries","getFixedPositionOffsetParent","getReferenceNode","boundariesElement","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","popper","padding","isPaddingNumber","placement","getBoundaries","rects","refRect","sortedAreas","Object","keys","map","getArea","sort","b","area","a","filteredAreas","filter","computedPlacement","length","key","variation","split","commonOffsetParent","x","marginBottom","y","marginRight","hash","replace","popperRect","getOuterSizes","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","referenceOffsets","getOppositePlacement","Array","prototype","find","arr","findIndex","cur","match","obj","modifiersToRun","ends","modifiers","slice","forEach","warn","fn","enabled","isFunction","data","state","isDestroyed","getReferenceOffsets","options","positionFixed","computeAutoPlacement","flip","originalPlacement","getPopperOffsets","position","runModifiers","isCreated","onUpdate","onCreate","some","name","prefixes","upperProp","charAt","toUpperCase","i","prefix","toCheck","style","isModifierEnabled","removeAttribute","willChange","getSupportedPropertyName","disableEventListeners","removeOnDestroy","removeChild","isBody","target","addEventListener","passive","push","updateBound","scrollElement","scrollParents","eventsEnabled","setupEventListeners","scheduleUpdate","removeEventListener","removeEventListeners","n","isNaN","isFinite","unit","isNumeric","value","attributes","setAttribute","round","noRound","referenceWidth","popperWidth","isVertical","isVariation","horizontalToInteger","verticalToInteger","bothOddWidth","requesting","isRequired","requested","counter","index","validPlacements","concat","reverse","str","size","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","mergeWithPrevious","op","reduce","toValue","index2","basePlacement","parseOffset","min","floor","max","navigator","longerTimeoutBrowsers","isBrowser","userAgent","supportsMicroTasks","Promise","called","resolve","then","scheduled","MSInputMethodContext","documentMode","isFirefox","placements","BEHAVIORS","Popper","requestAnimationFrame","update","debounce","bind","Defaults","jquery","modifierOptions","onLoad","enableEventListeners","destroy","Utils","global","PopperUtils","shiftvariation","shiftOffsets","instance","transformProp","popperStyles","transform","priority","check","escapeWithReference","opSide","isModifierRequired","arrowElement","querySelector","len","sideCapitalized","toLowerCase","altSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","arrow","flipped","placementOpposite","flipOrder","behavior","FLIP","CLOCKWISE","clockwise","COUNTERCLOCKWISE","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariationByRef","flipVariations","flippedVariationByContent","flipVariationsByContent","flippedVariation","getOppositeVariation","subtractLength","bound","hide","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","getRoundedOffsets","devicePixelRatio","prefixedProperty","invertTop","invertLeft","arrowStyles"],"mappings":"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"}'
  admin-Public-Admin-plugins-sparklines-sparkline.js: "(function (root, factory) {\r\n
    \ if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as
    an anonymous module.\r\n    define(factory);\r\n  } else if (typeof exports ===
    'object') {\r\n    // Node. Does not work with strict CommonJS, but\r\n    //
    only CommonJS-like enviroments that support module.exports,\r\n    // like Node.\r\n
    \   module.exports = factory();\r\n  } else {\r\n    // Browser globals (root
    is window)\r\n    root.Sparkline = factory();\r\n  }\r\n}(window, function ()
    {\r\n  function extend(specific, general) {\r\n    var obj = {};\r\n    for (var
    key in general) {\r\n      obj[key] = key in specific ? specific[key] : general[key];\r\n
    \   }\r\n    return obj;\r\n  }\r\n\r\n  function Sparkline(element, options)
    {\r\n    this.element = element;\r\n    this.options = extend(options || {}, Sparkline.options);\r\n\r\n
    \   init: {\r\n      this.element.innerHTML = \"<canvas></canvas>\";\r\n      this.canvas
    = this.element.firstChild;\r\n      this.context = this.canvas.getContext(\"2d\");\r\n
    \     this.ratio = window.devicePixelRatio || 1;\r\n\r\n      if (this.options.tooltip)
    {\r\n        this.canvas.style.position = \"relative\";\r\n        this.canvas.onmousemove
    = showTooltip.bind(this);\r\n      }\r\n    }\r\n  }\r\n\r\n  Sparkline.options
    = {\r\n    width: 100,\r\n    height: null,\r\n    lineColor: \"black\",\r\n    lineWidth:
    1.5,\r\n    startColor: \"transparent\",\r\n    endColor: \"black\",\r\n    maxColor:
    \"transparent\",\r\n    minColor: \"transparent\",\r\n    minValue: null,\r\n
    \   maxValue: null,\r\n    minMaxValue: null,\r\n    maxMinValue: null,\r\n    dotRadius:
    2.5,\r\n    tooltip: null,\r\n    fillBelow: true,\r\n    fillLighten: 0.5,\r\n
    \   startLine: false,\r\n    endLine: false,\r\n    minLine: false,\r\n    maxLine:
    false,\r\n    bottomLine: false,\r\n    topLine: false,\r\n    averageLine: false\r\n
    \ };\r\n\r\n  Sparkline.init = function (element, options) {\r\n    return new
    Sparkline(element, options);\r\n  };\r\n\r\n  Sparkline.draw = function (element,
    points, options) {\r\n    var sparkline = new Sparkline(element, options);\r\n
    \   sparkline.draw(points);\r\n    return sparkline;\r\n  }\r\n\r\n  function
    getY(minValue, maxValue, offsetY, height, index) {\r\n    var range = maxValue
    - minValue;\r\n    if (range == 0) {\r\n      return offsetY + height / 2;\r\n
    \   } else {\r\n      return (offsetY + height) - ((this[index] - minValue) /
    range) * height;\r\n    }\r\n  }\r\n\r\n  function drawDot(radius, x1, x2, color,
    line, x, y) {\r\n    this.context.beginPath();\r\n    this.context.fillStyle =
    color;\r\n    this.context.arc(x, y, radius, 0, Math.PI * 2, false);\r\n    this.context.fill();\r\n
    \   drawLine.call(this, x1, x2, line, x, y);\r\n  }\r\n\r\n  function drawLine(x1,
    x2, style, x, y){\r\n    if(!style) return;\r\n\r\n    this.context.save();\r\n
    \   this.context.strokeStyle = style.color || 'black';\r\n    this.context.lineWidth
    = (style.width || 1) * this.ratio;\r\n    this.context.globalAlpha = style.alpha
    || 1;\r\n    this.context.beginPath();\r\n    this.context.moveTo(style.direction
    != 'right' ? x1 : x, y);\r\n    this.context.lineTo(style.direction != 'left'
    ? x2 : x, y);\r\n    this.context.stroke();\r\n    this.context.restore();\r\n
    \ }\r\n\r\n  function showTooltip(e) {\r\n    var x = e.offsetX || e.layerX ||
    0;\r\n    var delta = ((this.options.width - this.options.dotRadius * 2) / (this.points.length
    - 1));\r\n    var index = minmax(0, Math.round((x - this.options.dotRadius) /
    delta), this.points.length - 1);\r\n\r\n    this.canvas.title = this.options.tooltip(this.points[index],
    index, this.points);\r\n  }\r\n\r\n  Sparkline.prototype.draw = function (points)
    {\r\n\r\n    points = points || [];\r\n    this.points = points;\r\n\r\n    this.canvas.width
    = this.options.width * this.ratio;\r\n    this.canvas.style.width = this.options.width
    + 'px';\r\n\r\n    var pxHeight = this.options.height || this.element.offsetHeight;\r\n
    \   this.canvas.height = pxHeight * this.ratio;\r\n    this.canvas.style.height
    = pxHeight + 'px';\r\n\r\n    var lineWidth = this.options.lineWidth * this.ratio;\r\n
    \   var offsetX = Math.max(this.options.dotRadius * this.ratio, lineWidth/2);\r\n
    \   var offsetY = Math.max(this.options.dotRadius * this.ratio, lineWidth/2);\r\n
    \   var width = this.canvas.width - offsetX * 2;\r\n    var height = this.canvas.height
    - offsetY * 2;\r\n\r\n    var minValue = Math.min.apply(Math, points);\r\n    var
    maxValue = Math.max.apply(Math, points);\r\n    var bottomValue = this.options.minValue
    != undefined ? this.options.minValue : Math.min(minValue, this.options.maxMinValue
    != undefined ? this.options.maxMinValue : minValue);\r\n    var topValue = this.options.maxValue
    != undefined ? this.options.maxValue : Math.max(maxValue, this.options.minMaxValue
    != undefined ? this.options.minMaxValue : maxValue);\r\n    var minX = offsetX;\r\n
    \   var maxX = offsetX;\r\n\r\n    var x = offsetX;\r\n    var y = getY.bind(points,
    bottomValue, topValue, offsetY, height);\r\n    var delta = width / (points.length
    - 1);\r\n\r\n    var dot = drawDot.bind(this, this.options.dotRadius * this.ratio,
    offsetX, width + offsetX);\r\n    var line = drawLine.bind(this, offsetX, width
    + offsetX);\r\n\r\n    this.context.save();\r\n\r\n    this.context.strokeStyle
    = this.options.lineColor;\r\n    this.context.fillStyle = this.options.lineColor;\r\n
    \   this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = 'round';\r\n
    \   this.context.lineJoin = 'round';\r\n\r\n    if(this.options.fillBelow && points.length
    > 1){\r\n      this.context.save();\r\n      this.context.beginPath();\r\n      this.context.moveTo(x,
    y(0));\r\n      for (var i = 1; i < points.length; i++) {\r\n        x += delta;\r\n\r\n
    \       minX = points[i] == minValue ? x : minX;\r\n        maxX = points[i] ==
    maxValue ? x : maxX;\r\n\r\n        this.context.lineTo(x, y(i));\r\n      }\r\n
    \     this.context.lineTo(width+offsetX, height + offsetY + lineWidth/2);\r\n
    \     this.context.lineTo(offsetX, height + offsetY + lineWidth/2);\r\n      this.context.fill();\r\n
    \     if(this.options.fillLighten > 0){\r\n        this.context.fillStyle = 'white';\r\n
    \       this.context.globalAlpha = this.options.fillLighten;\r\n        this.context.fill();\r\n
    \       this.context.globalAlpha = 1;\r\n      }else if(this.options.fillLighten
    < 0){\r\n        this.context.fillStyle = 'black';\r\n        this.context.globalAlpha
    = -this.options.fillLighten;\r\n        this.context.fill();\r\n      }\r\n      this.context.restore();\r\n
    \   }\r\n\r\n    x = offsetX;\r\n    this.context.beginPath();\r\n    this.context.moveTo(x,
    y(0));\r\n    for (var i = 1; i < points.length; i++) {\r\n      x += delta;\r\n
    \     this.context.lineTo(x, y(i));\r\n    }\r\n    this.context.stroke();\r\n\r\n
    \   this.context.restore();\r\n\r\n    line(this.options.bottomLine, 0, offsetY);\r\n
    \   line(this.options.topLine, 0, height + offsetY+lineWidth/2);\r\n\r\n    dot(this.options.startColor,
    this.options.startLine, offsetX + (points.length == 1 ? width / 2 : 0), y(0));\r\n
    \   dot(this.options.endColor, this.options.endLine, offsetX + (points.length
    == 1 ? width / 2 : width), y(points.length-1));\r\n    dot(this.options.minColor,
    this.options.minLine, minX + (points.length == 1 ? width / 2 : 0), y(points.indexOf(minValue)));\r\n
    \   dot(this.options.maxColor, this.options.maxLine, maxX + (points.length ==
    1 ? width / 2 : 0), y(points.indexOf(maxValue)));\r\n\r\n    //line(this.options.averageLine,
    )\r\n  }\r\n\r\n  function minmax(a, b, c) {\r\n    return Math.max(a, Math.min(b,
    c));\r\n  }\r\n\r\n  return Sparkline;\r\n}));\r\n"
  admin-Public-Admin-plugins-sparklines-sparkline.mjs: |
    export default class Sparkline {
      constructor(element, options = {}) {
        this.element = element;
        this.options = { ...Sparkline.options, ...options };

        init: {
          this.element.innerHTML = "<canvas></canvas>";
          this.canvas = this.element.firstChild;
          this.context = this.canvas.getContext("2d");
          this.ratio = window.devicePixelRatio || 1;

          if (this.options.tooltip) {
            this.canvas.style.position = "relative";
            this.canvas.addEventListener('mousemove', e => {
              const x = e.offsetX || e.layerX || 0;
              const delta = ((this.options.width - this.options.dotRadius * 2) / (this._points.length - 1));
              const index = minmax(0, Math.round((x - this.options.dotRadius) / delta), this._points.length - 1);

              this.canvas.title = this.options.tooltip(this._points[index], index, this._points);
            }, false);
          }
        }
      }

      set points(points) {
        this.draw(points);
      }

      get points() {
        return this._points;
      }

      draw(points = []) {
        this._points = points;

        this.canvas.width = this.options.width * this.ratio;
        this.canvas.style.width = `${this.options.width}px`;

        const pxHeight = this.options.height || this.element.offsetHeight;
        this.canvas.height = pxHeight * this.ratio;
        this.canvas.style.height = `${pxHeight}px`;

        const lineWidth = this.options.lineWidth * this.ratio;
        const offsetX = Math.max(this.options.dotRadius * this.ratio, lineWidth / 2);
        const offsetY = Math.max(this.options.dotRadius * this.ratio, lineWidth / 2);
        const width = this.canvas.width - offsetX * 2;
        const height = this.canvas.height - offsetY * 2;

        const minValue = Math.min.apply(Math, points);
        const maxValue = Math.max.apply(Math, points);
        const bottomValue = this.options.minValue != undefined ? this.options.minValue : Math.min(minValue, this.options.maxMinValue != undefined ? this.options.maxMinValue : minValue);
        const topValue = this.options.maxValue != undefined ? this.options.maxValue : Math.max(maxValue, this.options.minMaxValue != undefined ? this.options.minMaxValue : maxValue);
        let minX = offsetX;
        let maxX = offsetX;

        let x = offsetX;
        const y = index => (topValue === bottomValue)
          ? offsetY + height / 2
          : (offsetY + height) - ((points[index] - bottomValue) / (topValue - bottomValue)) * height;
        const delta = width / (points.length - 1);

        const line = (style, x, y) => {
          if (!style) return;

          this.context.save();
          this.context.strokeStyle = style.color || 'black';
          this.context.lineWidth = (style.width || 1) * this.ratio;
          this.context.globalAlpha = style.alpha || 1;
          this.context.beginPath();
          this.context.moveTo(style.direction != 'right' ? offsetX : x, y);
          this.context.lineTo(style.direction != 'left' ? width + offsetX : x, y);
          this.context.stroke();
          this.context.restore();
        }

        const dot = (color, lineStyle, x, y) => {
          this.context.beginPath();
          this.context.fillStyle = color;
          this.context.arc(x, y, this.options.dotRadius * this.ratio, 0, Math.PI * 2, false);
          this.context.fill();
          line(lineStyle, x, y);
        }

        this.context.save();

        this.context.strokeStyle = this.options.lineColor;
        this.context.fillStyle = this.options.lineColor;
        this.context.lineWidth = lineWidth;
        this.context.lineCap = 'round';
        this.context.lineJoin = 'round';

        if (this.options.fillBelow && points.length > 1) {
          this.context.save();
          this.context.beginPath();
          this.context.moveTo(x, y(0));
          for (let i = 1; i < points.length; i++) {
            x += delta;

            minX = points[i] == minValue ? x : minX;
            maxX = points[i] == maxValue ? x : maxX;

            this.context.lineTo(x, y(i));
          }
          this.context.lineTo(width + offsetX, height + offsetY + lineWidth / 2);
          this.context.lineTo(offsetX, height + offsetY + lineWidth / 2);
          this.context.fill();
          if (this.options.fillLighten > 0) {
            this.context.fillStyle = 'white';
            this.context.globalAlpha = this.options.fillLighten;
            this.context.fill();
            this.context.globalAlpha = 1;
          } else if (this.options.fillLighten < 0) {
            this.context.fillStyle = 'black';
            this.context.globalAlpha = -this.options.fillLighten;
            this.context.fill();
          }
          this.context.restore();
        }

        x = offsetX;
        this.context.beginPath();
        this.context.moveTo(x, y(0));
        for (let i = 1; i < points.length; i++) {
          x += delta;
          this.context.lineTo(x, y(i));
        }
        this.context.stroke();

        this.context.restore();

        line(this.options.bottomLine, 0, offsetY);
        line(this.options.topLine, 0, height + offsetY + lineWidth / 2);

        dot(this.options.startColor, this.options.startLine, offsetX + (points.length == 1 ? width / 2 : 0), y(0));
        dot(this.options.endColor, this.options.endLine, offsetX + (points.length == 1 ? width / 2 : width), y(points.length - 1));
        dot(this.options.minColor, this.options.minLine, minX + (points.length == 1 ? width / 2 : 0), y(points.indexOf(minValue)));
        dot(this.options.maxColor, this.options.maxLine, maxX + (points.length == 1 ? width / 2 : 0), y(points.indexOf(maxValue)));
      }

      static init(element, options) {
        return new Sparkline(element, options);
      }

      static draw(element, points, options) {
        const sparkline = new Sparkline(element, options);
        sparkline.draw(points);
        return sparkline;
      }
    }

    Sparkline.options = {
      width: 100,
      height: null,
      lineColor: "black",
      lineWidth: 1.5,
      startColor: "transparent",
      endColor: "black",
      maxColor: "transparent",
      minColor: "transparent",
      minValue: null,
      maxValue: null,
      minMaxValue: null,
      maxMinValue: null,
      dotRadius: 2.5,
      tooltip: null,
      fillBelow: true,
      fillLighten: 0.5,
      startLine: false,
      endLine: false,
      minLine: false,
      maxLine: false,
      bottomLine: false,
      topLine: false,
      averageLine: false
    };

    function minmax(a, b, c) {
      return Math.max(a, Math.min(b, c));
    }
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: php-code-content-7
