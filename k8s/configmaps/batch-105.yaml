apiVersion: v1
data:
  uploads-admin-Public-Admin-plugins-codemirror-mode-clojure-clojure.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports === "object" && typeof module === "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define === "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("clojure", function (options) {
      var atoms = ["false", "nil", "true"];
      var specialForms = [".", "catch", "def", "do", "if", "monitor-enter",
          "monitor-exit", "new", "quote", "recur", "set!", "throw", "try", "var"];
      var coreSymbols = ["*", "*'", "*1", "*2", "*3", "*agent*",
          "*allow-unresolved-vars*", "*assert*", "*clojure-version*",
          "*command-line-args*", "*compile-files*", "*compile-path*",
          "*compiler-options*", "*data-readers*", "*default-data-reader-fn*", "*e",
          "*err*", "*file*", "*flush-on-newline*", "*fn-loader*", "*in*",
          "*math-context*", "*ns*", "*out*", "*print-dup*", "*print-length*",
          "*print-level*", "*print-meta*", "*print-namespace-maps*",
          "*print-readably*", "*read-eval*", "*reader-resolver*", "*source-path*",
          "*suppress-read*", "*unchecked-math*", "*use-context-classloader*",
          "*verbose-defrecords*", "*warn-on-reflection*", "+", "+'", "-", "-'",
          "->", "->>", "->ArrayChunk", "->Eduction", "->Vec", "->VecNode",
          "->VecSeq", "-cache-protocol-fn", "-reset-methods", "..", "/", "<", "<=",
          "=", "==", ">", ">=", "EMPTY-NODE", "Inst", "StackTraceElement->vec",
          "Throwable->map", "accessor", "aclone", "add-classpath", "add-watch",
          "agent", "agent-error", "agent-errors", "aget", "alength", "alias",
          "all-ns", "alter", "alter-meta!", "alter-var-root", "amap", "ancestors",
          "and", "any?", "apply", "areduce", "array-map", "as->", "aset",
          "aset-boolean", "aset-byte", "aset-char", "aset-double", "aset-float",
          "aset-int", "aset-long", "aset-short", "assert", "assoc", "assoc!",
          "assoc-in", "associative?", "atom", "await", "await-for", "await1",
          "bases", "bean", "bigdec", "bigint", "biginteger", "binding", "bit-and",
          "bit-and-not", "bit-clear", "bit-flip", "bit-not", "bit-or", "bit-set",
          "bit-shift-left", "bit-shift-right", "bit-test", "bit-xor", "boolean",
          "boolean-array", "boolean?", "booleans", "bound-fn", "bound-fn*",
          "bound?", "bounded-count", "butlast", "byte", "byte-array", "bytes",
          "bytes?", "case", "cast", "cat", "char", "char-array",
          "char-escape-string", "char-name-string", "char?", "chars", "chunk",
          "chunk-append", "chunk-buffer", "chunk-cons", "chunk-first", "chunk-next",
          "chunk-rest", "chunked-seq?", "class", "class?", "clear-agent-errors",
          "clojure-version", "coll?", "comment", "commute", "comp", "comparator",
          "compare", "compare-and-set!", "compile", "complement", "completing",
          "concat", "cond", "cond->", "cond->>", "condp", "conj", "conj!", "cons",
          "constantly", "construct-proxy", "contains?", "count", "counted?",
          "create-ns", "create-struct", "cycle", "dec", "dec'", "decimal?",
          "declare", "dedupe", "default-data-readers", "definline", "definterface",
          "defmacro", "defmethod", "defmulti", "defn", "defn-", "defonce",
          "defprotocol", "defrecord", "defstruct", "deftype", "delay", "delay?",
          "deliver", "denominator", "deref", "derive", "descendants", "destructure",
          "disj", "disj!", "dissoc", "dissoc!", "distinct", "distinct?", "doall",
          "dorun", "doseq", "dosync", "dotimes", "doto", "double", "double-array",
          "double?", "doubles", "drop", "drop-last", "drop-while", "eduction",
          "empty", "empty?", "ensure", "ensure-reduced", "enumeration-seq",
          "error-handler", "error-mode", "eval", "even?", "every-pred", "every?",
          "ex-data", "ex-info", "extend", "extend-protocol", "extend-type",
          "extenders", "extends?", "false?", "ffirst", "file-seq", "filter",
          "filterv", "find", "find-keyword", "find-ns", "find-protocol-impl",
          "find-protocol-method", "find-var", "first", "flatten", "float",
          "float-array", "float?", "floats", "flush", "fn", "fn?", "fnext", "fnil",
          "for", "force", "format", "frequencies", "future", "future-call",
          "future-cancel", "future-cancelled?", "future-done?", "future?",
          "gen-class", "gen-interface", "gensym", "get", "get-in", "get-method",
          "get-proxy-class", "get-thread-bindings", "get-validator", "group-by",
          "halt-when", "hash", "hash-combine", "hash-map", "hash-ordered-coll",
          "hash-set", "hash-unordered-coll", "ident?", "identical?", "identity",
          "if-let", "if-not", "if-some", "ifn?", "import", "in-ns", "inc", "inc'",
          "indexed?", "init-proxy", "inst-ms", "inst-ms*", "inst?", "instance?",
          "int", "int-array", "int?", "integer?", "interleave", "intern",
          "interpose", "into", "into-array", "ints", "io!", "isa?", "iterate",
          "iterator-seq", "juxt", "keep", "keep-indexed", "key", "keys", "keyword",
          "keyword?", "last", "lazy-cat", "lazy-seq", "let", "letfn", "line-seq",
          "list", "list*", "list?", "load", "load-file", "load-reader",
          "load-string", "loaded-libs", "locking", "long", "long-array", "longs",
          "loop", "macroexpand", "macroexpand-1", "make-array", "make-hierarchy",
          "map", "map-entry?", "map-indexed", "map?", "mapcat", "mapv", "max",
          "max-key", "memfn", "memoize", "merge", "merge-with", "meta",
          "method-sig", "methods", "min", "min-key", "mix-collection-hash", "mod",
          "munge", "name", "namespace", "namespace-munge", "nat-int?", "neg-int?",
          "neg?", "newline", "next", "nfirst", "nil?", "nnext", "not", "not-any?",
          "not-empty", "not-every?", "not=", "ns", "ns-aliases", "ns-imports",
          "ns-interns", "ns-map", "ns-name", "ns-publics", "ns-refers",
          "ns-resolve", "ns-unalias", "ns-unmap", "nth", "nthnext", "nthrest",
          "num", "number?", "numerator", "object-array", "odd?", "or", "parents",
          "partial", "partition", "partition-all", "partition-by", "pcalls", "peek",
          "persistent!", "pmap", "pop", "pop!", "pop-thread-bindings", "pos-int?",
          "pos?", "pr", "pr-str", "prefer-method", "prefers",
          "primitives-classnames", "print", "print-ctor", "print-dup",
          "print-method", "print-simple", "print-str", "printf", "println",
          "println-str", "prn", "prn-str", "promise", "proxy",
          "proxy-call-with-super", "proxy-mappings", "proxy-name", "proxy-super",
          "push-thread-bindings", "pvalues", "qualified-ident?",
          "qualified-keyword?", "qualified-symbol?", "quot", "rand", "rand-int",
          "rand-nth", "random-sample", "range", "ratio?", "rational?",
          "rationalize", "re-find", "re-groups", "re-matcher", "re-matches",
          "re-pattern", "re-seq", "read", "read-line", "read-string",
          "reader-conditional", "reader-conditional?", "realized?", "record?",
          "reduce", "reduce-kv", "reduced", "reduced?", "reductions", "ref",
          "ref-history-count", "ref-max-history", "ref-min-history", "ref-set",
          "refer", "refer-clojure", "reify", "release-pending-sends", "rem",
          "remove", "remove-all-methods", "remove-method", "remove-ns",
          "remove-watch", "repeat", "repeatedly", "replace", "replicate", "require",
          "reset!", "reset-meta!", "reset-vals!", "resolve", "rest",
          "restart-agent", "resultset-seq", "reverse", "reversible?", "rseq",
          "rsubseq", "run!", "satisfies?", "second", "select-keys", "send",
          "send-off", "send-via", "seq", "seq?", "seqable?", "seque", "sequence",
          "sequential?", "set", "set-agent-send-executor!",
          "set-agent-send-off-executor!", "set-error-handler!", "set-error-mode!",
          "set-validator!", "set?", "short", "short-array", "shorts", "shuffle",
          "shutdown-agents", "simple-ident?", "simple-keyword?", "simple-symbol?",
          "slurp", "some", "some->", "some->>", "some-fn", "some?", "sort",
          "sort-by", "sorted-map", "sorted-map-by", "sorted-set", "sorted-set-by",
          "sorted?", "special-symbol?", "spit", "split-at", "split-with", "str",
          "string?", "struct", "struct-map", "subs", "subseq", "subvec", "supers",
          "swap!", "swap-vals!", "symbol", "symbol?", "sync", "tagged-literal",
          "tagged-literal?", "take", "take-last", "take-nth", "take-while", "test",
          "the-ns", "thread-bound?", "time", "to-array", "to-array-2d",
          "trampoline", "transduce", "transient", "tree-seq", "true?", "type",
          "unchecked-add", "unchecked-add-int", "unchecked-byte", "unchecked-char",
          "unchecked-dec", "unchecked-dec-int", "unchecked-divide-int",
          "unchecked-double", "unchecked-float", "unchecked-inc",
          "unchecked-inc-int", "unchecked-int", "unchecked-long",
          "unchecked-multiply", "unchecked-multiply-int", "unchecked-negate",
          "unchecked-negate-int", "unchecked-remainder-int", "unchecked-short",
          "unchecked-subtract", "unchecked-subtract-int", "underive", "unquote",
          "unquote-splicing", "unreduced", "unsigned-bit-shift-right", "update",
          "update-in", "update-proxy", "uri?", "use", "uuid?", "val", "vals",
          "var-get", "var-set", "var?", "vary-meta", "vec", "vector", "vector-of",
          "vector?", "volatile!", "volatile?", "vreset!", "vswap!", "when",
          "when-first", "when-let", "when-not", "when-some", "while",
          "with-bindings", "with-bindings*", "with-in-str", "with-loading-context",
          "with-local-vars", "with-meta", "with-open", "with-out-str",
          "with-precision", "with-redefs", "with-redefs-fn", "xml-seq", "zero?",
          "zipmap"];
      var haveBodyParameter = [
          "->", "->>", "as->", "binding", "bound-fn", "case", "catch", "comment",
          "cond", "cond->", "cond->>", "condp", "def", "definterface", "defmethod",
          "defn", "defmacro", "defprotocol", "defrecord", "defstruct", "deftype",
          "do", "doseq", "dotimes", "doto", "extend", "extend-protocol",
          "extend-type", "fn", "for", "future", "if", "if-let", "if-not", "if-some",
          "let", "letfn", "locking", "loop", "ns", "proxy", "reify", "struct-map",
          "some->", "some->>", "try", "when", "when-first", "when-let", "when-not",
          "when-some", "while", "with-bindings", "with-bindings*", "with-in-str",
          "with-loading-context", "with-local-vars", "with-meta", "with-open",
          "with-out-str", "with-precision", "with-redefs", "with-redefs-fn"];

      CodeMirror.registerHelper("hintWords", "clojure",
        [].concat(atoms, specialForms, coreSymbols));

      var atom = createLookupMap(atoms);
      var specialForm = createLookupMap(specialForms);
      var coreSymbol = createLookupMap(coreSymbols);
      var hasBodyParameter = createLookupMap(haveBodyParameter);
      var delimiter = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/;
      var numberLiteral = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/;
      var characterLiteral = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/;

      // simple-namespace := /^[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*/
      // simple-symbol    := /^(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)/
      // qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>
      var qualifiedSymbol = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;

      function base(stream, state) {
        if (stream.eatSpace() || stream.eat(",")) return ["space", null];
        if (stream.match(numberLiteral)) return [null, "number"];
        if (stream.match(characterLiteral)) return [null, "string-2"];
        if (stream.eat(/^"/)) return (state.tokenize = inString)(stream, state);
        if (stream.eat(/^[(\[{]/)) return ["open", "bracket"];
        if (stream.eat(/^[)\]}]/)) return ["close", "bracket"];
        if (stream.eat(/^;/)) {stream.skipToEnd(); return ["space", "comment"];}
        if (stream.eat(/^[#'@^`~]/)) return [null, "meta"];

        var matches = stream.match(qualifiedSymbol);
        var symbol = matches && matches[0];

        if (!symbol) {
          // advance stream by at least one character so we don't get stuck.
          stream.next();
          stream.eatWhile(function (c) {return !is(c, delimiter);});
          return [null, "error"];
        }

        if (symbol === "comment" && state.lastToken === "(")
          return (state.tokenize = inComment)(stream, state);
        if (is(symbol, atom) || symbol.charAt(0) === ":") return ["symbol", "atom"];
        if (is(symbol, specialForm) || is(symbol, coreSymbol)) return ["symbol", "keyword"];
        if (state.lastToken === "(") return ["symbol", "builtin"]; // other operator

        return ["symbol", "variable"];
      }

      function inString(stream, state) {
        var escaped = false, next;

        while (next = stream.next()) {
          if (next === "\"" && !escaped) {state.tokenize = base; break;}
          escaped = !escaped && next === "\\";
        }

        return [null, "string"];
      }

      function inComment(stream, state) {
        var parenthesisCount = 1;
        var next;

        while (next = stream.next()) {
          if (next === ")") parenthesisCount--;
          if (next === "(") parenthesisCount++;
          if (parenthesisCount === 0) {
            stream.backUp(1);
            state.tokenize = base;
            break;
          }
        }

        return ["space", "comment"];
      }

      function createLookupMap(words) {
        var obj = {};

        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;

        return obj;
      }

      function is(value, test) {
        if (test instanceof RegExp) return test.test(value);
        if (test instanceof Object) return test.propertyIsEnumerable(value);
      }

      return {
        startState: function () {
          return {
            ctx: {prev: null, start: 0, indentTo: 0},
            lastToken: null,
            tokenize: base
          };
        },

        token: function (stream, state) {
          if (stream.sol() && (typeof state.ctx.indentTo !== "number"))
            state.ctx.indentTo = state.ctx.start + 1;

          var typeStylePair = state.tokenize(stream, state);
          var type = typeStylePair[0];
          var style = typeStylePair[1];
          var current = stream.current();

          if (type !== "space") {
            if (state.lastToken === "(" && state.ctx.indentTo === null) {
              if (type === "symbol" && is(current, hasBodyParameter))
                state.ctx.indentTo = state.ctx.start + options.indentUnit;
              else state.ctx.indentTo = "next";
            } else if (state.ctx.indentTo === "next") {
              state.ctx.indentTo = stream.column();
            }

            state.lastToken = current;
          }

          if (type === "open")
            state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
          else if (type === "close") state.ctx = state.ctx.prev || state.ctx;

          return style;
        },

        indent: function (state) {
          var i = state.ctx.indentTo;

          return (typeof i === "number") ?
            i :
            state.ctx.start + 1;
        },

        closeBrackets: {pairs: "()[]{}\"\""},
        lineComment: ";;"
      };
    });

    CodeMirror.defineMIME("text/x-clojure", "clojure");
    CodeMirror.defineMIME("text/x-clojurescript", "clojure");
    CodeMirror.defineMIME("application/edn", "clojure");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-cmake-cmake.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("cmake", function () {
      var variable_regex = /({)?[a-zA-Z0-9_]+(})?/;

      function tokenString(stream, state) {
        var current, prev, found_var = false;
        while (!stream.eol() && (current = stream.next()) != state.pending) {
          if (current === '$' && prev != '\\' && state.pending == '"') {
            found_var = true;
            break;
          }
          prev = current;
        }
        if (found_var) {
          stream.backUp(1);
        }
        if (current == state.pending) {
          state.continueString = false;
        } else {
          state.continueString = true;
        }
        return "string";
      }

      function tokenize(stream, state) {
        var ch = stream.next();

        // Have we found a variable?
        if (ch === '$') {
          if (stream.match(variable_regex)) {
            return 'variable-2';
          }
          return 'variable';
        }
        // Should we still be looking for the end of a string?
        if (state.continueString) {
          // If so, go through the loop again
          stream.backUp(1);
          return tokenString(stream, state);
        }
        // Do we just have a function on our hands?
        // In 'cmake_minimum_required (VERSION 2.8.8)', 'cmake_minimum_required' is matched
        if (stream.match(/(\s+)?\w+\(/) || stream.match(/(\s+)?\w+\ \(/)) {
          stream.backUp(1);
          return 'def';
        }
        if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        }
        // Have we found a string?
        if (ch == "'" || ch == '"') {
          // Store the type (single or double)
          state.pending = ch;
          // Perform the looping function to find the end
          return tokenString(stream, state);
        }
        if (ch == '(' || ch == ')') {
          return 'bracket';
        }
        if (ch.match(/[0-9]/)) {
          return 'number';
        }
        stream.eatWhile(/[\w-]/);
        return null;
      }
      return {
        startState: function () {
          var state = {};
          state.inDefinition = false;
          state.inInclude = false;
          state.continueString = false;
          state.pending = false;
          return state;
        },
        token: function (stream, state) {
          if (stream.eatSpace()) return null;
          return tokenize(stream, state);
        }
      };
    });

    CodeMirror.defineMIME("text/x-cmake", "cmake");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-css-css.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("css", function(config, parserConfig) {
      var inline = parserConfig.inline
      if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

      var indentUnit = config.indentUnit,
          tokenHooks = parserConfig.tokenHooks,
          documentTypes = parserConfig.documentTypes || {},
          mediaTypes = parserConfig.mediaTypes || {},
          mediaFeatures = parserConfig.mediaFeatures || {},
          mediaValueKeywords = parserConfig.mediaValueKeywords || {},
          propertyKeywords = parserConfig.propertyKeywords || {},
          nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
          fontProperties = parserConfig.fontProperties || {},
          counterDescriptors = parserConfig.counterDescriptors || {},
          colorKeywords = parserConfig.colorKeywords || {},
          valueKeywords = parserConfig.valueKeywords || {},
          allowNested = parserConfig.allowNested,
          lineComment = parserConfig.lineComment,
          supportsAtComponent = parserConfig.supportsAtComponent === true,
          highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;

      var type, override;
      function ret(style, tp) { type = tp; return style; }

      // Tokenizers

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (tokenHooks[ch]) {
          var result = tokenHooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == "@") {
          stream.eatWhile(/[\w\\\-]/);
          return ret("def", stream.current());
        } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
          return ret(null, "compare");
        } else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "#") {
          stream.eatWhile(/[\w\\\-]/);
          return ret("atom", "hash");
        } else if (ch == "!") {
          stream.match(/^\s*\w*/);
          return ret("keyword", "important");
        } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (ch === "-") {
          if (/[\d.]/.test(stream.peek())) {
            stream.eatWhile(/[\w.%]/);
            return ret("number", "unit");
          } else if (stream.match(/^-[\w\\\-]*/)) {
            stream.eatWhile(/[\w\\\-]/);
            if (stream.match(/^\s*:/, false))
              return ret("variable-2", "variable-definition");
            return ret("variable-2", "variable");
          } else if (stream.match(/^\w+-/)) {
            return ret("meta", "meta");
          }
        } else if (/[,+>*\/]/.test(ch)) {
          return ret(null, "select-op");
        } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
          return ret("qualifier", "qualifier");
        } else if (/[:;{}\[\]\(\)]/.test(ch)) {
          return ret(null, ch);
        } else if (stream.match(/^[\w-.]+(?=\()/)) {
          if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
            state.tokenize = tokenParenthesized;
          }
          return ret("variable callee", "variable");
        } else if (/[\w\\\-]/.test(ch)) {
          stream.eatWhile(/[\w\\\-]/);
          return ret("property", "word");
        } else {
          return ret(null, null);
        }
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              if (quote == ")") stream.backUp(1);
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          if (ch == quote || !escaped && quote != ")") state.tokenize = null;
          return ret("string", "string");
        };
      }

      function tokenParenthesized(stream, state) {
        stream.next(); // Must be '('
        if (!stream.match(/^\s*[\"\')]/, false))
          state.tokenize = tokenString(")");
        else
          state.tokenize = null;
        return ret(null, "(");
      }

      // Context management

      function Context(type, indent, prev) {
        this.type = type;
        this.indent = indent;
        this.prev = prev;
      }

      function pushContext(state, stream, type, indent) {
        state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
        return type;
      }

      function popContext(state) {
        if (state.context.prev)
          state.context = state.context.prev;
        return state.context.type;
      }

      function pass(type, stream, state) {
        return states[state.context.type](type, stream, state);
      }
      function popAndPass(type, stream, state, n) {
        for (var i = n || 1; i > 0; i--)
          state.context = state.context.prev;
        return pass(type, stream, state);
      }

      // Parser

      function wordAsValue(stream) {
        var word = stream.current().toLowerCase();
        if (valueKeywords.hasOwnProperty(word))
          override = "atom";
        else if (colorKeywords.hasOwnProperty(word))
          override = "keyword";
        else
          override = "variable";
      }

      var states = {};

      states.top = function(type, stream, state) {
        if (type == "{") {
          return pushContext(state, stream, "block");
        } else if (type == "}" && state.context.prev) {
          return popContext(state);
        } else if (supportsAtComponent && /@component/i.test(type)) {
          return pushContext(state, stream, "atComponentBlock");
        } else if (/^@(-moz-)?document$/i.test(type)) {
          return pushContext(state, stream, "documentTypes");
        } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
          return pushContext(state, stream, "atBlock");
        } else if (/^@(font-face|counter-style)/i.test(type)) {
          state.stateArg = type;
          return "restricted_atBlock_before";
        } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
          return "keyframes";
        } else if (type && type.charAt(0) == "@") {
          return pushContext(state, stream, "at");
        } else if (type == "hash") {
          override = "builtin";
        } else if (type == "word") {
          override = "tag";
        } else if (type == "variable-definition") {
          return "maybeprop";
        } else if (type == "interpolation") {
          return pushContext(state, stream, "interpolation");
        } else if (type == ":") {
          return "pseudo";
        } else if (allowNested && type == "(") {
          return pushContext(state, stream, "parens");
        }
        return state.context.type;
      };

      states.block = function(type, stream, state) {
        if (type == "word") {
          var word = stream.current().toLowerCase();
          if (propertyKeywords.hasOwnProperty(word)) {
            override = "property";
            return "maybeprop";
          } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
            override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
            return "maybeprop";
          } else if (allowNested) {
            override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
            return "block";
          } else {
            override += " error";
            return "maybeprop";
          }
        } else if (type == "meta") {
          return "block";
        } else if (!allowNested && (type == "hash" || type == "qualifier")) {
          override = "error";
          return "block";
        } else {
          return states.top(type, stream, state);
        }
      };

      states.maybeprop = function(type, stream, state) {
        if (type == ":") return pushContext(state, stream, "prop");
        return pass(type, stream, state);
      };

      states.prop = function(type, stream, state) {
        if (type == ";") return popContext(state);
        if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
        if (type == "}" || type == "{") return popAndPass(type, stream, state);
        if (type == "(") return pushContext(state, stream, "parens");

        if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
          override += " error";
        } else if (type == "word") {
          wordAsValue(stream);
        } else if (type == "interpolation") {
          return pushContext(state, stream, "interpolation");
        }
        return "prop";
      };

      states.propBlock = function(type, _stream, state) {
        if (type == "}") return popContext(state);
        if (type == "word") { override = "property"; return "maybeprop"; }
        return state.context.type;
      };

      states.parens = function(type, stream, state) {
        if (type == "{" || type == "}") return popAndPass(type, stream, state);
        if (type == ")") return popContext(state);
        if (type == "(") return pushContext(state, stream, "parens");
        if (type == "interpolation") return pushContext(state, stream, "interpolation");
        if (type == "word") wordAsValue(stream);
        return "parens";
      };

      states.pseudo = function(type, stream, state) {
        if (type == "meta") return "pseudo";

        if (type == "word") {
          override = "variable-3";
          return state.context.type;
        }
        return pass(type, stream, state);
      };

      states.documentTypes = function(type, stream, state) {
        if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
          override = "tag";
          return state.context.type;
        } else {
          return states.atBlock(type, stream, state);
        }
      };

      states.atBlock = function(type, stream, state) {
        if (type == "(") return pushContext(state, stream, "atBlock_parens");
        if (type == "}" || type == ";") return popAndPass(type, stream, state);
        if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

        if (type == "interpolation") return pushContext(state, stream, "interpolation");

        if (type == "word") {
          var word = stream.current().toLowerCase();
          if (word == "only" || word == "not" || word == "and" || word == "or")
            override = "keyword";
          else if (mediaTypes.hasOwnProperty(word))
            override = "attribute";
          else if (mediaFeatures.hasOwnProperty(word))
            override = "property";
          else if (mediaValueKeywords.hasOwnProperty(word))
            override = "keyword";
          else if (propertyKeywords.hasOwnProperty(word))
            override = "property";
          else if (nonStandardPropertyKeywords.hasOwnProperty(word))
            override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
          else if (valueKeywords.hasOwnProperty(word))
            override = "atom";
          else if (colorKeywords.hasOwnProperty(word))
            override = "keyword";
          else
            override = "error";
        }
        return state.context.type;
      };

      states.atComponentBlock = function(type, stream, state) {
        if (type == "}")
          return popAndPass(type, stream, state);
        if (type == "{")
          return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
        if (type == "word")
          override = "error";
        return state.context.type;
      };

      states.atBlock_parens = function(type, stream, state) {
        if (type == ")") return popContext(state);
        if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
        return states.atBlock(type, stream, state);
      };

      states.restricted_atBlock_before = function(type, stream, state) {
        if (type == "{")
          return pushContext(state, stream, "restricted_atBlock");
        if (type == "word" && state.stateArg == "@counter-style") {
          override = "variable";
          return "restricted_atBlock_before";
        }
        return pass(type, stream, state);
      };

      states.restricted_atBlock = function(type, stream, state) {
        if (type == "}") {
          state.stateArg = null;
          return popContext(state);
        }
        if (type == "word") {
          if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
              (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
            override = "error";
          else
            override = "property";
          return "maybeprop";
        }
        return "restricted_atBlock";
      };

      states.keyframes = function(type, stream, state) {
        if (type == "word") { override = "variable"; return "keyframes"; }
        if (type == "{") return pushContext(state, stream, "top");
        return pass(type, stream, state);
      };

      states.at = function(type, stream, state) {
        if (type == ";") return popContext(state);
        if (type == "{" || type == "}") return popAndPass(type, stream, state);
        if (type == "word") override = "tag";
        else if (type == "hash") override = "builtin";
        return "at";
      };

      states.interpolation = function(type, stream, state) {
        if (type == "}") return popContext(state);
        if (type == "{" || type == ";") return popAndPass(type, stream, state);
        if (type == "word") override = "variable";
        else if (type != "variable" && type != "(" && type != ")") override = "error";
        return "interpolation";
      };

      return {
        startState: function(base) {
          return {tokenize: null,
                  state: inline ? "block" : "top",
                  stateArg: null,
                  context: new Context(inline ? "block" : "top", base || 0, null)};
        },

        token: function(stream, state) {
          if (!state.tokenize && stream.eatSpace()) return null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style && typeof style == "object") {
            type = style[1];
            style = style[0];
          }
          override = style;
          if (type != "comment")
            state.state = states[state.state](type, stream, state);
          return override;
        },

        indent: function(state, textAfter) {
          var cx = state.context, ch = textAfter && textAfter.charAt(0);
          var indent = cx.indent;
          if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
          if (cx.prev) {
            if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                              cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
              // Resume indentation from parent context.
              cx = cx.prev;
              indent = cx.indent;
            } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
                ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
              // Dedent relative to current context.
              indent = Math.max(0, cx.indent - indentUnit);
            }
          }
          return indent;
        },

        electricChars: "}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        blockCommentContinue: " * ",
        lineComment: lineComment,
        fold: "brace"
      };
    });

      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) {
          keys[array[i].toLowerCase()] = true;
        }
        return keys;
      }

      var documentTypes_ = [
        "domain", "regexp", "url", "url-prefix"
      ], documentTypes = keySet(documentTypes_);

      var mediaTypes_ = [
        "all", "aural", "braille", "handheld", "print", "projection", "screen",
        "tty", "tv", "embossed"
      ], mediaTypes = keySet(mediaTypes_);

      var mediaFeatures_ = [
        "width", "min-width", "max-width", "height", "min-height", "max-height",
        "device-width", "min-device-width", "max-device-width", "device-height",
        "min-device-height", "max-device-height", "aspect-ratio",
        "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
        "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
        "max-color", "color-index", "min-color-index", "max-color-index",
        "monochrome", "min-monochrome", "max-monochrome", "resolution",
        "min-resolution", "max-resolution", "scan", "grid", "orientation",
        "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
        "pointer", "any-pointer", "hover", "any-hover", "prefers-color-scheme"
      ], mediaFeatures = keySet(mediaFeatures_);

      var mediaValueKeywords_ = [
        "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
        "interlace", "progressive",
        "dark", "light"
      ], mediaValueKeywords = keySet(mediaValueKeywords_);

      var propertyKeywords_ = [
        "align-content", "align-items", "align-self", "alignment-adjust",
        "alignment-baseline", "all", "anchor-point", "animation", "animation-delay",
        "animation-direction", "animation-duration", "animation-fill-mode",
        "animation-iteration-count", "animation-name", "animation-play-state",
        "animation-timing-function", "appearance", "azimuth", "backdrop-filter",
        "backface-visibility", "background", "background-attachment",
        "background-blend-mode", "background-clip", "background-color",
        "background-image", "background-origin", "background-position",
        "background-position-x", "background-position-y", "background-repeat",
        "background-size", "baseline-shift", "binding", "bleed", "block-size",
        "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target",
        "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius",
        "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
        "border-collapse", "border-color", "border-image", "border-image-outset",
        "border-image-repeat", "border-image-slice", "border-image-source",
        "border-image-width", "border-left", "border-left-color", "border-left-style",
        "border-left-width", "border-radius", "border-right", "border-right-color",
        "border-right-style", "border-right-width", "border-spacing", "border-style",
        "border-top", "border-top-color", "border-top-left-radius",
        "border-top-right-radius", "border-top-style", "border-top-width",
        "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing",
        "break-after", "break-before", "break-inside", "caption-side", "caret-color",
        "clear", "clip", "color", "color-profile", "column-count", "column-fill",
        "column-gap", "column-rule", "column-rule-color", "column-rule-style",
        "column-rule-width", "column-span", "column-width", "columns", "contain",
        "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after",
        "cue-before", "cursor", "direction", "display", "dominant-baseline",
        "drop-initial-after-adjust", "drop-initial-after-align",
        "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",
        "drop-initial-value", "elevation", "empty-cells", "fit", "fit-content", "fit-position",
        "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow",
        "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into",
        "font", "font-family", "font-feature-settings", "font-kerning",
        "font-language-override", "font-optical-sizing", "font-size",
        "font-size-adjust", "font-stretch", "font-style", "font-synthesis",
        "font-variant", "font-variant-alternates", "font-variant-caps",
        "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric",
        "font-variant-position", "font-variation-settings", "font-weight", "gap",
        "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows",
        "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start",
        "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start",
        "grid-template", "grid-template-areas", "grid-template-columns",
        "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon",
        "image-orientation", "image-rendering", "image-resolution", "inline-box-align",
        "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline",
        "inset-inline-end", "inset-inline-start", "isolation", "justify-content",
        "justify-items", "justify-self", "left", "letter-spacing", "line-break",
        "line-height", "line-height-step", "line-stacking", "line-stacking-ruby",
        "line-stacking-shift", "line-stacking-strategy", "list-style",
        "list-style-image", "list-style-position", "list-style-type", "margin",
        "margin-bottom", "margin-left", "margin-right", "margin-top", "marks",
        "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed",
        "marquee-style", "mask-clip", "mask-composite", "mask-image", "mask-mode",
        "mask-origin", "mask-position", "mask-repeat", "mask-size","mask-type",
        "max-block-size", "max-height", "max-inline-size",
        "max-width", "min-block-size", "min-height", "min-inline-size", "min-width",
        "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right",
        "nav-up", "object-fit", "object-position", "offset", "offset-anchor",
        "offset-distance", "offset-path", "offset-position", "offset-rotate",
        "opacity", "order", "orphans", "outline", "outline-color", "outline-offset",
        "outline-style", "outline-width", "overflow", "overflow-style",
        "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom",
        "padding-left", "padding-right", "padding-top", "page", "page-break-after",
        "page-break-before", "page-break-inside", "page-policy", "pause",
        "pause-after", "pause-before", "perspective", "perspective-origin", "pitch",
        "pitch-range", "place-content", "place-items", "place-self", "play-during",
        "position", "presentation-level", "punctuation-trim", "quotes",
        "region-break-after", "region-break-before", "region-break-inside",
        "region-fragment", "rendering-intent", "resize", "rest", "rest-after",
        "rest-before", "richness", "right", "rotate", "rotation", "rotation-point",
        "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span",
        "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block",
        "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom",
        "scroll-margin-inline", "scroll-margin-inline-end",
        "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right",
        "scroll-margin-top", "scroll-padding", "scroll-padding-block",
        "scroll-padding-block-end", "scroll-padding-block-start",
        "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end",
        "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right",
        "scroll-padding-top", "scroll-snap-align", "scroll-snap-type",
        "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside",
        "size", "speak", "speak-as", "speak-header", "speak-numeral",
        "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size",
        "table-layout", "target", "target-name", "target-new", "target-position",
        "text-align", "text-align-last", "text-combine-upright", "text-decoration",
        "text-decoration-color", "text-decoration-line", "text-decoration-skip",
        "text-decoration-skip-ink", "text-decoration-style", "text-emphasis",
        "text-emphasis-color", "text-emphasis-position", "text-emphasis-style",
        "text-height", "text-indent", "text-justify", "text-orientation",
        "text-outline", "text-overflow", "text-rendering", "text-shadow",
        "text-size-adjust", "text-space-collapse", "text-transform",
        "text-underline-position", "text-wrap", "top", "touch-action", "transform", "transform-origin",
        "transform-style", "transition", "transition-delay", "transition-duration",
        "transition-property", "transition-timing-function", "translate",
        "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance",
        "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate",
        "voice-stress", "voice-volume", "volume", "white-space", "widows", "width",
        "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index",
        // SVG-specific
        "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
        "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
        "color-interpolation", "color-interpolation-filters",
        "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
        "marker", "marker-end", "marker-mid", "marker-start", "paint-order", "shape-rendering", "stroke",
        "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
        "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
        "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
        "glyph-orientation-vertical", "text-anchor", "writing-mode",
      ], propertyKeywords = keySet(propertyKeywords_);

      var nonStandardPropertyKeywords_ = [
        "accent-color", "aspect-ratio", "border-block", "border-block-color", "border-block-end",
        "border-block-end-color", "border-block-end-style", "border-block-end-width",
        "border-block-start", "border-block-start-color", "border-block-start-style",
        "border-block-start-width", "border-block-style", "border-block-width",
        "border-inline", "border-inline-color", "border-inline-end",
        "border-inline-end-color", "border-inline-end-style",
        "border-inline-end-width", "border-inline-start", "border-inline-start-color",
        "border-inline-start-style", "border-inline-start-width",
        "border-inline-style", "border-inline-width", "content-visibility", "margin-block",
        "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end",
        "margin-inline-start", "overflow-anchor", "overscroll-behavior", "padding-block", "padding-block-end",
        "padding-block-start", "padding-inline", "padding-inline-end",
        "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color",
        "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
        "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
        "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration",
        "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"
      ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

      var fontProperties_ = [
        "font-display", "font-family", "src", "unicode-range", "font-variant",
         "font-feature-settings", "font-stretch", "font-weight", "font-style"
      ], fontProperties = keySet(fontProperties_);

      var counterDescriptors_ = [
        "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
        "speak-as", "suffix", "symbols", "system"
      ], counterDescriptors = keySet(counterDescriptors_);

      var colorKeywords_ = [
        "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
        "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
        "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
        "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
        "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen",
        "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
        "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet",
        "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick",
        "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
        "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
        "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
        "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
        "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink",
        "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey",
        "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
        "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
        "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
        "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
        "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
        "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
        "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
        "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
        "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
        "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan",
        "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
        "whitesmoke", "yellow", "yellowgreen"
      ], colorKeywords = keySet(colorKeywords_);

      var valueKeywords_ = [
        "above", "absolute", "activeborder", "additive", "activecaption", "afar",
        "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
        "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
        "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
        "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "binary",
        "bengali", "blink", "block", "block-axis", "blur", "bold", "bolder", "border", "border-box",
        "both", "bottom", "break", "break-all", "break-word", "brightness", "bullets", "button", "button-bevel",
        "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
        "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
        "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
        "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
        "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
        "compact", "condensed", "contain", "content", "contents",
        "content-box", "context-menu", "continuous", "contrast", "copy", "counter", "counters", "cover", "crop",
        "cross", "crosshair", "cubic-bezier", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
        "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
        "destination-in", "destination-out", "destination-over", "devanagari", "difference",
        "disc", "discard", "disclosure-closed", "disclosure-open", "document",
        "dot-dash", "dot-dot-dash",
        "dotted", "double", "down", "drop-shadow", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
        "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
        "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
        "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
        "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
        "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
        "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
        "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
        "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
        "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
        "forwards", "from", "geometricPrecision", "georgian", "grayscale", "graytext", "grid", "groove",
        "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
        "help", "hidden", "hide", "higher", "highlight", "highlighttext",
        "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "hue-rotate", "icon", "ignore",
        "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
        "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
        "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
        "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
        "katakana", "katakana-iroha", "keep-all", "khmer",
        "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
        "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
        "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
        "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
        "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
        "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "manipulation", "match", "matrix", "matrix3d",
        "media-controls-background", "media-current-time-display",
        "media-fullscreen-button", "media-mute-button", "media-play-button",
        "media-return-to-realtime-button", "media-rewind-button",
        "media-seek-back-button", "media-seek-forward-button", "media-slider",
        "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
        "media-volume-slider-container", "media-volume-sliderthumb", "medium",
        "menu", "menulist", "menulist-button", "menulist-text",
        "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
        "mix", "mongolian", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "myanmar", "n-resize",
        "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
        "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
        "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
        "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
        "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
        "painted", "page", "paused", "persian", "perspective", "pinch-zoom", "plus-darker", "plus-lighter",
        "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
        "progress", "push-button", "radial-gradient", "radio", "read-only",
        "read-write", "read-write-plaintext-only", "rectangle", "region",
        "relative", "repeat", "repeating-linear-gradient",
        "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
        "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
        "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
        "s-resize", "sans-serif", "saturate", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
        "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
        "searchfield-cancel-button", "searchfield-decoration",
        "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
        "semi-condensed", "semi-expanded", "separate", "sepia", "serif", "show", "sidama",
        "simp-chinese-formal", "simp-chinese-informal", "single",
        "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
        "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
        "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
        "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
        "square-button", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub",
        "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
        "table-caption", "table-cell", "table-column", "table-column-group",
        "table-footer-group", "table-header-group", "table-row", "table-row-group",
        "tamil",
        "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
        "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
        "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
        "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
        "trad-chinese-formal", "trad-chinese-informal", "transform",
        "translate", "translate3d", "translateX", "translateY", "translateZ",
        "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up",
        "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
        "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
        "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted",
        "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
        "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
        "xx-large", "xx-small"
      ], valueKeywords = keySet(valueKeywords_);

      var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
        .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
        .concat(valueKeywords_);
      CodeMirror.registerHelper("hintWords", "css", allWords);

      function tokenCComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ["comment", "comment"];
      }

      CodeMirror.defineMIME("text/css", {
        documentTypes: documentTypes,
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        mediaValueKeywords: mediaValueKeywords,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        fontProperties: fontProperties,
        counterDescriptors: counterDescriptors,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        tokenHooks: {
          "/": function(stream, state) {
            if (!stream.eat("*")) return false;
            state.tokenize = tokenCComment;
            return tokenCComment(stream, state);
          }
        },
        name: "css"
      });

      CodeMirror.defineMIME("text/x-scss", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        mediaValueKeywords: mediaValueKeywords,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        allowNested: true,
        lineComment: "//",
        tokenHooks: {
          "/": function(stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          ":": function(stream) {
            if (stream.match(/^\s*\{/, false))
              return [null, null]
            return false;
          },
          "$": function(stream) {
            stream.match(/^[\w-]+/);
            if (stream.match(/^\s*:/, false))
              return ["variable-2", "variable-definition"];
            return ["variable-2", "variable"];
          },
          "#": function(stream) {
            if (!stream.eat("{")) return false;
            return [null, "interpolation"];
          }
        },
        name: "css",
        helperType: "scss"
      });

      CodeMirror.defineMIME("text/x-less", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        mediaValueKeywords: mediaValueKeywords,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        allowNested: true,
        lineComment: "//",
        tokenHooks: {
          "/": function(stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          "@": function(stream) {
            if (stream.eat("{")) return [null, "interpolation"];
            if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
            stream.eatWhile(/[\w\\\-]/);
            if (stream.match(/^\s*:/, false))
              return ["variable-2", "variable-definition"];
            return ["variable-2", "variable"];
          },
          "&": function() {
            return ["atom", "atom"];
          }
        },
        name: "css",
        helperType: "less"
      });

      CodeMirror.defineMIME("text/x-gss", {
        documentTypes: documentTypes,
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        fontProperties: fontProperties,
        counterDescriptors: counterDescriptors,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        supportsAtComponent: true,
        tokenHooks: {
          "/": function(stream, state) {
            if (!stream.eat("*")) return false;
            state.tokenize = tokenCComment;
            return tokenCComment(stream, state);
          }
        },
        name: "css",
        helperType: "gss"
      });

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-django-django.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"),
            require("../../addon/mode/overlay"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../htmlmixed/htmlmixed",
                "../../addon/mode/overlay"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("django:inner", function() {
        var keywords = ["block", "endblock", "for", "endfor", "true", "false", "filter", "endfilter",
                        "loop", "none", "self", "super", "if", "elif", "endif", "as", "else", "import",
                        "with", "endwith", "without", "context", "ifequal", "endifequal", "ifnotequal",
                        "endifnotequal", "extends", "include", "load", "comment", "endcomment",
                        "empty", "url", "static", "trans", "blocktrans", "endblocktrans", "now",
                        "regroup", "lorem", "ifchanged", "endifchanged", "firstof", "debug", "cycle",
                        "csrf_token", "autoescape", "endautoescape", "spaceless", "endspaceless",
                        "ssi", "templatetag", "verbatim", "endverbatim", "widthratio"],
            filters = ["add", "addslashes", "capfirst", "center", "cut", "date",
                       "default", "default_if_none", "dictsort",
                       "dictsortreversed", "divisibleby", "escape", "escapejs",
                       "filesizeformat", "first", "floatformat", "force_escape",
                       "get_digit", "iriencode", "join", "last", "length",
                       "length_is", "linebreaks", "linebreaksbr", "linenumbers",
                       "ljust", "lower", "make_list", "phone2numeric", "pluralize",
                       "pprint", "random", "removetags", "rjust", "safe",
                       "safeseq", "slice", "slugify", "stringformat", "striptags",
                       "time", "timesince", "timeuntil", "title", "truncatechars",
                       "truncatechars_html", "truncatewords", "truncatewords_html",
                       "unordered_list", "upper", "urlencode", "urlize",
                       "urlizetrunc", "wordcount", "wordwrap", "yesno"],
            operators = ["==", "!=", "<", ">", "<=", ">="],
            wordOperators = ["in", "not", "or", "and"];

        keywords = new RegExp("^\\b(" + keywords.join("|") + ")\\b");
        filters = new RegExp("^\\b(" + filters.join("|") + ")\\b");
        operators = new RegExp("^\\b(" + operators.join("|") + ")\\b");
        wordOperators = new RegExp("^\\b(" + wordOperators.join("|") + ")\\b");

        // We have to return "null" instead of null, in order to avoid string
        // styling as the default, when using Django templates inside HTML
        // element attributes
        function tokenBase (stream, state) {
          // Attempt to identify a variable, template or comment tag respectively
          if (stream.match("{{")) {
            state.tokenize = inVariable;
            return "tag";
          } else if (stream.match("{%")) {
            state.tokenize = inTag;
            return "tag";
          } else if (stream.match("{#")) {
            state.tokenize = inComment;
            return "comment";
          }

          // Ignore completely any stream series that do not match the
          // Django template opening tags.
          while (stream.next() != null && !stream.match(/\{[{%#]/, false)) {}
          return null;
        }

        // A string can be included in either single or double quotes (this is
        // the delimiter). Mark everything as a string until the start delimiter
        // occurs again.
        function inString (delimiter, previousTokenizer) {
          return function (stream, state) {
            if (!state.escapeNext && stream.eat(delimiter)) {
              state.tokenize = previousTokenizer;
            } else {
              if (state.escapeNext) {
                state.escapeNext = false;
              }

              var ch = stream.next();

              // Take into account the backslash for escaping characters, such as
              // the string delimiter.
              if (ch == "\\") {
                state.escapeNext = true;
              }
            }

            return "string";
          };
        }

        // Apply Django template variable syntax highlighting
        function inVariable (stream, state) {
          // Attempt to match a dot that precedes a property
          if (state.waitDot) {
            state.waitDot = false;

            if (stream.peek() != ".") {
              return "null";
            }

            // Dot followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat(".")) {
              state.waitProperty = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for property.");
            }
          }

          // Attempt to match a pipe that precedes a filter
          if (state.waitPipe) {
            state.waitPipe = false;

            if (stream.peek() != "|") {
              return "null";
            }

            // Pipe followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat("|")) {
              state.waitFilter = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for filter.");
            }
          }

          // Highlight properties
          if (state.waitProperty) {
            state.waitProperty = false;
            if (stream.match(/\b(\w+)\b/)) {
              state.waitDot = true;  // A property can be followed by another property
              state.waitPipe = true;  // A property can be followed by a filter
              return "property";
            }
          }

          // Highlight filters
          if (state.waitFilter) {
              state.waitFilter = false;
            if (stream.match(filters)) {
              return "variable-2";
            }
          }

          // Ignore all white spaces
          if (stream.eatSpace()) {
            state.waitProperty = false;
            return "null";
          }

          // Identify numbers
          if (stream.match(/\b\d+(\.\d+)?\b/)) {
            return "number";
          }

          // Identify strings
          if (stream.match("'")) {
            state.tokenize = inString("'", state.tokenize);
            return "string";
          } else if (stream.match('"')) {
            state.tokenize = inString('"', state.tokenize);
            return "string";
          }

          // Attempt to find the variable
          if (stream.match(/\b(\w+)\b/) && !state.foundVariable) {
            state.waitDot = true;
            state.waitPipe = true;  // A property can be followed by a filter
            return "variable";
          }

          // If found closing tag reset
          if (stream.match("}}")) {
            state.waitProperty = null;
            state.waitFilter = null;
            state.waitDot = null;
            state.waitPipe = null;
            state.tokenize = tokenBase;
            return "tag";
          }

          // If nothing was found, advance to the next character
          stream.next();
          return "null";
        }

        function inTag (stream, state) {
          // Attempt to match a dot that precedes a property
          if (state.waitDot) {
            state.waitDot = false;

            if (stream.peek() != ".") {
              return "null";
            }

            // Dot followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat(".")) {
              state.waitProperty = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for property.");
            }
          }

          // Attempt to match a pipe that precedes a filter
          if (state.waitPipe) {
            state.waitPipe = false;

            if (stream.peek() != "|") {
              return "null";
            }

            // Pipe followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat("|")) {
              state.waitFilter = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for filter.");
            }
          }

          // Highlight properties
          if (state.waitProperty) {
            state.waitProperty = false;
            if (stream.match(/\b(\w+)\b/)) {
              state.waitDot = true;  // A property can be followed by another property
              state.waitPipe = true;  // A property can be followed by a filter
              return "property";
            }
          }

          // Highlight filters
          if (state.waitFilter) {
              state.waitFilter = false;
            if (stream.match(filters)) {
              return "variable-2";
            }
          }

          // Ignore all white spaces
          if (stream.eatSpace()) {
            state.waitProperty = false;
            return "null";
          }

          // Identify numbers
          if (stream.match(/\b\d+(\.\d+)?\b/)) {
            return "number";
          }

          // Identify strings
          if (stream.match("'")) {
            state.tokenize = inString("'", state.tokenize);
            return "string";
          } else if (stream.match('"')) {
            state.tokenize = inString('"', state.tokenize);
            return "string";
          }

          // Attempt to match an operator
          if (stream.match(operators)) {
            return "operator";
          }

          // Attempt to match a word operator
          if (stream.match(wordOperators)) {
            return "keyword";
          }

          // Attempt to match a keyword
          var keywordMatch = stream.match(keywords);
          if (keywordMatch) {
            if (keywordMatch[0] == "comment") {
              state.blockCommentTag = true;
            }
            return "keyword";
          }

          // Attempt to match a variable
          if (stream.match(/\b(\w+)\b/)) {
            state.waitDot = true;
            state.waitPipe = true;  // A property can be followed by a filter
            return "variable";
          }

          // If found closing tag reset
          if (stream.match("%}")) {
            state.waitProperty = null;
            state.waitFilter = null;
            state.waitDot = null;
            state.waitPipe = null;
            // If the tag that closes is a block comment tag, we want to mark the
            // following code as comment, until the tag closes.
            if (state.blockCommentTag) {
              state.blockCommentTag = false;  // Release the "lock"
              state.tokenize = inBlockComment;
            } else {
              state.tokenize = tokenBase;
            }
            return "tag";
          }

          // If nothing was found, advance to the next character
          stream.next();
          return "null";
        }

        // Mark everything as comment inside the tag and the tag itself.
        function inComment (stream, state) {
          if (stream.match(/^.*?#\}/)) state.tokenize = tokenBase
          else stream.skipToEnd()
          return "comment";
        }

        // Mark everything as a comment until the `blockcomment` tag closes.
        function inBlockComment (stream, state) {
          if (stream.match(/\{%\s*endcomment\s*%\}/, false)) {
            state.tokenize = inTag;
            stream.match("{%");
            return "tag";
          } else {
            stream.next();
            return "comment";
          }
        }

        return {
          startState: function () {
            return {tokenize: tokenBase};
          },
          token: function (stream, state) {
            return state.tokenize(stream, state);
          },
          blockCommentStart: "{% comment %}",
          blockCommentEnd: "{% endcomment %}"
        };
      });

      CodeMirror.defineMode("django", function(config) {
        var htmlBase = CodeMirror.getMode(config, "text/html");
        var djangoInner = CodeMirror.getMode(config, "django:inner");
        return CodeMirror.overlayMode(htmlBase, djangoInner);
      });

      CodeMirror.defineMIME("text/x-django", "django");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-dtd-dtd.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
      DTD mode
      Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>
      Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues
      GitHub: @peterkroon
    */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("dtd", function(config) {
      var indentUnit = config.indentUnit, type;
      function ret(style, tp) {type = tp; return style;}

      function tokenBase(stream, state) {
        var ch = stream.next();

        if (ch == "<" && stream.eat("!") ) {
          if (stream.eatWhile(/[\-]/)) {
            state.tokenize = tokenSGMLComment;
            return tokenSGMLComment(stream, state);
          } else if (stream.eatWhile(/[\w]/)) return ret("keyword", "doindent");
        } else if (ch == "<" && stream.eat("?")) { //xml declaration
          state.tokenize = inBlock("meta", "?>");
          return ret("meta", ch);
        } else if (ch == "#" && stream.eatWhile(/[\w]/)) return ret("atom", "tag");
        else if (ch == "|") return ret("keyword", "separator");
        else if (ch.match(/[\(\)\[\]\-\.,\+\?>]/)) return ret(null, ch);//if(ch === ">") return ret(null, "endtag"); else
        else if (ch.match(/[\[\]]/)) return ret("rule", ch);
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (stream.eatWhile(/[a-zA-Z\?\+\d]/)) {
          var sc = stream.current();
          if( sc.substr(sc.length-1,sc.length).match(/\?|\+/) !== null )stream.backUp(1);
          return ret("tag", "tag");
        } else if (ch == "%" || ch == "*" ) return ret("number", "number");
        else {
          stream.eatWhile(/[\w\\\-_%.{,]/);
          return ret(null, null);
        }
      }

      function tokenSGMLComment(stream, state) {
        var dashes = 0, ch;
        while ((ch = stream.next()) != null) {
          if (dashes >= 2 && ch == ">") {
            state.tokenize = tokenBase;
            break;
          }
          dashes = (ch == "-") ? dashes + 1 : 0;
        }
        return ret("comment", "comment");
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          return ret("string", "tag");
        };
      }

      function inBlock(style, terminator) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = tokenBase;
              break;
            }
            stream.next();
          }
          return style;
        };
      }

      return {
        startState: function(base) {
          return {tokenize: tokenBase,
                  baseIndent: base || 0,
                  stack: []};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);

          var context = state.stack[state.stack.length-1];
          if (stream.current() == "[" || type === "doindent" || type == "[") state.stack.push("rule");
          else if (type === "endtag") state.stack[state.stack.length-1] = "endtag";
          else if (stream.current() == "]" || type == "]" || (type == ">" && context == "rule")) state.stack.pop();
          else if (type == "[") state.stack.push("[");
          return style;
        },

        indent: function(state, textAfter) {
          var n = state.stack.length;

          if( textAfter.charAt(0) === ']' )n--;
          else if(textAfter.substr(textAfter.length-1, textAfter.length) === ">"){
            if(textAfter.substr(0,1) === "<") {}
            else if( type == "doindent" && textAfter.length > 1 ) {}
            else if( type == "doindent")n--;
            else if( type == ">" && textAfter.length > 1) {}
            else if( type == "tag" && textAfter !== ">") {}
            else if( type == "tag" && state.stack[state.stack.length-1] == "rule")n--;
            else if( type == "tag")n++;
            else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule" && type === ">")n--;
            else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule") {}
            else if( textAfter.substr(0,1) !== "<" && textAfter.substr(0,1) === ">" )n=n-1;
            else if( textAfter === ">") {}
            else n=n-1;
            //over rule them all
            if(type == null || type == "]")n--;
          }

          return state.baseIndent + n * indentUnit;
        },

        electricChars: "]>"
      };
    });

    CodeMirror.defineMIME("application/xml-dtd", "dtd");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-dylan-dylan.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    function forEach(arr, f) {
      for (var i = 0; i < arr.length; i++) f(arr[i], i)
    }
    function some(arr, f) {
      for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true
      return false
    }

    CodeMirror.defineMode("dylan", function(_config) {
      // Words
      var words = {
        // Words that introduce unnamed definitions like "define interface"
        unnamedDefinition: ["interface"],

        // Words that introduce simple named definitions like "define library"
        namedDefinition: ["module", "library", "macro",
                          "C-struct", "C-union",
                          "C-function", "C-callable-wrapper"
                         ],

        // Words that introduce type definitions like "define class".
        // These are also parameterized like "define method" and are
        // appended to otherParameterizedDefinitionWords
        typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

        // Words that introduce trickier definitions like "define method".
        // These require special definitions to be added to startExpressions
        otherParameterizedDefinition: ["method", "function",
                                       "C-variable", "C-address"
                                      ],

        // Words that introduce module constant definitions.
        // These must also be simple definitions and are
        // appended to otherSimpleDefinitionWords
        constantSimpleDefinition: ["constant"],

        // Words that introduce module variable definitions.
        // These must also be simple definitions and are
        // appended to otherSimpleDefinitionWords
        variableSimpleDefinition: ["variable"],

        // Other words that introduce simple definitions
        // (without implicit bodies).
        otherSimpleDefinition: ["generic", "domain",
                                "C-pointer-type",
                                "table"
                               ],

        // Words that begin statements with implicit bodies.
        statement: ["if", "block", "begin", "method", "case",
                    "for", "select", "when", "unless", "until",
                    "while", "iterate", "profiling", "dynamic-bind"
                   ],

        // Patterns that act as separators in compound statements.
        // This may include any general pattern that must be indented
        // specially.
        separator: ["finally", "exception", "cleanup", "else",
                    "elseif", "afterwards"
                   ],

        // Keywords that do not require special indentation handling,
        // but which should be highlighted
        other: ["above", "below", "by", "from", "handler", "in",
                "instance", "let", "local", "otherwise", "slot",
                "subclass", "then", "to", "keyed-by", "virtual"
               ],

        // Condition signaling function calls
        signalingCalls: ["signal", "error", "cerror",
                         "break", "check-type", "abort"
                        ]
      };

      words["otherDefinition"] =
        words["unnamedDefinition"]
        .concat(words["namedDefinition"])
        .concat(words["otherParameterizedDefinition"]);

      words["definition"] =
        words["typeParameterizedDefinition"]
        .concat(words["otherDefinition"]);

      words["parameterizedDefinition"] =
        words["typeParameterizedDefinition"]
        .concat(words["otherParameterizedDefinition"]);

      words["simpleDefinition"] =
        words["constantSimpleDefinition"]
        .concat(words["variableSimpleDefinition"])
        .concat(words["otherSimpleDefinition"]);

      words["keyword"] =
        words["statement"]
        .concat(words["separator"])
        .concat(words["other"]);

      // Patterns
      var symbolPattern = "[-_a-zA-Z?!*@<>$%]+";
      var symbol = new RegExp("^" + symbolPattern);
      var patterns = {
        // Symbols with special syntax
        symbolKeyword: symbolPattern + ":",
        symbolClass: "<" + symbolPattern + ">",
        symbolGlobal: "\\*" + symbolPattern + "\\*",
        symbolConstant: "\\$" + symbolPattern
      };
      var patternStyles = {
        symbolKeyword: "atom",
        symbolClass: "tag",
        symbolGlobal: "variable-2",
        symbolConstant: "variable-3"
      };

      // Compile all patterns to regular expressions
      for (var patternName in patterns)
        if (patterns.hasOwnProperty(patternName))
          patterns[patternName] = new RegExp("^" + patterns[patternName]);

      // Names beginning "with-" and "without-" are commonly
      // used as statement macro
      patterns["keyword"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];

      var styles = {};
      styles["keyword"] = "keyword";
      styles["definition"] = "def";
      styles["simpleDefinition"] = "def";
      styles["signalingCalls"] = "builtin";

      // protected words lookup table
      var wordLookup = {};
      var styleLookup = {};

      forEach([
        "keyword",
        "definition",
        "simpleDefinition",
        "signalingCalls"
      ], function(type) {
        forEach(words[type], function(word) {
          wordLookup[word] = type;
          styleLookup[word] = styles[type];
        });
      });


      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      function tokenBase(stream, state) {
        // String
        var ch = stream.peek();
        if (ch == "'" || ch == '"') {
          stream.next();
          return chain(stream, state, tokenString(ch, "string"));
        }
        // Comment
        else if (ch == "/") {
          stream.next();
          if (stream.eat("*")) {
            return chain(stream, state, tokenComment);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
          stream.backUp(1);
        }
        // Decimal
        else if (/[+\-\d\.]/.test(ch)) {
          if (stream.match(/^[+-]?[0-9]*\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||
              stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||
              stream.match(/^[+-]?\d+/)) {
            return "number";
          }
        }
        // Hash
        else if (ch == "#") {
          stream.next();
          // Symbol with string syntax
          ch = stream.peek();
          if (ch == '"') {
            stream.next();
            return chain(stream, state, tokenString('"', "string"));
          }
          // Binary number
          else if (ch == "b") {
            stream.next();
            stream.eatWhile(/[01]/);
            return "number";
          }
          // Hex number
          else if (ch == "x") {
            stream.next();
            stream.eatWhile(/[\da-f]/i);
            return "number";
          }
          // Octal number
          else if (ch == "o") {
            stream.next();
            stream.eatWhile(/[0-7]/);
            return "number";
          }
          // Token concatenation in macros
          else if (ch == '#') {
            stream.next();
            return "punctuation";
          }
          // Sequence literals
          else if ((ch == '[') || (ch == '(')) {
            stream.next();
            return "bracket";
          // Hash symbol
          } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {
            return "atom";
          } else {
            stream.eatWhile(/[-a-zA-Z]/);
            return "error";
          }
        } else if (ch == "~") {
          stream.next();
          ch = stream.peek();
          if (ch == "=") {
            stream.next();
            ch = stream.peek();
            if (ch == "=") {
              stream.next();
              return "operator";
            }
            return "operator";
          }
          return "operator";
        } else if (ch == ":") {
          stream.next();
          ch = stream.peek();
          if (ch == "=") {
            stream.next();
            return "operator";
          } else if (ch == ":") {
            stream.next();
            return "punctuation";
          }
        } else if ("[](){}".indexOf(ch) != -1) {
          stream.next();
          return "bracket";
        } else if (".,".indexOf(ch) != -1) {
          stream.next();
          return "punctuation";
        } else if (stream.match("end")) {
          return "keyword";
        }
        for (var name in patterns) {
          if (patterns.hasOwnProperty(name)) {
            var pattern = patterns[name];
            if ((pattern instanceof Array && some(pattern, function(p) {
              return stream.match(p);
            })) || stream.match(pattern))
              return patternStyles[name];
          }
        }
        if (/[+\-*\/^=<>&|]/.test(ch)) {
          stream.next();
          return "operator";
        }
        if (stream.match("define")) {
          return "def";
        } else {
          stream.eatWhile(/[\w\-]/);
          // Keyword
          if (wordLookup.hasOwnProperty(stream.current())) {
            return styleLookup[stream.current()];
          } else if (stream.current().match(symbol)) {
            return "variable";
          } else {
            stream.next();
            return "variable-2";
          }
        }
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
        while ((ch = stream.next())) {
          if (ch == "/" && maybeEnd) {
            if (nestedCount > 0) {
              nestedCount--;
            } else {
              state.tokenize = tokenBase;
              break;
            }
          } else if (ch == "*" && maybeNested) {
            nestedCount++;
          }
          maybeEnd = (ch == "*");
          maybeNested = (ch == "/");
        }
        return "comment";
      }

      function tokenString(quote, style) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped) {
            state.tokenize = tokenBase;
          }
          return style;
        };
      }

      // Interface
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            currentIndent: 0
          };
        },
        token: function(stream, state) {
          if (stream.eatSpace())
            return null;
          var style = state.tokenize(stream, state);
          return style;
        },
        blockCommentStart: "/*",
        blockCommentEnd: "*/"
      };
    });

    CodeMirror.defineMIME("text/x-dylan", "dylan");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-ebnf-ebnf.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("ebnf", function (config) {
        var commentType = {slash: 0, parenthesis: 1};
        var stateType = {comment: 0, _string: 1, characterClass: 2};
        var bracesMode = null;

        if (config.bracesMode)
          bracesMode = CodeMirror.getMode(config, config.bracesMode);

        return {
          startState: function () {
            return {
              stringType: null,
              commentType: null,
              braced: 0,
              lhs: true,
              localState: null,
              stack: [],
              inDefinition: false
            };
          },
          token: function (stream, state) {
            if (!stream) return;

            //check for state changes
            if (state.stack.length === 0) {
              //strings
              if ((stream.peek() == '"') || (stream.peek() == "'")) {
                state.stringType = stream.peek();
                stream.next(); // Skip quote
                state.stack.unshift(stateType._string);
              } else if (stream.match('/*')) { //comments starting with /*
                state.stack.unshift(stateType.comment);
                state.commentType = commentType.slash;
              } else if (stream.match('(*')) { //comments starting with (*
                state.stack.unshift(stateType.comment);
                state.commentType = commentType.parenthesis;
              }
            }

            //return state
            //stack has
            switch (state.stack[0]) {
            case stateType._string:
              while (state.stack[0] === stateType._string && !stream.eol()) {
                if (stream.peek() === state.stringType) {
                  stream.next(); // Skip quote
                  state.stack.shift(); // Clear flag
                } else if (stream.peek() === "\\") {
                  stream.next();
                  stream.next();
                } else {
                  stream.match(/^.[^\\\"\']*/);
                }
              }
              return state.lhs ? "property string" : "string"; // Token style

            case stateType.comment:
              while (state.stack[0] === stateType.comment && !stream.eol()) {
                if (state.commentType === commentType.slash && stream.match('*/')) {
                  state.stack.shift(); // Clear flag
                  state.commentType = null;
                } else if (state.commentType === commentType.parenthesis && stream.match('*)')) {
                  state.stack.shift(); // Clear flag
                  state.commentType = null;
                } else {
                  stream.match(/^.[^\*]*/);
                }
              }
              return "comment";

            case stateType.characterClass:
              while (state.stack[0] === stateType.characterClass && !stream.eol()) {
                if (!(stream.match(/^[^\]\\]+/) || stream.match('.'))) {
                  state.stack.shift();
                }
              }
              return "operator";
            }

            var peek = stream.peek();

            if (bracesMode !== null && (state.braced || peek === "{")) {
              if (state.localState === null)
                state.localState = CodeMirror.startState(bracesMode);

              var token = bracesMode.token(stream, state.localState),
              text = stream.current();

              if (!token) {
                for (var i = 0; i < text.length; i++) {
                  if (text[i] === "{") {
                    if (state.braced === 0) {
                      token = "matchingbracket";
                    }
                    state.braced++;
                  } else if (text[i] === "}") {
                    state.braced--;
                    if (state.braced === 0) {
                      token = "matchingbracket";
                    }
                  }
                }
              }
              return token;
            }

            //no stack
            switch (peek) {
            case "[":
              stream.next();
              state.stack.unshift(stateType.characterClass);
              return "bracket";
            case ":":
            case "|":
            case ";":
              stream.next();
              return "operator";
            case "%":
              if (stream.match("%%")) {
                return "header";
              } else if (stream.match(/[%][A-Za-z]+/)) {
                return "keyword";
              } else if (stream.match(/[%][}]/)) {
                return "matchingbracket";
              }
              break;
            case "/":
              if (stream.match(/[\/][A-Za-z]+/)) {
              return "keyword";
            }
            case "\\":
              if (stream.match(/[\][a-z]+/)) {
                return "string-2";
              }
            case ".":
              if (stream.match(".")) {
                return "atom";
              }
            case "*":
            case "-":
            case "+":
            case "^":
              if (stream.match(peek)) {
                return "atom";
              }
            case "$":
              if (stream.match("$$")) {
                return "builtin";
              } else if (stream.match(/[$][0-9]+/)) {
                return "variable-3";
              }
            case "<":
              if (stream.match(/<<[a-zA-Z_]+>>/)) {
                return "builtin";
              }
            }

            if (stream.match('//')) {
              stream.skipToEnd();
              return "comment";
            } else if (stream.match('return')) {
              return "operator";
            } else if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
              if (stream.match(/(?=[\(.])/)) {
                return "variable";
              } else if (stream.match(/(?=[\s\n]*[:=])/)) {
                return "def";
              }
              return "variable-2";
            } else if (["[", "]", "(", ")"].indexOf(stream.peek()) != -1) {
              stream.next();
              return "bracket";
            } else if (!stream.eatSpace()) {
              stream.next();
            }
            return null;
          }
        };
      });

      CodeMirror.defineMIME("text/x-ebnf", "ebnf");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-ecl-ecl.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("ecl", function(config) {

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      function metaHook(stream, state) {
        if (!state.startOfLine) return false;
        stream.skipToEnd();
        return "meta";
      }

      var indentUnit = config.indentUnit;
      var keyword = words("abs acos allnodes ascii asin asstring atan atan2 ave case choose choosen choosesets clustersize combine correlation cos cosh count covariance cron dataset dedup define denormalize distribute distributed distribution ebcdic enth error evaluate event eventextra eventname exists exp failcode failmessage fetch fromunicode getisvalid global graph group hash hash32 hash64 hashcrc hashmd5 having if index intformat isvalid iterate join keyunicode length library limit ln local log loop map matched matchlength matchposition matchtext matchunicode max merge mergejoin min nolocal nonempty normalize parse pipe power preload process project pull random range rank ranked realformat recordof regexfind regexreplace regroup rejected rollup round roundup row rowdiff sample set sin sinh sizeof soapcall sort sorted sqrt stepped stored sum table tan tanh thisnode topn tounicode transfer trim truncate typeof ungroup unicodeorder variance which workunit xmldecode xmlencode xmltext xmlunicode");
      var variable = words("apply assert build buildindex evaluate fail keydiff keypatch loadxml nothor notify output parallel sequential soapcall wait");
      var variable_2 = words("__compressed__ all and any as atmost before beginc++ best between case const counter csv descend encrypt end endc++ endmacro except exclusive expire export extend false few first flat from full function group header heading hole ifblock import in interface joined keep keyed last left limit load local locale lookup macro many maxcount maxlength min skew module named nocase noroot noscan nosort not of only opt or outer overwrite packed partition penalty physicallength pipe quote record relationship repeat return right scan self separator service shared skew skip sql store terminator thor threshold token transform trim true type unicodeorder unsorted validate virtual whole wild within xml xpath");
      var variable_3 = words("ascii big_endian boolean data decimal ebcdic integer pattern qstring real record rule set of string token udecimal unicode unsigned varstring varunicode");
      var builtin = words("checkpoint deprecated failcode failmessage failure global independent onwarning persist priority recovery stored success wait when");
      var blockKeywords = words("catch class do else finally for if switch try while");
      var atoms = words("true false null");
      var hooks = {"#": metaHook};
      var isOperatorChar = /[+\-*&%=<>!?|\/]/;

      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current().toLowerCase();
        if (keyword.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "keyword";
        } else if (variable.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "variable";
        } else if (variable_2.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "variable-2";
        } else if (variable_3.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "variable-3";
        } else if (builtin.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "builtin";
        } else { //Data types are of from KEYWORD##
                    var i = cur.length - 1;
                    while(i >= 0 && (!isNaN(cur[i]) || cur[i] == '_'))
                            --i;

                    if (i > 0) {
                            var cur2 = cur.substr(0, i + 1);
                    if (variable_3.propertyIsEnumerable(cur2)) {
                            if (blockKeywords.propertyIsEnumerable(cur2)) curPunc = "newstatement";
                            return "variable-3";
                    }
                }
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return null;
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped)
            state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
          var closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}"
      };
    });

    CodeMirror.defineMIME("text/x-ecl", "ecl");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-eiffel-eiffel.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("eiffel", function() {
      function wordObj(words) {
        var o = {};
        for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
        return o;
      }
      var keywords = wordObj([
        'note',
        'across',
        'when',
        'variant',
        'until',
        'unique',
        'undefine',
        'then',
        'strip',
        'select',
        'retry',
        'rescue',
        'require',
        'rename',
        'reference',
        'redefine',
        'prefix',
        'once',
        'old',
        'obsolete',
        'loop',
        'local',
        'like',
        'is',
        'inspect',
        'infix',
        'include',
        'if',
        'frozen',
        'from',
        'external',
        'export',
        'ensure',
        'end',
        'elseif',
        'else',
        'do',
        'creation',
        'create',
        'check',
        'alias',
        'agent',
        'separate',
        'invariant',
        'inherit',
        'indexing',
        'feature',
        'expanded',
        'deferred',
        'class',
        'Void',
        'True',
        'Result',
        'Precursor',
        'False',
        'Current',
        'create',
        'attached',
        'detachable',
        'as',
        'and',
        'implies',
        'not',
        'or'
      ]);
      var operators = wordObj([":=", "and then","and", "or","<<",">>"]);

      function chain(newtok, stream, state) {
        state.tokenize.push(newtok);
        return newtok(stream, state);
      }

      function tokenBase(stream, state) {
        if (stream.eatSpace()) return null;
        var ch = stream.next();
        if (ch == '"'||ch == "'") {
          return chain(readQuoted(ch, "string"), stream, state);
        } else if (ch == "-"&&stream.eat("-")) {
          stream.skipToEnd();
          return "comment";
        } else if (ch == ":"&&stream.eat("=")) {
          return "operator";
        } else if (/[0-9]/.test(ch)) {
          stream.eatWhile(/[xXbBCc0-9\.]/);
          stream.eat(/[\?\!]/);
          return "ident";
        } else if (/[a-zA-Z_0-9]/.test(ch)) {
          stream.eatWhile(/[a-zA-Z_0-9]/);
          stream.eat(/[\?\!]/);
          return "ident";
        } else if (/[=+\-\/*^%<>~]/.test(ch)) {
          stream.eatWhile(/[=+\-\/*^%<>~]/);
          return "operator";
        } else {
          return null;
        }
      }

      function readQuoted(quote, style,  unescaped) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && (unescaped || !escaped)) {
              state.tokenize.pop();
              break;
            }
            escaped = !escaped && ch == "%";
          }
          return style;
        };
      }

      return {
        startState: function() {
          return {tokenize: [tokenBase]};
        },

        token: function(stream, state) {
          var style = state.tokenize[state.tokenize.length-1](stream, state);
          if (style == "ident") {
            var word = stream.current();
            style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
              : operators.propertyIsEnumerable(stream.current()) ? "operator"
              : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
              : /^0[bB][0-1]+$/g.test(word) ? "number"
              : /^0[cC][0-7]+$/g.test(word) ? "number"
              : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
              : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
              : /^[0-9]+$/g.test(word) ? "number"
              : "variable";
          }
          return style;
        },
        lineComment: "--"
      };
    });

    CodeMirror.defineMIME("text/x-eiffel", "eiffel");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-erlang-erlang.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*jshint unused:true, eqnull:true, curly:true, bitwise:true */
    /*jshint undef:true, latedef:true, trailing:true */
    /*global CodeMirror:true */

    // erlang mode.
    // tokenizer -> token types -> CodeMirror styles
    // tokenizer maintains a parse stack
    // indenter uses the parse stack

    // TODO indenter:
    //   bit syntax
    //   old guard/bif/conversion clashes (e.g. "float/1")
    //   type/spec/opaque

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMIME("text/x-erlang", "erlang");

    CodeMirror.defineMode("erlang", function(cmCfg) {
      "use strict";

    /////////////////////////////////////////////////////////////////////////////
    // constants

      var typeWords = [
        "-type", "-spec", "-export_type", "-opaque"];

      var keywordWords = [
        "after","begin","catch","case","cond","end","fun","if",
        "let","of","query","receive","try","when"];

      var separatorRE    = /[\->,;]/;
      var separatorWords = [
        "->",";",","];

      var operatorAtomWords = [
        "and","andalso","band","bnot","bor","bsl","bsr","bxor",
        "div","not","or","orelse","rem","xor"];

      var operatorSymbolRE    = /[\+\-\*\/<>=\|:!]/;
      var operatorSymbolWords = [
        "=","+","-","*","/",">",">=","<","=<","=:=","==","=/=","/=","||","<-","!"];

      var openParenRE    = /[<\(\[\{]/;
      var openParenWords = [
        "<<","(","[","{"];

      var closeParenRE    = /[>\)\]\}]/;
      var closeParenWords = [
        "}","]",")",">>"];

      var guardWords = [
        "is_atom","is_binary","is_bitstring","is_boolean","is_float",
        "is_function","is_integer","is_list","is_number","is_pid",
        "is_port","is_record","is_reference","is_tuple",
        "atom","binary","bitstring","boolean","function","integer","list",
        "number","pid","port","record","reference","tuple"];

      var bifWords = [
        "abs","adler32","adler32_combine","alive","apply","atom_to_binary",
        "atom_to_list","binary_to_atom","binary_to_existing_atom",
        "binary_to_list","binary_to_term","bit_size","bitstring_to_list",
        "byte_size","check_process_code","contact_binary","crc32",
        "crc32_combine","date","decode_packet","delete_module",
        "disconnect_node","element","erase","exit","float","float_to_list",
        "garbage_collect","get","get_keys","group_leader","halt","hd",
        "integer_to_list","internal_bif","iolist_size","iolist_to_binary",
        "is_alive","is_atom","is_binary","is_bitstring","is_boolean",
        "is_float","is_function","is_integer","is_list","is_number","is_pid",
        "is_port","is_process_alive","is_record","is_reference","is_tuple",
        "length","link","list_to_atom","list_to_binary","list_to_bitstring",
        "list_to_existing_atom","list_to_float","list_to_integer",
        "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",
        "monitor_node","node","node_link","node_unlink","nodes","notalive",
        "now","open_port","pid_to_list","port_close","port_command",
        "port_connect","port_control","pre_loaded","process_flag",
        "process_info","processes","purge_module","put","register",
        "registered","round","self","setelement","size","spawn","spawn_link",
        "spawn_monitor","spawn_opt","split_binary","statistics",
        "term_to_binary","time","throw","tl","trunc","tuple_size",
        "tuple_to_list","unlink","unregister","whereis"];

    // upper case: [A-Z] [Ø-Þ] [À-Ö]
    // lower case: [a-z] [ß-ö] [ø-ÿ]
      var anumRE       = /[\w@Ø-ÞÀ-Öß-öø-ÿ]/;
      var escapesRE    =
        /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

    /////////////////////////////////////////////////////////////////////////////
    // tokenizer

      function tokenizer(stream,state) {
        // in multi-line string
        if (state.in_string) {
          state.in_string = (!doubleQuote(stream));
          return rval(state,stream,"string");
        }

        // in multi-line atom
        if (state.in_atom) {
          state.in_atom = (!singleQuote(stream));
          return rval(state,stream,"atom");
        }

        // whitespace
        if (stream.eatSpace()) {
          return rval(state,stream,"whitespace");
        }

        // attributes and type specs
        if (!peekToken(state) &&
            stream.match(/-\s*[a-zß-öø-ÿ][\wØ-ÞÀ-Öß-öø-ÿ]*/)) {
          if (is_member(stream.current(),typeWords)) {
            return rval(state,stream,"type");
          }else{
            return rval(state,stream,"attribute");
          }
        }

        var ch = stream.next();

        // comment
        if (ch == '%') {
          stream.skipToEnd();
          return rval(state,stream,"comment");
        }

        // colon
        if (ch == ":") {
          return rval(state,stream,"colon");
        }

        // macro
        if (ch == '?') {
          stream.eatSpace();
          stream.eatWhile(anumRE);
          return rval(state,stream,"macro");
        }

        // record
        if (ch == "#") {
          stream.eatSpace();
          stream.eatWhile(anumRE);
          return rval(state,stream,"record");
        }

        // dollar escape
        if (ch == "$") {
          if (stream.next() == "\\" && !stream.match(escapesRE)) {
            return rval(state,stream,"error");
          }
          return rval(state,stream,"number");
        }

        // dot
        if (ch == ".") {
          return rval(state,stream,"dot");
        }

        // quoted atom
        if (ch == '\'') {
          if (!(state.in_atom = (!singleQuote(stream)))) {
            if (stream.match(/\s*\/\s*[0-9]/,false)) {
              stream.match(/\s*\/\s*[0-9]/,true);
              return rval(state,stream,"fun");      // 'f'/0 style fun
            }
            if (stream.match(/\s*\(/,false) || stream.match(/\s*:/,false)) {
              return rval(state,stream,"function");
            }
          }
          return rval(state,stream,"atom");
        }

        // string
        if (ch == '"') {
          state.in_string = (!doubleQuote(stream));
          return rval(state,stream,"string");
        }

        // variable
        if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {
          stream.eatWhile(anumRE);
          return rval(state,stream,"variable");
        }

        // atom/keyword/BIF/function
        if (/[a-z_ß-öø-ÿ]/.test(ch)) {
          stream.eatWhile(anumRE);

          if (stream.match(/\s*\/\s*[0-9]/,false)) {
            stream.match(/\s*\/\s*[0-9]/,true);
            return rval(state,stream,"fun");      // f/0 style fun
          }

          var w = stream.current();

          if (is_member(w,keywordWords)) {
            return rval(state,stream,"keyword");
          }else if (is_member(w,operatorAtomWords)) {
            return rval(state,stream,"operator");
          }else if (stream.match(/\s*\(/,false)) {
            // 'put' and 'erlang:put' are bifs, 'foo:put' is not
            if (is_member(w,bifWords) &&
                ((peekToken(state).token != ":") ||
                 (peekToken(state,2).token == "erlang"))) {
              return rval(state,stream,"builtin");
            }else if (is_member(w,guardWords)) {
              return rval(state,stream,"guard");
            }else{
              return rval(state,stream,"function");
            }
          }else if (lookahead(stream) == ":") {
            if (w == "erlang") {
              return rval(state,stream,"builtin");
            } else {
              return rval(state,stream,"function");
            }
          }else if (is_member(w,["true","false"])) {
            return rval(state,stream,"boolean");
          }else{
            return rval(state,stream,"atom");
          }
        }

        // number
        var digitRE      = /[0-9]/;
        var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int
        if (digitRE.test(ch)) {
          stream.eatWhile(digitRE);
          if (stream.eat('#')) {                // 36#aZ  style integer
            if (!stream.eatWhile(radixRE)) {
              stream.backUp(1);                 //"36#" - syntax error
            }
          } else if (stream.eat('.')) {       // float
            if (!stream.eatWhile(digitRE)) {
              stream.backUp(1);        // "3." - probably end of function
            } else {
              if (stream.eat(/[eE]/)) {        // float with exponent
                if (stream.eat(/[-+]/)) {
                  if (!stream.eatWhile(digitRE)) {
                    stream.backUp(2);            // "2e-" - syntax error
                  }
                } else {
                  if (!stream.eatWhile(digitRE)) {
                    stream.backUp(1);            // "2e" - syntax error
                  }
                }
              }
            }
          }
          return rval(state,stream,"number");   // normal integer
        }

        // open parens
        if (nongreedy(stream,openParenRE,openParenWords)) {
          return rval(state,stream,"open_paren");
        }

        // close parens
        if (nongreedy(stream,closeParenRE,closeParenWords)) {
          return rval(state,stream,"close_paren");
        }

        // separators
        if (greedy(stream,separatorRE,separatorWords)) {
          return rval(state,stream,"separator");
        }

        // operators
        if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {
          return rval(state,stream,"operator");
        }

        return rval(state,stream,null);
      }

    /////////////////////////////////////////////////////////////////////////////
    // utilities
      function nongreedy(stream,re,words) {
        if (stream.current().length == 1 && re.test(stream.current())) {
          stream.backUp(1);
          while (re.test(stream.peek())) {
            stream.next();
            if (is_member(stream.current(),words)) {
              return true;
            }
          }
          stream.backUp(stream.current().length-1);
        }
        return false;
      }

      function greedy(stream,re,words) {
        if (stream.current().length == 1 && re.test(stream.current())) {
          while (re.test(stream.peek())) {
            stream.next();
          }
          while (0 < stream.current().length) {
            if (is_member(stream.current(),words)) {
              return true;
            }else{
              stream.backUp(1);
            }
          }
          stream.next();
        }
        return false;
      }

      function doubleQuote(stream) {
        return quote(stream, '"', '\\');
      }

      function singleQuote(stream) {
        return quote(stream,'\'','\\');
      }

      function quote(stream,quoteChar,escapeChar) {
        while (!stream.eol()) {
          var ch = stream.next();
          if (ch == quoteChar) {
            return true;
          }else if (ch == escapeChar) {
            stream.next();
          }
        }
        return false;
      }

      function lookahead(stream) {
        var m = stream.match(/^\s*([^\s%])/, false)
        return m ? m[1] : "";
      }

      function is_member(element,list) {
        return (-1 < list.indexOf(element));
      }

      function rval(state,stream,type) {

        // parse stack
        pushToken(state,realToken(type,stream));

        // map erlang token type to CodeMirror style class
        //     erlang             -> CodeMirror tag
        switch (type) {
          case "atom":        return "atom";
          case "attribute":   return "attribute";
          case "boolean":     return "atom";
          case "builtin":     return "builtin";
          case "close_paren": return null;
          case "colon":       return null;
          case "comment":     return "comment";
          case "dot":         return null;
          case "error":       return "error";
          case "fun":         return "meta";
          case "function":    return "tag";
          case "guard":       return "property";
          case "keyword":     return "keyword";
          case "macro":       return "variable-2";
          case "number":      return "number";
          case "open_paren":  return null;
          case "operator":    return "operator";
          case "record":      return "bracket";
          case "separator":   return null;
          case "string":      return "string";
          case "type":        return "def";
          case "variable":    return "variable";
          default:            return null;
        }
      }

      function aToken(tok,col,ind,typ) {
        return {token:  tok,
                column: col,
                indent: ind,
                type:   typ};
      }

      function realToken(type,stream) {
        return aToken(stream.current(),
                     stream.column(),
                     stream.indentation(),
                     type);
      }

      function fakeToken(type) {
        return aToken(type,0,0,type);
      }

      function peekToken(state,depth) {
        var len = state.tokenStack.length;
        var dep = (depth ? depth : 1);

        if (len < dep) {
          return false;
        }else{
          return state.tokenStack[len-dep];
        }
      }

      function pushToken(state,token) {

        if (!(token.type == "comment" || token.type == "whitespace")) {
          state.tokenStack = maybe_drop_pre(state.tokenStack,token);
          state.tokenStack = maybe_drop_post(state.tokenStack);
        }
      }

      function maybe_drop_pre(s,token) {
        var last = s.length-1;

        if (0 < last && s[last].type === "record" && token.type === "dot") {
          s.pop();
        }else if (0 < last && s[last].type === "group") {
          s.pop();
          s.push(token);
        }else{
          s.push(token);
        }
        return s;
      }

      function maybe_drop_post(s) {
        if (!s.length) return s
        var last = s.length-1;

        if (s[last].type === "dot") {
          return [];
        }
        if (last > 1 && s[last].type === "fun" && s[last-1].token === "fun") {
          return s.slice(0,last-1);
        }
        switch (s[last].token) {
          case "}":    return d(s,{g:["{"]});
          case "]":    return d(s,{i:["["]});
          case ")":    return d(s,{i:["("]});
          case ">>":   return d(s,{i:["<<"]});
          case "end":  return d(s,{i:["begin","case","fun","if","receive","try"]});
          case ",":    return d(s,{e:["begin","try","when","->",
                                      ",","(","[","{","<<"]});
          case "->":   return d(s,{r:["when"],
                                   m:["try","if","case","receive"]});
          case ";":    return d(s,{E:["case","fun","if","receive","try","when"]});
          case "catch":return d(s,{e:["try"]});
          case "of":   return d(s,{e:["case"]});
          case "after":return d(s,{e:["receive","try"]});
          default:     return s;
        }
      }

      function d(stack,tt) {
        // stack is a stack of Token objects.
        // tt is an object; {type:tokens}
        // type is a char, tokens is a list of token strings.
        // The function returns (possibly truncated) stack.
        // It will descend the stack, looking for a Token such that Token.token
        //  is a member of tokens. If it does not find that, it will normally (but
        //  see "E" below) return stack. If it does find a match, it will remove
        //  all the Tokens between the top and the matched Token.
        // If type is "m", that is all it does.
        // If type is "i", it will also remove the matched Token and the top Token.
        // If type is "g", like "i", but add a fake "group" token at the top.
        // If type is "r", it will remove the matched Token, but not the top Token.
        // If type is "e", it will keep the matched Token but not the top Token.
        // If type is "E", it behaves as for type "e", except if there is no match,
        //  in which case it will return an empty stack.

        for (var type in tt) {
          var len = stack.length-1;
          var tokens = tt[type];
          for (var i = len-1; -1 < i ; i--) {
            if (is_member(stack[i].token,tokens)) {
              var ss = stack.slice(0,i);
              switch (type) {
                  case "m": return ss.concat(stack[i]).concat(stack[len]);
                  case "r": return ss.concat(stack[len]);
                  case "i": return ss;
                  case "g": return ss.concat(fakeToken("group"));
                  case "E": return ss.concat(stack[i]);
                  case "e": return ss.concat(stack[i]);
              }
            }
          }
        }
        return (type == "E" ? [] : stack);
      }

    /////////////////////////////////////////////////////////////////////////////
    // indenter

      function indenter(state,textAfter) {
        var t;
        var unit = cmCfg.indentUnit;
        var wordAfter = wordafter(textAfter);
        var currT = peekToken(state,1);
        var prevT = peekToken(state,2);

        if (state.in_string || state.in_atom) {
          return CodeMirror.Pass;
        }else if (!prevT) {
          return 0;
        }else if (currT.token == "when") {
          return currT.column+unit;
        }else if (wordAfter === "when" && prevT.type === "function") {
          return prevT.indent+unit;
        }else if (wordAfter === "(" && currT.token === "fun") {
          return  currT.column+3;
        }else if (wordAfter === "catch" && (t = getToken(state,["try"]))) {
          return t.column;
        }else if (is_member(wordAfter,["end","after","of"])) {
          t = getToken(state,["begin","case","fun","if","receive","try"]);
          return t ? t.column : CodeMirror.Pass;
        }else if (is_member(wordAfter,closeParenWords)) {
          t = getToken(state,openParenWords);
          return t ? t.column : CodeMirror.Pass;
        }else if (is_member(currT.token,[",","|","||"]) ||
                  is_member(wordAfter,[",","|","||"])) {
          t = postcommaToken(state);
          return t ? t.column+t.token.length : unit;
        }else if (currT.token == "->") {
          if (is_member(prevT.token, ["receive","case","if","try"])) {
            return prevT.column+unit+unit;
          }else{
            return prevT.column+unit;
          }
        }else if (is_member(currT.token,openParenWords)) {
          return currT.column+currT.token.length;
        }else{
          t = defaultToken(state);
          return truthy(t) ? t.column+unit : 0;
        }
      }

      function wordafter(str) {
        var m = str.match(/,|[a-z]+|\}|\]|\)|>>|\|+|\(/);

        return truthy(m) && (m.index === 0) ? m[0] : "";
      }

      function postcommaToken(state) {
        var objs = state.tokenStack.slice(0,-1);
        var i = getTokenIndex(objs,"type",["open_paren"]);

        return truthy(objs[i]) ? objs[i] : false;
      }

      function defaultToken(state) {
        var objs = state.tokenStack;
        var stop = getTokenIndex(objs,"type",["open_paren","separator","keyword"]);
        var oper = getTokenIndex(objs,"type",["operator"]);

        if (truthy(stop) && truthy(oper) && stop < oper) {
          return objs[stop+1];
        } else if (truthy(stop)) {
          return objs[stop];
        } else {
          return false;
        }
      }

      function getToken(state,tokens) {
        var objs = state.tokenStack;
        var i = getTokenIndex(objs,"token",tokens);

        return truthy(objs[i]) ? objs[i] : false;
      }

      function getTokenIndex(objs,propname,propvals) {

        for (var i = objs.length-1; -1 < i ; i--) {
          if (is_member(objs[i][propname],propvals)) {
            return i;
          }
        }
        return false;
      }

      function truthy(x) {
        return (x !== false) && (x != null);
      }

    /////////////////////////////////////////////////////////////////////////////
    // this object defines the mode

      return {
        startState:
          function() {
            return {tokenStack: [],
                    in_string:  false,
                    in_atom:    false};
          },

        token:
          function(stream, state) {
            return tokenizer(stream, state);
          },

        indent:
          function(state, textAfter) {
            return indenter(state,textAfter);
          },

        lineComment: "%"
      };
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-fcl-fcl.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("fcl", function(config) {
      var indentUnit = config.indentUnit;

      var keywords = {
          "term": true,
          "method": true, "accu": true,
          "rule": true, "then": true, "is": true, "and": true, "or": true,
          "if": true, "default": true
      };

      var start_blocks = {
          "var_input": true,
          "var_output": true,
          "fuzzify": true,
          "defuzzify": true,
          "function_block": true,
          "ruleblock": true
      };

      var end_blocks = {
          "end_ruleblock": true,
          "end_defuzzify": true,
          "end_function_block": true,
          "end_fuzzify": true,
          "end_var": true
      };

      var atoms = {
          "true": true, "false": true, "nan": true,
          "real": true, "min": true, "max": true, "cog": true, "cogs": true
      };

      var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

      function tokenBase(stream, state) {
        var ch = stream.next();

        if (/[\d\.]/.test(ch)) {
          if (ch == ".") {
            stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
          } else if (ch == "0") {
            stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
          } else {
            stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
          }
          return "number";
        }

        if (ch == "/" || ch == "(") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);

        var cur = stream.current().toLowerCase();
        if (keywords.propertyIsEnumerable(cur) ||
            start_blocks.propertyIsEnumerable(cur) ||
            end_blocks.propertyIsEnumerable(cur)) {
          return "keyword";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }


      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if ((ch == "/" || ch == ")") && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }

      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }

      function popContext(state) {
        if (!state.context.prev) return;
        var t = state.context.type;
        if (t == "end_block")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
                if (ctx.align == null) ctx.align = false;
                state.indented = stream.indentation();
                state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;

            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            var cur = stream.current().toLowerCase();

            if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), "end_block");
            else if (end_blocks.propertyIsEnumerable(cur))  popContext(state);

            state.startOfLine = false;
            return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var ctx = state.context;

          var closing = end_blocks.propertyIsEnumerable(textAfter);
          if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "ryk",
        fold: "brace",
        blockCommentStart: "(*",
        blockCommentEnd: "*)",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME("text/x-fcl", "fcl");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-forth-forth.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Author: Aliaksei Chapyzhenka

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      function toWordList(words) {
        var ret = [];
        words.split(' ').forEach(function(e){
          ret.push({name: e});
        });
        return ret;
      }

      var coreWordList = toWordList(
    'INVERT AND OR XOR\
     2* 2/ LSHIFT RSHIFT\
     0= = 0< < > U< MIN MAX\
     2DROP 2DUP 2OVER 2SWAP ?DUP DEPTH DROP DUP OVER ROT SWAP\
     >R R> R@\
     + - 1+ 1- ABS NEGATE\
     S>D * M* UM*\
     FM/MOD SM/REM UM/MOD */ */MOD / /MOD MOD\
     HERE , @ ! CELL+ CELLS C, C@ C! CHARS 2@ 2!\
     ALIGN ALIGNED +! ALLOT\
     CHAR [CHAR] [ ] BL\
     FIND EXECUTE IMMEDIATE COUNT LITERAL STATE\
     ; DOES> >BODY\
     EVALUATE\
     SOURCE >IN\
     <# # #S #> HOLD SIGN BASE >NUMBER HEX DECIMAL\
     FILL MOVE\
     . CR EMIT SPACE SPACES TYPE U. .R U.R\
     ACCEPT\
     TRUE FALSE\
     <> U> 0<> 0>\
     NIP TUCK ROLL PICK\
     2>R 2R@ 2R>\
     WITHIN UNUSED MARKER\
     I J\
     TO\
     COMPILE, [COMPILE]\
     SAVE-INPUT RESTORE-INPUT\
     PAD ERASE\
     2LITERAL DNEGATE\
     D- D+ D0< D0= D2* D2/ D< D= DMAX DMIN D>S DABS\
     M+ M*/ D. D.R 2ROT DU<\
     CATCH THROW\
     FREE RESIZE ALLOCATE\
     CS-PICK CS-ROLL\
     GET-CURRENT SET-CURRENT FORTH-WORDLIST GET-ORDER SET-ORDER\
     PREVIOUS SEARCH-WORDLIST WORDLIST FIND ALSO ONLY FORTH DEFINITIONS ORDER\
     -TRAILING /STRING SEARCH COMPARE CMOVE CMOVE> BLANK SLITERAL');

      var immediateWordList = toWordList('IF ELSE THEN BEGIN WHILE REPEAT UNTIL RECURSE [IF] [ELSE] [THEN] ?DO DO LOOP +LOOP UNLOOP LEAVE EXIT AGAIN CASE OF ENDOF ENDCASE');

      CodeMirror.defineMode('forth', function() {
        function searchWordList (wordList, word) {
          var i;
          for (i = wordList.length - 1; i >= 0; i--) {
            if (wordList[i].name === word.toUpperCase()) {
              return wordList[i];
            }
          }
          return undefined;
        }
      return {
        startState: function() {
          return {
            state: '',
            base: 10,
            coreWordList: coreWordList,
            immediateWordList: immediateWordList,
            wordList: []
          };
        },
        token: function (stream, stt) {
          var mat;
          if (stream.eatSpace()) {
            return null;
          }
          if (stt.state === '') { // interpretation
            if (stream.match(/^(\]|:NONAME)(\s|$)/i)) {
              stt.state = ' compilation';
              return 'builtin compilation';
            }
            mat = stream.match(/^(\:)\s+(\S+)(\s|$)+/);
            if (mat) {
              stt.wordList.push({name: mat[2].toUpperCase()});
              stt.state = ' compilation';
              return 'def' + stt.state;
            }
            mat = stream.match(/^(VARIABLE|2VARIABLE|CONSTANT|2CONSTANT|CREATE|POSTPONE|VALUE|WORD)\s+(\S+)(\s|$)+/i);
            if (mat) {
              stt.wordList.push({name: mat[2].toUpperCase()});
              return 'def' + stt.state;
            }
            mat = stream.match(/^(\'|\[\'\])\s+(\S+)(\s|$)+/);
            if (mat) {
              return 'builtin' + stt.state;
            }
            } else { // compilation
            // ; [
            if (stream.match(/^(\;|\[)(\s)/)) {
              stt.state = '';
              stream.backUp(1);
              return 'builtin compilation';
            }
            if (stream.match(/^(\;|\[)($)/)) {
              stt.state = '';
              return 'builtin compilation';
            }
            if (stream.match(/^(POSTPONE)\s+\S+(\s|$)+/)) {
              return 'builtin';
            }
          }

          // dynamic wordlist
          mat = stream.match(/^(\S+)(\s+|$)/);
          if (mat) {
            if (searchWordList(stt.wordList, mat[1]) !== undefined) {
              return 'variable' + stt.state;
            }

            // comments
            if (mat[1] === '\\') {
              stream.skipToEnd();
                return 'comment' + stt.state;
              }

              // core words
              if (searchWordList(stt.coreWordList, mat[1]) !== undefined) {
                return 'builtin' + stt.state;
              }
              if (searchWordList(stt.immediateWordList, mat[1]) !== undefined) {
                return 'keyword' + stt.state;
              }

              if (mat[1] === '(') {
                stream.eatWhile(function (s) { return s !== ')'; });
                stream.eat(')');
                return 'comment' + stt.state;
              }

              // // strings
              if (mat[1] === '.(') {
                stream.eatWhile(function (s) { return s !== ')'; });
                stream.eat(')');
                return 'string' + stt.state;
              }
              if (mat[1] === 'S"' || mat[1] === '."' || mat[1] === 'C"') {
                stream.eatWhile(function (s) { return s !== '"'; });
                stream.eat('"');
                return 'string' + stt.state;
              }

              // numbers
              if (mat[1] - 0xfffffffff) {
                return 'number' + stt.state;
              }
              // if (mat[1].match(/^[-+]?[0-9]+\.[0-9]*/)) {
              //     return 'number' + stt.state;
              // }

              return 'atom' + stt.state;
            }
          }
        };
      });
      CodeMirror.defineMIME("text/x-forth", "forth");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-gfm-gfm.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../markdown/markdown"), require("../../addon/mode/overlay"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i

    CodeMirror.defineMode("gfm", function(config, modeConfig) {
      var codeDepth = 0;
      function blankLine(state) {
        state.code = false;
        return null;
      }
      var gfmOverlay = {
        startState: function() {
          return {
            code: false,
            codeBlock: false,
            ateSpace: false
          };
        },
        copyState: function(s) {
          return {
            code: s.code,
            codeBlock: s.codeBlock,
            ateSpace: s.ateSpace
          };
        },
        token: function(stream, state) {
          state.combineTokens = null;

          // Hack to prevent formatting override inside code blocks (block and inline)
          if (state.codeBlock) {
            if (stream.match(/^```+/)) {
              state.codeBlock = false;
              return null;
            }
            stream.skipToEnd();
            return null;
          }
          if (stream.sol()) {
            state.code = false;
          }
          if (stream.sol() && stream.match(/^```+/)) {
            stream.skipToEnd();
            state.codeBlock = true;
            return null;
          }
          // If this block is changed, it may need to be updated in Markdown mode
          if (stream.peek() === '`') {
            stream.next();
            var before = stream.pos;
            stream.eatWhile('`');
            var difference = 1 + stream.pos - before;
            if (!state.code) {
              codeDepth = difference;
              state.code = true;
            } else {
              if (difference === codeDepth) { // Must be exact
                state.code = false;
              }
            }
            return null;
          } else if (state.code) {
            stream.next();
            return null;
          }
          // Check if space. If so, links can be formatted later on
          if (stream.eatSpace()) {
            state.ateSpace = true;
            return null;
          }
          if (stream.sol() || state.ateSpace) {
            state.ateSpace = false;
            if (modeConfig.gitHubSpice !== false) {
              if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
                // User/Project@SHA
                // User@SHA
                // SHA
                state.combineTokens = true;
                return "link";
              } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                // User/Project#Num
                // User#Num
                // #Num
                state.combineTokens = true;
                return "link";
              }
            }
          }
          if (stream.match(urlRE) &&
              stream.string.slice(stream.start - 2, stream.start) != "](" &&
              (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
            // URLs
            // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
            // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
            // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
            state.combineTokens = true;
            return "link";
          }
          stream.next();
          return null;
        },
        blankLine: blankLine
      };

      var markdownConfig = {
        taskLists: true,
        strikethrough: true,
        emoji: true
      };
      for (var attr in modeConfig) {
        markdownConfig[attr] = modeConfig[attr];
      }
      markdownConfig.name = "markdown";
      return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);

    }, "markdown");

      CodeMirror.defineMIME("text/x-gfm", "gfm");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-groovy-groovy.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("groovy", function(config) {
      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var keywords = words(
        "abstract as assert boolean break byte case catch char class const continue def default " +
        "do double else enum extends final finally float for goto if implements import in " +
        "instanceof int interface long native new package private protected public return " +
        "short static strictfp super switch synchronized threadsafe throw throws trait transient " +
        "try void volatile while");
      var blockKeywords = words("catch class def do else enum finally for if interface switch trait try while");
      var standaloneKeywords = words("return break continue");
      var atoms = words("null true false this");

      var curPunc;
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          return startString(ch, stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          if (stream.eat(/eE/)) { stream.eat(/\+\-/); stream.eatWhile(/\d/); }
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize.push(tokenComment);
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
          if (expectExpression(state.lastToken, false)) {
            return startString(ch, stream, state);
          }
        }
        if (ch == "-" && stream.eat(">")) {
          curPunc = "->";
          return null;
        }
        if (/[+\-*&%=<>!?|\/~]/.test(ch)) {
          stream.eatWhile(/[+\-*&%=<>|~]/);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        if (ch == "@") { stream.eatWhile(/[\w\$_\.]/); return "meta"; }
        if (state.lastToken == ".") return "property";
        if (stream.eat(":")) { curPunc = "proplabel"; return "property"; }
        var cur = stream.current();
        if (atoms.propertyIsEnumerable(cur)) { return "atom"; }
        if (keywords.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = "standalone";
          return "keyword";
        }
        return "variable";
      }
      tokenBase.isBase = true;

      function startString(quote, stream, state) {
        var tripleQuoted = false;
        if (quote != "/" && stream.eat(quote)) {
          if (stream.eat(quote)) tripleQuoted = true;
          else return "string";
        }
        function t(stream, state) {
          var escaped = false, next, end = !tripleQuoted;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              if (!tripleQuoted) { break; }
              if (stream.match(quote + quote)) { end = true; break; }
            }
            if (quote == '"' && next == "$" && !escaped && stream.eat("{")) {
              state.tokenize.push(tokenBaseUntilBrace());
              return "string";
            }
            escaped = !escaped && next == "\\";
          }
          if (end) state.tokenize.pop();
          return "string";
        }
        state.tokenize.push(t);
        return t(stream, state);
      }

      function tokenBaseUntilBrace() {
        var depth = 1;
        function t(stream, state) {
          if (stream.peek() == "}") {
            depth--;
            if (depth == 0) {
              state.tokenize.pop();
              return state.tokenize[state.tokenize.length-1](stream, state);
            }
          } else if (stream.peek() == "{") {
            depth++;
          }
          return tokenBase(stream, state);
        }
        t.isBase = true;
        return t;
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize.pop();
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function expectExpression(last, newline) {
        return !last || last == "operator" || last == "->" || /[\.\[\{\(,;:]/.test(last) ||
          last == "newstatement" || last == "keyword" || last == "proplabel" ||
          (last == "standalone" && !newline);
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: [tokenBase],
            context: new Context((basecolumn || 0) - config.indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true,
            lastToken: null
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
            // Automatic semicolon insertion
            if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) {
              popContext(state); ctx = state.context;
            }
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = state.tokenize[state.tokenize.length-1](stream, state);
          if (style == "comment") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          // Handle indentation for {x -> \n ... }
          else if (curPunc == "->" && ctx.type == "statement" && ctx.prev.type == "}") {
            popContext(state);
            state.context.align = false;
          }
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          state.lastToken = curPunc || style;
          return style;
        },

        indent: function(state, textAfter) {
          if (!state.tokenize[state.tokenize.length-1].isBase) return CodeMirror.Pass;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.context;
          if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) ctx = ctx.prev;
          var closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : config.indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : config.indentUnit);
        },

        electricChars: "{}",
        closeBrackets: {triples: "'\""},
        fold: "brace",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME("text/x-groovy", "groovy");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-haml-haml.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"), require("../ruby/ruby"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../ruby/ruby"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

      // full haml mode. This handled embedded ruby and html fragments too
      CodeMirror.defineMode("haml", function(config) {
        var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
        var rubyMode = CodeMirror.getMode(config, "ruby");

        function rubyInQuote(endQuote) {
          return function(stream, state) {
            var ch = stream.peek();
            if (ch == endQuote && state.rubyState.tokenize.length == 1) {
              // step out of ruby context as it seems to complete processing all the braces
              stream.next();
              state.tokenize = html;
              return "closeAttributeTag";
            } else {
              return ruby(stream, state);
            }
          };
        }

        function ruby(stream, state) {
          if (stream.match("-#")) {
            stream.skipToEnd();
            return "comment";
          }
          return rubyMode.token(stream, state.rubyState);
        }

        function html(stream, state) {
          var ch = stream.peek();

          // handle haml declarations. All declarations that cant be handled here
          // will be passed to html mode
          if (state.previousToken.style == "comment" ) {
            if (state.indented > state.previousToken.indented) {
              stream.skipToEnd();
              return "commentLine";
            }
          }

          if (state.startOfLine) {
            if (ch == "!" && stream.match("!!")) {
              stream.skipToEnd();
              return "tag";
            } else if (stream.match(/^%[\w:#\.]+=/)) {
              state.tokenize = ruby;
              return "hamlTag";
            } else if (stream.match(/^%[\w:]+/)) {
              return "hamlTag";
            } else if (ch == "/" ) {
              stream.skipToEnd();
              return "comment";
            }
          }

          if (state.startOfLine || state.previousToken.style == "hamlTag") {
            if ( ch == "#" || ch == ".") {
              stream.match(/[\w-#\.]*/);
              return "hamlAttribute";
            }
          }

          // do not handle --> as valid ruby, make it HTML close comment instead
          if (state.startOfLine && !stream.match("-->", false) && (ch == "=" || ch == "-" )) {
            state.tokenize = ruby;
            return state.tokenize(stream, state);
          }

          if (state.previousToken.style == "hamlTag" ||
              state.previousToken.style == "closeAttributeTag" ||
              state.previousToken.style == "hamlAttribute") {
            if (ch == "(") {
              state.tokenize = rubyInQuote(")");
              return state.tokenize(stream, state);
            } else if (ch == "{") {
              if (!stream.match(/^\{%.*/)) {
                state.tokenize = rubyInQuote("}");
                return state.tokenize(stream, state);
              }
            }
          }

          return htmlMode.token(stream, state.htmlState);
        }

        return {
          // default to html mode
          startState: function() {
            var htmlState = CodeMirror.startState(htmlMode);
            var rubyState = CodeMirror.startState(rubyMode);
            return {
              htmlState: htmlState,
              rubyState: rubyState,
              indented: 0,
              previousToken: { style: null, indented: 0},
              tokenize: html
            };
          },

          copyState: function(state) {
            return {
              htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
              rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
              indented: state.indented,
              previousToken: state.previousToken,
              tokenize: state.tokenize
            };
          },

          token: function(stream, state) {
            if (stream.sol()) {
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            state.startOfLine = false;
            // dont record comment line as we only want to measure comment line with
            // the opening comment block
            if (style && style != "commentLine") {
              state.previousToken = { style: style, indented: state.indented };
            }
            // if current state is ruby and the previous token is not `,` reset the
            // tokenize to html
            if (stream.eol() && state.tokenize == ruby) {
              stream.backUp(1);
              var ch = stream.peek();
              stream.next();
              if (ch && ch != ",") {
                state.tokenize = html;
              }
            }
            // reprocess some of the specific style tag when finish setting previousToken
            if (style == "hamlTag") {
              style = "tag";
            } else if (style == "commentLine") {
              style = "comment";
            } else if (style == "hamlAttribute") {
              style = "attribute";
            } else if (style == "closeAttributeTag") {
              style = null;
            }
            return style;
          }
        };
      }, "htmlmixed", "ruby");

      CodeMirror.defineMIME("text/x-haml", "haml");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-haskell-haskell.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("haskell", function(_config, modeConfig) {

      function switchState(source, setState, f) {
        setState(f);
        return f(source, setState);
      }

      // These should all be Unicode extended, as per the Haskell 2010 report
      var smallRE = /[a-z_]/;
      var largeRE = /[A-Z]/;
      var digitRE = /\d/;
      var hexitRE = /[0-9A-Fa-f]/;
      var octitRE = /[0-7]/;
      var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
      var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
      var specialRE = /[(),;[\]`{}]/;
      var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

      function normal(source, setState) {
        if (source.eatWhile(whiteCharRE)) {
          return null;
        }

        var ch = source.next();
        if (specialRE.test(ch)) {
          if (ch == '{' && source.eat('-')) {
            var t = "comment";
            if (source.eat('#')) {
              t = "meta";
            }
            return switchState(source, setState, ncomment(t, 1));
          }
          return null;
        }

        if (ch == '\'') {
          if (source.eat('\\')) {
            source.next();  // should handle other escapes here
          }
          else {
            source.next();
          }
          if (source.eat('\'')) {
            return "string";
          }
          return "string error";
        }

        if (ch == '"') {
          return switchState(source, setState, stringLiteral);
        }

        if (largeRE.test(ch)) {
          source.eatWhile(idRE);
          if (source.eat('.')) {
            return "qualifier";
          }
          return "variable-2";
        }

        if (smallRE.test(ch)) {
          source.eatWhile(idRE);
          return "variable";
        }

        if (digitRE.test(ch)) {
          if (ch == '0') {
            if (source.eat(/[xX]/)) {
              source.eatWhile(hexitRE); // should require at least 1
              return "integer";
            }
            if (source.eat(/[oO]/)) {
              source.eatWhile(octitRE); // should require at least 1
              return "number";
            }
          }
          source.eatWhile(digitRE);
          var t = "number";
          if (source.match(/^\.\d+/)) {
            t = "number";
          }
          if (source.eat(/[eE]/)) {
            t = "number";
            source.eat(/[-+]/);
            source.eatWhile(digitRE); // should require at least 1
          }
          return t;
        }

        if (ch == "." && source.eat("."))
          return "keyword";

        if (symbolRE.test(ch)) {
          if (ch == '-' && source.eat(/-/)) {
            source.eatWhile(/-/);
            if (!source.eat(symbolRE)) {
              source.skipToEnd();
              return "comment";
            }
          }
          var t = "variable";
          if (ch == ':') {
            t = "variable-2";
          }
          source.eatWhile(symbolRE);
          return t;
        }

        return "error";
      }

      function ncomment(type, nest) {
        if (nest == 0) {
          return normal;
        }
        return function(source, setState) {
          var currNest = nest;
          while (!source.eol()) {
            var ch = source.next();
            if (ch == '{' && source.eat('-')) {
              ++currNest;
            }
            else if (ch == '-' && source.eat('}')) {
              --currNest;
              if (currNest == 0) {
                setState(normal);
                return type;
              }
            }
          }
          setState(ncomment(type, currNest));
          return type;
        };
      }

      function stringLiteral(source, setState) {
        while (!source.eol()) {
          var ch = source.next();
          if (ch == '"') {
            setState(normal);
            return "string";
          }
          if (ch == '\\') {
            if (source.eol() || source.eat(whiteCharRE)) {
              setState(stringGap);
              return "string";
            }
            if (source.eat('&')) {
            }
            else {
              source.next(); // should handle other escapes here
            }
          }
        }
        setState(normal);
        return "string error";
      }

      function stringGap(source, setState) {
        if (source.eat('\\')) {
          return switchState(source, setState, stringLiteral);
        }
        source.next();
        setState(normal);
        return "error";
      }


      var wellKnownWords = (function() {
        var wkw = {};
        function setType(t) {
          return function () {
            for (var i = 0; i < arguments.length; i++)
              wkw[arguments[i]] = t;
          };
        }

        setType("keyword")(
          "case", "class", "data", "default", "deriving", "do", "else", "foreign",
          "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
          "module", "newtype", "of", "then", "type", "where", "_");

        setType("keyword")(
          "\.\.", ":", "::", "=", "\\", "<-", "->", "@", "~", "=>");

        setType("builtin")(
          "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<*", "<=",
          "<$>", "<*>", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*",
          "*>", "**");

        setType("builtin")(
          "Applicative", "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum",
          "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor",
          "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
          "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
          "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
          "String", "True");

        setType("builtin")(
          "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
          "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
          "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
          "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
          "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
          "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
          "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
          "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
          "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
          "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
          "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
          "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
          "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
          "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
          "otherwise", "pi", "pred", "print", "product", "properFraction", "pure",
          "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
          "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
          "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
          "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
          "sequence", "sequence_", "show", "showChar", "showList", "showParen",
          "showString", "shows", "showsPrec", "significand", "signum", "sin",
          "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
          "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
          "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
          "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
          "zip3", "zipWith", "zipWith3");

        var override = modeConfig.overrideKeywords;
        if (override) for (var word in override) if (override.hasOwnProperty(word))
          wkw[word] = override[word];

        return wkw;
      })();



      return {
        startState: function ()  { return { f: normal }; },
        copyState:  function (s) { return { f: s.f }; },

        token: function(stream, state) {
          var t = state.f(stream, function(s) { state.f = s; });
          var w = stream.current();
          return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
        },

        blockCommentStart: "{-",
        blockCommentEnd: "-}",
        lineComment: "--"
      };

    });

    CodeMirror.defineMIME("text/x-haskell", "haskell");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-haskell-literate-haskell-literate.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function (mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../haskell/haskell"))
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../haskell/haskell"], mod)
      else // Plain browser env
        mod(CodeMirror)
    })(function (CodeMirror) {
      "use strict"

      CodeMirror.defineMode("haskell-literate", function (config, parserConfig) {
        var baseMode = CodeMirror.getMode(config, (parserConfig && parserConfig.base) || "haskell")

        return {
          startState: function () {
            return {
              inCode: false,
              baseState: CodeMirror.startState(baseMode)
            }
          },
          token: function (stream, state) {
            if (stream.sol()) {
              if (state.inCode = stream.eat(">"))
                return "meta"
            }
            if (state.inCode) {
              return baseMode.token(stream, state.baseState)
            } else {
              stream.skipToEnd()
              return "comment"
            }
          },
          innerMode: function (state) {
            return state.inCode ? {state: state.baseState, mode: baseMode} : null
          }
        }
      }, "haskell")

      CodeMirror.defineMIME("text/x-literate-haskell", "haskell-literate")
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-jinja2-jinja2.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("jinja2", function() {
        var keywords = ["and", "as", "block", "endblock", "by", "cycle", "debug", "else", "elif",
          "extends", "filter", "endfilter", "firstof", "for",
          "endfor", "if", "endif", "ifchanged", "endifchanged",
          "ifequal", "endifequal", "ifnotequal",
          "endifnotequal", "in", "include", "load", "not", "now", "or",
          "parsed", "regroup", "reversed", "spaceless",
          "endspaceless", "ssi", "templatetag", "openblock",
          "closeblock", "openvariable", "closevariable",
          "openbrace", "closebrace", "opencomment",
          "closecomment", "widthratio", "url", "with", "endwith",
          "get_current_language", "trans", "endtrans", "noop", "blocktrans",
          "endblocktrans", "get_available_languages",
          "get_current_language_bidi", "plural"],
        operator = /^[+\-*&%=<>!?|~^]/,
        sign = /^[:\[\(\{]/,
        atom = ["true", "false"],
        number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

        keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
        atom = new RegExp("((" + atom.join(")|(") + "))\\b");

        function tokenBase (stream, state) {
          var ch = stream.peek();

          //Comment
          if (state.incomment) {
            if(!stream.skipTo("#}")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\#|}/);
              state.incomment = false;
            }
            return "comment";
          //Tag
          } else if (state.intag) {
            //After operator
            if(state.operator) {
              state.operator = false;
              if(stream.match(atom)) {
                return "atom";
              }
              if(stream.match(number)) {
                return "number";
              }
            }
            //After sign
            if(state.sign) {
              state.sign = false;
              if(stream.match(atom)) {
                return "atom";
              }
              if(stream.match(number)) {
                return "number";
              }
            }

            if(state.instring) {
              if(ch == state.instring) {
                state.instring = false;
              }
              stream.next();
              return "string";
            } else if(ch == "'" || ch == '"') {
              state.instring = ch;
              stream.next();
              return "string";
            } else if(stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
              state.intag = false;
              return "tag";
            } else if(stream.match(operator)) {
              state.operator = true;
              return "operator";
            } else if(stream.match(sign)) {
              state.sign = true;
            } else {
              if(stream.eat(" ") || stream.sol()) {
                if(stream.match(keywords)) {
                  return "keyword";
                }
                if(stream.match(atom)) {
                  return "atom";
                }
                if(stream.match(number)) {
                  return "number";
                }
                if(stream.sol()) {
                  stream.next();
                }
              } else {
                stream.next();
              }

            }
            return "variable";
          } else if (stream.eat("{")) {
            if (stream.eat("#")) {
              state.incomment = true;
              if(!stream.skipTo("#}")) {
                stream.skipToEnd();
              } else {
                stream.eatWhile(/\#|}/);
                state.incomment = false;
              }
              return "comment";
            //Open tag
            } else if (ch = stream.eat(/\{|%/)) {
              //Cache close tag
              state.intag = ch;
              if(ch == "{") {
                state.intag = "}";
              }
              stream.eat("-");
              return "tag";
            }
          }
          stream.next();
        };

        return {
          startState: function () {
            return {tokenize: tokenBase};
          },
          token: function (stream, state) {
            return state.tokenize(stream, state);
          },
          blockCommentStart: "{#",
          blockCommentEnd: "#}"
        };
      });

      CodeMirror.defineMIME("text/jinja2", "jinja2");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-jsx-jsx.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"))
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript"], mod)
      else // Plain browser env
        mod(CodeMirror)
    })(function(CodeMirror) {
      "use strict"

      // Depth means the amount of open braces in JS context, in XML
      // context 0 means not in tag, 1 means in tag, and 2 means in tag
      // and js block comment.
      function Context(state, mode, depth, prev) {
        this.state = state; this.mode = mode; this.depth = depth; this.prev = prev
      }

      function copyContext(context) {
        return new Context(CodeMirror.copyState(context.mode, context.state),
                           context.mode,
                           context.depth,
                           context.prev && copyContext(context.prev))
      }

      CodeMirror.defineMode("jsx", function(config, modeConfig) {
        var xmlMode = CodeMirror.getMode(config, {name: "xml", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})
        var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript")

        function flatXMLIndent(state) {
          var tagName = state.tagName
          state.tagName = null
          var result = xmlMode.indent(state, "", "")
          state.tagName = tagName
          return result
        }

        function token(stream, state) {
          if (state.context.mode == xmlMode)
            return xmlToken(stream, state, state.context)
          else
            return jsToken(stream, state, state.context)
        }

        function xmlToken(stream, state, cx) {
          if (cx.depth == 2) { // Inside a JS /* */ comment
            if (stream.match(/^.*?\*\//)) cx.depth = 1
            else stream.skipToEnd()
            return "comment"
          }

          if (stream.peek() == "{") {
            xmlMode.skipAttribute(cx.state)

            var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context
            // If JS starts on same line as tag
            if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
              while (xmlContext.prev && !xmlContext.startOfLine)
                xmlContext = xmlContext.prev
              // If tag starts the line, use XML indentation level
              if (xmlContext.startOfLine) indent -= config.indentUnit
              // Else use JS indentation level
              else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented
            // Else if inside of tag
            } else if (cx.depth == 1) {
              indent += config.indentUnit
            }

            state.context = new Context(CodeMirror.startState(jsMode, indent),
                                        jsMode, 0, state.context)
            return null
          }

          if (cx.depth == 1) { // Inside of tag
            if (stream.peek() == "<") { // Tag inside of tag
              xmlMode.skipAttribute(cx.state)
              state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),
                                          xmlMode, 0, state.context)
              return null
            } else if (stream.match("//")) {
              stream.skipToEnd()
              return "comment"
            } else if (stream.match("/*")) {
              cx.depth = 2
              return token(stream, state)
            }
          }

          var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop
          if (/\btag\b/.test(style)) {
            if (/>$/.test(cur)) {
              if (cx.state.context) cx.depth = 0
              else state.context = state.context.prev
            } else if (/^</.test(cur)) {
              cx.depth = 1
            }
          } else if (!style && (stop = cur.indexOf("{")) > -1) {
            stream.backUp(cur.length - stop)
          }
          return style
        }

        function jsToken(stream, state, cx) {
          if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
            state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "", "")),
                                        xmlMode, 0, state.context)
            jsMode.skipExpression(cx.state)
            return null
          }

          var style = jsMode.token(stream, cx.state)
          if (!style && cx.depth != null) {
            var cur = stream.current()
            if (cur == "{") {
              cx.depth++
            } else if (cur == "}") {
              if (--cx.depth == 0) state.context = state.context.prev
            }
          }
          return style
        }

        return {
          startState: function() {
            return {context: new Context(CodeMirror.startState(jsMode), jsMode)}
          },

          copyState: function(state) {
            return {context: copyContext(state.context)}
          },

          token: token,

          indent: function(state, textAfter, fullLine) {
            return state.context.mode.indent(state.context.state, textAfter, fullLine)
          },

          innerMode: function(state) {
            return state.context
          }
        }
      }, "xml", "javascript")

      CodeMirror.defineMIME("text/jsx", "jsx")
      CodeMirror.defineMIME("text/typescript-jsx", {name: "jsx", base: {name: "javascript", typescript: true}})
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-julia-julia.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("julia", function(config, parserConf) {
      function wordRegexp(words, end, pre) {
        if (typeof pre === "undefined") { pre = ""; }
        if (typeof end === "undefined") { end = "\\b"; }
        return new RegExp("^" + pre + "((" + words.join(")|(") + "))" + end);
      }

      var octChar = "\\\\[0-7]{1,3}";
      var hexChar = "\\\\x[A-Fa-f0-9]{1,2}";
      var sChar = "\\\\[abefnrtv0%?'\"\\\\]";
      var uChar = "([^\\u0027\\u005C\\uD800-\\uDFFF]|[\\uD800-\\uDFFF][\\uDC00-\\uDFFF])";

      var asciiOperatorsList = [
        "[<>]:", "[<>=]=", "<<=?", ">>>?=?", "=>", "--?>", "<--[->]?", "\\/\\/",
        "\\.{2,3}", "[\\.\\\\%*+\\-<>!\\/^|&]=?", "\\?", "\\$", "~", ":"
      ];
      var operators = parserConf.operators || wordRegexp([
        "[<>]:", "[<>=]=", "<<=?", ">>>?=?", "=>", "--?>", "<--[->]?", "\\/\\/",
        "[\\\\%*+\\-<>!\\/^|&\\u00F7\\u22BB]=?", "\\?", "\\$", "~", ":",
        "\\u00D7", "\\u2208", "\\u2209", "\\u220B", "\\u220C", "\\u2218",
        "\\u221A", "\\u221B", "\\u2229", "\\u222A", "\\u2260", "\\u2264",
        "\\u2265", "\\u2286", "\\u2288", "\\u228A", "\\u22C5",
        "\\b(in|isa)\\b(?!\.?\\()"
      ], "");
      var delimiters = parserConf.delimiters || /^[;,()[\]{}]/;
      var identifiers = parserConf.identifiers ||
            /^[_A-Za-z\u00A1-\u2217\u2219-\uFFFF][\w\u00A1-\u2217\u2219-\uFFFF]*!*/;

      var chars = wordRegexp([octChar, hexChar, sChar, uChar], "'");

      var openersList = ["begin", "function", "type", "struct", "immutable", "let",
            "macro", "for", "while", "quote", "if", "else", "elseif", "try",
            "finally", "catch", "do"];

      var closersList = ["end", "else", "elseif", "catch", "finally"];

      var keywordsList = ["if", "else", "elseif", "while", "for", "begin", "let",
            "end", "do", "try", "catch", "finally", "return", "break", "continue",
            "global", "local", "const", "export", "import", "importall", "using",
            "function", "where", "macro", "module", "baremodule", "struct", "type",
            "mutable", "immutable", "quote", "typealias", "abstract", "primitive",
            "bitstype"];

      var builtinsList = ["true", "false", "nothing", "NaN", "Inf"];

      CodeMirror.registerHelper("hintWords", "julia", keywordsList.concat(builtinsList));

      var openers = wordRegexp(openersList);
      var closers = wordRegexp(closersList);
      var keywords = wordRegexp(keywordsList);
      var builtins = wordRegexp(builtinsList);

      var macro = /^@[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;
      var symbol = /^:[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;
      var stringPrefixes = /^(`|([_A-Za-z\u00A1-\uFFFF]*"("")?))/;

      var macroOperators = wordRegexp(asciiOperatorsList, "", "@");
      var symbolOperators = wordRegexp(asciiOperatorsList, "", ":");

      function inArray(state) {
        return (state.nestedArrays > 0);
      }

      function inGenerator(state) {
        return (state.nestedGenerators > 0);
      }

      function currentScope(state, n) {
        if (typeof(n) === "undefined") { n = 0; }
        if (state.scopes.length <= n) {
          return null;
        }
        return state.scopes[state.scopes.length - (n + 1)];
      }

      // tokenizers
      function tokenBase(stream, state) {
        // Handle multiline comments
        if (stream.match('#=', false)) {
          state.tokenize = tokenComment;
          return state.tokenize(stream, state);
        }

        // Handle scope changes
        var leavingExpr = state.leavingExpr;
        if (stream.sol()) {
          leavingExpr = false;
        }
        state.leavingExpr = false;

        if (leavingExpr) {
          if (stream.match(/^'+/)) {
            return "operator";
          }
        }

        if (stream.match(/\.{4,}/)) {
          return "error";
        } else if (stream.match(/\.{1,3}/)) {
          return "operator";
        }

        if (stream.eatSpace()) {
          return null;
        }

        var ch = stream.peek();

        // Handle single line comments
        if (ch === '#') {
          stream.skipToEnd();
          return "comment";
        }

        if (ch === '[') {
          state.scopes.push('[');
          state.nestedArrays++;
        }

        if (ch === '(') {
          state.scopes.push('(');
          state.nestedGenerators++;
        }

        if (inArray(state) && ch === ']') {
          while (state.scopes.length && currentScope(state) !== "[") { state.scopes.pop(); }
          state.scopes.pop();
          state.nestedArrays--;
          state.leavingExpr = true;
        }

        if (inGenerator(state) && ch === ')') {
          while (state.scopes.length && currentScope(state) !== "(") { state.scopes.pop(); }
          state.scopes.pop();
          state.nestedGenerators--;
          state.leavingExpr = true;
        }

        if (inArray(state)) {
          if (state.lastToken == "end" && stream.match(':')) {
            return "operator";
          }
          if (stream.match('end')) {
            return "number";
          }
        }

        var match;
        if (match = stream.match(openers, false)) {
          state.scopes.push(match[0]);
        }

        if (stream.match(closers, false)) {
          state.scopes.pop();
        }

        // Handle type annotations
        if (stream.match(/^::(?![:\$])/)) {
          state.tokenize = tokenAnnotation;
          return state.tokenize(stream, state);
        }

        // Handle symbols
        if (!leavingExpr && (stream.match(symbol) || stream.match(symbolOperators))) {
          return "builtin";
        }

        // Handle parametric types
        //if (stream.match(/^{[^}]*}(?=\()/)) {
        //  return "builtin";
        //}

        // Handle operators and Delimiters
        if (stream.match(operators)) {
          return "operator";
        }

        // Handle Number Literals
        if (stream.match(/^\.?\d/, false)) {
          var imMatcher = RegExp(/^im\b/);
          var numberLiteral = false;
          if (stream.match(/^0x\.[0-9a-f_]+p[\+\-]?[_\d]+/i)) { numberLiteral = true; }
          // Integers
          if (stream.match(/^0x[0-9a-f_]+/i)) { numberLiteral = true; } // Hex
          if (stream.match(/^0b[01_]+/i)) { numberLiteral = true; } // Binary
          if (stream.match(/^0o[0-7_]+/i)) { numberLiteral = true; } // Octal
          // Floats
          if (stream.match(/^(?:(?:\d[_\d]*)?\.(?!\.)(?:\d[_\d]*)?|\d[_\d]*\.(?!\.)(?:\d[_\d]*))?([Eef][\+\-]?[_\d]+)?/i)) { numberLiteral = true; }
          if (stream.match(/^\d[_\d]*(e[\+\-]?\d+)?/i)) { numberLiteral = true; } // Decimal
          if (numberLiteral) {
              // Integer literals may be "long"
              stream.match(imMatcher);
              state.leavingExpr = true;
              return "number";
          }
        }

        // Handle Chars
        if (stream.match('\'')) {
          state.tokenize = tokenChar;
          return state.tokenize(stream, state);
        }

        // Handle Strings
        if (stream.match(stringPrefixes)) {
          state.tokenize = tokenStringFactory(stream.current());
          return state.tokenize(stream, state);
        }

        if (stream.match(macro) || stream.match(macroOperators)) {
          return "meta";
        }

        if (stream.match(delimiters)) {
          return null;
        }

        if (stream.match(keywords)) {
          return "keyword";
        }

        if (stream.match(builtins)) {
          return "builtin";
        }

        var isDefinition = state.isDefinition || state.lastToken == "function" ||
                           state.lastToken == "macro" || state.lastToken == "type" ||
                           state.lastToken == "struct" || state.lastToken == "immutable";

        if (stream.match(identifiers)) {
          if (isDefinition) {
            if (stream.peek() === '.') {
              state.isDefinition = true;
              return "variable";
            }
            state.isDefinition = false;
            return "def";
          }
          state.leavingExpr = true;
          return "variable";
        }

        // Handle non-detected items
        stream.next();
        return "error";
      }

      function tokenAnnotation(stream, state) {
        stream.match(/.*?(?=[,;{}()=\s]|$)/);
        if (stream.match('{')) {
          state.nestedParameters++;
        } else if (stream.match('}') && state.nestedParameters > 0) {
          state.nestedParameters--;
        }
        if (state.nestedParameters > 0) {
          stream.match(/.*?(?={|})/) || stream.next();
        } else if (state.nestedParameters == 0) {
          state.tokenize = tokenBase;
        }
        return "builtin";
      }

      function tokenComment(stream, state) {
        if (stream.match('#=')) {
          state.nestedComments++;
        }
        if (!stream.match(/.*?(?=(#=|=#))/)) {
          stream.skipToEnd();
        }
        if (stream.match('=#')) {
          state.nestedComments--;
          if (state.nestedComments == 0)
            state.tokenize = tokenBase;
        }
        return "comment";
      }

      function tokenChar(stream, state) {
        var isChar = false, match;
        if (stream.match(chars)) {
          isChar = true;
        } else if (match = stream.match(/\\u([a-f0-9]{1,4})(?=')/i)) {
          var value = parseInt(match[1], 16);
          if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)
            isChar = true;
            stream.next();
          }
        } else if (match = stream.match(/\\U([A-Fa-f0-9]{5,8})(?=')/)) {
          var value = parseInt(match[1], 16);
          if (value <= 1114111) { // U+10FFFF
            isChar = true;
            stream.next();
          }
        }
        if (isChar) {
          state.leavingExpr = true;
          state.tokenize = tokenBase;
          return "string";
        }
        if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }
        if (stream.match('\'')) { state.tokenize = tokenBase; }
        return "error";
      }

      function tokenStringFactory(delimiter) {
        if (delimiter.substr(-3) === '"""') {
          delimiter = '"""';
        } else if (delimiter.substr(-1) === '"') {
          delimiter = '"';
        }
        function tokenString(stream, state) {
          if (stream.eat('\\')) {
            stream.next();
          } else if (stream.match(delimiter)) {
            state.tokenize = tokenBase;
            state.leavingExpr = true;
            return "string";
          } else {
            stream.eat(/[`"]/);
          }
          stream.eatWhile(/[^\\`"]/);
          return "string";
        }
        return tokenString;
      }

      var external = {
        startState: function() {
          return {
            tokenize: tokenBase,
            scopes: [],
            lastToken: null,
            leavingExpr: false,
            isDefinition: false,
            nestedArrays: 0,
            nestedComments: 0,
            nestedGenerators: 0,
            nestedParameters: 0,
            firstParenPos: -1
          };
        },

        token: function(stream, state) {
          var style = state.tokenize(stream, state);
          var current = stream.current();

          if (current && style) {
            state.lastToken = current;
          }

          return style;
        },

        indent: function(state, textAfter) {
          var delta = 0;
          if ( textAfter === ']' || textAfter === ')' || /^end\b/.test(textAfter) ||
               /^else/.test(textAfter) || /^catch\b/.test(textAfter) || /^elseif\b/.test(textAfter) ||
               /^finally/.test(textAfter) ) {
            delta = -1;
          }
          return (state.scopes.length + delta) * config.indentUnit;
        },

        electricInput: /\b(end|else|catch|finally)\b/,
        blockCommentStart: "#=",
        blockCommentEnd: "=#",
        lineComment: "#",
        closeBrackets: "()[]{}\"\"",
        fold: "indent"
      };
      return external;
    });


    CodeMirror.defineMIME("text/x-julia", "julia");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-livescript-livescript.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Link to the project's GitHub page:
     * https://github.com/duralog/CodeMirror
     */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode('livescript', function(){
        var tokenBase = function(stream, state) {
          var next_rule = state.next || "start";
          if (next_rule) {
            state.next = state.next;
            var nr = Rules[next_rule];
            if (nr.splice) {
              for (var i$ = 0; i$ < nr.length; ++i$) {
                var r = nr[i$];
                if (r.regex && stream.match(r.regex)) {
                  state.next = r.next || state.next;
                  return r.token;
                }
              }
              stream.next();
              return 'error';
            }
            if (stream.match(r = Rules[next_rule])) {
              if (r.regex && stream.match(r.regex)) {
                state.next = r.next;
                return r.token;
              } else {
                stream.next();
                return 'error';
              }
            }
          }
          stream.next();
          return 'error';
        };
        var external = {
          startState: function(){
            return {
              next: 'start',
              lastToken: {style: null, indent: 0, content: ""}
            };
          },
          token: function(stream, state){
            while (stream.pos == stream.start)
              var style = tokenBase(stream, state);
            state.lastToken = {
              style: style,
              indent: stream.indentation(),
              content: stream.current()
            };
            return style.replace(/\./g, ' ');
          },
          indent: function(state){
            var indentation = state.lastToken.indent;
            if (state.lastToken.content.match(indenter)) {
              indentation += 2;
            }
            return indentation;
          }
        };
        return external;
      });

      var identifier = '(?![\\d\\s])[$\\w\\xAA-\\uFFDC](?:(?!\\s)[$\\w\\xAA-\\uFFDC]|-[A-Za-z])*';
      var indenter = RegExp('(?:[({[=:]|[-~]>|\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\s*all)?|const|var|let|new|catch(?:\\s*' + identifier + ')?))\\s*$');
      var keywordend = '(?![$\\w]|-[A-Za-z]|\\s*:(?![:=]))';
      var stringfill = {
        token: 'string',
        regex: '.+'
      };
      var Rules = {
        start: [
          {
            token: 'comment.doc',
            regex: '/\\*',
            next: 'comment'
          }, {
            token: 'comment',
            regex: '#.*'
          }, {
            token: 'keyword',
            regex: '(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)' + keywordend
          }, {
            token: 'constant.language',
            regex: '(?:true|false|yes|no|on|off|null|void|undefined)' + keywordend
          }, {
            token: 'invalid.illegal',
            regex: '(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)' + keywordend
          }, {
            token: 'language.support.class',
            regex: '(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)' + keywordend
          }, {
            token: 'language.support.function',
            regex: '(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)' + keywordend
          }, {
            token: 'variable.language',
            regex: '(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)' + keywordend
          }, {
            token: 'identifier',
            regex: identifier + '\\s*:(?![:=])'
          }, {
            token: 'variable',
            regex: identifier
          }, {
            token: 'keyword.operator',
            regex: '(?:\\.{3}|\\s+\\?)'
          }, {
            token: 'keyword.variable',
            regex: '(?:@+|::|\\.\\.)',
            next: 'key'
          }, {
            token: 'keyword.operator',
            regex: '\\.\\s*',
            next: 'key'
          }, {
            token: 'string',
            regex: '\\\\\\S[^\\s,;)}\\]]*'
          }, {
            token: 'string.doc',
            regex: '\'\'\'',
            next: 'qdoc'
          }, {
            token: 'string.doc',
            regex: '"""',
            next: 'qqdoc'
          }, {
            token: 'string',
            regex: '\'',
            next: 'qstring'
          }, {
            token: 'string',
            regex: '"',
            next: 'qqstring'
          }, {
            token: 'string',
            regex: '`',
            next: 'js'
          }, {
            token: 'string',
            regex: '<\\[',
            next: 'words'
          }, {
            token: 'string.regex',
            regex: '//',
            next: 'heregex'
          }, {
            token: 'string.regex',
            regex: '\\/(?:[^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/[gimy$]{0,4}',
            next: 'key'
          }, {
            token: 'constant.numeric',
            regex: '(?:0x[\\da-fA-F][\\da-fA-F_]*|(?:[2-9]|[12]\\d|3[0-6])r[\\da-zA-Z][\\da-zA-Z_]*|(?:\\d[\\d_]*(?:\\.\\d[\\d_]*)?|\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[\\w$]*)'
          }, {
            token: 'lparen',
            regex: '[({[]'
          }, {
            token: 'rparen',
            regex: '[)}\\]]',
            next: 'key'
          }, {
            token: 'keyword.operator',
            regex: '\\S+'
          }, {
            token: 'text',
            regex: '\\s+'
          }
        ],
        heregex: [
          {
            token: 'string.regex',
            regex: '.*?//[gimy$?]{0,4}',
            next: 'start'
          }, {
            token: 'string.regex',
            regex: '\\s*#{'
          }, {
            token: 'comment.regex',
            regex: '\\s+(?:#.*)?'
          }, {
            token: 'string.regex',
            regex: '\\S+'
          }
        ],
        key: [
          {
            token: 'keyword.operator',
            regex: '[.?@!]+'
          }, {
            token: 'identifier',
            regex: identifier,
            next: 'start'
          }, {
            token: 'text',
            regex: '',
            next: 'start'
          }
        ],
        comment: [
          {
            token: 'comment.doc',
            regex: '.*?\\*/',
            next: 'start'
          }, {
            token: 'comment.doc',
            regex: '.+'
          }
        ],
        qdoc: [
          {
            token: 'string',
            regex: ".*?'''",
            next: 'key'
          }, stringfill
        ],
        qqdoc: [
          {
            token: 'string',
            regex: '.*?"""',
            next: 'key'
          }, stringfill
        ],
        qstring: [
          {
            token: 'string',
            regex: '[^\\\\\']*(?:\\\\.[^\\\\\']*)*\'',
            next: 'key'
          }, stringfill
        ],
        qqstring: [
          {
            token: 'string',
            regex: '[^\\\\"]*(?:\\\\.[^\\\\"]*)*"',
            next: 'key'
          }, stringfill
        ],
        js: [
          {
            token: 'string',
            regex: '[^\\\\`]*(?:\\\\.[^\\\\`]*)*`',
            next: 'key'
          }, stringfill
        ],
        words: [
          {
            token: 'string',
            regex: '.*?\\]>',
            next: 'key'
          }, stringfill
        ]
      };
      for (var idx in Rules) {
        var r = Rules[idx];
        if (r.splice) {
          for (var i = 0, len = r.length; i < len; ++i) {
            var rr = r[i];
            if (typeof rr.regex === 'string') {
              Rules[idx][i].regex = new RegExp('^' + rr.regex);
            }
          }
        } else if (typeof rr.regex === 'string') {
          Rules[idx].regex = new RegExp('^' + r.regex);
        }
      }

      CodeMirror.defineMIME('text/x-livescript', 'livescript');

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-mbox-mbox.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    var rfc2822 = [
      "From", "Sender", "Reply-To", "To", "Cc", "Bcc", "Message-ID",
      "In-Reply-To", "References", "Resent-From", "Resent-Sender", "Resent-To",
      "Resent-Cc", "Resent-Bcc", "Resent-Message-ID", "Return-Path", "Received"
    ];
    var rfc2822NoEmail = [
      "Date", "Subject", "Comments", "Keywords", "Resent-Date"
    ];

    CodeMirror.registerHelper("hintWords", "mbox", rfc2822.concat(rfc2822NoEmail));

    var whitespace = /^[ \t]/;
    var separator = /^From /; // See RFC 4155
    var rfc2822Header = new RegExp("^(" + rfc2822.join("|") + "): ");
    var rfc2822HeaderNoEmail = new RegExp("^(" + rfc2822NoEmail.join("|") + "): ");
    var header = /^[^:]+:/; // Optional fields defined in RFC 2822
    var email = /^[^ ]+@[^ ]+/;
    var untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;
    var bracketedEmail = /^<.*?>/;
    var untilBracketedEmail = /^.*?(?=<.*>)/;

    function styleForHeader(header) {
      if (header === "Subject") return "header";
      return "string";
    }

    function readToken(stream, state) {
      if (stream.sol()) {
        // From last line
        state.inSeparator = false;
        if (state.inHeader && stream.match(whitespace)) {
          // Header folding
          return null;
        } else {
          state.inHeader = false;
          state.header = null;
        }

        if (stream.match(separator)) {
          state.inHeaders = true;
          state.inSeparator = true;
          return "atom";
        }

        var match;
        var emailPermitted = false;
        if ((match = stream.match(rfc2822HeaderNoEmail)) ||
            (emailPermitted = true) && (match = stream.match(rfc2822Header))) {
          state.inHeaders = true;
          state.inHeader = true;
          state.emailPermitted = emailPermitted;
          state.header = match[1];
          return "atom";
        }

        // Use vim's heuristics: recognize custom headers only if the line is in a
        // block of legitimate headers.
        if (state.inHeaders && (match = stream.match(header))) {
          state.inHeader = true;
          state.emailPermitted = true;
          state.header = match[1];
          return "atom";
        }

        state.inHeaders = false;
        stream.skipToEnd();
        return null;
      }

      if (state.inSeparator) {
        if (stream.match(email)) return "link";
        if (stream.match(untilEmail)) return "atom";
        stream.skipToEnd();
        return "atom";
      }

      if (state.inHeader) {
        var style = styleForHeader(state.header);

        if (state.emailPermitted) {
          if (stream.match(bracketedEmail)) return style + " link";
          if (stream.match(untilBracketedEmail)) return style;
        }
        stream.skipToEnd();
        return style;
      }

      stream.skipToEnd();
      return null;
    };

    CodeMirror.defineMode("mbox", function() {
      return {
        startState: function() {
          return {
            // Is in a mbox separator
            inSeparator: false,
            // Is in a mail header
            inHeader: false,
            // If bracketed email is permitted. Only applicable when inHeader
            emailPermitted: false,
            // Name of current header
            header: null,
            // Is in a region of mail headers
            inHeaders: false
          };
        },
        token: readToken,
        blankLine: function(state) {
          state.inHeaders = state.inSeparator = state.inHeader = false;
        }
      };
    });

    CodeMirror.defineMIME("application/mbox", "mbox");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-meta.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.modeInfo = [
        {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
        {name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"]},
        {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
        {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
        {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
        {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"]},
        {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
        {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"]},
        {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"]},
        {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
        {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
        {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
        {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/},
        {name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
        {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
        {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
        {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
        {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
        {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
        {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
        {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
        {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
        {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
        {name: "Django", mime: "text/x-django", mode: "django"},
        {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
        {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
        {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
        {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
        {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
        {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
        {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
        {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
        {name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
        {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
        {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
        {name: "Esper", mime: "text/x-esper", mode: "sql"},
        {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
        {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
        {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
        {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"]},
        {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
        {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
        {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
        {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i},
        {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
        {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
        {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
        {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
        {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
        {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
        {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
        {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
        {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"]},
        {name: "HTTP", mime: "message/http", mode: "http"},
        {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
        {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
        {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
        {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
        {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
         mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
        {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
        {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
        {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
        {name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"]},
        {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"]},
        {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
        {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
        {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
        {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
        {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
        {name: "mIRC", mime: "text/mirc", mode: "mirc"},
        {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
        {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"]},
        {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
        {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
        {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
        {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
        {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
        {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
        {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
        {name: "NTriples", mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
         mode: "ntriples", ext: ["nt", "nq"]},
        {name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"]},
        {name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"]},
        {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
        {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
        {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
        {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
        {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
        {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
        {name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"]},
        {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
        {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
        {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
        {name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql"},
        {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
        {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
        {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
        {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
        {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
        {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
        {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
        {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
        {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
        {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
        {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
        {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
        {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
        {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
        {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
        {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
        {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
        {name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
        {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
        {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
        {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
        {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
        {name: "Solr", mime: "text/x-solr", mode: "solr"},
        {name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"]},
        {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
        {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
        {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
        {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
        {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
        {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
        {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
        {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
        {name: "sTeX", mime: "text/x-stex", mode: "stex"},
        {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"]},
        {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"]},
        {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
        {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
        {name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
        {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
        {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
        {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
        {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
        {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
        {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
        {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
        {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
        {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
        {name: "Twig", mime: "text/x-twig", mode: "twig"},
        {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
        {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
        {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
        {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
        {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
        {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
        {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
        {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
        {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
        {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
        {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
        {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
        {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
        {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
        {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]},
        {name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"]},
      ];
      // Ensure all modes have a mime property for backwards compatibility
      for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
        var info = CodeMirror.modeInfo[i];
        if (info.mimes) info.mime = info.mimes[0];
      }

      CodeMirror.findModeByMIME = function(mime) {
        mime = mime.toLowerCase();
        for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
          var info = CodeMirror.modeInfo[i];
          if (info.mime == mime) return info;
          if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
            if (info.mimes[j] == mime) return info;
        }
        if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
        if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
      };

      CodeMirror.findModeByExtension = function(ext) {
        ext = ext.toLowerCase();
        for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
          var info = CodeMirror.modeInfo[i];
          if (info.ext) for (var j = 0; j < info.ext.length; j++)
            if (info.ext[j] == ext) return info;
        }
      };

      CodeMirror.findModeByFileName = function(filename) {
        for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
          var info = CodeMirror.modeInfo[i];
          if (info.file && info.file.test(filename)) return info;
        }
        var dot = filename.lastIndexOf(".");
        var ext = dot > -1 && filename.substring(dot + 1, filename.length);
        if (ext) return CodeMirror.findModeByExtension(ext);
      };

      CodeMirror.findModeByName = function(name) {
        name = name.toLowerCase();
        for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
          var info = CodeMirror.modeInfo[i];
          if (info.name.toLowerCase() == name) return info;
          if (info.alias) for (var j = 0; j < info.alias.length; j++)
            if (info.alias[j].toLowerCase() == name) return info;
        }
      };
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-mirc-mirc.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    //mIRC mode by Ford_Lawnmower :: Based on Velocity mode by Steve O'Hara

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMIME("text/mirc", "mirc");
    CodeMirror.defineMode("mirc", function() {
      function parseWords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var specials = parseWords("$! $$ $& $? $+ $abook $abs $active $activecid " +
                                "$activewid $address $addtok $agent $agentname $agentstat $agentver " +
                                "$alias $and $anick $ansi2mirc $aop $appactive $appstate $asc $asctime " +
                                "$asin $atan $avoice $away $awaymsg $awaytime $banmask $base $bfind " +
                                "$binoff $biton $bnick $bvar $bytes $calc $cb $cd $ceil $chan $chanmodes " +
                                "$chantypes $chat $chr $cid $clevel $click $cmdbox $cmdline $cnick $color " +
                                "$com $comcall $comchan $comerr $compact $compress $comval $cos $count " +
                                "$cr $crc $creq $crlf $ctime $ctimer $ctrlenter $date $day $daylight " +
                                "$dbuh $dbuw $dccignore $dccport $dde $ddename $debug $decode $decompress " +
                                "$deltok $devent $dialog $did $didreg $didtok $didwm $disk $dlevel $dll " +
                                "$dllcall $dname $dns $duration $ebeeps $editbox $emailaddr $encode $error " +
                                "$eval $event $exist $feof $ferr $fgetc $file $filename $filtered $finddir " +
                                "$finddirn $findfile $findfilen $findtok $fline $floor $fopen $fread $fserve " +
                                "$fulladdress $fulldate $fullname $fullscreen $get $getdir $getdot $gettok $gmt " +
                                "$group $halted $hash $height $hfind $hget $highlight $hnick $hotline " +
                                "$hotlinepos $ial $ialchan $ibl $idle $iel $ifmatch $ignore $iif $iil " +
                                "$inelipse $ini $inmidi $inpaste $inpoly $input $inrect $inroundrect " +
                                "$insong $instok $int $inwave $ip $isalias $isbit $isdde $isdir $isfile " +
                                "$isid $islower $istok $isupper $keychar $keyrpt $keyval $knick $lactive " +
                                "$lactivecid $lactivewid $left $len $level $lf $line $lines $link $lock " +
                                "$lock $locked $log $logstamp $logstampfmt $longfn $longip $lower $ltimer " +
                                "$maddress $mask $matchkey $matchtok $md5 $me $menu $menubar $menucontext " +
                                "$menutype $mid $middir $mircdir $mircexe $mircini $mklogfn $mnick $mode " +
                                "$modefirst $modelast $modespl $mouse $msfile $network $newnick $nick $nofile " +
                                "$nopath $noqt $not $notags $notify $null $numeric $numok $oline $onpoly " +
                                "$opnick $or $ord $os $passivedcc $pic $play $pnick $port $portable $portfree " +
                                "$pos $prefix $prop $protect $puttok $qt $query $rand $r $rawmsg $read $readomo " +
                                "$readn $regex $regml $regsub $regsubex $remove $remtok $replace $replacex " +
                                "$reptok $result $rgb $right $round $scid $scon $script $scriptdir $scriptline " +
                                "$sdir $send $server $serverip $sfile $sha1 $shortfn $show $signal $sin " +
                                "$site $sline $snick $snicks $snotify $sock $sockbr $sockerr $sockname " +
                                "$sorttok $sound $sqrt $ssl $sreq $sslready $status $strip $str $stripped " +
                                "$syle $submenu $switchbar $tan $target $ticks $time $timer $timestamp " +
                                "$timestampfmt $timezone $tip $titlebar $toolbar $treebar $trust $ulevel " +
                                "$ulist $upper $uptime $url $usermode $v1 $v2 $var $vcmd $vcmdstat $vcmdver " +
                                "$version $vnick $vol $wid $width $wildsite $wildtok $window $wrap $xor");
      var keywords = parseWords("abook ajinvite alias aline ame amsg anick aop auser autojoin avoice " +
                                "away background ban bcopy beep bread break breplace bset btrunc bunset bwrite " +
                                "channel clear clearall cline clipboard close cnick color comclose comopen " +
                                "comreg continue copy creq ctcpreply ctcps dcc dccserver dde ddeserver " +
                                "debug dec describe dialog did didtok disable disconnect dlevel dline dll " +
                                "dns dqwindow drawcopy drawdot drawfill drawline drawpic drawrect drawreplace " +
                                "drawrot drawsave drawscroll drawtext ebeeps echo editbox emailaddr enable " +
                                "events exit fclose filter findtext finger firewall flash flist flood flush " +
                                "flushini font fopen fseek fsend fserve fullname fwrite ghide gload gmove " +
                                "gopts goto gplay gpoint gqreq groups gshow gsize gstop gtalk gunload hadd " +
                                "halt haltdef hdec hdel help hfree hinc hload hmake hop hsave ial ialclear " +
                                "ialmark identd if ignore iline inc invite iuser join kick linesep links list " +
                                "load loadbuf localinfo log mdi me menubar mkdir mnick mode msg nick noop notice " +
                                "notify omsg onotice part partall pdcc perform play playctrl pop protect pvoice " +
                                "qme qmsg query queryn quit raw reload remini remote remove rename renwin " +
                                "reseterror resetidle return rlevel rline rmdir run ruser save savebuf saveini " +
                                "say scid scon server set showmirc signam sline sockaccept sockclose socklist " +
                                "socklisten sockmark sockopen sockpause sockread sockrename sockudp sockwrite " +
                                "sound speak splay sreq strip switchbar timer timestamp titlebar tnick tokenize " +
                                "toolbar topic tray treebar ulist unload unset unsetall updatenl url uwho " +
                                "var vcadd vcmd vcrem vol while whois window winhelp write writeint if isalnum " +
                                "isalpha isaop isavoice isban ischan ishop isignore isin isincs isletter islower " +
                                "isnotify isnum ison isop isprotect isreg isupper isvoice iswm iswmcs " +
                                "elseif else goto menu nicklist status title icon size option text edit " +
                                "button check radio box scroll list combo link tab item");
      var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
      var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }
      function tokenBase(stream, state) {
        var beforeParams = state.beforeParams;
        state.beforeParams = false;
        var ch = stream.next();
        if (/[\[\]{}\(\),\.]/.test(ch)) {
          if (ch == "(" && beforeParams) state.inParams = true;
          else if (ch == ")") state.inParams = false;
          return null;
        }
        else if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        else if (ch == "\\") {
          stream.eat("\\");
          stream.eat(/./);
          return "number";
        }
        else if (ch == "/" && stream.eat("*")) {
          return chain(stream, state, tokenComment);
        }
        else if (ch == ";" && stream.match(/ *\( *\(/)) {
          return chain(stream, state, tokenUnparsed);
        }
        else if (ch == ";" && !state.inParams) {
          stream.skipToEnd();
          return "comment";
        }
        else if (ch == '"') {
          stream.eat(/"/);
          return "keyword";
        }
        else if (ch == "$") {
          stream.eatWhile(/[$_a-z0-9A-Z\.:]/);
          if (specials && specials.propertyIsEnumerable(stream.current().toLowerCase())) {
            return "keyword";
          }
          else {
            state.beforeParams = true;
            return "builtin";
          }
        }
        else if (ch == "%") {
          stream.eatWhile(/[^,\s()]/);
          state.beforeParams = true;
          return "string";
        }
        else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        else {
          stream.eatWhile(/[\w\$_{}]/);
          var word = stream.current().toLowerCase();
          if (keywords && keywords.propertyIsEnumerable(word))
            return "keyword";
          if (functions && functions.propertyIsEnumerable(word)) {
            state.beforeParams = true;
            return "keyword";
          }
          return null;
        }
      }
      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }
      function tokenUnparsed(stream, state) {
        var maybeEnd = 0, ch;
        while (ch = stream.next()) {
          if (ch == ";" && maybeEnd == 2) {
            state.tokenize = tokenBase;
            break;
          }
          if (ch == ")")
            maybeEnd++;
          else if (ch != " ")
            maybeEnd = 0;
        }
        return "meta";
      }
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            beforeParams: false,
            inParams: false
          };
        },
        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        }
      };
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-mscgen-mscgen.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // mode(s) for the sequence chart dsl's mscgen, xù and msgenny
    // For more information on mscgen, see the site of the original author:
    // http://www.mcternan.me.uk/mscgen
    //
    // This mode for mscgen and the two derivative languages were
    // originally made for use in the mscgen_js interpreter
    // (https://sverweij.github.io/mscgen_js)

    (function(mod) {
      if ( typeof exports == "object" && typeof module == "object")// CommonJS
        mod(require("../../lib/codemirror"));
      else if ( typeof define == "function" && define.amd)// AMD
        define(["../../lib/codemirror"], mod);
      else// Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var languages = {
        mscgen: {
          "keywords" : ["msc"],
          "options" : ["hscale", "width", "arcgradient", "wordwraparcs"],
          "constants" : ["true", "false", "on", "off"],
          "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip"],
          "brackets" : ["\\{", "\\}"], // [ and  ] are brackets too, but these get handled in with lists
          "arcsWords" : ["note", "abox", "rbox", "box"],
          "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
          "singlecomment" : ["//", "#"],
          "operators" : ["="]
        },
        xu: {
          "keywords" : ["msc", "xu"],
          "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
          "constants" : ["true", "false", "on", "off", "auto"],
          "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip", "title", "deactivate", "activate", "activation"],
          "brackets" : ["\\{", "\\}"],  // [ and  ] are brackets too, but these get handled in with lists
          "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
          "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
          "singlecomment" : ["//", "#"],
          "operators" : ["="]
        },
        msgenny: {
          "keywords" : null,
          "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
          "constants" : ["true", "false", "on", "off", "auto"],
          "attributes" : null,
          "brackets" : ["\\{", "\\}"],
          "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
          "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
          "singlecomment" : ["//", "#"],
          "operators" : ["="]
        }
      }

      CodeMirror.defineMode("mscgen", function(_, modeConfig) {
        var language = languages[modeConfig && modeConfig.language || "mscgen"]
        return {
          startState: startStateFn,
          copyState: copyStateFn,
          token: produceTokenFunction(language),
          lineComment : "#",
          blockCommentStart : "/*",
          blockCommentEnd : "*/"
        };
      });

      CodeMirror.defineMIME("text/x-mscgen", "mscgen");
      CodeMirror.defineMIME("text/x-xu", {name: "mscgen", language: "xu"});
      CodeMirror.defineMIME("text/x-msgenny", {name: "mscgen", language: "msgenny"});

      function wordRegexpBoundary(pWords) {
        return new RegExp("^\\b(?:" + pWords.join("|") + ")\\b", "i");
      }

      function wordRegexp(pWords) {
        return new RegExp("^(?:" + pWords.join("|") + ")", "i");
      }

      function startStateFn() {
        return {
          inComment : false,
          inString : false,
          inAttributeList : false,
          inScript : false
        };
      }

      function copyStateFn(pState) {
        return {
          inComment : pState.inComment,
          inString : pState.inString,
          inAttributeList : pState.inAttributeList,
          inScript : pState.inScript
        };
      }

      function produceTokenFunction(pConfig) {

        return function(pStream, pState) {
          if (pStream.match(wordRegexp(pConfig.brackets), true, true)) {
            return "bracket";
          }
          /* comments */
          if (!pState.inComment) {
            if (pStream.match(/\/\*[^\*\/]*/, true, true)) {
              pState.inComment = true;
              return "comment";
            }
            if (pStream.match(wordRegexp(pConfig.singlecomment), true, true)) {
              pStream.skipToEnd();
              return "comment";
            }
          }
          if (pState.inComment) {
            if (pStream.match(/[^\*\/]*\*\//, true, true))
              pState.inComment = false;
            else
              pStream.skipToEnd();
            return "comment";
          }
          /* strings */
          if (!pState.inString && pStream.match(/\"(\\\"|[^\"])*/, true, true)) {
            pState.inString = true;
            return "string";
          }
          if (pState.inString) {
            if (pStream.match(/[^\"]*\"/, true, true))
              pState.inString = false;
            else
              pStream.skipToEnd();
            return "string";
          }
          /* keywords & operators */
          if (!!pConfig.keywords && pStream.match(wordRegexpBoundary(pConfig.keywords), true, true))
            return "keyword";

          if (pStream.match(wordRegexpBoundary(pConfig.options), true, true))
            return "keyword";

          if (pStream.match(wordRegexpBoundary(pConfig.arcsWords), true, true))
            return "keyword";

          if (pStream.match(wordRegexp(pConfig.arcsOthers), true, true))
            return "keyword";

          if (!!pConfig.operators && pStream.match(wordRegexp(pConfig.operators), true, true))
            return "operator";

          if (!!pConfig.constants && pStream.match(wordRegexp(pConfig.constants), true, true))
            return "variable";

          /* attribute lists */
          if (!pConfig.inAttributeList && !!pConfig.attributes && pStream.match('[', true, true)) {
            pConfig.inAttributeList = true;
            return "bracket";
          }
          if (pConfig.inAttributeList) {
            if (pConfig.attributes !== null && pStream.match(wordRegexpBoundary(pConfig.attributes), true, true)) {
              return "attribute";
            }
            if (pStream.match(']', true, true)) {
              pConfig.inAttributeList = false;
              return "bracket";
            }
          }

          pStream.next();
          return "base";
        };
      }

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-nginx-nginx.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("nginx", function(config) {

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var keywords = words(
        /* ngxDirectiveControl */ "break return rewrite set" +
        /* ngxDirective */ " accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout rewrite_log rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set_real_ip_from smtp_auth smtp_capabilities smtp_client_buffer smtp_greeting_delay so_keepalive source_charset ssi ssi_ignore_recycled_buffers ssi_min_file_chunk ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush thread_stack_size timeout timer_resolution types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn use user userid userid_domain userid_expires userid_mark userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending worker_threads working_directory xclient xml_entities xslt_stylesheet xslt_typesdrew@li229-23"
        );

      var keywords_block = words(
        /* ngxDirectiveBlock */ "http mail events server types location upstream charset_map limit_except if geo map"
        );

      var keywords_important = words(
        /* ngxDirectiveImportant */ "include root server server_name listen internal proxy_pass memcached_pass fastcgi_pass try_files"
        );

      var indentUnit = config.indentUnit, type;
      function ret(style, tp) {type = tp; return style;}

      function tokenBase(stream, state) {


        stream.eatWhile(/[\w\$_]/);

        var cur = stream.current();


        if (keywords.propertyIsEnumerable(cur)) {
          return "keyword";
        }
        else if (keywords_block.propertyIsEnumerable(cur)) {
          return "variable-2";
        }
        else if (keywords_important.propertyIsEnumerable(cur)) {
          return "string-2";
        }
        /**/

        var ch = stream.next();
        if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("meta", stream.current());}
        else if (ch == "/" && stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        }
        else if (ch == "<" && stream.eat("!")) {
          state.tokenize = tokenSGMLComment;
          return tokenSGMLComment(stream, state);
        }
        else if (ch == "=") ret(null, "compare");
        else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        else if (ch == "#") {
          stream.skipToEnd();
          return ret("comment", "comment");
        }
        else if (ch == "!") {
          stream.match(/^\s*\w*/);
          return ret("keyword", "important");
        }
        else if (/\d/.test(ch)) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        }
        else if (/[,.+>*\/]/.test(ch)) {
          return ret(null, "select-op");
        }
        else if (/[;{}:\[\]]/.test(ch)) {
          return ret(null, ch);
        }
        else {
          stream.eatWhile(/[\w\\\-]/);
          return ret("variable", "variable");
        }
      }

      function tokenCComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
      }

      function tokenSGMLComment(stream, state) {
        var dashes = 0, ch;
        while ((ch = stream.next()) != null) {
          if (dashes >= 2 && ch == ">") {
            state.tokenize = tokenBase;
            break;
          }
          dashes = (ch == "-") ? dashes + 1 : 0;
        }
        return ret("comment", "comment");
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped)
              break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }

      return {
        startState: function(base) {
          return {tokenize: tokenBase,
                  baseIndent: base || 0,
                  stack: []};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          type = null;
          var style = state.tokenize(stream, state);

          var context = state.stack[state.stack.length-1];
          if (type == "hash" && context == "rule") style = "atom";
          else if (style == "variable") {
            if (context == "rule") style = "number";
            else if (!context || context == "@media{") style = "tag";
          }

          if (context == "rule" && /^[\{\};]$/.test(type))
            state.stack.pop();
          if (type == "{") {
            if (context == "@media") state.stack[state.stack.length-1] = "@media{";
            else state.stack.push("{");
          }
          else if (type == "}") state.stack.pop();
          else if (type == "@media") state.stack.push("@media");
          else if (context == "{" && type != "comment") state.stack.push("rule");
          return style;
        },

        indent: function(state, textAfter) {
          var n = state.stack.length;
          if (/^\}/.test(textAfter))
            n -= state.stack[state.stack.length-1] == "rule" ? 2 : 1;
          return state.baseIndent + n * indentUnit;
        },

        electricChars: "}"
      };
    });

    CodeMirror.defineMIME("text/x-nginx-conf", "nginx");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-nsis-nsis.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Author: Jan T. Sott (http://github.com/idleberg)

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../addon/mode/simple"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineSimpleMode("nsis",{
      start:[
        // Numbers
        {regex: /(?:[+-]?)(?:0x[\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\d+.?\d*)/, token: "number"},

        // Strings
        { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
        { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },
        { regex: /`(?:[^\\`]|\\.)*`?/, token: "string" },

        // Compile Time Commands
        {regex: /^\s*(?:\!(include|addincludedir|addplugindir|appendfile|cd|delfile|echo|error|execute|packhdr|pragma|finalize|getdllversion|gettlbversion|system|tempfile|warning|verbose|define|undef|insertmacro|macro|macroend|makensis|searchparse|searchreplace))\b/, token: "keyword"},

        // Conditional Compilation
        {regex: /^\s*(?:\!(if(?:n?def)?|ifmacron?def|macro))\b/, token: "keyword", indent: true},
        {regex: /^\s*(?:\!(else|endif|macroend))\b/, token: "keyword", dedent: true},

        // Runtime Commands
        {regex: /^\s*(?:Abort|AddBrandingImage|AddSize|AllowRootDirInstall|AllowSkipFiles|AutoCloseWindow|BGFont|BGGradient|BrandingText|BringToFront|Call|CallInstDLL|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|CRCCheck|CreateDirectory|CreateFont|CreateShortCut|Delete|DeleteINISec|DeleteINIStr|DeleteRegKey|DeleteRegValue|DetailPrint|DetailsButtonText|DirText|DirVar|DirVerify|EnableWindow|EnumRegKey|EnumRegValue|Exch|Exec|ExecShell|ExecShellWait|ExecWait|ExpandEnvStrings|File|FileBufSize|FileClose|FileErrorText|FileOpen|FileRead|FileReadByte|FileReadUTF16LE|FileReadWord|FileWriteUTF16LE|FileSeek|FileWrite|FileWriteByte|FileWriteWord|FindClose|FindFirst|FindNext|FindWindow|FlushINI|GetCurInstType|GetCurrentAddress|GetDlgItem|GetDLLVersion|GetDLLVersionLocal|GetErrorLevel|GetFileTime|GetFileTimeLocal|GetFullPathName|GetFunctionAddress|GetInstDirError|GetKnownFolderPath|GetLabelAddress|GetTempFileName|Goto|HideWindow|Icon|IfAbort|IfErrors|IfFileExists|IfRebootFlag|IfRtlLanguage|IfShellVarContextAll|IfSilent|InitPluginsDir|InstallButtonText|InstallColors|InstallDir|InstallDirRegKey|InstProgressFlags|InstType|InstTypeGetText|InstTypeSetText|Int64Cmp|Int64CmpU|Int64Fmt|IntCmp|IntCmpU|IntFmt|IntOp|IntPtrCmp|IntPtrCmpU|IntPtrOp|IsWindow|LangString|LicenseBkColor|LicenseData|LicenseForceSelection|LicenseLangString|LicenseText|LoadAndSetImage|LoadLanguageFile|LockWindow|LogSet|LogText|ManifestDPIAware|ManifestLongPathAware|ManifestMaxVersionTested|ManifestSupportedOS|MessageBox|MiscButtonText|Name|Nop|OutFile|Page|PageCallbacks|PEAddResource|PEDllCharacteristics|PERemoveResource|PESubsysVer|Pop|Push|Quit|ReadEnvStr|ReadINIStr|ReadRegDWORD|ReadRegStr|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|RMDir|SearchPath|SectionGetFlags|SectionGetInstTypes|SectionGetSize|SectionGetText|SectionIn|SectionSetFlags|SectionSetInstTypes|SectionSetSize|SectionSetText|SendMessage|SetAutoClose|SetBrandingImage|SetCompress|SetCompressor|SetCompressorDictSize|SetCtlColors|SetCurInstType|SetDatablockOptimize|SetDateSave|SetDetailsPrint|SetDetailsView|SetErrorLevel|SetErrors|SetFileAttributes|SetFont|SetOutPath|SetOverwrite|SetRebootFlag|SetRegView|SetShellVarContext|SetSilent|ShowInstDetails|ShowUninstDetails|ShowWindow|SilentInstall|SilentUnInstall|Sleep|SpaceTexts|StrCmp|StrCmpS|StrCpy|StrLen|SubCaption|Unicode|UninstallButtonText|UninstallCaption|UninstallIcon|UninstallSubCaption|UninstallText|UninstPage|UnRegDLL|Var|VIAddVersionKey|VIFileVersion|VIProductVersion|WindowIcon|WriteINIStr|WriteRegBin|WriteRegDWORD|WriteRegExpandStr|WriteRegMultiStr|WriteRegNone|WriteRegStr|WriteUninstaller|XPStyle)\b/, token: "keyword"},
        {regex: /^\s*(?:Function|PageEx|Section(?:Group)?)\b/, token: "keyword", indent: true},
        {regex: /^\s*(?:(Function|PageEx|Section(?:Group)?)End)\b/, token: "keyword", dedent: true},

        // Command Options
        {regex: /\b(?:ARCHIVE|FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_OFFLINE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_TEMPORARY|HIDDEN|HKCC|HKCR(32|64)?|HKCU(32|64)?|HKDD|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_DYN_DATA|HKEY_LOCAL_MACHINE|HKEY_PERFORMANCE_DATA|HKEY_USERS|HKLM(32|64)?|HKPD|HKU|IDABORT|IDCANCEL|IDD_DIR|IDD_INST|IDD_INSTFILES|IDD_LICENSE|IDD_SELCOM|IDD_UNINST|IDD_VERIFY|IDIGNORE|IDNO|IDOK|IDRETRY|IDYES|MB_ABORTRETRYIGNORE|MB_DEFBUTTON1|MB_DEFBUTTON2|MB_DEFBUTTON3|MB_DEFBUTTON4|MB_ICONEXCLAMATION|MB_ICONINFORMATION|MB_ICONQUESTION|MB_ICONSTOP|MB_OK|MB_OKCANCEL|MB_RETRYCANCEL|MB_RIGHT|MB_RTLREADING|MB_SETFOREGROUND|MB_TOPMOST|MB_USERICON|MB_YESNO|MB_YESNOCANCEL|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SW_HIDE|SW_SHOWDEFAULT|SW_SHOWMAXIMIZED|SW_SHOWMINIMIZED|SW_SHOWNORMAL|SYSTEM|TEMPORARY)\b/, token: "atom"},
        {regex: /\b(?:admin|all|auto|both|bottom|bzip2|components|current|custom|directory|false|force|hide|highest|ifdiff|ifnewer|instfiles|lastused|leave|left|license|listonly|lzma|nevershow|none|normal|notset|off|on|right|show|silent|silentlog|textonly|top|true|try|un\.components|un\.custom|un\.directory|un\.instfiles|un\.license|uninstConfirm|user|Win10|Win7|Win8|WinVista|zlib)\b/, token: "builtin"},

        // LogicLib.nsh
        {regex: /\$\{(?:And(?:If(?:Not)?|Unless)|Break|Case(?:Else)?|Continue|Default|Do(?:Until|While)?|Else(?:If(?:Not)?|Unless)?|End(?:If|Select|Switch)|Exit(?:Do|For|While)|For(?:Each)?|If(?:Cmd|Not(?:Then)?|Then)?|Loop(?:Until|While)?|Or(?:If(?:Not)?|Unless)|Select|Switch|Unless|While)\}/, token: "variable-2", indent: true},

        // FileFunc.nsh
        {regex: /\$\{(?:BannerTrimPath|DirState|DriveSpace|Get(BaseName|Drives|ExeName|ExePath|FileAttributes|FileExt|FileName|FileVersion|Options|OptionsS|Parameters|Parent|Root|Size|Time)|Locate|RefreshShellIcons)\}/, token: "variable-2", dedent: true},

        // Memento.nsh
        {regex: /\$\{(?:Memento(?:Section(?:Done|End|Restore|Save)?|UnselectedSection))\}/, token: "variable-2", dedent: true},

        // TextFunc.nsh
        {regex: /\$\{(?:Config(?:Read|ReadS|Write|WriteS)|File(?:Join|ReadFromEnd|Recode)|Line(?:Find|Read|Sum)|Text(?:Compare|CompareS)|TrimNewLines)\}/, token: "variable-2", dedent: true},

        // WinVer.nsh
        {regex: /\$\{(?:(?:At(?:Least|Most)|Is)(?:ServicePack|Win(?:7|8|10|95|98|200(?:0|3|8(?:R2)?)|ME|NT4|Vista|XP))|Is(?:NT|Server))\}/, token: "variable", dedent: true},

        // WordFunc.nsh
        {regex: /\$\{(?:StrFilterS?|Version(?:Compare|Convert)|Word(?:AddS?|Find(?:(?:2|3)X)?S?|InsertS?|ReplaceS?))\}/, token: "variable-2", dedent: true},

        // x64.nsh
        {regex: /\$\{(?:RunningX64)\}/, token: "variable", dedent: true},
        {regex: /\$\{(?:Disable|Enable)X64FSRedirection\}/, token: "variable-2", dedent: true},

        // Line Comment
        {regex: /(#|;).*/, token: "comment"},

        // Block Comment
        {regex: /\/\*/, token: "comment", next: "comment"},

        // Operator
        {regex: /[-+\/*=<>!]+/, token: "operator"},

        // Variable
        {regex: /\$\w+/, token: "variable"},

        // Constant
        {regex: /\${[\w\.:-]+}/, token: "variable-2"},

        // Language String
        {regex: /\$\([\w\.:-]+\)/, token: "variable-3"}
      ],
      comment: [
        {regex: /.*?\*\//, token: "comment", next: "start"},
        {regex: /.*/, token: "comment"}
      ],
      meta: {
        electricInput: /^\s*((Function|PageEx|Section|Section(Group)?)End|(\!(endif|macroend))|\$\{(End(If|Unless|While)|Loop(Until)|Next)\})$/,
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: ["#", ";"]
      }
    });

    CodeMirror.defineMIME("text/x-nsis", "nsis");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-ntriples-ntriples.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**********************************************************
    * This script provides syntax highlighting support for
    * the N-Triples format.
    * N-Triples format specification:
    *     https://www.w3.org/TR/n-triples/
    ***********************************************************/

    /*
        The following expression defines the defined ASF grammar transitions.

        pre_subject ->
            {
            ( writing_subject_uri | writing_bnode_uri )
                -> pre_predicate
                    -> writing_predicate_uri
                        -> pre_object
                            -> writing_object_uri | writing_object_bnode |
                              (
                                writing_object_literal
                                    -> writing_literal_lang | writing_literal_type
                              )
                                -> post_object
                                    -> BEGIN
             } otherwise {
                 -> ERROR
             }
    */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("ntriples", function() {

      var Location = {
        PRE_SUBJECT         : 0,
        WRITING_SUB_URI     : 1,
        WRITING_BNODE_URI   : 2,
        PRE_PRED            : 3,
        WRITING_PRED_URI    : 4,
        PRE_OBJ             : 5,
        WRITING_OBJ_URI     : 6,
        WRITING_OBJ_BNODE   : 7,
        WRITING_OBJ_LITERAL : 8,
        WRITING_LIT_LANG    : 9,
        WRITING_LIT_TYPE    : 10,
        POST_OBJ            : 11,
        ERROR               : 12
      };
      function transitState(currState, c) {
        var currLocation = currState.location;
        var ret;

        // Opening.
        if     (currLocation == Location.PRE_SUBJECT && c == '<') ret = Location.WRITING_SUB_URI;
        else if(currLocation == Location.PRE_SUBJECT && c == '_') ret = Location.WRITING_BNODE_URI;
        else if(currLocation == Location.PRE_PRED    && c == '<') ret = Location.WRITING_PRED_URI;
        else if(currLocation == Location.PRE_OBJ     && c == '<') ret = Location.WRITING_OBJ_URI;
        else if(currLocation == Location.PRE_OBJ     && c == '_') ret = Location.WRITING_OBJ_BNODE;
        else if(currLocation == Location.PRE_OBJ     && c == '"') ret = Location.WRITING_OBJ_LITERAL;

        // Closing.
        else if(currLocation == Location.WRITING_SUB_URI     && c == '>') ret = Location.PRE_PRED;
        else if(currLocation == Location.WRITING_BNODE_URI   && c == ' ') ret = Location.PRE_PRED;
        else if(currLocation == Location.WRITING_PRED_URI    && c == '>') ret = Location.PRE_OBJ;
        else if(currLocation == Location.WRITING_OBJ_URI     && c == '>') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_OBJ_BNODE   && c == ' ') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '"') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_LIT_LANG && c == ' ') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_LIT_TYPE && c == '>') ret = Location.POST_OBJ;

        // Closing typed and language literal.
        else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '@') ret = Location.WRITING_LIT_LANG;
        else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '^') ret = Location.WRITING_LIT_TYPE;

        // Spaces.
        else if( c == ' ' &&
                 (
                   currLocation == Location.PRE_SUBJECT ||
                   currLocation == Location.PRE_PRED    ||
                   currLocation == Location.PRE_OBJ     ||
                   currLocation == Location.POST_OBJ
                 )
               ) ret = currLocation;

        // Reset.
        else if(currLocation == Location.POST_OBJ && c == '.') ret = Location.PRE_SUBJECT;

        // Error
        else ret = Location.ERROR;

        currState.location=ret;
      }

      return {
        startState: function() {
           return {
               location : Location.PRE_SUBJECT,
               uris     : [],
               anchors  : [],
               bnodes   : [],
               langs    : [],
               types    : []
           };
        },
        token: function(stream, state) {
          var ch = stream.next();
          if(ch == '<') {
             transitState(state, ch);
             var parsedURI = '';
             stream.eatWhile( function(c) { if( c != '#' && c != '>' ) { parsedURI += c; return true; } return false;} );
             state.uris.push(parsedURI);
             if( stream.match('#', false) ) return 'variable';
             stream.next();
             transitState(state, '>');
             return 'variable';
          }
          if(ch == '#') {
            var parsedAnchor = '';
            stream.eatWhile(function(c) { if(c != '>' && c != ' ') { parsedAnchor+= c; return true; } return false;});
            state.anchors.push(parsedAnchor);
            return 'variable-2';
          }
          if(ch == '>') {
              transitState(state, '>');
              return 'variable';
          }
          if(ch == '_') {
              transitState(state, ch);
              var parsedBNode = '';
              stream.eatWhile(function(c) { if( c != ' ' ) { parsedBNode += c; return true; } return false;});
              state.bnodes.push(parsedBNode);
              stream.next();
              transitState(state, ' ');
              return 'builtin';
          }
          if(ch == '"') {
              transitState(state, ch);
              stream.eatWhile( function(c) { return c != '"'; } );
              stream.next();
              if( stream.peek() != '@' && stream.peek() != '^' ) {
                  transitState(state, '"');
              }
              return 'string';
          }
          if( ch == '@' ) {
              transitState(state, '@');
              var parsedLang = '';
              stream.eatWhile(function(c) { if( c != ' ' ) { parsedLang += c; return true; } return false;});
              state.langs.push(parsedLang);
              stream.next();
              transitState(state, ' ');
              return 'string-2';
          }
          if( ch == '^' ) {
              stream.next();
              transitState(state, '^');
              var parsedType = '';
              stream.eatWhile(function(c) { if( c != '>' ) { parsedType += c; return true; } return false;} );
              state.types.push(parsedType);
              stream.next();
              transitState(state, '>');
              return 'variable';
          }
          if( ch == ' ' ) {
              transitState(state, ch);
          }
          if( ch == '.' ) {
              transitState(state, ch);
          }
        }
      };
    });

    // define the registered Media Type for n-triples:
    // https://www.w3.org/TR/n-triples/#n-triples-mediatype
    CodeMirror.defineMIME("application/n-triples", "ntriples");

    // N-Quads is based on the N-Triples format (so same highlighting works)
    // https://www.w3.org/TR/n-quads/
    CodeMirror.defineMIME("application/n-quads", "ntriples");

    // previously used, though technically incorrect media type for n-triples
    CodeMirror.defineMIME("text/n-triples", "ntriples");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-pegjs-pegjs.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../javascript/javascript"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../javascript/javascript"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("pegjs", function (config) {
      var jsMode = CodeMirror.getMode(config, "javascript");

      function identifier(stream) {
        return stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
      }

      return {
        startState: function () {
          return {
            inString: false,
            stringType: null,
            inComment: false,
            inCharacterClass: false,
            braced: 0,
            lhs: true,
            localState: null
          };
        },
        token: function (stream, state) {
          if (stream)

          //check for state changes
          if (!state.inString && !state.inComment && ((stream.peek() == '"') || (stream.peek() == "'"))) {
            state.stringType = stream.peek();
            stream.next(); // Skip quote
            state.inString = true; // Update state
          }
          if (!state.inString && !state.inComment && stream.match('/*')) {
            state.inComment = true;
          }

          //return state
          if (state.inString) {
            while (state.inString && !stream.eol()) {
              if (stream.peek() === state.stringType) {
                stream.next(); // Skip quote
                state.inString = false; // Clear flag
              } else if (stream.peek() === '\\') {
                stream.next();
                stream.next();
              } else {
                stream.match(/^.[^\\\"\']*/);
              }
            }
            return state.lhs ? "property string" : "string"; // Token style
          } else if (state.inComment) {
            while (state.inComment && !stream.eol()) {
              if (stream.match('*/')) {
                state.inComment = false; // Clear flag
              } else {
                stream.match(/^.[^\*]*/);
              }
            }
            return "comment";
          } else if (state.inCharacterClass) {
              while (state.inCharacterClass && !stream.eol()) {
                if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./))) {
                  state.inCharacterClass = false;
                }
              }
          } else if (stream.peek() === '[') {
            stream.next();
            state.inCharacterClass = true;
            return 'bracket';
          } else if (stream.match('//')) {
            stream.skipToEnd();
            return "comment";
          } else if (state.braced || stream.peek() === '{') {
            if (state.localState === null) {
              state.localState = CodeMirror.startState(jsMode);
            }
            var token = jsMode.token(stream, state.localState);
            var text = stream.current();
            if (!token) {
              for (var i = 0; i < text.length; i++) {
                if (text[i] === '{') {
                  state.braced++;
                } else if (text[i] === '}') {
                  state.braced--;
                }
              };
            }
            return token;
          } else if (identifier(stream)) {
            if (stream.peek() === ':') {
              return 'variable';
            }
            return 'variable-2';
          } else if (['[', ']', '(', ')'].indexOf(stream.peek()) != -1) {
            stream.next();
            return 'bracket';
          } else if (!stream.eatSpace()) {
            stream.next();
          }
          return null;
        }
      };
    }, "javascript");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-perl-perl.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // CodeMirror2 mode/perl/perl.js (text/x-perl) beta 0.10 (2011-11-08)
    // This is a part of CodeMirror from https://github.com/sabaca/CodeMirror_mode_perl (mail@sabaca.com)

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("perl",function(){
            // http://perldoc.perl.org
            var PERL={                                      //   null - magic touch
                                                            //   1 - keyword
                                                            //   2 - def
                                                            //   3 - atom
                                                            //   4 - operator
                                                            //   5 - variable-2 (predefined)
                                                            //   [x,y] - x=1,2,3; y=must be defined if x{...}
                                                    //      PERL operators
                    '->'                            :   4,
                    '++'                            :   4,
                    '--'                            :   4,
                    '**'                            :   4,
                                                            //   ! ~ \ and unary + and -
                    '=~'                            :   4,
                    '!~'                            :   4,
                    '*'                             :   4,
                    '/'                             :   4,
                    '%'                             :   4,
                    'x'                             :   4,
                    '+'                             :   4,
                    '-'                             :   4,
                    '.'                             :   4,
                    '<<'                            :   4,
                    '>>'                            :   4,
                                                            //   named unary operators
                    '<'                             :   4,
                    '>'                             :   4,
                    '<='                            :   4,
                    '>='                            :   4,
                    'lt'                            :   4,
                    'gt'                            :   4,
                    'le'                            :   4,
                    'ge'                            :   4,
                    '=='                            :   4,
                    '!='                            :   4,
                    '<=>'                           :   4,
                    'eq'                            :   4,
                    'ne'                            :   4,
                    'cmp'                           :   4,
                    '~~'                            :   4,
                    '&'                             :   4,
                    '|'                             :   4,
                    '^'                             :   4,
                    '&&'                            :   4,
                    '||'                            :   4,
                    '//'                            :   4,
                    '..'                            :   4,
                    '...'                           :   4,
                    '?'                             :   4,
                    ':'                             :   4,
                    '='                             :   4,
                    '+='                            :   4,
                    '-='                            :   4,
                    '*='                            :   4,  //   etc. ???
                    ','                             :   4,
                    '=>'                            :   4,
                    '::'                            :   4,
                                                            //   list operators (rightward)
                    'not'                           :   4,
                    'and'                           :   4,
                    'or'                            :   4,
                    'xor'                           :   4,
                                                    //      PERL predefined variables (I know, what this is a paranoid idea, but may be needed for people, who learn PERL, and for me as well, ...and may be for you?;)
                    'BEGIN'                         :   [5,1],
                    'END'                           :   [5,1],
                    'PRINT'                         :   [5,1],
                    'PRINTF'                        :   [5,1],
                    'GETC'                          :   [5,1],
                    'READ'                          :   [5,1],
                    'READLINE'                      :   [5,1],
                    'DESTROY'                       :   [5,1],
                    'TIE'                           :   [5,1],
                    'TIEHANDLE'                     :   [5,1],
                    'UNTIE'                         :   [5,1],
                    'STDIN'                         :    5,
                    'STDIN_TOP'                     :    5,
                    'STDOUT'                        :    5,
                    'STDOUT_TOP'                    :    5,
                    'STDERR'                        :    5,
                    'STDERR_TOP'                    :    5,
                    '$ARG'                          :    5,
                    '$_'                            :    5,
                    '@ARG'                          :    5,
                    '@_'                            :    5,
                    '$LIST_SEPARATOR'               :    5,
                    '$"'                            :    5,
                    '$PROCESS_ID'                   :    5,
                    '$PID'                          :    5,
                    '$$'                            :    5,
                    '$REAL_GROUP_ID'                :    5,
                    '$GID'                          :    5,
                    '$('                            :    5,
                    '$EFFECTIVE_GROUP_ID'           :    5,
                    '$EGID'                         :    5,
                    '$)'                            :    5,
                    '$PROGRAM_NAME'                 :    5,
                    '$0'                            :    5,
                    '$SUBSCRIPT_SEPARATOR'          :    5,
                    '$SUBSEP'                       :    5,
                    '$;'                            :    5,
                    '$REAL_USER_ID'                 :    5,
                    '$UID'                          :    5,
                    '$<'                            :    5,
                    '$EFFECTIVE_USER_ID'            :    5,
                    '$EUID'                         :    5,
                    '$>'                            :    5,
                    '$a'                            :    5,
                    '$b'                            :    5,
                    '$COMPILING'                    :    5,
                    '$^C'                           :    5,
                    '$DEBUGGING'                    :    5,
                    '$^D'                           :    5,
                    '${^ENCODING}'                  :    5,
                    '$ENV'                          :    5,
                    '%ENV'                          :    5,
                    '$SYSTEM_FD_MAX'                :    5,
                    '$^F'                           :    5,
                    '@F'                            :    5,
                    '${^GLOBAL_PHASE}'              :    5,
                    '$^H'                           :    5,
                    '%^H'                           :    5,
                    '@INC'                          :    5,
                    '%INC'                          :    5,
                    '$INPLACE_EDIT'                 :    5,
                    '$^I'                           :    5,
                    '$^M'                           :    5,
                    '$OSNAME'                       :    5,
                    '$^O'                           :    5,
                    '${^OPEN}'                      :    5,
                    '$PERLDB'                       :    5,
                    '$^P'                           :    5,
                    '$SIG'                          :    5,
                    '%SIG'                          :    5,
                    '$BASETIME'                     :    5,
                    '$^T'                           :    5,
                    '${^TAINT}'                     :    5,
                    '${^UNICODE}'                   :    5,
                    '${^UTF8CACHE}'                 :    5,
                    '${^UTF8LOCALE}'                :    5,
                    '$PERL_VERSION'                 :    5,
                    '$^V'                           :    5,
                    '${^WIN32_SLOPPY_STAT}'         :    5,
                    '$EXECUTABLE_NAME'              :    5,
                    '$^X'                           :    5,
                    '$1'                            :    5, // - regexp $1, $2...
                    '$MATCH'                        :    5,
                    '$&'                            :    5,
                    '${^MATCH}'                     :    5,
                    '$PREMATCH'                     :    5,
                    '$`'                            :    5,
                    '${^PREMATCH}'                  :    5,
                    '$POSTMATCH'                    :    5,
                    "$'"                            :    5,
                    '${^POSTMATCH}'                 :    5,
                    '$LAST_PAREN_MATCH'             :    5,
                    '$+'                            :    5,
                    '$LAST_SUBMATCH_RESULT'         :    5,
                    '$^N'                           :    5,
                    '@LAST_MATCH_END'               :    5,
                    '@+'                            :    5,
                    '%LAST_PAREN_MATCH'             :    5,
                    '%+'                            :    5,
                    '@LAST_MATCH_START'             :    5,
                    '@-'                            :    5,
                    '%LAST_MATCH_START'             :    5,
                    '%-'                            :    5,
                    '$LAST_REGEXP_CODE_RESULT'      :    5,
                    '$^R'                           :    5,
                    '${^RE_DEBUG_FLAGS}'            :    5,
                    '${^RE_TRIE_MAXBUF}'            :    5,
                    '$ARGV'                         :    5,
                    '@ARGV'                         :    5,
                    'ARGV'                          :    5,
                    'ARGVOUT'                       :    5,
                    '$OUTPUT_FIELD_SEPARATOR'       :    5,
                    '$OFS'                          :    5,
                    '$,'                            :    5,
                    '$INPUT_LINE_NUMBER'            :    5,
                    '$NR'                           :    5,
                    '$.'                            :    5,
                    '$INPUT_RECORD_SEPARATOR'       :    5,
                    '$RS'                           :    5,
                    '$/'                            :    5,
                    '$OUTPUT_RECORD_SEPARATOR'      :    5,
                    '$ORS'                          :    5,
                    '$\\'                           :    5,
                    '$OUTPUT_AUTOFLUSH'             :    5,
                    '$|'                            :    5,
                    '$ACCUMULATOR'                  :    5,
                    '$^A'                           :    5,
                    '$FORMAT_FORMFEED'              :    5,
                    '$^L'                           :    5,
                    '$FORMAT_PAGE_NUMBER'           :    5,
                    '$%'                            :    5,
                    '$FORMAT_LINES_LEFT'            :    5,
                    '$-'                            :    5,
                    '$FORMAT_LINE_BREAK_CHARACTERS' :    5,
                    '$:'                            :    5,
                    '$FORMAT_LINES_PER_PAGE'        :    5,
                    '$='                            :    5,
                    '$FORMAT_TOP_NAME'              :    5,
                    '$^'                            :    5,
                    '$FORMAT_NAME'                  :    5,
                    '$~'                            :    5,
                    '${^CHILD_ERROR_NATIVE}'        :    5,
                    '$EXTENDED_OS_ERROR'            :    5,
                    '$^E'                           :    5,
                    '$EXCEPTIONS_BEING_CAUGHT'      :    5,
                    '$^S'                           :    5,
                    '$WARNING'                      :    5,
                    '$^W'                           :    5,
                    '${^WARNING_BITS}'              :    5,
                    '$OS_ERROR'                     :    5,
                    '$ERRNO'                        :    5,
                    '$!'                            :    5,
                    '%OS_ERROR'                     :    5,
                    '%ERRNO'                        :    5,
                    '%!'                            :    5,
                    '$CHILD_ERROR'                  :    5,
                    '$?'                            :    5,
                    '$EVAL_ERROR'                   :    5,
                    '$@'                            :    5,
                    '$OFMT'                         :    5,
                    '$#'                            :    5,
                    '$*'                            :    5,
                    '$ARRAY_BASE'                   :    5,
                    '$['                            :    5,
                    '$OLD_PERL_VERSION'             :    5,
                    '$]'                            :    5,
                                                    //      PERL blocks
                    'if'                            :[1,1],
                    elsif                           :[1,1],
                    'else'                          :[1,1],
                    'while'                         :[1,1],
                    unless                          :[1,1],
                    'for'                           :[1,1],
                    foreach                         :[1,1],
                                                    //      PERL functions
                    'abs'                           :1,     // - absolute value function
                    accept                          :1,     // - accept an incoming socket connect
                    alarm                           :1,     // - schedule a SIGALRM
                    'atan2'                         :1,     // - arctangent of Y/X in the range -PI to PI
                    bind                            :1,     // - binds an address to a socket
                    binmode                         :1,     // - prepare binary files for I/O
                    bless                           :1,     // - create an object
                    bootstrap                       :1,     //
                    'break'                         :1,     // - break out of a "given" block
                    caller                          :1,     // - get context of the current subroutine call
                    chdir                           :1,     // - change your current working directory
                    chmod                           :1,     // - changes the permissions on a list of files
                    chomp                           :1,     // - remove a trailing record separator from a string
                    chop                            :1,     // - remove the last character from a string
                    chown                           :1,     // - change the ownership on a list of files
                    chr                             :1,     // - get character this number represents
                    chroot                          :1,     // - make directory new root for path lookups
                    close                           :1,     // - close file (or pipe or socket) handle
                    closedir                        :1,     // - close directory handle
                    connect                         :1,     // - connect to a remote socket
                    'continue'                      :[1,1], // - optional trailing block in a while or foreach
                    'cos'                           :1,     // - cosine function
                    crypt                           :1,     // - one-way passwd-style encryption
                    dbmclose                        :1,     // - breaks binding on a tied dbm file
                    dbmopen                         :1,     // - create binding on a tied dbm file
                    'default'                       :1,     //
                    defined                         :1,     // - test whether a value, variable, or function is defined
                    'delete'                        :1,     // - deletes a value from a hash
                    die                             :1,     // - raise an exception or bail out
                    'do'                            :1,     // - turn a BLOCK into a TERM
                    dump                            :1,     // - create an immediate core dump
                    each                            :1,     // - retrieve the next key/value pair from a hash
                    endgrent                        :1,     // - be done using group file
                    endhostent                      :1,     // - be done using hosts file
                    endnetent                       :1,     // - be done using networks file
                    endprotoent                     :1,     // - be done using protocols file
                    endpwent                        :1,     // - be done using passwd file
                    endservent                      :1,     // - be done using services file
                    eof                             :1,     // - test a filehandle for its end
                    'eval'                          :1,     // - catch exceptions or compile and run code
                    'exec'                          :1,     // - abandon this program to run another
                    exists                          :1,     // - test whether a hash key is present
                    exit                            :1,     // - terminate this program
                    'exp'                           :1,     // - raise I to a power
                    fcntl                           :1,     // - file control system call
                    fileno                          :1,     // - return file descriptor from filehandle
                    flock                           :1,     // - lock an entire file with an advisory lock
                    fork                            :1,     // - create a new process just like this one
                    format                          :1,     // - declare a picture format with use by the write() function
                    formline                        :1,     // - internal function used for formats
                    getc                            :1,     // - get the next character from the filehandle
                    getgrent                        :1,     // - get next group record
                    getgrgid                        :1,     // - get group record given group user ID
                    getgrnam                        :1,     // - get group record given group name
                    gethostbyaddr                   :1,     // - get host record given its address
                    gethostbyname                   :1,     // - get host record given name
                    gethostent                      :1,     // - get next hosts record
                    getlogin                        :1,     // - return who logged in at this tty
                    getnetbyaddr                    :1,     // - get network record given its address
                    getnetbyname                    :1,     // - get networks record given name
                    getnetent                       :1,     // - get next networks record
                    getpeername                     :1,     // - find the other end of a socket connection
                    getpgrp                         :1,     // - get process group
                    getppid                         :1,     // - get parent process ID
                    getpriority                     :1,     // - get current nice value
                    getprotobyname                  :1,     // - get protocol record given name
                    getprotobynumber                :1,     // - get protocol record numeric protocol
                    getprotoent                     :1,     // - get next protocols record
                    getpwent                        :1,     // - get next passwd record
                    getpwnam                        :1,     // - get passwd record given user login name
                    getpwuid                        :1,     // - get passwd record given user ID
                    getservbyname                   :1,     // - get services record given its name
                    getservbyport                   :1,     // - get services record given numeric port
                    getservent                      :1,     // - get next services record
                    getsockname                     :1,     // - retrieve the sockaddr for a given socket
                    getsockopt                      :1,     // - get socket options on a given socket
                    given                           :1,     //
                    glob                            :1,     // - expand filenames using wildcards
                    gmtime                          :1,     // - convert UNIX time into record or string using Greenwich time
                    'goto'                          :1,     // - create spaghetti code
                    grep                            :1,     // - locate elements in a list test true against a given criterion
                    hex                             :1,     // - convert a string to a hexadecimal number
                    'import'                        :1,     // - patch a module's namespace into your own
                    index                           :1,     // - find a substring within a string
                    'int'                           :1,     // - get the integer portion of a number
                    ioctl                           :1,     // - system-dependent device control system call
                    'join'                          :1,     // - join a list into a string using a separator
                    keys                            :1,     // - retrieve list of indices from a hash
                    kill                            :1,     // - send a signal to a process or process group
                    last                            :1,     // - exit a block prematurely
                    lc                              :1,     // - return lower-case version of a string
                    lcfirst                         :1,     // - return a string with just the next letter in lower case
                    length                          :1,     // - return the number of bytes in a string
                    'link'                          :1,     // - create a hard link in the filesystem
                    listen                          :1,     // - register your socket as a server
                    local                           : 2,    // - create a temporary value for a global variable (dynamic scoping)
                    localtime                       :1,     // - convert UNIX time into record or string using local time
                    lock                            :1,     // - get a thread lock on a variable, subroutine, or method
                    'log'                           :1,     // - retrieve the natural logarithm for a number
                    lstat                           :1,     // - stat a symbolic link
                    m                               :null,  // - match a string with a regular expression pattern
                    map                             :1,     // - apply a change to a list to get back a new list with the changes
                    mkdir                           :1,     // - create a directory
                    msgctl                          :1,     // - SysV IPC message control operations
                    msgget                          :1,     // - get SysV IPC message queue
                    msgrcv                          :1,     // - receive a SysV IPC message from a message queue
                    msgsnd                          :1,     // - send a SysV IPC message to a message queue
                    my                              : 2,    // - declare and assign a local variable (lexical scoping)
                    'new'                           :1,     //
                    next                            :1,     // - iterate a block prematurely
                    no                              :1,     // - unimport some module symbols or semantics at compile time
                    oct                             :1,     // - convert a string to an octal number
                    open                            :1,     // - open a file, pipe, or descriptor
                    opendir                         :1,     // - open a directory
                    ord                             :1,     // - find a character's numeric representation
                    our                             : 2,    // - declare and assign a package variable (lexical scoping)
                    pack                            :1,     // - convert a list into a binary representation
                    'package'                       :1,     // - declare a separate global namespace
                    pipe                            :1,     // - open a pair of connected filehandles
                    pop                             :1,     // - remove the last element from an array and return it
                    pos                             :1,     // - find or set the offset for the last/next m//g search
                    print                           :1,     // - output a list to a filehandle
                    printf                          :1,     // - output a formatted list to a filehandle
                    prototype                       :1,     // - get the prototype (if any) of a subroutine
                    push                            :1,     // - append one or more elements to an array
                    q                               :null,  // - singly quote a string
                    qq                              :null,  // - doubly quote a string
                    qr                              :null,  // - Compile pattern
                    quotemeta                       :null,  // - quote regular expression magic characters
                    qw                              :null,  // - quote a list of words
                    qx                              :null,  // - backquote quote a string
                    rand                            :1,     // - retrieve the next pseudorandom number
                    read                            :1,     // - fixed-length buffered input from a filehandle
                    readdir                         :1,     // - get a directory from a directory handle
                    readline                        :1,     // - fetch a record from a file
                    readlink                        :1,     // - determine where a symbolic link is pointing
                    readpipe                        :1,     // - execute a system command and collect standard output
                    recv                            :1,     // - receive a message over a Socket
                    redo                            :1,     // - start this loop iteration over again
                    ref                             :1,     // - find out the type of thing being referenced
                    rename                          :1,     // - change a filename
                    require                         :1,     // - load in external functions from a library at runtime
                    reset                           :1,     // - clear all variables of a given name
                    'return'                        :1,     // - get out of a function early
                    reverse                         :1,     // - flip a string or a list
                    rewinddir                       :1,     // - reset directory handle
                    rindex                          :1,     // - right-to-left substring search
                    rmdir                           :1,     // - remove a directory
                    s                               :null,  // - replace a pattern with a string
                    say                             :1,     // - print with newline
                    scalar                          :1,     // - force a scalar context
                    seek                            :1,     // - reposition file pointer for random-access I/O
                    seekdir                         :1,     // - reposition directory pointer
                    select                          :1,     // - reset default output or do I/O multiplexing
                    semctl                          :1,     // - SysV semaphore control operations
                    semget                          :1,     // - get set of SysV semaphores
                    semop                           :1,     // - SysV semaphore operations
                    send                            :1,     // - send a message over a socket
                    setgrent                        :1,     // - prepare group file for use
                    sethostent                      :1,     // - prepare hosts file for use
                    setnetent                       :1,     // - prepare networks file for use
                    setpgrp                         :1,     // - set the process group of a process
                    setpriority                     :1,     // - set a process's nice value
                    setprotoent                     :1,     // - prepare protocols file for use
                    setpwent                        :1,     // - prepare passwd file for use
                    setservent                      :1,     // - prepare services file for use
                    setsockopt                      :1,     // - set some socket options
                    shift                           :1,     // - remove the first element of an array, and return it
                    shmctl                          :1,     // - SysV shared memory operations
                    shmget                          :1,     // - get SysV shared memory segment identifier
                    shmread                         :1,     // - read SysV shared memory
                    shmwrite                        :1,     // - write SysV shared memory
                    shutdown                        :1,     // - close down just half of a socket connection
                    'sin'                           :1,     // - return the sine of a number
                    sleep                           :1,     // - block for some number of seconds
                    socket                          :1,     // - create a socket
                    socketpair                      :1,     // - create a pair of sockets
                    'sort'                          :1,     // - sort a list of values
                    splice                          :1,     // - add or remove elements anywhere in an array
                    'split'                         :1,     // - split up a string using a regexp delimiter
                    sprintf                         :1,     // - formatted print into a string
                    'sqrt'                          :1,     // - square root function
                    srand                           :1,     // - seed the random number generator
                    stat                            :1,     // - get a file's status information
                    state                           :1,     // - declare and assign a state variable (persistent lexical scoping)
                    study                           :1,     // - optimize input data for repeated searches
                    'sub'                           :1,     // - declare a subroutine, possibly anonymously
                    'substr'                        :1,     // - get or alter a portion of a string
                    symlink                         :1,     // - create a symbolic link to a file
                    syscall                         :1,     // - execute an arbitrary system call
                    sysopen                         :1,     // - open a file, pipe, or descriptor
                    sysread                         :1,     // - fixed-length unbuffered input from a filehandle
                    sysseek                         :1,     // - position I/O pointer on handle used with sysread and syswrite
                    system                          :1,     // - run a separate program
                    syswrite                        :1,     // - fixed-length unbuffered output to a filehandle
                    tell                            :1,     // - get current seekpointer on a filehandle
                    telldir                         :1,     // - get current seekpointer on a directory handle
                    tie                             :1,     // - bind a variable to an object class
                    tied                            :1,     // - get a reference to the object underlying a tied variable
                    time                            :1,     // - return number of seconds since 1970
                    times                           :1,     // - return elapsed time for self and child processes
                    tr                              :null,  // - transliterate a string
                    truncate                        :1,     // - shorten a file
                    uc                              :1,     // - return upper-case version of a string
                    ucfirst                         :1,     // - return a string with just the next letter in upper case
                    umask                           :1,     // - set file creation mode mask
                    undef                           :1,     // - remove a variable or function definition
                    unlink                          :1,     // - remove one link to a file
                    unpack                          :1,     // - convert binary structure into normal perl variables
                    unshift                         :1,     // - prepend more elements to the beginning of a list
                    untie                           :1,     // - break a tie binding to a variable
                    use                             :1,     // - load in a module at compile time
                    utime                           :1,     // - set a file's last access and modify times
                    values                          :1,     // - return a list of the values in a hash
                    vec                             :1,     // - test or set particular bits in a string
                    wait                            :1,     // - wait for any child process to die
                    waitpid                         :1,     // - wait for a particular child process to die
                    wantarray                       :1,     // - get void vs scalar vs list context of current subroutine call
                    warn                            :1,     // - print debugging info
                    when                            :1,     //
                    write                           :1,     // - print a picture record
                    y                               :null}; // - transliterate a string

            var RXstyle="string-2";
            var RXmodifiers=/[goseximacplud]/;              // NOTE: "m", "s", "y" and "tr" need to correct real modifiers for each regexp type

            function tokenChain(stream,state,chain,style,tail){     // NOTE: chain.length > 2 is not working now (it's for s[...][...]geos;)
                    state.chain=null;                               //                                                          12   3tail
                    state.style=null;
                    state.tail=null;
                    state.tokenize=function(stream,state){
                            var e=false,c,i=0;
                            while(c=stream.next()){
                                    if(c===chain[i]&&!e){
                                            if(chain[++i]!==undefined){
                                                    state.chain=chain[i];
                                                    state.style=style;
                                                    state.tail=tail;}
                                            else if(tail)
                                                    stream.eatWhile(tail);
                                            state.tokenize=tokenPerl;
                                            return style;}
                                    e=!e&&c=="\\";}
                            return style;};
                    return state.tokenize(stream,state);}

            function tokenSOMETHING(stream,state,string){
                    state.tokenize=function(stream,state){
                            if(stream.string==string)
                                    state.tokenize=tokenPerl;
                            stream.skipToEnd();
                            return "string";};
                    return state.tokenize(stream,state);}

            function tokenPerl(stream,state){
                    if(stream.eatSpace())
                            return null;
                    if(state.chain)
                            return tokenChain(stream,state,state.chain,state.style,state.tail);
                    if(stream.match(/^\-?[\d\.]/,false))
                            if(stream.match(/^(\-?(\d*\.\d+(e[+-]?\d+)?|\d+\.\d*)|0x[\da-fA-F]+|0b[01]+|\d+(e[+-]?\d+)?)/))
                                    return 'number';
                    if(stream.match(/^<<(?=[_a-zA-Z])/)){                  // NOTE: <<SOMETHING\n...\nSOMETHING\n
                            stream.eatWhile(/\w/);
                            return tokenSOMETHING(stream,state,stream.current().substr(2));}
                    if(stream.sol()&&stream.match(/^\=item(?!\w)/)){// NOTE: \n=item...\n=cut\n
                            return tokenSOMETHING(stream,state,'=cut');}
                    var ch=stream.next();
                    if(ch=='"'||ch=="'"){                           // NOTE: ' or " or <<'SOMETHING'\n...\nSOMETHING\n or <<"SOMETHING"\n...\nSOMETHING\n
                            if(prefix(stream, 3)=="<<"+ch){
                                    var p=stream.pos;
                                    stream.eatWhile(/\w/);
                                    var n=stream.current().substr(1);
                                    if(n&&stream.eat(ch))
                                            return tokenSOMETHING(stream,state,n);
                                    stream.pos=p;}
                            return tokenChain(stream,state,[ch],"string");}
                    if(ch=="q"){
                            var c=look(stream, -2);
                            if(!(c&&/\w/.test(c))){
                                    c=look(stream, 0);
                                    if(c=="x"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                    else if(c=="q"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],"string");}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],"string");}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],"string");}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],"string");}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],"string");}}
                                    else if(c=="w"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],"bracket");}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],"bracket");}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],"bracket");}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],"bracket");}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],"bracket");}}
                                    else if(c=="r"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                    else if(/[\^'"!~\/(\[{<]/.test(c)){
                                            if(c=="("){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[")"],"string");}
                                            if(c=="["){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,["]"],"string");}
                                            if(c=="{"){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,["}"],"string");}
                                            if(c=="<"){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[">"],"string");}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    return tokenChain(stream,state,[stream.eat(c)],"string");}}}}
                    if(ch=="m"){
                            var c=look(stream, -2);
                            if(!(c&&/\w/.test(c))){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(/[\^'"!~\/]/.test(c)){
                                                    return tokenChain(stream,state,[c],RXstyle,RXmodifiers);}
                                            if(c=="("){
                                                    return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                            if(c=="["){
                                                    return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                            if(c=="{"){
                                                    return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                            if(c=="<"){
                                                    return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}}}}
                    if(ch=="s"){
                            var c=/[\/>\]})\w]/.test(look(stream, -2));
                            if(!c){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(c=="[")
                                                    return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                            if(c=="{")
                                                    return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                            if(c=="<")
                                                    return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                            if(c=="(")
                                                    return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                            return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                    if(ch=="y"){
                            var c=/[\/>\]})\w]/.test(look(stream, -2));
                            if(!c){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(c=="[")
                                                    return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                            if(c=="{")
                                                    return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                            if(c=="<")
                                                    return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                            if(c=="(")
                                                    return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                            return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                    if(ch=="t"){
                            var c=/[\/>\]})\w]/.test(look(stream, -2));
                            if(!c){
                                    c=stream.eat("r");if(c){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(c=="[")
                                                    return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                            if(c=="{")
                                                    return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                            if(c=="<")
                                                    return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                            if(c=="(")
                                                    return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                            return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}}
                    if(ch=="`"){
                            return tokenChain(stream,state,[ch],"variable-2");}
                    if(ch=="/"){
                            if(!/~\s*$/.test(prefix(stream)))
                                    return "operator";
                            else
                                    return tokenChain(stream,state,[ch],RXstyle,RXmodifiers);}
                    if(ch=="$"){
                            var p=stream.pos;
                            if(stream.eatWhile(/\d/)||stream.eat("{")&&stream.eatWhile(/\d/)&&stream.eat("}"))
                                    return "variable-2";
                            else
                                    stream.pos=p;}
                    if(/[$@%]/.test(ch)){
                            var p=stream.pos;
                            if(stream.eat("^")&&stream.eat(/[A-Z]/)||!/[@$%&]/.test(look(stream, -2))&&stream.eat(/[=|\\\-#?@;:&`~\^!\[\]*'"$+.,\/<>()]/)){
                                    var c=stream.current();
                                    if(PERL[c])
                                            return "variable-2";}
                            stream.pos=p;}
                    if(/[$@%&]/.test(ch)){
                            if(stream.eatWhile(/[\w$]/)||stream.eat("{")&&stream.eatWhile(/[\w$]/)&&stream.eat("}")){
                                    var c=stream.current();
                                    if(PERL[c])
                                            return "variable-2";
                                    else
                                            return "variable";}}
                    if(ch=="#"){
                            if(look(stream, -2)!="$"){
                                    stream.skipToEnd();
                                    return "comment";}}
                    if(/[:+\-\^*$&%@=<>!?|\/~\.]/.test(ch)){
                            var p=stream.pos;
                            stream.eatWhile(/[:+\-\^*$&%@=<>!?|\/~\.]/);
                            if(PERL[stream.current()])
                                    return "operator";
                            else
                                    stream.pos=p;}
                    if(ch=="_"){
                            if(stream.pos==1){
                                    if(suffix(stream, 6)=="_END__"){
                                            return tokenChain(stream,state,['\0'],"comment");}
                                    else if(suffix(stream, 7)=="_DATA__"){
                                            return tokenChain(stream,state,['\0'],"variable-2");}
                                    else if(suffix(stream, 7)=="_C__"){
                                            return tokenChain(stream,state,['\0'],"string");}}}
                    if(/\w/.test(ch)){
                            var p=stream.pos;
                            if(look(stream, -2)=="{"&&(look(stream, 0)=="}"||stream.eatWhile(/\w/)&&look(stream, 0)=="}"))
                                    return "string";
                            else
                                    stream.pos=p;}
                    if(/[A-Z]/.test(ch)){
                            var l=look(stream, -2);
                            var p=stream.pos;
                            stream.eatWhile(/[A-Z_]/);
                            if(/[\da-z]/.test(look(stream, 0))){
                                    stream.pos=p;}
                            else{
                                    var c=PERL[stream.current()];
                                    if(!c)
                                            return "meta";
                                    if(c[1])
                                            c=c[0];
                                    if(l!=":"){
                                            if(c==1)
                                                    return "keyword";
                                            else if(c==2)
                                                    return "def";
                                            else if(c==3)
                                                    return "atom";
                                            else if(c==4)
                                                    return "operator";
                                            else if(c==5)
                                                    return "variable-2";
                                            else
                                                    return "meta";}
                                    else
                                            return "meta";}}
                    if(/[a-zA-Z_]/.test(ch)){
                            var l=look(stream, -2);
                            stream.eatWhile(/\w/);
                            var c=PERL[stream.current()];
                            if(!c)
                                    return "meta";
                            if(c[1])
                                    c=c[0];
                            if(l!=":"){
                                    if(c==1)
                                            return "keyword";
                                    else if(c==2)
                                            return "def";
                                    else if(c==3)
                                            return "atom";
                                    else if(c==4)
                                            return "operator";
                                    else if(c==5)
                                            return "variable-2";
                                    else
                                            return "meta";}
                            else
                                    return "meta";}
                    return null;}

            return {
                startState: function() {
                    return {
                        tokenize: tokenPerl,
                        chain: null,
                        style: null,
                        tail: null
                    };
                },
                token: function(stream, state) {
                    return (state.tokenize || tokenPerl)(stream, state);
                },
                lineComment: '#'
            };
    });

    CodeMirror.registerHelper("wordChars", "perl", /[\w$]/);

    CodeMirror.defineMIME("text/x-perl", "perl");

    // it's like "peek", but need for look-ahead or look-behind if index < 0
    function look(stream, c){
      return stream.string.charAt(stream.pos+(c||0));
    }

    // return a part of prefix of current stream from current position
    function prefix(stream, c){
      if(c){
        var x=stream.pos-c;
        return stream.string.substr((x>=0?x:0),c);}
      else{
        return stream.string.substr(0,stream.pos-1);
      }
    }

    // return a part of suffix of current stream from current position
    function suffix(stream, c){
      var y=stream.string.length;
      var x=y-stream.pos+1;
      return stream.string.substr(stream.pos,(c&&c<y?c:x));
    }

    // eating and vomiting a part of stream from current position
    function eatSuffix(stream, c){
      var x=stream.pos+c;
      var y;
      if(x<=0)
        stream.pos=0;
      else if(x>=(y=stream.string.length-1))
        stream.pos=y;
      else
        stream.pos=x;
    }

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-properties-properties.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("properties", function() {
      return {
        token: function(stream, state) {
          var sol = stream.sol() || state.afterSection;
          var eol = stream.eol();

          state.afterSection = false;

          if (sol) {
            if (state.nextMultiline) {
              state.inMultiline = true;
              state.nextMultiline = false;
            } else {
              state.position = "def";
            }
          }

          if (eol && ! state.nextMultiline) {
            state.inMultiline = false;
            state.position = "def";
          }

          if (sol) {
            while(stream.eatSpace()) {}
          }

          var ch = stream.next();

          if (sol && (ch === "#" || ch === "!" || ch === ";")) {
            state.position = "comment";
            stream.skipToEnd();
            return "comment";
          } else if (sol && ch === "[") {
            state.afterSection = true;
            stream.skipTo("]"); stream.eat("]");
            return "header";
          } else if (ch === "=" || ch === ":") {
            state.position = "quote";
            return null;
          } else if (ch === "\\" && state.position === "quote") {
            if (stream.eol()) {  // end of line?
              // Multiline value
              state.nextMultiline = true;
            }
          }

          return state.position;
        },

        startState: function() {
          return {
            position : "def",       // Current position, "def", "quote" or "comment"
            nextMultiline : false,  // Is the next line multiline value
            inMultiline : false,    // Is the current line a multiline value
            afterSection : false    // Did we just open a section
          };
        }

      };
    });

    CodeMirror.defineMIME("text/x-properties", "properties");
    CodeMirror.defineMIME("text/x-ini", "properties");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-protobuf-protobuf.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
      };

      var keywordArray = [
        "package", "message", "import", "syntax",
        "required", "optional", "repeated", "reserved", "default", "extensions", "packed",
        "bool", "bytes", "double", "enum", "float", "string",
        "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64",
        "option", "service", "rpc", "returns"
      ];
      var keywords = wordRegexp(keywordArray);

      CodeMirror.registerHelper("hintWords", "protobuf", keywordArray);

      var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

      function tokenBase(stream) {
        // whitespaces
        if (stream.eatSpace()) return null;

        // Handle one line Comments
        if (stream.match("//")) {
          stream.skipToEnd();
          return "comment";
        }

        // Handle Number Literals
        if (stream.match(/^[0-9\.+-]/, false)) {
          if (stream.match(/^[+-]?0x[0-9a-fA-F]+/))
            return "number";
          if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?/))
            return "number";
          if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?/))
            return "number";
        }

        // Handle Strings
        if (stream.match(/^"([^"]|(""))*"/)) { return "string"; }
        if (stream.match(/^'([^']|(''))*'/)) { return "string"; }

        // Handle words
        if (stream.match(keywords)) { return "keyword"; }
        if (stream.match(identifiers)) { return "variable"; } ;

        // Handle non-detected items
        stream.next();
        return null;
      };

      CodeMirror.defineMode("protobuf", function() {
        return {
          token: tokenBase,
          fold: "brace"
        };
      });

      CodeMirror.defineMIME("text/x-protobuf", "protobuf");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-pug-pug.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../javascript/javascript"), require("../css/css"), require("../htmlmixed/htmlmixed"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../javascript/javascript", "../css/css", "../htmlmixed/htmlmixed"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("pug", function (config) {
      // token types
      var KEYWORD = 'keyword';
      var DOCTYPE = 'meta';
      var ID = 'builtin';
      var CLASS = 'qualifier';

      var ATTRS_NEST = {
        '{': '}',
        '(': ')',
        '[': ']'
      };

      var jsMode = CodeMirror.getMode(config, 'javascript');

      function State() {
        this.javaScriptLine = false;
        this.javaScriptLineExcludesColon = false;

        this.javaScriptArguments = false;
        this.javaScriptArgumentsDepth = 0;

        this.isInterpolating = false;
        this.interpolationNesting = 0;

        this.jsState = CodeMirror.startState(jsMode);

        this.restOfLine = '';

        this.isIncludeFiltered = false;
        this.isEach = false;

        this.lastTag = '';
        this.scriptType = '';

        // Attributes Mode
        this.isAttrs = false;
        this.attrsNest = [];
        this.inAttributeName = true;
        this.attributeIsType = false;
        this.attrValue = '';

        // Indented Mode
        this.indentOf = Infinity;
        this.indentToken = '';

        this.innerMode = null;
        this.innerState = null;

        this.innerModeForLine = false;
      }
      /**
       * Safely copy a state
       *
       * @return {State}
       */
      State.prototype.copy = function () {
        var res = new State();
        res.javaScriptLine = this.javaScriptLine;
        res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;
        res.javaScriptArguments = this.javaScriptArguments;
        res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;
        res.isInterpolating = this.isInterpolating;
        res.interpolationNesting = this.interpolationNesting;

        res.jsState = CodeMirror.copyState(jsMode, this.jsState);

        res.innerMode = this.innerMode;
        if (this.innerMode && this.innerState) {
          res.innerState = CodeMirror.copyState(this.innerMode, this.innerState);
        }

        res.restOfLine = this.restOfLine;

        res.isIncludeFiltered = this.isIncludeFiltered;
        res.isEach = this.isEach;
        res.lastTag = this.lastTag;
        res.scriptType = this.scriptType;
        res.isAttrs = this.isAttrs;
        res.attrsNest = this.attrsNest.slice();
        res.inAttributeName = this.inAttributeName;
        res.attributeIsType = this.attributeIsType;
        res.attrValue = this.attrValue;
        res.indentOf = this.indentOf;
        res.indentToken = this.indentToken;

        res.innerModeForLine = this.innerModeForLine;

        return res;
      };

      function javaScript(stream, state) {
        if (stream.sol()) {
          // if javaScriptLine was set at end of line, ignore it
          state.javaScriptLine = false;
          state.javaScriptLineExcludesColon = false;
        }
        if (state.javaScriptLine) {
          if (state.javaScriptLineExcludesColon && stream.peek() === ':') {
            state.javaScriptLine = false;
            state.javaScriptLineExcludesColon = false;
            return;
          }
          var tok = jsMode.token(stream, state.jsState);
          if (stream.eol()) state.javaScriptLine = false;
          return tok || true;
        }
      }
      function javaScriptArguments(stream, state) {
        if (state.javaScriptArguments) {
          if (state.javaScriptArgumentsDepth === 0 && stream.peek() !== '(') {
            state.javaScriptArguments = false;
            return;
          }
          if (stream.peek() === '(') {
            state.javaScriptArgumentsDepth++;
          } else if (stream.peek() === ')') {
            state.javaScriptArgumentsDepth--;
          }
          if (state.javaScriptArgumentsDepth === 0) {
            state.javaScriptArguments = false;
            return;
          }

          var tok = jsMode.token(stream, state.jsState);
          return tok || true;
        }
      }

      function yieldStatement(stream) {
        if (stream.match(/^yield\b/)) {
            return 'keyword';
        }
      }

      function doctype(stream) {
        if (stream.match(/^(?:doctype) *([^\n]+)?/)) {
            return DOCTYPE;
        }
      }

      function interpolation(stream, state) {
        if (stream.match('#{')) {
          state.isInterpolating = true;
          state.interpolationNesting = 0;
          return 'punctuation';
        }
      }

      function interpolationContinued(stream, state) {
        if (state.isInterpolating) {
          if (stream.peek() === '}') {
            state.interpolationNesting--;
            if (state.interpolationNesting < 0) {
              stream.next();
              state.isInterpolating = false;
              return 'punctuation';
            }
          } else if (stream.peek() === '{') {
            state.interpolationNesting++;
          }
          return jsMode.token(stream, state.jsState) || true;
        }
      }

      function caseStatement(stream, state) {
        if (stream.match(/^case\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function when(stream, state) {
        if (stream.match(/^when\b/)) {
          state.javaScriptLine = true;
          state.javaScriptLineExcludesColon = true;
          return KEYWORD;
        }
      }

      function defaultStatement(stream) {
        if (stream.match(/^default\b/)) {
          return KEYWORD;
        }
      }

      function extendsStatement(stream, state) {
        if (stream.match(/^extends?\b/)) {
          state.restOfLine = 'string';
          return KEYWORD;
        }
      }

      function append(stream, state) {
        if (stream.match(/^append\b/)) {
          state.restOfLine = 'variable';
          return KEYWORD;
        }
      }
      function prepend(stream, state) {
        if (stream.match(/^prepend\b/)) {
          state.restOfLine = 'variable';
          return KEYWORD;
        }
      }
      function block(stream, state) {
        if (stream.match(/^block\b *(?:(prepend|append)\b)?/)) {
          state.restOfLine = 'variable';
          return KEYWORD;
        }
      }

      function include(stream, state) {
        if (stream.match(/^include\b/)) {
          state.restOfLine = 'string';
          return KEYWORD;
        }
      }

      function includeFiltered(stream, state) {
        if (stream.match(/^include:([a-zA-Z0-9\-]+)/, false) && stream.match('include')) {
          state.isIncludeFiltered = true;
          return KEYWORD;
        }
      }

      function includeFilteredContinued(stream, state) {
        if (state.isIncludeFiltered) {
          var tok = filter(stream, state);
          state.isIncludeFiltered = false;
          state.restOfLine = 'string';
          return tok;
        }
      }

      function mixin(stream, state) {
        if (stream.match(/^mixin\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function call(stream, state) {
        if (stream.match(/^\+([-\w]+)/)) {
          if (!stream.match(/^\( *[-\w]+ *=/, false)) {
            state.javaScriptArguments = true;
            state.javaScriptArgumentsDepth = 0;
          }
          return 'variable';
        }
        if (stream.match('+#{', false)) {
          stream.next();
          state.mixinCallAfter = true;
          return interpolation(stream, state);
        }
      }
      function callArguments(stream, state) {
        if (state.mixinCallAfter) {
          state.mixinCallAfter = false;
          if (!stream.match(/^\( *[-\w]+ *=/, false)) {
            state.javaScriptArguments = true;
            state.javaScriptArgumentsDepth = 0;
          }
          return true;
        }
      }

      function conditional(stream, state) {
        if (stream.match(/^(if|unless|else if|else)\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function each(stream, state) {
        if (stream.match(/^(- *)?(each|for)\b/)) {
          state.isEach = true;
          return KEYWORD;
        }
      }
      function eachContinued(stream, state) {
        if (state.isEach) {
          if (stream.match(/^ in\b/)) {
            state.javaScriptLine = true;
            state.isEach = false;
            return KEYWORD;
          } else if (stream.sol() || stream.eol()) {
            state.isEach = false;
          } else if (stream.next()) {
            while (!stream.match(/^ in\b/, false) && stream.next());
            return 'variable';
          }
        }
      }

      function whileStatement(stream, state) {
        if (stream.match(/^while\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function tag(stream, state) {
        var captures;
        if (captures = stream.match(/^(\w(?:[-:\w]*\w)?)\/?/)) {
          state.lastTag = captures[1].toLowerCase();
          if (state.lastTag === 'script') {
            state.scriptType = 'application/javascript';
          }
          return 'tag';
        }
      }

      function filter(stream, state) {
        if (stream.match(/^:([\w\-]+)/)) {
          var innerMode;
          if (config && config.innerModes) {
            innerMode = config.innerModes(stream.current().substring(1));
          }
          if (!innerMode) {
            innerMode = stream.current().substring(1);
          }
          if (typeof innerMode === 'string') {
            innerMode = CodeMirror.getMode(config, innerMode);
          }
          setInnerMode(stream, state, innerMode);
          return 'atom';
        }
      }

      function code(stream, state) {
        if (stream.match(/^(!?=|-)/)) {
          state.javaScriptLine = true;
          return 'punctuation';
        }
      }

      function id(stream) {
        if (stream.match(/^#([\w-]+)/)) {
          return ID;
        }
      }

      function className(stream) {
        if (stream.match(/^\.([\w-]+)/)) {
          return CLASS;
        }
      }

      function attrs(stream, state) {
        if (stream.peek() == '(') {
          stream.next();
          state.isAttrs = true;
          state.attrsNest = [];
          state.inAttributeName = true;
          state.attrValue = '';
          state.attributeIsType = false;
          return 'punctuation';
        }
      }

      function attrsContinued(stream, state) {
        if (state.isAttrs) {
          if (ATTRS_NEST[stream.peek()]) {
            state.attrsNest.push(ATTRS_NEST[stream.peek()]);
          }
          if (state.attrsNest[state.attrsNest.length - 1] === stream.peek()) {
            state.attrsNest.pop();
          } else  if (stream.eat(')')) {
            state.isAttrs = false;
            return 'punctuation';
          }
          if (state.inAttributeName && stream.match(/^[^=,\)!]+/)) {
            if (stream.peek() === '=' || stream.peek() === '!') {
              state.inAttributeName = false;
              state.jsState = CodeMirror.startState(jsMode);
              if (state.lastTag === 'script' && stream.current().trim().toLowerCase() === 'type') {
                state.attributeIsType = true;
              } else {
                state.attributeIsType = false;
              }
            }
            return 'attribute';
          }

          var tok = jsMode.token(stream, state.jsState);
          if (state.attributeIsType && tok === 'string') {
            state.scriptType = stream.current().toString();
          }
          if (state.attrsNest.length === 0 && (tok === 'string' || tok === 'variable' || tok === 'keyword')) {
            try {
              Function('', 'var x ' + state.attrValue.replace(/,\s*$/, '').replace(/^!/, ''));
              state.inAttributeName = true;
              state.attrValue = '';
              stream.backUp(stream.current().length);
              return attrsContinued(stream, state);
            } catch (ex) {
              //not the end of an attribute
            }
          }
          state.attrValue += stream.current();
          return tok || true;
        }
      }

      function attributesBlock(stream, state) {
        if (stream.match(/^&attributes\b/)) {
          state.javaScriptArguments = true;
          state.javaScriptArgumentsDepth = 0;
          return 'keyword';
        }
      }

      function indent(stream) {
        if (stream.sol() && stream.eatSpace()) {
          return 'indent';
        }
      }

      function comment(stream, state) {
        if (stream.match(/^ *\/\/(-)?([^\n]*)/)) {
          state.indentOf = stream.indentation();
          state.indentToken = 'comment';
          return 'comment';
        }
      }

      function colon(stream) {
        if (stream.match(/^: */)) {
          return 'colon';
        }
      }

      function text(stream, state) {
        if (stream.match(/^(?:\| ?| )([^\n]+)/)) {
          return 'string';
        }
        if (stream.match(/^(<[^\n]*)/, false)) {
          // html string
          setInnerMode(stream, state, 'htmlmixed');
          state.innerModeForLine = true;
          return innerMode(stream, state, true);
        }
      }

      function dot(stream, state) {
        if (stream.eat('.')) {
          var innerMode = null;
          if (state.lastTag === 'script' && state.scriptType.toLowerCase().indexOf('javascript') != -1) {
            innerMode = state.scriptType.toLowerCase().replace(/"|'/g, '');
          } else if (state.lastTag === 'style') {
            innerMode = 'css';
          }
          setInnerMode(stream, state, innerMode);
          return 'dot';
        }
      }

      function fail(stream) {
        stream.next();
        return null;
      }


      function setInnerMode(stream, state, mode) {
        mode = CodeMirror.mimeModes[mode] || mode;
        mode = config.innerModes ? config.innerModes(mode) || mode : mode;
        mode = CodeMirror.mimeModes[mode] || mode;
        mode = CodeMirror.getMode(config, mode);
        state.indentOf = stream.indentation();

        if (mode && mode.name !== 'null') {
          state.innerMode = mode;
        } else {
          state.indentToken = 'string';
        }
      }
      function innerMode(stream, state, force) {
        if (stream.indentation() > state.indentOf || (state.innerModeForLine && !stream.sol()) || force) {
          if (state.innerMode) {
            if (!state.innerState) {
              state.innerState = state.innerMode.startState ? CodeMirror.startState(state.innerMode, stream.indentation()) : {};
            }
            return stream.hideFirstChars(state.indentOf + 2, function () {
              return state.innerMode.token(stream, state.innerState) || true;
            });
          } else {
            stream.skipToEnd();
            return state.indentToken;
          }
        } else if (stream.sol()) {
          state.indentOf = Infinity;
          state.indentToken = null;
          state.innerMode = null;
          state.innerState = null;
        }
      }
      function restOfLine(stream, state) {
        if (stream.sol()) {
          // if restOfLine was set at end of line, ignore it
          state.restOfLine = '';
        }
        if (state.restOfLine) {
          stream.skipToEnd();
          var tok = state.restOfLine;
          state.restOfLine = '';
          return tok;
        }
      }


      function startState() {
        return new State();
      }
      function copyState(state) {
        return state.copy();
      }
      /**
       * Get the next token in the stream
       *
       * @param {Stream} stream
       * @param {State} state
       */
      function nextToken(stream, state) {
        var tok = innerMode(stream, state)
          || restOfLine(stream, state)
          || interpolationContinued(stream, state)
          || includeFilteredContinued(stream, state)
          || eachContinued(stream, state)
          || attrsContinued(stream, state)
          || javaScript(stream, state)
          || javaScriptArguments(stream, state)
          || callArguments(stream, state)

          || yieldStatement(stream)
          || doctype(stream)
          || interpolation(stream, state)
          || caseStatement(stream, state)
          || when(stream, state)
          || defaultStatement(stream)
          || extendsStatement(stream, state)
          || append(stream, state)
          || prepend(stream, state)
          || block(stream, state)
          || include(stream, state)
          || includeFiltered(stream, state)
          || mixin(stream, state)
          || call(stream, state)
          || conditional(stream, state)
          || each(stream, state)
          || whileStatement(stream, state)
          || tag(stream, state)
          || filter(stream, state)
          || code(stream, state)
          || id(stream)
          || className(stream)
          || attrs(stream, state)
          || attributesBlock(stream, state)
          || indent(stream)
          || text(stream, state)
          || comment(stream, state)
          || colon(stream)
          || dot(stream, state)
          || fail(stream);

        return tok === true ? null : tok;
      }
      return {
        startState: startState,
        copyState: copyState,
        token: nextToken
      };
    }, 'javascript', 'css', 'htmlmixed');

    CodeMirror.defineMIME('text/x-pug', 'pug');
    CodeMirror.defineMIME('text/x-jade', 'pug');

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-r-r.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.registerHelper("wordChars", "r", /[\w.]/);

    CodeMirror.defineMode("r", function(config) {
      function wordObj(words) {
        var res = {};
        for (var i = 0; i < words.length; ++i) res[words[i]] = true;
        return res;
      }
      var commonAtoms = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
      var commonBuiltins = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
      var commonKeywords = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
      var commonBlockKeywords = ["if", "else", "repeat", "while", "function", "for"];

      CodeMirror.registerHelper("hintWords", "r", commonAtoms.concat(commonBuiltins, commonKeywords));

      var atoms = wordObj(commonAtoms);
      var builtins = wordObj(commonBuiltins);
      var keywords = wordObj(commonKeywords);
      var blockkeywords = wordObj(commonBlockKeywords);
      var opChars = /[+\-*\/^<>=!&|~$:]/;
      var curPunc;

      function tokenBase(stream, state) {
        curPunc = null;
        var ch = stream.next();
        if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        } else if (ch == "0" && stream.eat("x")) {
          stream.eatWhile(/[\da-f]/i);
          return "number";
        } else if (ch == "." && stream.eat(/\d/)) {
          stream.match(/\d*(?:e[+\-]?\d+)?/);
          return "number";
        } else if (/\d/.test(ch)) {
          stream.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/);
          return "number";
        } else if (ch == "'" || ch == '"') {
          state.tokenize = tokenString(ch);
          return "string";
        } else if (ch == "`") {
          stream.match(/[^`]+`/);
          return "variable-3";
        } else if (ch == "." && stream.match(/.(?:[.]|\d+)/)) {
          return "keyword";
        } else if (/[a-zA-Z\.]/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          var word = stream.current();
          if (atoms.propertyIsEnumerable(word)) return "atom";
          if (keywords.propertyIsEnumerable(word)) {
            // Block keywords start new blocks, except 'else if', which only starts
            // one new block for the 'if', no block for the 'else'.
            if (blockkeywords.propertyIsEnumerable(word) &&
                !stream.match(/\s*if(\s+|$)/, false))
              curPunc = "block";
            return "keyword";
          }
          if (builtins.propertyIsEnumerable(word)) return "builtin";
          return "variable";
        } else if (ch == "%") {
          if (stream.skipTo("%")) stream.next();
          return "operator variable-2";
        } else if (
            (ch == "<" && stream.eat("-")) ||
            (ch == "<" && stream.match("<-")) ||
            (ch == "-" && stream.match(/>>?/))
          ) {
          return "operator arrow";
        } else if (ch == "=" && state.ctx.argList) {
          return "arg-is";
        } else if (opChars.test(ch)) {
          if (ch == "$") return "operator dollar";
          stream.eatWhile(opChars);
          return "operator";
        } else if (/[\(\){}\[\];]/.test(ch)) {
          curPunc = ch;
          if (ch == ";") return "semi";
          return null;
        } else {
          return null;
        }
      }

      function tokenString(quote) {
        return function(stream, state) {
          if (stream.eat("\\")) {
            var ch = stream.next();
            if (ch == "x") stream.match(/^[a-f0-9]{2}/i);
            else if ((ch == "u" || ch == "U") && stream.eat("{") && stream.skipTo("}")) stream.next();
            else if (ch == "u") stream.match(/^[a-f0-9]{4}/i);
            else if (ch == "U") stream.match(/^[a-f0-9]{8}/i);
            else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);
            return "string-2";
          } else {
            var next;
            while ((next = stream.next()) != null) {
              if (next == quote) { state.tokenize = tokenBase; break; }
              if (next == "\\") { stream.backUp(1); break; }
            }
            return "string";
          }
        };
      }

      var ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4

      function push(state, type, stream) {
        state.ctx = {type: type,
                     indent: state.indent,
                     flags: 0,
                     column: stream.column(),
                     prev: state.ctx};
      }
      function setFlag(state, flag) {
        var ctx = state.ctx
        state.ctx = {type: ctx.type,
                     indent: ctx.indent,
                     flags: ctx.flags | flag,
                     column: ctx.column,
                     prev: ctx.prev}
      }
      function pop(state) {
        state.indent = state.ctx.indent;
        state.ctx = state.ctx.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase,
                  ctx: {type: "top",
                        indent: -config.indentUnit,
                        flags: ALIGN_NO},
                  indent: 0,
                  afterIdent: false};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO
            if (state.ctx.flags & BRACELESS) pop(state)
            state.indent = stream.indentation();
          }
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (style != "comment" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES)

          if ((curPunc == ";" || curPunc == "{" || curPunc == "}") && state.ctx.type == "block") pop(state);
          if (curPunc == "{") push(state, "}", stream);
          else if (curPunc == "(") {
            push(state, ")", stream);
            if (state.afterIdent) state.ctx.argList = true;
          }
          else if (curPunc == "[") push(state, "]", stream);
          else if (curPunc == "block") push(state, "block", stream);
          else if (curPunc == state.ctx.type) pop(state);
          else if (state.ctx.type == "block" && style != "comment") setFlag(state, BRACELESS)
          state.afterIdent = style == "variable" || style == "keyword";
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,
              closing = firstChar == ctx.type;
          if (ctx.flags & BRACELESS) ctx = ctx.prev
          if (ctx.type == "block") return ctx.indent + (firstChar == "{" ? 0 : config.indentUnit);
          else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);
          else return ctx.indent + (closing ? 0 : config.indentUnit);
        },

        lineComment: "#"
      };
    });

    CodeMirror.defineMIME("text/x-rsrc", "r");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-rpm-rpm.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("rpm-changes", function() {
      var headerSeparator = /^-+$/;
      var headerLine = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)  ?\d{1,2} \d{2}:\d{2}(:\d{2})? [A-Z]{3,4} \d{4} - /;
      var simpleEmail = /^[\w+.-]+@[\w.-]+/;

      return {
        token: function(stream) {
          if (stream.sol()) {
            if (stream.match(headerSeparator)) { return 'tag'; }
            if (stream.match(headerLine)) { return 'tag'; }
          }
          if (stream.match(simpleEmail)) { return 'string'; }
          stream.next();
          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-rpm-changes", "rpm-changes");

    // Quick and dirty spec file highlighting

    CodeMirror.defineMode("rpm-spec", function() {
      var arch = /^(i386|i586|i686|x86_64|ppc64le|ppc64|ppc|ia64|s390x|s390|sparc64|sparcv9|sparc|noarch|alphaev6|alpha|hppa|mipsel)/;

      var preamble = /^[a-zA-Z0-9()]+:/;
      var section = /^%(debug_package|package|description|prep|build|install|files|clean|changelog|preinstall|preun|postinstall|postun|pretrans|posttrans|pre|post|triggerin|triggerun|verifyscript|check|triggerpostun|triggerprein|trigger)/;
      var control_flow_complex = /^%(ifnarch|ifarch|if)/; // rpm control flow macros
      var control_flow_simple = /^%(else|endif)/; // rpm control flow macros
      var operators = /^(\!|\?|\<\=|\<|\>\=|\>|\=\=|\&\&|\|\|)/; // operators in control flow macros

      return {
        startState: function () {
            return {
              controlFlow: false,
              macroParameters: false,
              section: false
            };
        },
        token: function (stream, state) {
          var ch = stream.peek();
          if (ch == "#") { stream.skipToEnd(); return "comment"; }

          if (stream.sol()) {
            if (stream.match(preamble)) { return "header"; }
            if (stream.match(section)) { return "atom"; }
          }

          if (stream.match(/^\$\w+/)) { return "def"; } // Variables like '$RPM_BUILD_ROOT'
          if (stream.match(/^\$\{\w+\}/)) { return "def"; } // Variables like '${RPM_BUILD_ROOT}'

          if (stream.match(control_flow_simple)) { return "keyword"; }
          if (stream.match(control_flow_complex)) {
            state.controlFlow = true;
            return "keyword";
          }
          if (state.controlFlow) {
            if (stream.match(operators)) { return "operator"; }
            if (stream.match(/^(\d+)/)) { return "number"; }
            if (stream.eol()) { state.controlFlow = false; }
          }

          if (stream.match(arch)) {
            if (stream.eol()) { state.controlFlow = false; }
            return "number";
          }

          // Macros like '%make_install' or '%attr(0775,root,root)'
          if (stream.match(/^%[\w]+/)) {
            if (stream.match('(')) { state.macroParameters = true; }
            return "keyword";
          }
          if (state.macroParameters) {
            if (stream.match(/^\d+/)) { return "number";}
            if (stream.match(')')) {
              state.macroParameters = false;
              return "keyword";
            }
          }

          // Macros like '%{defined fedora}'
          if (stream.match(/^%\{\??[\w \-\:\!]+\}/)) {
            if (stream.eol()) { state.controlFlow = false; }
            return "def";
          }

          //TODO: Include bash script sub-parser (CodeMirror supports that)
          stream.next();
          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-rpm-spec", "rpm-spec");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-sass-sass.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../css/css"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../css/css"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("sass", function(config) {
      var cssMode = CodeMirror.mimeModes["text/css"];
      var propertyKeywords = cssMode.propertyKeywords || {},
          colorKeywords = cssMode.colorKeywords || {},
          valueKeywords = cssMode.valueKeywords || {},
          fontProperties = cssMode.fontProperties || {};

      function tokenRegexp(words) {
        return new RegExp("^" + words.join("|"));
      }

      var keywords = ["true", "false", "null", "auto"];
      var keywordsRegexp = new RegExp("^" + keywords.join("|"));

      var operators = ["\\(", "\\)", "=", ">", "<", "==", ">=", "<=", "\\+", "-",
                       "\\!=", "/", "\\*", "%", "and", "or", "not", ";","\\{","\\}",":"];
      var opRegexp = tokenRegexp(operators);

      var pseudoElementsRegexp = /^::?[a-zA-Z_][\w\-]*/;

      var word;

      function isEndLine(stream) {
        return !stream.peek() || stream.match(/\s+$/, false);
      }

      function urlTokens(stream, state) {
        var ch = stream.peek();

        if (ch === ")") {
          stream.next();
          state.tokenizer = tokenBase;
          return "operator";
        } else if (ch === "(") {
          stream.next();
          stream.eatSpace();

          return "operator";
        } else if (ch === "'" || ch === '"') {
          state.tokenizer = buildStringTokenizer(stream.next());
          return "string";
        } else {
          state.tokenizer = buildStringTokenizer(")", false);
          return "string";
        }
      }
      function comment(indentation, multiLine) {
        return function(stream, state) {
          if (stream.sol() && stream.indentation() <= indentation) {
            state.tokenizer = tokenBase;
            return tokenBase(stream, state);
          }

          if (multiLine && stream.skipTo("*/")) {
            stream.next();
            stream.next();
            state.tokenizer = tokenBase;
          } else {
            stream.skipToEnd();
          }

          return "comment";
        };
      }

      function buildStringTokenizer(quote, greedy) {
        if (greedy == null) { greedy = true; }

        function stringTokenizer(stream, state) {
          var nextChar = stream.next();
          var peekChar = stream.peek();
          var previousChar = stream.string.charAt(stream.pos-2);

          var endingString = ((nextChar !== "\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\"));

          if (endingString) {
            if (nextChar !== quote && greedy) { stream.next(); }
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            state.tokenizer = tokenBase;
            return "string";
          } else if (nextChar === "#" && peekChar === "{") {
            state.tokenizer = buildInterpolationTokenizer(stringTokenizer);
            stream.next();
            return "operator";
          } else {
            return "string";
          }
        }

        return stringTokenizer;
      }

      function buildInterpolationTokenizer(currentTokenizer) {
        return function(stream, state) {
          if (stream.peek() === "}") {
            stream.next();
            state.tokenizer = currentTokenizer;
            return "operator";
          } else {
            return tokenBase(stream, state);
          }
        };
      }

      function indent(state) {
        if (state.indentCount == 0) {
          state.indentCount++;
          var lastScopeOffset = state.scopes[0].offset;
          var currentOffset = lastScopeOffset + config.indentUnit;
          state.scopes.unshift({ offset:currentOffset });
        }
      }

      function dedent(state) {
        if (state.scopes.length == 1) return;

        state.scopes.shift();
      }

      function tokenBase(stream, state) {
        var ch = stream.peek();

        // Comment
        if (stream.match("/*")) {
          state.tokenizer = comment(stream.indentation(), true);
          return state.tokenizer(stream, state);
        }
        if (stream.match("//")) {
          state.tokenizer = comment(stream.indentation(), false);
          return state.tokenizer(stream, state);
        }

        // Interpolation
        if (stream.match("#{")) {
          state.tokenizer = buildInterpolationTokenizer(tokenBase);
          return "operator";
        }

        // Strings
        if (ch === '"' || ch === "'") {
          stream.next();
          state.tokenizer = buildStringTokenizer(ch);
          return "string";
        }

        if(!state.cursorHalf){// state.cursorHalf === 0
        // first half i.e. before : for key-value pairs
        // including selectors

          if (ch === "-") {
            if (stream.match(/^-\w+-/)) {
              return "meta";
            }
          }

          if (ch === ".") {
            stream.next();
            if (stream.match(/^[\w-]+/)) {
              indent(state);
              return "qualifier";
            } else if (stream.peek() === "#") {
              indent(state);
              return "tag";
            }
          }

          if (ch === "#") {
            stream.next();
            // ID selectors
            if (stream.match(/^[\w-]+/)) {
              indent(state);
              return "builtin";
            }
            if (stream.peek() === "#") {
              indent(state);
              return "tag";
            }
          }

          // Variables
          if (ch === "$") {
            stream.next();
            stream.eatWhile(/[\w-]/);
            return "variable-2";
          }

          // Numbers
          if (stream.match(/^-?[0-9\.]+/))
            return "number";

          // Units
          if (stream.match(/^(px|em|in)\b/))
            return "unit";

          if (stream.match(keywordsRegexp))
            return "keyword";

          if (stream.match(/^url/) && stream.peek() === "(") {
            state.tokenizer = urlTokens;
            return "atom";
          }

          if (ch === "=") {
            // Match shortcut mixin definition
            if (stream.match(/^=[\w-]+/)) {
              indent(state);
              return "meta";
            }
          }

          if (ch === "+") {
            // Match shortcut mixin definition
            if (stream.match(/^\+[\w-]+/)){
              return "variable-3";
            }
          }

          if(ch === "@"){
            if(stream.match('@extend')){
              if(!stream.match(/\s*[\w]/))
                dedent(state);
            }
          }


          // Indent Directives
          if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {
            indent(state);
            return "def";
          }

          // Other Directives
          if (ch === "@") {
            stream.next();
            stream.eatWhile(/[\w-]/);
            return "def";
          }

          if (stream.eatWhile(/[\w-]/)){
            if(stream.match(/ *: *[\w-\+\$#!\("']/,false)){
              word = stream.current().toLowerCase();
              var prop = state.prevProp + "-" + word;
              if (propertyKeywords.hasOwnProperty(prop)) {
                return "property";
              } else if (propertyKeywords.hasOwnProperty(word)) {
                state.prevProp = word;
                return "property";
              } else if (fontProperties.hasOwnProperty(word)) {
                return "property";
              }
              return "tag";
            }
            else if(stream.match(/ *:/,false)){
              indent(state);
              state.cursorHalf = 1;
              state.prevProp = stream.current().toLowerCase();
              return "property";
            }
            else if(stream.match(/ *,/,false)){
              return "tag";
            }
            else{
              indent(state);
              return "tag";
            }
          }

          if(ch === ":"){
            if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element
              return "variable-3";
            }
            stream.next();
            state.cursorHalf=1;
            return "operator";
          }

        } // cursorHalf===0 ends here
        else{

          if (ch === "#") {
            stream.next();
            // Hex numbers
            if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){
              if (isEndLine(stream)) {
                state.cursorHalf = 0;
              }
              return "number";
            }
          }

          // Numbers
          if (stream.match(/^-?[0-9\.]+/)){
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            return "number";
          }

          // Units
          if (stream.match(/^(px|em|in)\b/)){
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            return "unit";
          }

          if (stream.match(keywordsRegexp)){
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            return "keyword";
          }

          if (stream.match(/^url/) && stream.peek() === "(") {
            state.tokenizer = urlTokens;
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            return "atom";
          }

          // Variables
          if (ch === "$") {
            stream.next();
            stream.eatWhile(/[\w-]/);
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            return "variable-2";
          }

          // bang character for !important, !default, etc.
          if (ch === "!") {
            stream.next();
            state.cursorHalf = 0;
            return stream.match(/^[\w]+/) ? "keyword": "operator";
          }

          if (stream.match(opRegexp)){
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            return "operator";
          }

          // attributes
          if (stream.eatWhile(/[\w-]/)) {
            if (isEndLine(stream)) {
              state.cursorHalf = 0;
            }
            word = stream.current().toLowerCase();
            if (valueKeywords.hasOwnProperty(word)) {
              return "atom";
            } else if (colorKeywords.hasOwnProperty(word)) {
              return "keyword";
            } else if (propertyKeywords.hasOwnProperty(word)) {
              state.prevProp = stream.current().toLowerCase();
              return "property";
            } else {
              return "tag";
            }
          }

          //stream.eatSpace();
          if (isEndLine(stream)) {
            state.cursorHalf = 0;
            return null;
          }

        } // else ends here

        if (stream.match(opRegexp))
          return "operator";

        // If we haven't returned by now, we move 1 character
        // and return an error
        stream.next();
        return null;
      }

      function tokenLexer(stream, state) {
        if (stream.sol()) state.indentCount = 0;
        var style = state.tokenizer(stream, state);
        var current = stream.current();

        if (current === "@return" || current === "}"){
          dedent(state);
        }

        if (style !== null) {
          var startOfToken = stream.pos - current.length;

          var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);

          var newScopes = [];

          for (var i = 0; i < state.scopes.length; i++) {
            var scope = state.scopes[i];

            if (scope.offset <= withCurrentIndent)
              newScopes.push(scope);
          }

          state.scopes = newScopes;
        }


        return style;
      }

      return {
        startState: function() {
          return {
            tokenizer: tokenBase,
            scopes: [{offset: 0, type: "sass"}],
            indentCount: 0,
            cursorHalf: 0,  // cursor half tells us if cursor lies after (1)
                            // or before (0) colon (well... more or less)
            definedVars: [],
            definedMixins: []
          };
        },
        token: function(stream, state) {
          var style = tokenLexer(stream, state);

          state.lastToken = { style: style, content: stream.current() };

          return style;
        },

        indent: function(state) {
          return state.scopes[0].offset;
        },

        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//",
        fold: "indent"
      };
    }, "css");

    CodeMirror.defineMIME("text/x-sass", "sass");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-solr-solr.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("solr", function() {
      "use strict";

      var isStringChar = /[^\s\|\!\+\-\*\?\~\^\&\:\(\)\[\]\{\}\"\\]/;
      var isOperatorChar = /[\|\!\+\-\*\?\~\^\&]/;
      var isOperatorString = /^(OR|AND|NOT|TO)$/i;

      function isNumber(word) {
        return parseFloat(word).toString() === word;
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) break;
            escaped = !escaped && next == "\\";
          }

          if (!escaped) state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenOperator(operator) {
        return function(stream, state) {
          var style = "operator";
          if (operator == "+")
            style += " positive";
          else if (operator == "-")
            style += " negative";
          else if (operator == "|")
            stream.eat(/\|/);
          else if (operator == "&")
            stream.eat(/\&/);
          else if (operator == "^")
            style += " boost";

          state.tokenize = tokenBase;
          return style;
        };
      }

      function tokenWord(ch) {
        return function(stream, state) {
          var word = ch;
          while ((ch = stream.peek()) && ch.match(isStringChar) != null) {
            word += stream.next();
          }

          state.tokenize = tokenBase;
          if (isOperatorString.test(word))
            return "operator";
          else if (isNumber(word))
            return "number";
          else if (stream.peek() == ":")
            return "field";
          else
            return "string";
        };
      }

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"')
          state.tokenize = tokenString(ch);
        else if (isOperatorChar.test(ch))
          state.tokenize = tokenOperator(ch);
        else if (isStringChar.test(ch))
          state.tokenize = tokenWord(ch);

        return (state.tokenize != tokenBase) ? state.tokenize(stream, state) : null;
      }

      return {
        startState: function() {
          return {
            tokenize: tokenBase
          };
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        }
      };
    });

    CodeMirror.defineMIME("text/x-solr", "solr");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-stylus-stylus.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Stylus mode created by Dmitry Kiselyov http://git.io/AaRB

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("stylus", function(config) {
        var indentUnit = config.indentUnit,
            indentUnitString = '',
            tagKeywords = keySet(tagKeywords_),
            tagVariablesRegexp = /^(a|b|i|s|col|em)$/i,
            propertyKeywords = keySet(propertyKeywords_),
            nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_),
            valueKeywords = keySet(valueKeywords_),
            colorKeywords = keySet(colorKeywords_),
            documentTypes = keySet(documentTypes_),
            documentTypesRegexp = wordRegexp(documentTypes_),
            mediaFeatures = keySet(mediaFeatures_),
            mediaTypes = keySet(mediaTypes_),
            fontProperties = keySet(fontProperties_),
            operatorsRegexp = /^\s*([.]{2,3}|&&|\|\||\*\*|[?!=:]?=|[-+*\/%<>]=?|\?:|\~)/,
            wordOperatorKeywordsRegexp = wordRegexp(wordOperatorKeywords_),
            blockKeywords = keySet(blockKeywords_),
            vendorPrefixesRegexp = new RegExp(/^\-(moz|ms|o|webkit)-/i),
            commonAtoms = keySet(commonAtoms_),
            firstWordMatch = "",
            states = {},
            ch,
            style,
            type,
            override;

        while (indentUnitString.length < indentUnit) indentUnitString += ' ';

        /**
         * Tokenizers
         */
        function tokenBase(stream, state) {
          firstWordMatch = stream.string.match(/(^[\w-]+\s*=\s*$)|(^\s*[\w-]+\s*=\s*[\w-])|(^\s*(\.|#|@|\$|\&|\[|\d|\+|::?|\{|\>|~|\/)?\s*[\w-]*([a-z0-9-]|\*|\/\*)(\(|,)?)/);
          state.context.line.firstWord = firstWordMatch ? firstWordMatch[0].replace(/^\s*/, "") : "";
          state.context.line.indent = stream.indentation();
          ch = stream.peek();

          // Line comment
          if (stream.match("//")) {
            stream.skipToEnd();
            return ["comment", "comment"];
          }
          // Block comment
          if (stream.match("/*")) {
            state.tokenize = tokenCComment;
            return tokenCComment(stream, state);
          }
          // String
          if (ch == "\"" || ch == "'") {
            stream.next();
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          // Def
          if (ch == "@") {
            stream.next();
            stream.eatWhile(/[\w\\-]/);
            return ["def", stream.current()];
          }
          // ID selector or Hex color
          if (ch == "#") {
            stream.next();
            // Hex color
            if (stream.match(/^[0-9a-f]{3}([0-9a-f]([0-9a-f]{2}){0,2})?\b(?!-)/i)) {
              return ["atom", "atom"];
            }
            // ID selector
            if (stream.match(/^[a-z][\w-]*/i)) {
              return ["builtin", "hash"];
            }
          }
          // Vendor prefixes
          if (stream.match(vendorPrefixesRegexp)) {
            return ["meta", "vendor-prefixes"];
          }
          // Numbers
          if (stream.match(/^-?[0-9]?\.?[0-9]/)) {
            stream.eatWhile(/[a-z%]/i);
            return ["number", "unit"];
          }
          // !important|optional
          if (ch == "!") {
            stream.next();
            return [stream.match(/^(important|optional)/i) ? "keyword": "operator", "important"];
          }
          // Class
          if (ch == "." && stream.match(/^\.[a-z][\w-]*/i)) {
            return ["qualifier", "qualifier"];
          }
          // url url-prefix domain regexp
          if (stream.match(documentTypesRegexp)) {
            if (stream.peek() == "(") state.tokenize = tokenParenthesized;
            return ["property", "word"];
          }
          // Mixins / Functions
          if (stream.match(/^[a-z][\w-]*\(/i)) {
            stream.backUp(1);
            return ["keyword", "mixin"];
          }
          // Block mixins
          if (stream.match(/^(\+|-)[a-z][\w-]*\(/i)) {
            stream.backUp(1);
            return ["keyword", "block-mixin"];
          }
          // Parent Reference BEM naming
          if (stream.string.match(/^\s*&/) && stream.match(/^[-_]+[a-z][\w-]*/)) {
            return ["qualifier", "qualifier"];
          }
          // / Root Reference & Parent Reference
          if (stream.match(/^(\/|&)(-|_|:|\.|#|[a-z])/)) {
            stream.backUp(1);
            return ["variable-3", "reference"];
          }
          if (stream.match(/^&{1}\s*$/)) {
            return ["variable-3", "reference"];
          }
          // Word operator
          if (stream.match(wordOperatorKeywordsRegexp)) {
            return ["operator", "operator"];
          }
          // Word
          if (stream.match(/^\$?[-_]*[a-z0-9]+[\w-]*/i)) {
            // Variable
            if (stream.match(/^(\.|\[)[\w-\'\"\]]+/i, false)) {
              if (!wordIsTag(stream.current())) {
                stream.match('.');
                return ["variable-2", "variable-name"];
              }
            }
            return ["variable-2", "word"];
          }
          // Operators
          if (stream.match(operatorsRegexp)) {
            return ["operator", stream.current()];
          }
          // Delimiters
          if (/[:;,{}\[\]\(\)]/.test(ch)) {
            stream.next();
            return [null, ch];
          }
          // Non-detected items
          stream.next();
          return [null, null];
        }

        /**
         * Token comment
         */
        function tokenCComment(stream, state) {
          var maybeEnd = false, ch;
          while ((ch = stream.next()) != null) {
            if (maybeEnd && ch == "/") {
              state.tokenize = null;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return ["comment", "comment"];
        }

        /**
         * Token string
         */
        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, ch;
            while ((ch = stream.next()) != null) {
              if (ch == quote && !escaped) {
                if (quote == ")") stream.backUp(1);
                break;
              }
              escaped = !escaped && ch == "\\";
            }
            if (ch == quote || !escaped && quote != ")") state.tokenize = null;
            return ["string", "string"];
          };
        }

        /**
         * Token parenthesized
         */
        function tokenParenthesized(stream, state) {
          stream.next(); // Must be "("
          if (!stream.match(/\s*[\"\')]/, false))
            state.tokenize = tokenString(")");
          else
            state.tokenize = null;
          return [null, "("];
        }

        /**
         * Context management
         */
        function Context(type, indent, prev, line) {
          this.type = type;
          this.indent = indent;
          this.prev = prev;
          this.line = line || {firstWord: "", indent: 0};
        }

        function pushContext(state, stream, type, indent) {
          indent = indent >= 0 ? indent : indentUnit;
          state.context = new Context(type, stream.indentation() + indent, state.context);
          return type;
        }

        function popContext(state, currentIndent) {
          var contextIndent = state.context.indent - indentUnit;
          currentIndent = currentIndent || false;
          state.context = state.context.prev;
          if (currentIndent) state.context.indent = contextIndent;
          return state.context.type;
        }

        function pass(type, stream, state) {
          return states[state.context.type](type, stream, state);
        }

        function popAndPass(type, stream, state, n) {
          for (var i = n || 1; i > 0; i--)
            state.context = state.context.prev;
          return pass(type, stream, state);
        }


        /**
         * Parser
         */
        function wordIsTag(word) {
          return word.toLowerCase() in tagKeywords;
        }

        function wordIsProperty(word) {
          word = word.toLowerCase();
          return word in propertyKeywords || word in fontProperties;
        }

        function wordIsBlock(word) {
          return word.toLowerCase() in blockKeywords;
        }

        function wordIsVendorPrefix(word) {
          return word.toLowerCase().match(vendorPrefixesRegexp);
        }

        function wordAsValue(word) {
          var wordLC = word.toLowerCase();
          var override = "variable-2";
          if (wordIsTag(word)) override = "tag";
          else if (wordIsBlock(word)) override = "block-keyword";
          else if (wordIsProperty(word)) override = "property";
          else if (wordLC in valueKeywords || wordLC in commonAtoms) override = "atom";
          else if (wordLC == "return" || wordLC in colorKeywords) override = "keyword";

          // Font family
          else if (word.match(/^[A-Z]/)) override = "string";
          return override;
        }

        function typeIsBlock(type, stream) {
          return ((endOfLine(stream) && (type == "{" || type == "]" || type == "hash" || type == "qualifier")) || type == "block-mixin");
        }

        function typeIsInterpolation(type, stream) {
          return type == "{" && stream.match(/^\s*\$?[\w-]+/i, false);
        }

        function typeIsPseudo(type, stream) {
          return type == ":" && stream.match(/^[a-z-]+/, false);
        }

        function startOfLine(stream) {
          return stream.sol() || stream.string.match(new RegExp("^\\s*" + escapeRegExp(stream.current())));
        }

        function endOfLine(stream) {
          return stream.eol() || stream.match(/^\s*$/, false);
        }

        function firstWordOfLine(line) {
          var re = /^\s*[-_]*[a-z0-9]+[\w-]*/i;
          var result = typeof line == "string" ? line.match(re) : line.string.match(re);
          return result ? result[0].replace(/^\s*/, "") : "";
        }


        /**
         * Block
         */
        states.block = function(type, stream, state) {
          if ((type == "comment" && startOfLine(stream)) ||
              (type == "," && endOfLine(stream)) ||
              type == "mixin") {
            return pushContext(state, stream, "block", 0);
          }
          if (typeIsInterpolation(type, stream)) {
            return pushContext(state, stream, "interpolation");
          }
          if (endOfLine(stream) && type == "]") {
            if (!/^\s*(\.|#|:|\[|\*|&)/.test(stream.string) && !wordIsTag(firstWordOfLine(stream))) {
              return pushContext(state, stream, "block", 0);
            }
          }
          if (typeIsBlock(type, stream)) {
            return pushContext(state, stream, "block");
          }
          if (type == "}" && endOfLine(stream)) {
            return pushContext(state, stream, "block", 0);
          }
          if (type == "variable-name") {
            if (stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/) || wordIsBlock(firstWordOfLine(stream))) {
              return pushContext(state, stream, "variableName");
            }
            else {
              return pushContext(state, stream, "variableName", 0);
            }
          }
          if (type == "=") {
            if (!endOfLine(stream) && !wordIsBlock(firstWordOfLine(stream))) {
              return pushContext(state, stream, "block", 0);
            }
            return pushContext(state, stream, "block");
          }
          if (type == "*") {
            if (endOfLine(stream) || stream.match(/\s*(,|\.|#|\[|:|{)/,false)) {
              override = "tag";
              return pushContext(state, stream, "block");
            }
          }
          if (typeIsPseudo(type, stream)) {
            return pushContext(state, stream, "pseudo");
          }
          if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {
            return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
          }
          if (/@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
            return pushContext(state, stream, "keyframes");
          }
          if (/@extends?/.test(type)) {
            return pushContext(state, stream, "extend", 0);
          }
          if (type && type.charAt(0) == "@") {

            // Property Lookup
            if (stream.indentation() > 0 && wordIsProperty(stream.current().slice(1))) {
              override = "variable-2";
              return "block";
            }
            if (/(@import|@require|@charset)/.test(type)) {
              return pushContext(state, stream, "block", 0);
            }
            return pushContext(state, stream, "block");
          }
          if (type == "reference" && endOfLine(stream)) {
            return pushContext(state, stream, "block");
          }
          if (type == "(") {
            return pushContext(state, stream, "parens");
          }

          if (type == "vendor-prefixes") {
            return pushContext(state, stream, "vendorPrefixes");
          }
          if (type == "word") {
            var word = stream.current();
            override = wordAsValue(word);

            if (override == "property") {
              if (startOfLine(stream)) {
                return pushContext(state, stream, "block", 0);
              } else {
                override = "atom";
                return "block";
              }
            }

            if (override == "tag") {

              // tag is a css value
              if (/embed|menu|pre|progress|sub|table/.test(word)) {
                if (wordIsProperty(firstWordOfLine(stream))) {
                  override = "atom";
                  return "block";
                }
              }

              // tag is an attribute
              if (stream.string.match(new RegExp("\\[\\s*" + word + "|" + word +"\\s*\\]"))) {
                override = "atom";
                return "block";
              }

              // tag is a variable
              if (tagVariablesRegexp.test(word)) {
                if ((startOfLine(stream) && stream.string.match(/=/)) ||
                    (!startOfLine(stream) &&
                     !stream.string.match(/^(\s*\.|#|\&|\[|\/|>|\*)/) &&
                     !wordIsTag(firstWordOfLine(stream)))) {
                  override = "variable-2";
                  if (wordIsBlock(firstWordOfLine(stream)))  return "block";
                  return pushContext(state, stream, "block", 0);
                }
              }

              if (endOfLine(stream)) return pushContext(state, stream, "block");
            }
            if (override == "block-keyword") {
              override = "keyword";

              // Postfix conditionals
              if (stream.current(/(if|unless)/) && !startOfLine(stream)) {
                return "block";
              }
              return pushContext(state, stream, "block");
            }
            if (word == "return") return pushContext(state, stream, "block", 0);

            // Placeholder selector
            if (override == "variable-2" && stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/)) {
              return pushContext(state, stream, "block");
            }
          }
          return state.context.type;
        };


        /**
         * Parens
         */
        states.parens = function(type, stream, state) {
          if (type == "(") return pushContext(state, stream, "parens");
          if (type == ")") {
            if (state.context.prev.type == "parens") {
              return popContext(state);
            }
            if ((stream.string.match(/^[a-z][\w-]*\(/i) && endOfLine(stream)) ||
                wordIsBlock(firstWordOfLine(stream)) ||
                /(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(firstWordOfLine(stream)) ||
                (!stream.string.match(/^-?[a-z][\w-\.\[\]\'\"]*\s*=/) &&
                 wordIsTag(firstWordOfLine(stream)))) {
              return pushContext(state, stream, "block");
            }
            if (stream.string.match(/^[\$-]?[a-z][\w-\.\[\]\'\"]*\s*=/) ||
                stream.string.match(/^\s*(\(|\)|[0-9])/) ||
                stream.string.match(/^\s+[a-z][\w-]*\(/i) ||
                stream.string.match(/^\s+[\$-]?[a-z]/i)) {
              return pushContext(state, stream, "block", 0);
            }
            if (endOfLine(stream)) return pushContext(state, stream, "block");
            else return pushContext(state, stream, "block", 0);
          }
          if (type && type.charAt(0) == "@" && wordIsProperty(stream.current().slice(1))) {
            override = "variable-2";
          }
          if (type == "word") {
            var word = stream.current();
            override = wordAsValue(word);
            if (override == "tag" && tagVariablesRegexp.test(word)) {
              override = "variable-2";
            }
            if (override == "property" || word == "to") override = "atom";
          }
          if (type == "variable-name") {
            return pushContext(state, stream, "variableName");
          }
          if (typeIsPseudo(type, stream)) {
            return pushContext(state, stream, "pseudo");
          }
          return state.context.type;
        };


        /**
         * Vendor prefixes
         */
        states.vendorPrefixes = function(type, stream, state) {
          if (type == "word") {
            override = "property";
            return pushContext(state, stream, "block", 0);
          }
          return popContext(state);
        };


        /**
         * Pseudo
         */
        states.pseudo = function(type, stream, state) {
          if (!wordIsProperty(firstWordOfLine(stream.string))) {
            stream.match(/^[a-z-]+/);
            override = "variable-3";
            if (endOfLine(stream)) return pushContext(state, stream, "block");
            return popContext(state);
          }
          return popAndPass(type, stream, state);
        };


        /**
         * atBlock
         */
        states.atBlock = function(type, stream, state) {
          if (type == "(") return pushContext(state, stream, "atBlock_parens");
          if (typeIsBlock(type, stream)) {
            return pushContext(state, stream, "block");
          }
          if (typeIsInterpolation(type, stream)) {
            return pushContext(state, stream, "interpolation");
          }
          if (type == "word") {
            var word = stream.current().toLowerCase();
            if (/^(only|not|and|or)$/.test(word))
              override = "keyword";
            else if (documentTypes.hasOwnProperty(word))
              override = "tag";
            else if (mediaTypes.hasOwnProperty(word))
              override = "attribute";
            else if (mediaFeatures.hasOwnProperty(word))
              override = "property";
            else if (nonStandardPropertyKeywords.hasOwnProperty(word))
              override = "string-2";
            else override = wordAsValue(stream.current());
            if (override == "tag" && endOfLine(stream)) {
              return pushContext(state, stream, "block");
            }
          }
          if (type == "operator" && /^(not|and|or)$/.test(stream.current())) {
            override = "keyword";
          }
          return state.context.type;
        };

        states.atBlock_parens = function(type, stream, state) {
          if (type == "{" || type == "}") return state.context.type;
          if (type == ")") {
            if (endOfLine(stream)) return pushContext(state, stream, "block");
            else return pushContext(state, stream, "atBlock");
          }
          if (type == "word") {
            var word = stream.current().toLowerCase();
            override = wordAsValue(word);
            if (/^(max|min)/.test(word)) override = "property";
            if (override == "tag") {
              tagVariablesRegexp.test(word) ? override = "variable-2" : override = "atom";
            }
            return state.context.type;
          }
          return states.atBlock(type, stream, state);
        };


        /**
         * Keyframes
         */
        states.keyframes = function(type, stream, state) {
          if (stream.indentation() == "0" && ((type == "}" && startOfLine(stream)) || type == "]" || type == "hash"
                                              || type == "qualifier" || wordIsTag(stream.current()))) {
            return popAndPass(type, stream, state);
          }
          if (type == "{") return pushContext(state, stream, "keyframes");
          if (type == "}") {
            if (startOfLine(stream)) return popContext(state, true);
            else return pushContext(state, stream, "keyframes");
          }
          if (type == "unit" && /^[0-9]+\%$/.test(stream.current())) {
            return pushContext(state, stream, "keyframes");
          }
          if (type == "word") {
            override = wordAsValue(stream.current());
            if (override == "block-keyword") {
              override = "keyword";
              return pushContext(state, stream, "keyframes");
            }
          }
          if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {
            return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
          }
          if (type == "mixin") {
            return pushContext(state, stream, "block", 0);
          }
          return state.context.type;
        };


        /**
         * Interpolation
         */
        states.interpolation = function(type, stream, state) {
          if (type == "{") popContext(state) && pushContext(state, stream, "block");
          if (type == "}") {
            if (stream.string.match(/^\s*(\.|#|:|\[|\*|&|>|~|\+|\/)/i) ||
                (stream.string.match(/^\s*[a-z]/i) && wordIsTag(firstWordOfLine(stream)))) {
              return pushContext(state, stream, "block");
            }
            if (!stream.string.match(/^(\{|\s*\&)/) ||
                stream.match(/\s*[\w-]/,false)) {
              return pushContext(state, stream, "block", 0);
            }
            return pushContext(state, stream, "block");
          }
          if (type == "variable-name") {
            return pushContext(state, stream, "variableName", 0);
          }
          if (type == "word") {
            override = wordAsValue(stream.current());
            if (override == "tag") override = "atom";
          }
          return state.context.type;
        };


        /**
         * Extend/s
         */
        states.extend = function(type, stream, state) {
          if (type == "[" || type == "=") return "extend";
          if (type == "]") return popContext(state);
          if (type == "word") {
            override = wordAsValue(stream.current());
            return "extend";
          }
          return popContext(state);
        };


        /**
         * Variable name
         */
        states.variableName = function(type, stream, state) {
          if (type == "string" || type == "[" || type == "]" || stream.current().match(/^(\.|\$)/)) {
            if (stream.current().match(/^\.[\w-]+/i)) override = "variable-2";
            return "variableName";
          }
          return popAndPass(type, stream, state);
        };


        return {
          startState: function(base) {
            return {
              tokenize: null,
              state: "block",
              context: new Context("block", base || 0, null)
            };
          },
          token: function(stream, state) {
            if (!state.tokenize && stream.eatSpace()) return null;
            style = (state.tokenize || tokenBase)(stream, state);
            if (style && typeof style == "object") {
              type = style[1];
              style = style[0];
            }
            override = style;
            state.state = states[state.state](type, stream, state);
            return override;
          },
          indent: function(state, textAfter, line) {

            var cx = state.context,
                ch = textAfter && textAfter.charAt(0),
                indent = cx.indent,
                lineFirstWord = firstWordOfLine(textAfter),
                lineIndent = line.match(/^\s*/)[0].replace(/\t/g, indentUnitString).length,
                prevLineFirstWord = state.context.prev ? state.context.prev.line.firstWord : "",
                prevLineIndent = state.context.prev ? state.context.prev.line.indent : lineIndent;

            if (cx.prev &&
                (ch == "}" && (cx.type == "block" || cx.type == "atBlock" || cx.type == "keyframes") ||
                 ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
                 ch == "{" && (cx.type == "at"))) {
              indent = cx.indent - indentUnit;
            } else if (!(/(\})/.test(ch))) {
              if (/@|\$|\d/.test(ch) ||
                  /^\{/.test(textAfter) ||
    /^\s*\/(\/|\*)/.test(textAfter) ||
                  /^\s*\/\*/.test(prevLineFirstWord) ||
                  /^\s*[\w-\.\[\]\'\"]+\s*(\?|:|\+)?=/i.test(textAfter) ||
    /^(\+|-)?[a-z][\w-]*\(/i.test(textAfter) ||
    /^return/.test(textAfter) ||
                  wordIsBlock(lineFirstWord)) {
                indent = lineIndent;
              } else if (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(ch) || wordIsTag(lineFirstWord)) {
                if (/\,\s*$/.test(prevLineFirstWord)) {
                  indent = prevLineIndent;
                } else if (/^\s+/.test(line) && (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(prevLineFirstWord) || wordIsTag(prevLineFirstWord))) {
                  indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
                } else {
                  indent = lineIndent;
                }
              } else if (!/,\s*$/.test(line) && (wordIsVendorPrefix(lineFirstWord) || wordIsProperty(lineFirstWord))) {
                if (wordIsBlock(prevLineFirstWord)) {
                  indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
                } else if (/^\{/.test(prevLineFirstWord)) {
                  indent = lineIndent <= prevLineIndent ? lineIndent : prevLineIndent + indentUnit;
                } else if (wordIsVendorPrefix(prevLineFirstWord) || wordIsProperty(prevLineFirstWord)) {
                  indent = lineIndent >= prevLineIndent ? prevLineIndent : lineIndent;
                } else if (/^(\.|#|:|\[|\*|&|@|\+|\-|>|~|\/)/.test(prevLineFirstWord) ||
                          /=\s*$/.test(prevLineFirstWord) ||
                          wordIsTag(prevLineFirstWord) ||
                          /^\$[\w-\.\[\]\'\"]/.test(prevLineFirstWord)) {
                  indent = prevLineIndent + indentUnit;
                } else {
                  indent = lineIndent;
                }
              }
            }
            return indent;
          },
          electricChars: "}",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          blockCommentContinue: " * ",
          lineComment: "//",
          fold: "indent"
        };
      });

      // developer.mozilla.org/en-US/docs/Web/HTML/Element
      var tagKeywords_ = ["a","abbr","address","area","article","aside","audio", "b", "base","bdi", "bdo","bgsound","blockquote","body","br","button","canvas","caption","cite", "code","col","colgroup","data","datalist","dd","del","details","dfn","div", "dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1", "h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe", "img","input","ins","kbd","keygen","label","legend","li","link","main","map", "mark","marquee","menu","menuitem","meta","meter","nav","nobr","noframes", "noscript","object","ol","optgroup","option","output","p","param","pre", "progress","q","rp","rt","ruby","s","samp","script","section","select", "small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","track", "u","ul","var","video"];

      // github.com/codemirror/CodeMirror/blob/master/mode/css/css.js
      // Note, "url-prefix" should precede "url" in order to match correctly in documentTypesRegexp
      var documentTypes_ = ["domain", "regexp", "url-prefix", "url"];
      var mediaTypes_ = ["all","aural","braille","handheld","print","projection","screen","tty","tv","embossed"];
      var mediaFeatures_ = ["width","min-width","max-width","height","min-height","max-height","device-width","min-device-width","max-device-width","device-height","min-device-height","max-device-height","aspect-ratio","min-aspect-ratio","max-aspect-ratio","device-aspect-ratio","min-device-aspect-ratio","max-device-aspect-ratio","color","min-color","max-color","color-index","min-color-index","max-color-index","monochrome","min-monochrome","max-monochrome","resolution","min-resolution","max-resolution","scan","grid"];
      var propertyKeywords_ = ["align-content","align-items","align-self","alignment-adjust","alignment-baseline","anchor-point","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","appearance","azimuth","backface-visibility","background","background-attachment","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","baseline-shift","binding","bleed","bookmark-label","bookmark-level","bookmark-state","bookmark-target","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","clear","clip","color","color-profile","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","content","counter-increment","counter-reset","crop","cue","cue-after","cue-before","cursor","direction","display","dominant-baseline","drop-initial-after-adjust","drop-initial-after-align","drop-initial-before-adjust","drop-initial-before-align","drop-initial-size","drop-initial-value","elevation","empty-cells","fit","fit-position","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","float-offset","flow-from","flow-into","font","font-feature-settings","font-family","font-kerning","font-language-override","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-weight","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-position","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","inline-box-align","justify-content","left","letter-spacing","line-break","line-height","line-stacking","line-stacking-ruby","line-stacking-shift","line-stacking-strategy","list-style","list-style-image","list-style-position","list-style-type","margin","margin-bottom","margin-left","margin-right","margin-top","marker-offset","marks","marquee-direction","marquee-loop","marquee-play-count","marquee-speed","marquee-style","max-height","max-width","min-height","min-width","move-to","nav-down","nav-index","nav-left","nav-right","nav-up","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-style","overflow-wrap","overflow-x","overflow-y","padding","padding-bottom","padding-left","padding-right","padding-top","page","page-break-after","page-break-before","page-break-inside","page-policy","pause","pause-after","pause-before","perspective","perspective-origin","pitch","pitch-range","play-during","position","presentation-level","punctuation-trim","quotes","region-break-after","region-break-before","region-break-inside","region-fragment","rendering-intent","resize","rest","rest-after","rest-before","richness","right","rotation","rotation-point","ruby-align","ruby-overhang","ruby-position","ruby-span","shape-image-threshold","shape-inside","shape-margin","shape-outside","size","speak","speak-as","speak-header","speak-numeral","speak-punctuation","speech-rate","stress","string-set","tab-size","table-layout","target","target-name","target-new","target-position","text-align","text-align-last","text-decoration","text-decoration-color","text-decoration-line","text-decoration-skip","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-height","text-indent","text-justify","text-outline","text-overflow","text-shadow","text-size-adjust","text-space-collapse","text-transform","text-underline-position","text-wrap","top","transform","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","z-index","clip-path","clip-rule","mask","enable-background","filter","flood-color","flood-opacity","lighting-color","stop-color","stop-opacity","pointer-events","color-interpolation","color-interpolation-filters","color-rendering","fill","fill-opacity","fill-rule","image-rendering","marker","marker-end","marker-mid","marker-start","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-rendering","baseline-shift","dominant-baseline","glyph-orientation-horizontal","glyph-orientation-vertical","text-anchor","writing-mode","font-smoothing","osx-font-smoothing"];
      var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color","scrollbar-base-color","scrollbar-dark-shadow-color","scrollbar-face-color","scrollbar-highlight-color","scrollbar-shadow-color","scrollbar-3d-light-color","scrollbar-track-color","shape-inside","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","zoom"];
      var fontProperties_ = ["font-family","src","unicode-range","font-variant","font-feature-settings","font-stretch","font-weight","font-style"];
      var colorKeywords_ = ["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"];
      var valueKeywords_ = ["above","absolute","activeborder","additive","activecaption","afar","after-white-space","ahead","alias","all","all-scroll","alphabetic","alternate","always","amharic","amharic-abegede","antialiased","appworkspace","arabic-indic","armenian","asterisks","attr","auto","avoid","avoid-column","avoid-page","avoid-region","background","backwards","baseline","below","bidi-override","binary","bengali","blink","block","block-axis","bold","bolder","border","border-box","both","bottom","break","break-all","break-word","bullets","button","button-bevel","buttonface","buttonhighlight","buttonshadow","buttontext","calc","cambodian","capitalize","caps-lock-indicator","caption","captiontext","caret","cell","center","checkbox","circle","cjk-decimal","cjk-earthly-branch","cjk-heavenly-stem","cjk-ideographic","clear","clip","close-quote","col-resize","collapse","column","compact","condensed","contain","content","contents","content-box","context-menu","continuous","copy","counter","counters","cover","crop","cross","crosshair","currentcolor","cursive","cyclic","dashed","decimal","decimal-leading-zero","default","default-button","destination-atop","destination-in","destination-out","destination-over","devanagari","disc","discard","disclosure-closed","disclosure-open","document","dot-dash","dot-dot-dash","dotted","double","down","e-resize","ease","ease-in","ease-in-out","ease-out","element","ellipse","ellipsis","embed","end","ethiopic","ethiopic-abegede","ethiopic-abegede-am-et","ethiopic-abegede-gez","ethiopic-abegede-ti-er","ethiopic-abegede-ti-et","ethiopic-halehame-aa-er","ethiopic-halehame-aa-et","ethiopic-halehame-am-et","ethiopic-halehame-gez","ethiopic-halehame-om-et","ethiopic-halehame-sid-et","ethiopic-halehame-so-et","ethiopic-halehame-ti-er","ethiopic-halehame-ti-et","ethiopic-halehame-tig","ethiopic-numeric","ew-resize","expanded","extends","extra-condensed","extra-expanded","fantasy","fast","fill","fixed","flat","flex","footnotes","forwards","from","geometricPrecision","georgian","graytext","groove","gujarati","gurmukhi","hand","hangul","hangul-consonant","hebrew","help","hidden","hide","higher","highlight","highlighttext","hiragana","hiragana-iroha","horizontal","hsl","hsla","icon","ignore","inactiveborder","inactivecaption","inactivecaptiontext","infinite","infobackground","infotext","inherit","initial","inline","inline-axis","inline-block","inline-flex","inline-table","inset","inside","intrinsic","invert","italic","japanese-formal","japanese-informal","justify","kannada","katakana","katakana-iroha","keep-all","khmer","korean-hangul-formal","korean-hanja-formal","korean-hanja-informal","landscape","lao","large","larger","left","level","lighter","line-through","linear","linear-gradient","lines","list-item","listbox","listitem","local","logical","loud","lower","lower-alpha","lower-armenian","lower-greek","lower-hexadecimal","lower-latin","lower-norwegian","lower-roman","lowercase","ltr","malayalam","match","matrix","matrix3d","media-controls-background","media-current-time-display","media-fullscreen-button","media-mute-button","media-play-button","media-return-to-realtime-button","media-rewind-button","media-seek-back-button","media-seek-forward-button","media-slider","media-sliderthumb","media-time-remaining-display","media-volume-slider","media-volume-slider-container","media-volume-sliderthumb","medium","menu","menulist","menulist-button","menulist-text","menulist-textfield","menutext","message-box","middle","min-intrinsic","mix","mongolian","monospace","move","multiple","myanmar","n-resize","narrower","ne-resize","nesw-resize","no-close-quote","no-drop","no-open-quote","no-repeat","none","normal","not-allowed","nowrap","ns-resize","numbers","numeric","nw-resize","nwse-resize","oblique","octal","open-quote","optimizeLegibility","optimizeSpeed","oriya","oromo","outset","outside","outside-shape","overlay","overline","padding","padding-box","painted","page","paused","persian","perspective","plus-darker","plus-lighter","pointer","polygon","portrait","pre","pre-line","pre-wrap","preserve-3d","progress","push-button","radial-gradient","radio","read-only","read-write","read-write-plaintext-only","rectangle","region","relative","repeat","repeating-linear-gradient","repeating-radial-gradient","repeat-x","repeat-y","reset","reverse","rgb","rgba","ridge","right","rotate","rotate3d","rotateX","rotateY","rotateZ","round","row-resize","rtl","run-in","running","s-resize","sans-serif","scale","scale3d","scaleX","scaleY","scaleZ","scroll","scrollbar","scroll-position","se-resize","searchfield","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","semi-condensed","semi-expanded","separate","serif","show","sidama","simp-chinese-formal","simp-chinese-informal","single","skew","skewX","skewY","skip-white-space","slide","slider-horizontal","slider-vertical","sliderthumb-horizontal","sliderthumb-vertical","slow","small","small-caps","small-caption","smaller","solid","somali","source-atop","source-in","source-out","source-over","space","spell-out","square","square-button","start","static","status-bar","stretch","stroke","sub","subpixel-antialiased","super","sw-resize","symbolic","symbols","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tamil","telugu","text","text-bottom","text-top","textarea","textfield","thai","thick","thin","threeddarkshadow","threedface","threedhighlight","threedlightshadow","threedshadow","tibetan","tigre","tigrinya-er","tigrinya-er-abegede","tigrinya-et","tigrinya-et-abegede","to","top","trad-chinese-formal","trad-chinese-informal","translate","translate3d","translateX","translateY","translateZ","transparent","ultra-condensed","ultra-expanded","underline","up","upper-alpha","upper-armenian","upper-greek","upper-hexadecimal","upper-latin","upper-norwegian","upper-roman","uppercase","urdu","url","var","vertical","vertical-text","visible","visibleFill","visiblePainted","visibleStroke","visual","w-resize","wait","wave","wider","window","windowframe","windowtext","words","x-large","x-small","xor","xx-large","xx-small","bicubic","optimizespeed","grayscale","row","row-reverse","wrap","wrap-reverse","column-reverse","flex-start","flex-end","space-between","space-around", "unset"];

      var wordOperatorKeywords_ = ["in","and","or","not","is not","is a","is","isnt","defined","if unless"],
          blockKeywords_ = ["for","if","else","unless", "from", "to"],
          commonAtoms_ = ["null","true","false","href","title","type","not-allowed","readonly","disabled"],
          commonDef_ = ["@font-face", "@keyframes", "@media", "@viewport", "@page", "@host", "@supports", "@block", "@css"];

      var hintWords = tagKeywords_.concat(documentTypes_,mediaTypes_,mediaFeatures_,
                                          propertyKeywords_,nonStandardPropertyKeywords_,
                                          colorKeywords_,valueKeywords_,fontProperties_,
                                          wordOperatorKeywords_,blockKeywords_,
                                          commonAtoms_,commonDef_);

      function wordRegexp(words) {
        words = words.sort(function(a,b){return b > a;});
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) keys[array[i]] = true;
        return keys;
      }

      function escapeRegExp(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      CodeMirror.registerHelper("hintWords", "stylus", hintWords);
      CodeMirror.defineMIME("text/x-styl", "stylus");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-tcl-tcl.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    //tcl mode by Ford_Lawnmower :: Based on Velocity mode by Steve O'Hara

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("tcl", function() {
      function parseWords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var keywords = parseWords("Tcl safe after append array auto_execok auto_import auto_load " +
            "auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror " +
            "binary break catch cd close concat continue dde eof encoding error " +
            "eval exec exit expr fblocked fconfigure fcopy file fileevent filename " +
            "filename flush for foreach format gets glob global history http if " +
            "incr info interp join lappend lindex linsert list llength load lrange " +
            "lreplace lsearch lset lsort memory msgcat namespace open package parray " +
            "pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp " +
            "registry regsub rename resource return scan seek set socket source split " +
            "string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord " +
            "tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest " +
            "tclvars tell time trace unknown unset update uplevel upvar variable " +
        "vwait");
        var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
        var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
        function chain(stream, state, f) {
          state.tokenize = f;
          return f(stream, state);
        }
        function tokenBase(stream, state) {
          var beforeParams = state.beforeParams;
          state.beforeParams = false;
          var ch = stream.next();
          if ((ch == '"' || ch == "'") && state.inParams) {
            return chain(stream, state, tokenString(ch));
          } else if (/[\[\]{}\(\),;\.]/.test(ch)) {
            if (ch == "(" && beforeParams) state.inParams = true;
            else if (ch == ")") state.inParams = false;
              return null;
          } else if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          } else if (ch == "#") {
            if (stream.eat("*"))
              return chain(stream, state, tokenComment);
            if (ch == "#" && stream.match(/ *\[ *\[/))
              return chain(stream, state, tokenUnparsed);
            stream.skipToEnd();
            return "comment";
          } else if (ch == '"') {
            stream.skipTo(/"/);
            return "comment";
          } else if (ch == "$") {
            stream.eatWhile(/[$_a-z0-9A-Z\.{:]/);
            stream.eatWhile(/}/);
            state.beforeParams = true;
            return "builtin";
          } else if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "comment";
          } else {
            stream.eatWhile(/[\w\$_{}\xa1-\uffff]/);
            var word = stream.current().toLowerCase();
            if (keywords && keywords.propertyIsEnumerable(word))
              return "keyword";
            if (functions && functions.propertyIsEnumerable(word)) {
              state.beforeParams = true;
              return "keyword";
            }
            return null;
          }
        }
        function tokenString(quote) {
          return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end) state.tokenize = tokenBase;
            return "string";
          };
        }
        function tokenComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (ch == "#" && maybeEnd) {
              state.tokenize = tokenBase;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return "comment";
        }
        function tokenUnparsed(stream, state) {
          var maybeEnd = 0, ch;
          while (ch = stream.next()) {
            if (ch == "#" && maybeEnd == 2) {
              state.tokenize = tokenBase;
              break;
            }
            if (ch == "]")
              maybeEnd++;
            else if (ch != " ")
              maybeEnd = 0;
          }
          return "meta";
        }
        return {
          startState: function() {
            return {
              tokenize: tokenBase,
              beforeParams: false,
              inParams: false
            };
          },
          token: function(stream, state) {
            if (stream.eatSpace()) return null;
            return state.tokenize(stream, state);
          },
          lineComment: "#"
        };
    });
    CodeMirror.defineMIME("text/x-tcl", "tcl");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-textile-textile.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") { // CommonJS
        mod(require("../../lib/codemirror"));
      } else if (typeof define == "function" && define.amd) { // AMD
        define(["../../lib/codemirror"], mod);
      } else { // Plain browser env
        mod(CodeMirror);
      }
    })(function(CodeMirror) {
      "use strict";

      var TOKEN_STYLES = {
        addition: "positive",
        attributes: "attribute",
        bold: "strong",
        cite: "keyword",
        code: "atom",
        definitionList: "number",
        deletion: "negative",
        div: "punctuation",
        em: "em",
        footnote: "variable",
        footCite: "qualifier",
        header: "header",
        html: "comment",
        image: "string",
        italic: "em",
        link: "link",
        linkDefinition: "link",
        list1: "variable-2",
        list2: "variable-3",
        list3: "keyword",
        notextile: "string-2",
        pre: "operator",
        p: "property",
        quote: "bracket",
        span: "quote",
        specialChar: "tag",
        strong: "strong",
        sub: "builtin",
        sup: "builtin",
        table: "variable-3",
        tableHeading: "operator"
      };

      function startNewLine(stream, state) {
        state.mode = Modes.newLayout;
        state.tableHeading = false;

        if (state.layoutType === "definitionList" && state.spanningLayout &&
            stream.match(RE("definitionListEnd"), false))
          state.spanningLayout = false;
      }

      function handlePhraseModifier(stream, state, ch) {
        if (ch === "_") {
          if (stream.eat("_"))
            return togglePhraseModifier(stream, state, "italic", /__/, 2);
          else
            return togglePhraseModifier(stream, state, "em", /_/, 1);
        }

        if (ch === "*") {
          if (stream.eat("*")) {
            return togglePhraseModifier(stream, state, "bold", /\*\*/, 2);
          }
          return togglePhraseModifier(stream, state, "strong", /\*/, 1);
        }

        if (ch === "[") {
          if (stream.match(/\d+\]/)) state.footCite = true;
          return tokenStyles(state);
        }

        if (ch === "(") {
          var spec = stream.match(/^(r|tm|c)\)/);
          if (spec)
            return tokenStylesWith(state, TOKEN_STYLES.specialChar);
        }

        if (ch === "<" && stream.match(/(\w+)[^>]+>[^<]+<\/\1>/))
          return tokenStylesWith(state, TOKEN_STYLES.html);

        if (ch === "?" && stream.eat("?"))
          return togglePhraseModifier(stream, state, "cite", /\?\?/, 2);

        if (ch === "=" && stream.eat("="))
          return togglePhraseModifier(stream, state, "notextile", /==/, 2);

        if (ch === "-" && !stream.eat("-"))
          return togglePhraseModifier(stream, state, "deletion", /-/, 1);

        if (ch === "+")
          return togglePhraseModifier(stream, state, "addition", /\+/, 1);

        if (ch === "~")
          return togglePhraseModifier(stream, state, "sub", /~/, 1);

        if (ch === "^")
          return togglePhraseModifier(stream, state, "sup", /\^/, 1);

        if (ch === "%")
          return togglePhraseModifier(stream, state, "span", /%/, 1);

        if (ch === "@")
          return togglePhraseModifier(stream, state, "code", /@/, 1);

        if (ch === "!") {
          var type = togglePhraseModifier(stream, state, "image", /(?:\([^\)]+\))?!/, 1);
          stream.match(/^:\S+/); // optional Url portion
          return type;
        }
        return tokenStyles(state);
      }

      function togglePhraseModifier(stream, state, phraseModifier, closeRE, openSize) {
        var charBefore = stream.pos > openSize ? stream.string.charAt(stream.pos - openSize - 1) : null;
        var charAfter = stream.peek();
        if (state[phraseModifier]) {
          if ((!charAfter || /\W/.test(charAfter)) && charBefore && /\S/.test(charBefore)) {
            var type = tokenStyles(state);
            state[phraseModifier] = false;
            return type;
          }
        } else if ((!charBefore || /\W/.test(charBefore)) && charAfter && /\S/.test(charAfter) &&
                   stream.match(new RegExp("^.*\\S" + closeRE.source + "(?:\\W|$)"), false)) {
          state[phraseModifier] = true;
          state.mode = Modes.attributes;
        }
        return tokenStyles(state);
      };

      function tokenStyles(state) {
        var disabled = textileDisabled(state);
        if (disabled) return disabled;

        var styles = [];
        if (state.layoutType) styles.push(TOKEN_STYLES[state.layoutType]);

        styles = styles.concat(activeStyles(
          state, "addition", "bold", "cite", "code", "deletion", "em", "footCite",
          "image", "italic", "link", "span", "strong", "sub", "sup", "table", "tableHeading"));

        if (state.layoutType === "header")
          styles.push(TOKEN_STYLES.header + "-" + state.header);

        return styles.length ? styles.join(" ") : null;
      }

      function textileDisabled(state) {
        var type = state.layoutType;

        switch(type) {
        case "notextile":
        case "code":
        case "pre":
          return TOKEN_STYLES[type];
        default:
          if (state.notextile)
            return TOKEN_STYLES.notextile + (type ? (" " + TOKEN_STYLES[type]) : "");
          return null;
        }
      }

      function tokenStylesWith(state, extraStyles) {
        var disabled = textileDisabled(state);
        if (disabled) return disabled;

        var type = tokenStyles(state);
        if (extraStyles)
          return type ? (type + " " + extraStyles) : extraStyles;
        else
          return type;
      }

      function activeStyles(state) {
        var styles = [];
        for (var i = 1; i < arguments.length; ++i) {
          if (state[arguments[i]])
            styles.push(TOKEN_STYLES[arguments[i]]);
        }
        return styles;
      }

      function blankLine(state) {
        var spanningLayout = state.spanningLayout, type = state.layoutType;

        for (var key in state) if (state.hasOwnProperty(key))
          delete state[key];

        state.mode = Modes.newLayout;
        if (spanningLayout) {
          state.layoutType = type;
          state.spanningLayout = true;
        }
      }

      var REs = {
        cache: {},
        single: {
          bc: "bc",
          bq: "bq",
          definitionList: /- .*?:=+/,
          definitionListEnd: /.*=:\s*$/,
          div: "div",
          drawTable: /\|.*\|/,
          foot: /fn\d+/,
          header: /h[1-6]/,
          html: /\s*<(?:\/)?(\w+)(?:[^>]+)?>(?:[^<]+<\/\1>)?/,
          link: /[^"]+":\S/,
          linkDefinition: /\[[^\s\]]+\]\S+/,
          list: /(?:#+|\*+)/,
          notextile: "notextile",
          para: "p",
          pre: "pre",
          table: "table",
          tableCellAttributes: /[\/\\]\d+/,
          tableHeading: /\|_\./,
          tableText: /[^"_\*\[\(\?\+~\^%@|-]+/,
          text: /[^!"_=\*\[\(<\?\+~\^%@-]+/
        },
        attributes: {
          align: /(?:<>|<|>|=)/,
          selector: /\([^\(][^\)]+\)/,
          lang: /\[[^\[\]]+\]/,
          pad: /(?:\(+|\)+){1,2}/,
          css: /\{[^\}]+\}/
        },
        createRe: function(name) {
          switch (name) {
          case "drawTable":
            return REs.makeRe("^", REs.single.drawTable, "$");
          case "html":
            return REs.makeRe("^", REs.single.html, "(?:", REs.single.html, ")*", "$");
          case "linkDefinition":
            return REs.makeRe("^", REs.single.linkDefinition, "$");
          case "listLayout":
            return REs.makeRe("^", REs.single.list, RE("allAttributes"), "*\\s+");
          case "tableCellAttributes":
            return REs.makeRe("^", REs.choiceRe(REs.single.tableCellAttributes,
                                                RE("allAttributes")), "+\\.");
          case "type":
            return REs.makeRe("^", RE("allTypes"));
          case "typeLayout":
            return REs.makeRe("^", RE("allTypes"), RE("allAttributes"),
                              "*\\.\\.?", "(\\s+|$)");
          case "attributes":
            return REs.makeRe("^", RE("allAttributes"), "+");

          case "allTypes":
            return REs.choiceRe(REs.single.div, REs.single.foot,
                                REs.single.header, REs.single.bc, REs.single.bq,
                                REs.single.notextile, REs.single.pre, REs.single.table,
                                REs.single.para);

          case "allAttributes":
            return REs.choiceRe(REs.attributes.selector, REs.attributes.css,
                                REs.attributes.lang, REs.attributes.align, REs.attributes.pad);

          default:
            return REs.makeRe("^", REs.single[name]);
          }
        },
        makeRe: function() {
          var pattern = "";
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            pattern += (typeof arg === "string") ? arg : arg.source;
          }
          return new RegExp(pattern);
        },
        choiceRe: function() {
          var parts = [arguments[0]];
          for (var i = 1; i < arguments.length; ++i) {
            parts[i * 2 - 1] = "|";
            parts[i * 2] = arguments[i];
          }

          parts.unshift("(?:");
          parts.push(")");
          return REs.makeRe.apply(null, parts);
        }
      };

      function RE(name) {
        return (REs.cache[name] || (REs.cache[name] = REs.createRe(name)));
      }

      var Modes = {
        newLayout: function(stream, state) {
          if (stream.match(RE("typeLayout"), false)) {
            state.spanningLayout = false;
            return (state.mode = Modes.blockType)(stream, state);
          }
          var newMode;
          if (!textileDisabled(state)) {
            if (stream.match(RE("listLayout"), false))
              newMode = Modes.list;
            else if (stream.match(RE("drawTable"), false))
              newMode = Modes.table;
            else if (stream.match(RE("linkDefinition"), false))
              newMode = Modes.linkDefinition;
            else if (stream.match(RE("definitionList")))
              newMode = Modes.definitionList;
            else if (stream.match(RE("html"), false))
              newMode = Modes.html;
          }
          return (state.mode = (newMode || Modes.text))(stream, state);
        },

        blockType: function(stream, state) {
          var match, type;
          state.layoutType = null;

          if (match = stream.match(RE("type")))
            type = match[0];
          else
            return (state.mode = Modes.text)(stream, state);

          if (match = type.match(RE("header"))) {
            state.layoutType = "header";
            state.header = parseInt(match[0][1]);
          } else if (type.match(RE("bq"))) {
            state.layoutType = "quote";
          } else if (type.match(RE("bc"))) {
            state.layoutType = "code";
          } else if (type.match(RE("foot"))) {
            state.layoutType = "footnote";
          } else if (type.match(RE("notextile"))) {
            state.layoutType = "notextile";
          } else if (type.match(RE("pre"))) {
            state.layoutType = "pre";
          } else if (type.match(RE("div"))) {
            state.layoutType = "div";
          } else if (type.match(RE("table"))) {
            state.layoutType = "table";
          }

          state.mode = Modes.attributes;
          return tokenStyles(state);
        },

        text: function(stream, state) {
          if (stream.match(RE("text"))) return tokenStyles(state);

          var ch = stream.next();
          if (ch === '"')
            return (state.mode = Modes.link)(stream, state);
          return handlePhraseModifier(stream, state, ch);
        },

        attributes: function(stream, state) {
          state.mode = Modes.layoutLength;

          if (stream.match(RE("attributes")))
            return tokenStylesWith(state, TOKEN_STYLES.attributes);
          else
            return tokenStyles(state);
        },

        layoutLength: function(stream, state) {
          if (stream.eat(".") && stream.eat("."))
            state.spanningLayout = true;

          state.mode = Modes.text;
          return tokenStyles(state);
        },

        list: function(stream, state) {
          var match = stream.match(RE("list"));
          state.listDepth = match[0].length;
          var listMod = (state.listDepth - 1) % 3;
          if (!listMod)
            state.layoutType = "list1";
          else if (listMod === 1)
            state.layoutType = "list2";
          else
            state.layoutType = "list3";

          state.mode = Modes.attributes;
          return tokenStyles(state);
        },

        link: function(stream, state) {
          state.mode = Modes.text;
          if (stream.match(RE("link"))) {
            stream.match(/\S+/);
            return tokenStylesWith(state, TOKEN_STYLES.link);
          }
          return tokenStyles(state);
        },

        linkDefinition: function(stream, state) {
          stream.skipToEnd();
          return tokenStylesWith(state, TOKEN_STYLES.linkDefinition);
        },

        definitionList: function(stream, state) {
          stream.match(RE("definitionList"));

          state.layoutType = "definitionList";

          if (stream.match(/\s*$/))
            state.spanningLayout = true;
          else
            state.mode = Modes.attributes;

          return tokenStyles(state);
        },

        html: function(stream, state) {
          stream.skipToEnd();
          return tokenStylesWith(state, TOKEN_STYLES.html);
        },

        table: function(stream, state) {
          state.layoutType = "table";
          return (state.mode = Modes.tableCell)(stream, state);
        },

        tableCell: function(stream, state) {
          if (stream.match(RE("tableHeading")))
            state.tableHeading = true;
          else
            stream.eat("|");

          state.mode = Modes.tableCellAttributes;
          return tokenStyles(state);
        },

        tableCellAttributes: function(stream, state) {
          state.mode = Modes.tableText;

          if (stream.match(RE("tableCellAttributes")))
            return tokenStylesWith(state, TOKEN_STYLES.attributes);
          else
            return tokenStyles(state);
        },

        tableText: function(stream, state) {
          if (stream.match(RE("tableText")))
            return tokenStyles(state);

          if (stream.peek() === "|") { // end of cell
            state.mode = Modes.tableCell;
            return tokenStyles(state);
          }
          return handlePhraseModifier(stream, state, stream.next());
        }
      };

      CodeMirror.defineMode("textile", function() {
        return {
          startState: function() {
            return { mode: Modes.newLayout };
          },
          token: function(stream, state) {
            if (stream.sol()) startNewLine(stream, state);
            return state.mode(stream, state);
          },
          blankLine: blankLine
        };
      });

      CodeMirror.defineMIME("text/x-textile", "textile");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-tiki-tiki.css: ".cm-tw-syntaxerror
    {\n\tcolor: #FFF;\n\tbackground-color: #900;\n}\n\n.cm-tw-deleted {\n\ttext-decoration:
    line-through;\n}\n\n.cm-tw-header5 {\n\tfont-weight: bold;\n}\n.cm-tw-listitem:first-child
    { /*Added first child to fix duplicate padding when highlighting*/\n\tpadding-left:
    10px;\n}\n\n.cm-tw-box {\n\tborder-top-width: 0px !important;\n\tborder-style:
    solid;\n\tborder-width: 1px;\n\tborder-color: inherit;\n}\n\n.cm-tw-underline
    {\n\ttext-decoration: underline;\n}"
  uploads-admin-Public-Admin-plugins-codemirror-mode-tiki-tiki.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode('tiki', function(config) {
      function inBlock(style, terminator, returnTokenizer) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }

          if (returnTokenizer) state.tokenize = returnTokenizer;

          return style;
        };
      }

      function inLine(style) {
        return function(stream, state) {
          while(!stream.eol()) {
            stream.next();
          }
          state.tokenize = inText;
          return style;
        };
      }

      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        var sol = stream.sol();
        var ch = stream.next();

        //non start of line
        switch (ch) { //switch is generally much faster than if, so it is used here
        case "{": //plugin
          stream.eat("/");
          stream.eatSpace();
          stream.eatWhile(/[^\s\u00a0=\"\'\/?(}]/);
          state.tokenize = inPlugin;
          return "tag";
        case "_": //bold
          if (stream.eat("_"))
            return chain(inBlock("strong", "__", inText));
          break;
        case "'": //italics
          if (stream.eat("'"))
            return chain(inBlock("em", "''", inText));
          break;
        case "(":// Wiki Link
          if (stream.eat("("))
            return chain(inBlock("variable-2", "))", inText));
          break;
        case "[":// Weblink
          return chain(inBlock("variable-3", "]", inText));
          break;
        case "|": //table
          if (stream.eat("|"))
            return chain(inBlock("comment", "||"));
          break;
        case "-":
          if (stream.eat("=")) {//titleBar
            return chain(inBlock("header string", "=-", inText));
          } else if (stream.eat("-")) {//deleted
            return chain(inBlock("error tw-deleted", "--", inText));
          }
          break;
        case "=": //underline
          if (stream.match("=="))
            return chain(inBlock("tw-underline", "===", inText));
          break;
        case ":":
          if (stream.eat(":"))
            return chain(inBlock("comment", "::"));
          break;
        case "^": //box
          return chain(inBlock("tw-box", "^"));
          break;
        case "~": //np
          if (stream.match("np~"))
            return chain(inBlock("meta", "~/np~"));
          break;
        }

        //start of line types
        if (sol) {
          switch (ch) {
          case "!": //header at start of line
            if (stream.match('!!!!!')) {
              return chain(inLine("header string"));
            } else if (stream.match('!!!!')) {
              return chain(inLine("header string"));
            } else if (stream.match('!!!')) {
              return chain(inLine("header string"));
            } else if (stream.match('!!')) {
              return chain(inLine("header string"));
            } else {
              return chain(inLine("header string"));
            }
            break;
          case "*": //unordered list line item, or <li /> at start of line
          case "#": //ordered list line item, or <li /> at start of line
          case "+": //ordered list line item, or <li /> at start of line
            return chain(inLine("tw-listitem bracket"));
            break;
          }
        }

        //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki
        return null;
      }

      var indentUnit = config.indentUnit;

      // Return variables for tokenizers
      var pluginName, type;
      function inPlugin(stream, state) {
        var ch = stream.next();
        var peek = stream.peek();

        if (ch == "}") {
          state.tokenize = inText;
          //type = ch == ")" ? "endPlugin" : "selfclosePlugin"; inPlugin
          return "tag";
        } else if (ch == "(" || ch == ")") {
          return "bracket";
        } else if (ch == "=") {
          type = "equals";

          if (peek == ">") {
            stream.next();
            peek = stream.peek();
          }

          //here we detect values directly after equal character with no quotes
          if (!/[\'\"]/.test(peek)) {
            state.tokenize = inAttributeNoQuote();
          }
          //end detect values

          return "operator";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          return state.tokenize(stream, state);
        } else {
          stream.eatWhile(/[^\s\u00a0=\"\'\/?]/);
          return "keyword";
        }
      }

      function inAttribute(quote) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inPlugin;
              break;
            }
          }
          return "string";
        };
      }

      function inAttributeNoQuote() {
        return function(stream, state) {
          while (!stream.eol()) {
            var ch = stream.next();
            var peek = stream.peek();
            if (ch == " " || ch == "," || /[ )}]/.test(peek)) {
          state.tokenize = inPlugin;
          break;
        }
      }
      return "string";
    };
                         }

    var curState, setStyle;
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
    }

    function cont() {
      pass.apply(null, arguments);
      return true;
    }

    function pushContext(pluginName, startOfLine) {
      var noIndent = curState.context && curState.context.noIndent;
      curState.context = {
        prev: curState.context,
        pluginName: pluginName,
        indent: curState.indented,
        startOfLine: startOfLine,
        noIndent: noIndent
      };
    }

    function popContext() {
      if (curState.context) curState.context = curState.context.prev;
    }

    function element(type) {
      if (type == "openPlugin") {curState.pluginName = pluginName; return cont(attributes, endplugin(curState.startOfLine));}
      else if (type == "closePlugin") {
        var err = false;
        if (curState.context) {
          err = curState.context.pluginName != pluginName;
          popContext();
        } else {
          err = true;
        }
        if (err) setStyle = "error";
        return cont(endcloseplugin(err));
      }
      else if (type == "string") {
        if (!curState.context || curState.context.name != "!cdata") pushContext("!cdata");
        if (curState.tokenize == inText) popContext();
        return cont();
      }
      else return cont();
    }

    function endplugin(startOfLine) {
      return function(type) {
        if (
          type == "selfclosePlugin" ||
            type == "endPlugin"
        )
          return cont();
        if (type == "endPlugin") {pushContext(curState.pluginName, startOfLine); return cont();}
        return cont();
      };
    }

    function endcloseplugin(err) {
      return function(type) {
        if (err) setStyle = "error";
        if (type == "endPlugin") return cont();
        return pass();
      };
    }

    function attributes(type) {
      if (type == "keyword") {setStyle = "attribute"; return cont(attributes);}
      if (type == "equals") return cont(attvalue, attributes);
      return pass();
    }
    function attvalue(type) {
      if (type == "keyword") {setStyle = "string"; return cont();}
      if (type == "string") return cont(attvaluemaybe);
      return pass();
    }
    function attvaluemaybe(type) {
      if (type == "string") return cont(attvaluemaybe);
      else return pass();
    }
    return {
      startState: function() {
        return {tokenize: inText, cc: [], indented: 0, startOfLine: true, pluginName: null, context: null};
      },
      token: function(stream, state) {
        if (stream.sol()) {
          state.startOfLine = true;
          state.indented = stream.indentation();
        }
        if (stream.eatSpace()) return null;

        setStyle = type = pluginName = null;
        var style = state.tokenize(stream, state);
        if ((style || type) && style != "comment") {
          curState = state;
          while (true) {
            var comb = state.cc.pop() || element;
            if (comb(type || style)) break;
          }
        }
        state.startOfLine = false;
        return setStyle || style;
      },
      indent: function(state, textAfter) {
        var context = state.context;
        if (context && context.noIndent) return 0;
        if (context && /^{\//.test(textAfter))
            context = context.prev;
        while (context && !context.startOfLine)
            context = context.prev;
        if (context) return context.indent + indentUnit;
        else return 0;
      },
      electricChars: "/"
    };
    });

    CodeMirror.defineMIME("text/tiki", "tiki");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-toml-toml.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("toml", function () {
      return {
        startState: function () {
          return {
            inString: false,
            stringType: "",
            lhs: true,
            inArray: 0
          };
        },
        token: function (stream, state) {
          //check for state changes
          if (!state.inString && ((stream.peek() == '"') || (stream.peek() == "'"))) {
            state.stringType = stream.peek();
            stream.next(); // Skip quote
            state.inString = true; // Update state
          }
          if (stream.sol() && state.inArray === 0) {
            state.lhs = true;
          }
          //return state
          if (state.inString) {
            while (state.inString && !stream.eol()) {
              if (stream.peek() === state.stringType) {
                stream.next(); // Skip quote
                state.inString = false; // Clear flag
              } else if (stream.peek() === '\\') {
                stream.next();
                stream.next();
              } else {
                stream.match(/^.[^\\\"\']*/);
              }
            }
            return state.lhs ? "property string" : "string"; // Token style
          } else if (state.inArray && stream.peek() === ']') {
            stream.next();
            state.inArray--;
            return 'bracket';
          } else if (state.lhs && stream.peek() === '[' && stream.skipTo(']')) {
            stream.next();//skip closing ]
            // array of objects has an extra open & close []
            if (stream.peek() === ']') stream.next();
            return "atom";
          } else if (stream.peek() === "#") {
            stream.skipToEnd();
            return "comment";
          } else if (stream.eatSpace()) {
            return null;
          } else if (state.lhs && stream.eatWhile(function (c) { return c != '=' && c != ' '; })) {
            return "property";
          } else if (state.lhs && stream.peek() === "=") {
            stream.next();
            state.lhs = false;
            return null;
          } else if (!state.lhs && stream.match(/^\d\d\d\d[\d\-\:\.T]*Z/)) {
            return 'atom'; //date
          } else if (!state.lhs && (stream.match('true') || stream.match('false'))) {
            return 'atom';
          } else if (!state.lhs && stream.peek() === '[') {
            state.inArray++;
            stream.next();
            return 'bracket';
          } else if (!state.lhs && stream.match(/^\-?\d+(?:\.\d+)?/)) {
            return 'number';
          } else if (!stream.eatSpace()) {
            stream.next();
          }
          return null;
        }
      };
    });

    CodeMirror.defineMIME('text/x-toml', 'toml');

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-ttcn-cfg-ttcn-cfg.js: |-
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("ttcn-cfg", function(config, parserConfig) {
        var indentUnit = config.indentUnit,
            keywords = parserConfig.keywords || {},
            fileNCtrlMaskOptions = parserConfig.fileNCtrlMaskOptions || {},
            externalCommands = parserConfig.externalCommands || {},
            multiLineStrings = parserConfig.multiLineStrings,
            indentStatements = parserConfig.indentStatements !== false;
        var isOperatorChar = /[\|]/;
        var curPunc;

        function tokenBase(stream, state) {
          var ch = stream.next();
          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          if (/[:=]/.test(ch)) {
            curPunc = ch;
            return "punctuation";
          }
          if (ch == "#"){
            stream.skipToEnd();
            return "comment";
          }
          if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          }
          if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
          if (ch == "["){
            stream.eatWhile(/[\w_\]]/);
            return "number sectionTitle";
          }

          stream.eatWhile(/[\w\$_]/);
          var cur = stream.current();
          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          if (fileNCtrlMaskOptions.propertyIsEnumerable(cur))
            return "negative fileNCtrlMaskOptions";
          if (externalCommands.propertyIsEnumerable(cur)) return "negative externalCommands";

          return "variable";
        }

        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped){
                var afterNext = stream.peek();
                //look if the character if the quote is like the B in '10100010'B
                if (afterNext){
                  afterNext = afterNext.toLowerCase();
                  if(afterNext == "b" || afterNext == "h" || afterNext == "o")
                    stream.next();
                }
                end = true; break;
              }
              escaped = !escaped && next == "\\";
            }
            if (end || !(escaped || multiLineStrings))
              state.tokenize = null;
            return "string";
          };
        }

        function Context(indented, column, type, align, prev) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.align = align;
          this.prev = prev;
        }
        function pushContext(state, col, type) {
          var indent = state.indented;
          if (state.context && state.context.type == "statement")
            indent = state.context.indented;
          return state.context = new Context(indent, col, type, null, state.context);
        }
        function popContext(state) {
          var t = state.context.type;
          if (t == ")" || t == "]" || t == "}")
            state.indented = state.context.indented;
          return state.context = state.context.prev;
        }

        //Interface
        return {
          startState: function(basecolumn) {
            return {
              tokenize: null,
              context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
              indented: 0,
              startOfLine: true
            };
          },

          token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
              if (ctx.align == null) ctx.align = false;
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            curPunc = null;
            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
                && ctx.type == "statement"){
              popContext(state);
            }
            else if (curPunc == "{") pushContext(state, stream.column(), "}");
            else if (curPunc == "[") pushContext(state, stream.column(), "]");
            else if (curPunc == "(") pushContext(state, stream.column(), ")");
            else if (curPunc == "}") {
              while (ctx.type == "statement") ctx = popContext(state);
              if (ctx.type == "}") ctx = popContext(state);
              while (ctx.type == "statement") ctx = popContext(state);
            }
            else if (curPunc == ctx.type) popContext(state);
            else if (indentStatements && (((ctx.type == "}" || ctx.type == "top")
                && curPunc != ';') || (ctx.type == "statement"
                && curPunc == "newstatement")))
              pushContext(state, stream.column(), "statement");
            state.startOfLine = false;
            return style;
          },

          electricChars: "{}",
          lineComment: "#",
          fold: "brace"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i)
          obj[words[i]] = true;
        return obj;
      }

      CodeMirror.defineMIME("text/x-ttcn-cfg", {
        name: "ttcn-cfg",
        keywords: words("Yes No LogFile FileMask ConsoleMask AppendFile" +
        " TimeStampFormat LogEventTypes SourceInfoFormat" +
        " LogEntityName LogSourceInfo DiskFullAction" +
        " LogFileNumber LogFileSize MatchingHints Detailed" +
        " Compact SubCategories Stack Single None Seconds" +
        " DateTime Time Stop Error Retry Delete TCPPort KillTimer" +
        " NumHCs UnixSocketsEnabled LocalAddress"),
        fileNCtrlMaskOptions: words("TTCN_EXECUTOR TTCN_ERROR TTCN_WARNING" +
        " TTCN_PORTEVENT TTCN_TIMEROP TTCN_VERDICTOP" +
        " TTCN_DEFAULTOP TTCN_TESTCASE TTCN_ACTION" +
        " TTCN_USER TTCN_FUNCTION TTCN_STATISTICS" +
        " TTCN_PARALLEL TTCN_MATCHING TTCN_DEBUG" +
        " EXECUTOR ERROR WARNING PORTEVENT TIMEROP" +
        " VERDICTOP DEFAULTOP TESTCASE ACTION USER" +
        " FUNCTION STATISTICS PARALLEL MATCHING DEBUG" +
        " LOG_ALL LOG_NOTHING ACTION_UNQUALIFIED" +
        " DEBUG_ENCDEC DEBUG_TESTPORT" +
        " DEBUG_UNQUALIFIED DEFAULTOP_ACTIVATE" +
        " DEFAULTOP_DEACTIVATE DEFAULTOP_EXIT" +
        " DEFAULTOP_UNQUALIFIED ERROR_UNQUALIFIED" +
        " EXECUTOR_COMPONENT EXECUTOR_CONFIGDATA" +
        " EXECUTOR_EXTCOMMAND EXECUTOR_LOGOPTIONS" +
        " EXECUTOR_RUNTIME EXECUTOR_UNQUALIFIED" +
        " FUNCTION_RND FUNCTION_UNQUALIFIED" +
        " MATCHING_DONE MATCHING_MCSUCCESS" +
        " MATCHING_MCUNSUCC MATCHING_MMSUCCESS" +
        " MATCHING_MMUNSUCC MATCHING_PCSUCCESS" +
        " MATCHING_PCUNSUCC MATCHING_PMSUCCESS" +
        " MATCHING_PMUNSUCC MATCHING_PROBLEM" +
        " MATCHING_TIMEOUT MATCHING_UNQUALIFIED" +
        " PARALLEL_PORTCONN PARALLEL_PORTMAP" +
        " PARALLEL_PTC PARALLEL_UNQUALIFIED" +
        " PORTEVENT_DUALRECV PORTEVENT_DUALSEND" +
        " PORTEVENT_MCRECV PORTEVENT_MCSEND" +
        " PORTEVENT_MMRECV PORTEVENT_MMSEND" +
        " PORTEVENT_MQUEUE PORTEVENT_PCIN" +
        " PORTEVENT_PCOUT PORTEVENT_PMIN" +
        " PORTEVENT_PMOUT PORTEVENT_PQUEUE" +
        " PORTEVENT_STATE PORTEVENT_UNQUALIFIED" +
        " STATISTICS_UNQUALIFIED STATISTICS_VERDICT" +
        " TESTCASE_FINISH TESTCASE_START" +
        " TESTCASE_UNQUALIFIED TIMEROP_GUARD" +
        " TIMEROP_READ TIMEROP_START TIMEROP_STOP" +
        " TIMEROP_TIMEOUT TIMEROP_UNQUALIFIED" +
        " USER_UNQUALIFIED VERDICTOP_FINAL" +
        " VERDICTOP_GETVERDICT VERDICTOP_SETVERDICT" +
        " VERDICTOP_UNQUALIFIED WARNING_UNQUALIFIED"),
        externalCommands: words("BeginControlPart EndControlPart BeginTestCase" +
        " EndTestCase"),
        multiLineStrings: true
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-ttcn-ttcn.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("ttcn", function(config, parserConfig) {
        var indentUnit = config.indentUnit,
            keywords = parserConfig.keywords || {},
            builtin = parserConfig.builtin || {},
            timerOps = parserConfig.timerOps || {},
            portOps  = parserConfig.portOps || {},
            configOps = parserConfig.configOps || {},
            verdictOps = parserConfig.verdictOps || {},
            sutOps = parserConfig.sutOps || {},
            functionOps = parserConfig.functionOps || {},

            verdictConsts = parserConfig.verdictConsts || {},
            booleanConsts = parserConfig.booleanConsts || {},
            otherConsts   = parserConfig.otherConsts || {},

            types = parserConfig.types || {},
            visibilityModifiers = parserConfig.visibilityModifiers || {},
            templateMatch = parserConfig.templateMatch || {},
            multiLineStrings = parserConfig.multiLineStrings,
            indentStatements = parserConfig.indentStatements !== false;
        var isOperatorChar = /[+\-*&@=<>!\/]/;
        var curPunc;

        function tokenBase(stream, state) {
          var ch = stream.next();

          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          if (/[\[\]{}\(\),;\\:\?\.]/.test(ch)) {
            curPunc = ch;
            return "punctuation";
          }
          if (ch == "#"){
            stream.skipToEnd();
            return "atom preprocessor";
          }
          if (ch == "%"){
            stream.eatWhile(/\b/);
            return "atom ttcn3Macros";
          }
          if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          }
          if (ch == "/") {
            if (stream.eat("*")) {
              state.tokenize = tokenComment;
              return tokenComment(stream, state);
            }
            if (stream.eat("/")) {
              stream.skipToEnd();
              return "comment";
            }
          }
          if (isOperatorChar.test(ch)) {
            if(ch == "@"){
              if(stream.match("try") || stream.match("catch")
                  || stream.match("lazy")){
                return "keyword";
              }
            }
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
          stream.eatWhile(/[\w\$_\xa1-\uffff]/);
          var cur = stream.current();

          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          if (builtin.propertyIsEnumerable(cur)) return "builtin";

          if (timerOps.propertyIsEnumerable(cur)) return "def timerOps";
          if (configOps.propertyIsEnumerable(cur)) return "def configOps";
          if (verdictOps.propertyIsEnumerable(cur)) return "def verdictOps";
          if (portOps.propertyIsEnumerable(cur)) return "def portOps";
          if (sutOps.propertyIsEnumerable(cur)) return "def sutOps";
          if (functionOps.propertyIsEnumerable(cur)) return "def functionOps";

          if (verdictConsts.propertyIsEnumerable(cur)) return "string verdictConsts";
          if (booleanConsts.propertyIsEnumerable(cur)) return "string booleanConsts";
          if (otherConsts.propertyIsEnumerable(cur)) return "string otherConsts";

          if (types.propertyIsEnumerable(cur)) return "builtin types";
          if (visibilityModifiers.propertyIsEnumerable(cur))
            return "builtin visibilityModifiers";
          if (templateMatch.propertyIsEnumerable(cur)) return "atom templateMatch";

          return "variable";
        }

        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped){
                var afterQuote = stream.peek();
                //look if the character after the quote is like the B in '10100010'B
                if (afterQuote){
                  afterQuote = afterQuote.toLowerCase();
                  if(afterQuote == "b" || afterQuote == "h" || afterQuote == "o")
                    stream.next();
                }
                end = true; break;
              }
              escaped = !escaped && next == "\\";
            }
            if (end || !(escaped || multiLineStrings))
              state.tokenize = null;
            return "string";
          };
        }

        function tokenComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
              state.tokenize = null;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return "comment";
        }

        function Context(indented, column, type, align, prev) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.align = align;
          this.prev = prev;
        }

        function pushContext(state, col, type) {
          var indent = state.indented;
          if (state.context && state.context.type == "statement")
            indent = state.context.indented;
          return state.context = new Context(indent, col, type, null, state.context);
        }

        function popContext(state) {
          var t = state.context.type;
          if (t == ")" || t == "]" || t == "}")
            state.indented = state.context.indented;
          return state.context = state.context.prev;
        }

        //Interface
        return {
          startState: function(basecolumn) {
            return {
              tokenize: null,
              context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
              indented: 0,
              startOfLine: true
            };
          },

          token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
              if (ctx.align == null) ctx.align = false;
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            curPunc = null;
            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
                && ctx.type == "statement"){
              popContext(state);
            }
            else if (curPunc == "{") pushContext(state, stream.column(), "}");
            else if (curPunc == "[") pushContext(state, stream.column(), "]");
            else if (curPunc == "(") pushContext(state, stream.column(), ")");
            else if (curPunc == "}") {
              while (ctx.type == "statement") ctx = popContext(state);
              if (ctx.type == "}") ctx = popContext(state);
              while (ctx.type == "statement") ctx = popContext(state);
            }
            else if (curPunc == ctx.type) popContext(state);
            else if (indentStatements &&
                (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') ||
                (ctx.type == "statement" && curPunc == "newstatement")))
              pushContext(state, stream.column(), "statement");

            state.startOfLine = false;

            return style;
          },

          electricChars: "{}",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//",
          fold: "brace"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      function def(mimes, mode) {
        if (typeof mimes == "string") mimes = [mimes];
        var words = [];
        function add(obj) {
          if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
            words.push(prop);
        }

        add(mode.keywords);
        add(mode.builtin);
        add(mode.timerOps);
        add(mode.portOps);

        if (words.length) {
          mode.helperType = mimes[0];
          CodeMirror.registerHelper("hintWords", mimes[0], words);
        }

        for (var i = 0; i < mimes.length; ++i)
          CodeMirror.defineMIME(mimes[i], mode);
      }

      def(["text/x-ttcn", "text/x-ttcn3", "text/x-ttcnpp"], {
        name: "ttcn",
        keywords: words("activate address alive all alt altstep and and4b any" +
        " break case component const continue control deactivate" +
        " display do else encode enumerated except exception" +
        " execute extends extension external for from function" +
        " goto group if import in infinity inout interleave" +
        " label language length log match message mixed mod" +
        " modifies module modulepar mtc noblock not not4b nowait" +
        " of on optional or or4b out override param pattern port" +
        " procedure record recursive rem repeat return runs select" +
        " self sender set signature system template testcase to" +
        " type union value valueof var variant while with xor xor4b"),
        builtin: words("bit2hex bit2int bit2oct bit2str char2int char2oct encvalue" +
        " decomp decvalue float2int float2str hex2bit hex2int" +
        " hex2oct hex2str int2bit int2char int2float int2hex" +
        " int2oct int2str int2unichar isbound ischosen ispresent" +
        " isvalue lengthof log2str oct2bit oct2char oct2hex oct2int" +
        " oct2str regexp replace rnd sizeof str2bit str2float" +
        " str2hex str2int str2oct substr unichar2int unichar2char" +
        " enum2int"),
        types: words("anytype bitstring boolean char charstring default float" +
        " hexstring integer objid octetstring universal verdicttype timer"),
        timerOps: words("read running start stop timeout"),
        portOps: words("call catch check clear getcall getreply halt raise receive" +
        " reply send trigger"),
        configOps: words("create connect disconnect done kill killed map unmap"),
        verdictOps: words("getverdict setverdict"),
        sutOps: words("action"),
        functionOps: words("apply derefers refers"),

        verdictConsts: words("error fail inconc none pass"),
        booleanConsts: words("true false"),
        otherConsts: words("null NULL omit"),

        visibilityModifiers: words("private public friend"),
        templateMatch: words("complement ifpresent subset superset permutation"),
        multiLineStrings: true
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-vb-vb.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("vb", function(conf, parserConf) {
        var ERRORCLASS = 'error';

        function wordRegexp(words) {
            return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
        }

        var singleOperators = new RegExp("^[\\+\\-\\*/%&\\\\|\\^~<>!]");
        var singleDelimiters = new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
        var doubleOperators = new RegExp("^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))");
        var doubleDelimiters = new RegExp("^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))");
        var tripleDelimiters = new RegExp("^((//=)|(>>=)|(<<=)|(\\*\\*=))");
        var identifiers = new RegExp("^[_A-Za-z][_A-Za-z0-9]*");

        var openingKeywords = ['class','module', 'sub','enum','select','while','if','function', 'get','set','property', 'try', 'structure', 'synclock', 'using', 'with'];
        var middleKeywords = ['else','elseif','case', 'catch', 'finally'];
        var endKeywords = ['next','loop'];

        var operatorKeywords = ['and', "andalso", 'or', 'orelse', 'xor', 'in', 'not', 'is', 'isnot', 'like'];
        var wordOperators = wordRegexp(operatorKeywords);

        var commonKeywords = ["#const", "#else", "#elseif", "#end", "#if", "#region", "addhandler", "addressof", "alias", "as", "byref", "byval", "cbool", "cbyte", "cchar", "cdate", "cdbl", "cdec", "cint", "clng", "cobj", "compare", "const", "continue", "csbyte", "cshort", "csng", "cstr", "cuint", "culng", "cushort", "declare", "default", "delegate", "dim", "directcast", "each", "erase", "error", "event", "exit", "explicit", "false", "for", "friend", "gettype", "goto", "handles", "implements", "imports", "infer", "inherits", "interface", "isfalse", "istrue", "lib", "me", "mod", "mustinherit", "mustoverride", "my", "mybase", "myclass", "namespace", "narrowing", "new", "nothing", "notinheritable", "notoverridable", "of", "off", "on", "operator", "option", "optional", "out", "overloads", "overridable", "overrides", "paramarray", "partial", "private", "protected", "public", "raiseevent", "readonly", "redim", "removehandler", "resume", "return", "shadows", "shared", "static", "step", "stop", "strict", "then", "throw", "to", "true", "trycast", "typeof", "until", "until", "when", "widening", "withevents", "writeonly"];

        var commontypes = ['object', 'boolean', 'char', 'string', 'byte', 'sbyte', 'short', 'ushort', 'int16', 'uint16', 'integer', 'uinteger', 'int32', 'uint32', 'long', 'ulong', 'int64', 'uint64', 'decimal', 'single', 'double', 'float', 'date', 'datetime', 'intptr', 'uintptr'];

        var keywords = wordRegexp(commonKeywords);
        var types = wordRegexp(commontypes);
        var stringPrefixes = '"';

        var opening = wordRegexp(openingKeywords);
        var middle = wordRegexp(middleKeywords);
        var closing = wordRegexp(endKeywords);
        var doubleClosing = wordRegexp(['end']);
        var doOpening = wordRegexp(['do']);

        var indentInfo = null;

        CodeMirror.registerHelper("hintWords", "vb", openingKeywords.concat(middleKeywords).concat(endKeywords)
                                    .concat(operatorKeywords).concat(commonKeywords).concat(commontypes));

        function indent(_stream, state) {
          state.currentIndent++;
        }

        function dedent(_stream, state) {
          state.currentIndent--;
        }
        // tokenizers
        function tokenBase(stream, state) {
            if (stream.eatSpace()) {
                return null;
            }

            var ch = stream.peek();

            // Handle Comments
            if (ch === "'") {
                stream.skipToEnd();
                return 'comment';
            }


            // Handle Number Literals
            if (stream.match(/^((&H)|(&O))?[0-9\.a-f]/i, false)) {
                var floatLiteral = false;
                // Floats
                if (stream.match(/^\d*\.\d+F?/i)) { floatLiteral = true; }
                else if (stream.match(/^\d+\.\d*F?/)) { floatLiteral = true; }
                else if (stream.match(/^\.\d+F?/)) { floatLiteral = true; }

                if (floatLiteral) {
                    // Float literals may be "imaginary"
                    stream.eat(/J/i);
                    return 'number';
                }
                // Integers
                var intLiteral = false;
                // Hex
                if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }
                // Octal
                else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }
                // Decimal
                else if (stream.match(/^[1-9]\d*F?/)) {
                    // Decimal literals may be "imaginary"
                    stream.eat(/J/i);
                    // TODO - Can you have imaginary longs?
                    intLiteral = true;
                }
                // Zero by itself with no other piece of number.
                else if (stream.match(/^0(?![\dx])/i)) { intLiteral = true; }
                if (intLiteral) {
                    // Integer literals may be "long"
                    stream.eat(/L/i);
                    return 'number';
                }
            }

            // Handle Strings
            if (stream.match(stringPrefixes)) {
                state.tokenize = tokenStringFactory(stream.current());
                return state.tokenize(stream, state);
            }

            // Handle operators and Delimiters
            if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
                return null;
            }
            if (stream.match(doubleOperators)
                || stream.match(singleOperators)
                || stream.match(wordOperators)) {
                return 'operator';
            }
            if (stream.match(singleDelimiters)) {
                return null;
            }
            if (stream.match(doOpening)) {
                indent(stream,state);
                state.doInCurrentLine = true;
                return 'keyword';
            }
            if (stream.match(opening)) {
                if (! state.doInCurrentLine)
                  indent(stream,state);
                else
                  state.doInCurrentLine = false;
                return 'keyword';
            }
            if (stream.match(middle)) {
                return 'keyword';
            }

            if (stream.match(doubleClosing)) {
                dedent(stream,state);
                dedent(stream,state);
                return 'keyword';
            }
            if (stream.match(closing)) {
                dedent(stream,state);
                return 'keyword';
            }

            if (stream.match(types)) {
                return 'keyword';
            }

            if (stream.match(keywords)) {
                return 'keyword';
            }

            if (stream.match(identifiers)) {
                return 'variable';
            }

            // Handle non-detected items
            stream.next();
            return ERRORCLASS;
        }

        function tokenStringFactory(delimiter) {
            var singleline = delimiter.length == 1;
            var OUTCLASS = 'string';

            return function(stream, state) {
                while (!stream.eol()) {
                    stream.eatWhile(/[^'"]/);
                    if (stream.match(delimiter)) {
                        state.tokenize = tokenBase;
                        return OUTCLASS;
                    } else {
                        stream.eat(/['"]/);
                    }
                }
                if (singleline) {
                    if (parserConf.singleLineStringErrors) {
                        return ERRORCLASS;
                    } else {
                        state.tokenize = tokenBase;
                    }
                }
                return OUTCLASS;
            };
        }


        function tokenLexer(stream, state) {
            var style = state.tokenize(stream, state);
            var current = stream.current();

            // Handle '.' connected identifiers
            if (current === '.') {
                style = state.tokenize(stream, state);
                if (style === 'variable') {
                    return 'variable';
                } else {
                    return ERRORCLASS;
                }
            }


            var delimiter_index = '[({'.indexOf(current);
            if (delimiter_index !== -1) {
                indent(stream, state );
            }
            if (indentInfo === 'dedent') {
                if (dedent(stream, state)) {
                    return ERRORCLASS;
                }
            }
            delimiter_index = '])}'.indexOf(current);
            if (delimiter_index !== -1) {
                if (dedent(stream, state)) {
                    return ERRORCLASS;
                }
            }

            return style;
        }

        var external = {
            electricChars:"dDpPtTfFeE ",
            startState: function() {
                return {
                  tokenize: tokenBase,
                  lastToken: null,
                  currentIndent: 0,
                  nextLineIndent: 0,
                  doInCurrentLine: false


              };
            },

            token: function(stream, state) {
                if (stream.sol()) {
                  state.currentIndent += state.nextLineIndent;
                  state.nextLineIndent = 0;
                  state.doInCurrentLine = 0;
                }
                var style = tokenLexer(stream, state);

                state.lastToken = {style:style, content: stream.current()};



                return style;
            },

            indent: function(state, textAfter) {
                var trueText = textAfter.replace(/^\s+|\s+$/g, '') ;
                if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);
                if(state.currentIndent < 0) return 0;
                return state.currentIndent * conf.indentUnit;
            },

            lineComment: "'"
        };
        return external;
    });

    CodeMirror.defineMIME("text/x-vb", "vb");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-vbscript-vbscript.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
    For extra ASP classic objects, initialize CodeMirror instance with this option:
        isASP: true

    E.G.:
        var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
            lineNumbers: true,
            isASP: true
          });
    */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("vbscript", function(conf, parserConf) {
        var ERRORCLASS = 'error';

        function wordRegexp(words) {
            return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
        }

        var singleOperators = new RegExp("^[\\+\\-\\*/&\\\\\\^<>=]");
        var doubleOperators = new RegExp("^((<>)|(<=)|(>=))");
        var singleDelimiters = new RegExp('^[\\.,]');
        var brackets = new RegExp('^[\\(\\)]');
        var identifiers = new RegExp("^[A-Za-z][_A-Za-z0-9]*");

        var openingKeywords = ['class','sub','select','while','if','function', 'property', 'with', 'for'];
        var middleKeywords = ['else','elseif','case'];
        var endKeywords = ['next','loop','wend'];

        var wordOperators = wordRegexp(['and', 'or', 'not', 'xor', 'is', 'mod', 'eqv', 'imp']);
        var commonkeywords = ['dim', 'redim', 'then',  'until', 'randomize',
                              'byval','byref','new','property', 'exit', 'in',
                              'const','private', 'public',
                              'get','set','let', 'stop', 'on error resume next', 'on error goto 0', 'option explicit', 'call', 'me'];

        //This list was from: http://msdn.microsoft.com/en-us/library/f8tbc79x(v=vs.84).aspx
        var atomWords = ['true', 'false', 'nothing', 'empty', 'null'];
        //This list was from: http://msdn.microsoft.com/en-us/library/3ca8tfek(v=vs.84).aspx
        var builtinFuncsWords = ['abs', 'array', 'asc', 'atn', 'cbool', 'cbyte', 'ccur', 'cdate', 'cdbl', 'chr', 'cint', 'clng', 'cos', 'csng', 'cstr', 'date', 'dateadd', 'datediff', 'datepart',
                            'dateserial', 'datevalue', 'day', 'escape', 'eval', 'execute', 'exp', 'filter', 'formatcurrency', 'formatdatetime', 'formatnumber', 'formatpercent', 'getlocale', 'getobject',
                            'getref', 'hex', 'hour', 'inputbox', 'instr', 'instrrev', 'int', 'fix', 'isarray', 'isdate', 'isempty', 'isnull', 'isnumeric', 'isobject', 'join', 'lbound', 'lcase', 'left',
                            'len', 'loadpicture', 'log', 'ltrim', 'rtrim', 'trim', 'maths', 'mid', 'minute', 'month', 'monthname', 'msgbox', 'now', 'oct', 'replace', 'rgb', 'right', 'rnd', 'round',
                            'scriptengine', 'scriptenginebuildversion', 'scriptenginemajorversion', 'scriptengineminorversion', 'second', 'setlocale', 'sgn', 'sin', 'space', 'split', 'sqr', 'strcomp',
                            'string', 'strreverse', 'tan', 'time', 'timer', 'timeserial', 'timevalue', 'typename', 'ubound', 'ucase', 'unescape', 'vartype', 'weekday', 'weekdayname', 'year'];

        //This list was from: http://msdn.microsoft.com/en-us/library/ydz4cfk3(v=vs.84).aspx
        var builtinConsts = ['vbBlack', 'vbRed', 'vbGreen', 'vbYellow', 'vbBlue', 'vbMagenta', 'vbCyan', 'vbWhite', 'vbBinaryCompare', 'vbTextCompare',
                             'vbSunday', 'vbMonday', 'vbTuesday', 'vbWednesday', 'vbThursday', 'vbFriday', 'vbSaturday', 'vbUseSystemDayOfWeek', 'vbFirstJan1', 'vbFirstFourDays', 'vbFirstFullWeek',
                             'vbGeneralDate', 'vbLongDate', 'vbShortDate', 'vbLongTime', 'vbShortTime', 'vbObjectError',
                             'vbOKOnly', 'vbOKCancel', 'vbAbortRetryIgnore', 'vbYesNoCancel', 'vbYesNo', 'vbRetryCancel', 'vbCritical', 'vbQuestion', 'vbExclamation', 'vbInformation', 'vbDefaultButton1', 'vbDefaultButton2',
                             'vbDefaultButton3', 'vbDefaultButton4', 'vbApplicationModal', 'vbSystemModal', 'vbOK', 'vbCancel', 'vbAbort', 'vbRetry', 'vbIgnore', 'vbYes', 'vbNo',
                             'vbCr', 'VbCrLf', 'vbFormFeed', 'vbLf', 'vbNewLine', 'vbNullChar', 'vbNullString', 'vbTab', 'vbVerticalTab', 'vbUseDefault', 'vbTrue', 'vbFalse',
                             'vbEmpty', 'vbNull', 'vbInteger', 'vbLong', 'vbSingle', 'vbDouble', 'vbCurrency', 'vbDate', 'vbString', 'vbObject', 'vbError', 'vbBoolean', 'vbVariant', 'vbDataObject', 'vbDecimal', 'vbByte', 'vbArray'];
        //This list was from: http://msdn.microsoft.com/en-us/library/hkc375ea(v=vs.84).aspx
        var builtinObjsWords = ['WScript', 'err', 'debug', 'RegExp'];
        var knownProperties = ['description', 'firstindex', 'global', 'helpcontext', 'helpfile', 'ignorecase', 'length', 'number', 'pattern', 'source', 'value', 'count'];
        var knownMethods = ['clear', 'execute', 'raise', 'replace', 'test', 'write', 'writeline', 'close', 'open', 'state', 'eof', 'update', 'addnew', 'end', 'createobject', 'quit'];

        var aspBuiltinObjsWords = ['server', 'response', 'request', 'session', 'application'];
        var aspKnownProperties = ['buffer', 'cachecontrol', 'charset', 'contenttype', 'expires', 'expiresabsolute', 'isclientconnected', 'pics', 'status', //response
                                  'clientcertificate', 'cookies', 'form', 'querystring', 'servervariables', 'totalbytes', //request
                                  'contents', 'staticobjects', //application
                                  'codepage', 'lcid', 'sessionid', 'timeout', //session
                                  'scripttimeout']; //server
        var aspKnownMethods = ['addheader', 'appendtolog', 'binarywrite', 'end', 'flush', 'redirect', //response
                               'binaryread', //request
                               'remove', 'removeall', 'lock', 'unlock', //application
                               'abandon', //session
                               'getlasterror', 'htmlencode', 'mappath', 'transfer', 'urlencode']; //server

        var knownWords = knownMethods.concat(knownProperties);

        builtinObjsWords = builtinObjsWords.concat(builtinConsts);

        if (conf.isASP){
            builtinObjsWords = builtinObjsWords.concat(aspBuiltinObjsWords);
            knownWords = knownWords.concat(aspKnownMethods, aspKnownProperties);
        };

        var keywords = wordRegexp(commonkeywords);
        var atoms = wordRegexp(atomWords);
        var builtinFuncs = wordRegexp(builtinFuncsWords);
        var builtinObjs = wordRegexp(builtinObjsWords);
        var known = wordRegexp(knownWords);
        var stringPrefixes = '"';

        var opening = wordRegexp(openingKeywords);
        var middle = wordRegexp(middleKeywords);
        var closing = wordRegexp(endKeywords);
        var doubleClosing = wordRegexp(['end']);
        var doOpening = wordRegexp(['do']);
        var noIndentWords = wordRegexp(['on error resume next', 'exit']);
        var comment = wordRegexp(['rem']);


        function indent(_stream, state) {
          state.currentIndent++;
        }

        function dedent(_stream, state) {
          state.currentIndent--;
        }
        // tokenizers
        function tokenBase(stream, state) {
            if (stream.eatSpace()) {
                return 'space';
                //return null;
            }

            var ch = stream.peek();

            // Handle Comments
            if (ch === "'") {
                stream.skipToEnd();
                return 'comment';
            }
            if (stream.match(comment)){
                stream.skipToEnd();
                return 'comment';
            }


            // Handle Number Literals
            if (stream.match(/^((&H)|(&O))?[0-9\.]/i, false) && !stream.match(/^((&H)|(&O))?[0-9\.]+[a-z_]/i, false)) {
                var floatLiteral = false;
                // Floats
                if (stream.match(/^\d*\.\d+/i)) { floatLiteral = true; }
                else if (stream.match(/^\d+\.\d*/)) { floatLiteral = true; }
                else if (stream.match(/^\.\d+/)) { floatLiteral = true; }

                if (floatLiteral) {
                    // Float literals may be "imaginary"
                    stream.eat(/J/i);
                    return 'number';
                }
                // Integers
                var intLiteral = false;
                // Hex
                if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }
                // Octal
                else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }
                // Decimal
                else if (stream.match(/^[1-9]\d*F?/)) {
                    // Decimal literals may be "imaginary"
                    stream.eat(/J/i);
                    // TODO - Can you have imaginary longs?
                    intLiteral = true;
                }
                // Zero by itself with no other piece of number.
                else if (stream.match(/^0(?![\dx])/i)) { intLiteral = true; }
                if (intLiteral) {
                    // Integer literals may be "long"
                    stream.eat(/L/i);
                    return 'number';
                }
            }

            // Handle Strings
            if (stream.match(stringPrefixes)) {
                state.tokenize = tokenStringFactory(stream.current());
                return state.tokenize(stream, state);
            }

            // Handle operators and Delimiters
            if (stream.match(doubleOperators)
                || stream.match(singleOperators)
                || stream.match(wordOperators)) {
                return 'operator';
            }
            if (stream.match(singleDelimiters)) {
                return null;
            }

            if (stream.match(brackets)) {
                return "bracket";
            }

            if (stream.match(noIndentWords)) {
                state.doInCurrentLine = true;

                return 'keyword';
            }

            if (stream.match(doOpening)) {
                indent(stream,state);
                state.doInCurrentLine = true;

                return 'keyword';
            }
            if (stream.match(opening)) {
                if (! state.doInCurrentLine)
                  indent(stream,state);
                else
                  state.doInCurrentLine = false;

                return 'keyword';
            }
            if (stream.match(middle)) {
                return 'keyword';
            }


            if (stream.match(doubleClosing)) {
                dedent(stream,state);
                dedent(stream,state);

                return 'keyword';
            }
            if (stream.match(closing)) {
                if (! state.doInCurrentLine)
                  dedent(stream,state);
                else
                  state.doInCurrentLine = false;

                return 'keyword';
            }

            if (stream.match(keywords)) {
                return 'keyword';
            }

            if (stream.match(atoms)) {
                return 'atom';
            }

            if (stream.match(known)) {
                return 'variable-2';
            }

            if (stream.match(builtinFuncs)) {
                return 'builtin';
            }

            if (stream.match(builtinObjs)){
                return 'variable-2';
            }

            if (stream.match(identifiers)) {
                return 'variable';
            }

            // Handle non-detected items
            stream.next();
            return ERRORCLASS;
        }

        function tokenStringFactory(delimiter) {
            var singleline = delimiter.length == 1;
            var OUTCLASS = 'string';

            return function(stream, state) {
                while (!stream.eol()) {
                    stream.eatWhile(/[^'"]/);
                    if (stream.match(delimiter)) {
                        state.tokenize = tokenBase;
                        return OUTCLASS;
                    } else {
                        stream.eat(/['"]/);
                    }
                }
                if (singleline) {
                    if (parserConf.singleLineStringErrors) {
                        return ERRORCLASS;
                    } else {
                        state.tokenize = tokenBase;
                    }
                }
                return OUTCLASS;
            };
        }


        function tokenLexer(stream, state) {
            var style = state.tokenize(stream, state);
            var current = stream.current();

            // Handle '.' connected identifiers
            if (current === '.') {
                style = state.tokenize(stream, state);

                current = stream.current();
                if (style && (style.substr(0, 8) === 'variable' || style==='builtin' || style==='keyword')){//|| knownWords.indexOf(current.substring(1)) > -1) {
                    if (style === 'builtin' || style === 'keyword') style='variable';
                    if (knownWords.indexOf(current.substr(1)) > -1) style='variable-2';

                    return style;
                } else {
                    return ERRORCLASS;
                }
            }

            return style;
        }

        var external = {
            electricChars:"dDpPtTfFeE ",
            startState: function() {
                return {
                  tokenize: tokenBase,
                  lastToken: null,
                  currentIndent: 0,
                  nextLineIndent: 0,
                  doInCurrentLine: false,
                  ignoreKeyword: false


              };
            },

            token: function(stream, state) {
                if (stream.sol()) {
                  state.currentIndent += state.nextLineIndent;
                  state.nextLineIndent = 0;
                  state.doInCurrentLine = 0;
                }
                var style = tokenLexer(stream, state);

                state.lastToken = {style:style, content: stream.current()};

                if (style==='space') style=null;

                return style;
            },

            indent: function(state, textAfter) {
                var trueText = textAfter.replace(/^\s+|\s+$/g, '') ;
                if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);
                if(state.currentIndent < 0) return 0;
                return state.currentIndent * conf.indentUnit;
            }

        };
        return external;
    });

    CodeMirror.defineMIME("text/vbscript", "vbscript");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-vhdl-vhdl.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Originally written by Alf Nielsen, re-written by Michael Zhou
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    function words(str) {
      var obj = {}, words = str.split(",");
      for (var i = 0; i < words.length; ++i) {
        var allCaps = words[i].toUpperCase();
        var firstCap = words[i].charAt(0).toUpperCase() + words[i].slice(1);
        obj[words[i]] = true;
        obj[allCaps] = true;
        obj[firstCap] = true;
      }
      return obj;
    }

    function metaHook(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    }

    CodeMirror.defineMode("vhdl", function(config, parserConfig) {
      var indentUnit = config.indentUnit,
          atoms = parserConfig.atoms || words("null"),
          hooks = parserConfig.hooks || {"`": metaHook, "$": metaHook},
          multiLineStrings = parserConfig.multiLineStrings;

      var keywords = words("abs,access,after,alias,all,and,architecture,array,assert,attribute,begin,block," +
          "body,buffer,bus,case,component,configuration,constant,disconnect,downto,else,elsif,end,end block,end case," +
          "end component,end for,end generate,end if,end loop,end process,end record,end units,entity,exit,file,for," +
          "function,generate,generic,generic map,group,guarded,if,impure,in,inertial,inout,is,label,library,linkage," +
          "literal,loop,map,mod,nand,new,next,nor,null,of,on,open,or,others,out,package,package body,port,port map," +
          "postponed,procedure,process,pure,range,record,register,reject,rem,report,return,rol,ror,select,severity,signal," +
          "sla,sll,sra,srl,subtype,then,to,transport,type,unaffected,units,until,use,variable,wait,when,while,with,xnor,xor");

      var blockKeywords = words("architecture,entity,begin,case,port,else,elsif,end,for,function,if");

      var isOperatorChar = /[&|~><!\)\(*#%@+\/=?\:;}{,\.\^\-\[\]]/;
      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"') {
          state.tokenize = tokenString2(ch);
          return state.tokenize(stream, state);
        }
        if (ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/[\d']/.test(ch)) {
          stream.eatWhile(/[\w\.']/);
          return "number";
        }
        if (ch == "-") {
          if (stream.eat("-")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur.toLowerCase())) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "keyword";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "--";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "string";
        };
      }
      function tokenString2(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "--";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "string-2";
        };
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface
      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}"
      };
    });

    CodeMirror.defineMIME("text/x-vhdl", "vhdl");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-xml-xml.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    var htmlConfig = {
      autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                        'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                        'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                        'track': true, 'wbr': true, 'menuitem': true},
      implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                         'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                         'th': true, 'tr': true},
      contextGrabbers: {
        'dd': {'dd': true, 'dt': true},
        'dt': {'dd': true, 'dt': true},
        'li': {'li': true},
        'option': {'option': true, 'optgroup': true},
        'optgroup': {'optgroup': true},
        'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
              'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
              'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
              'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
              'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
        'rp': {'rp': true, 'rt': true},
        'rt': {'rp': true, 'rt': true},
        'tbody': {'tbody': true, 'tfoot': true},
        'td': {'td': true, 'th': true},
        'tfoot': {'tbody': true},
        'th': {'td': true, 'th': true},
        'thead': {'tbody': true, 'tfoot': true},
        'tr': {'tr': true}
      },
      doNotIndent: {"pre": true},
      allowUnquoted: true,
      allowMissing: true,
      caseFold: true
    }

    var xmlConfig = {
      autoSelfClosers: {},
      implicitlyClosed: {},
      contextGrabbers: {},
      doNotIndent: {},
      allowUnquoted: false,
      allowMissing: false,
      allowMissingTagName: false,
      caseFold: false
    }

    CodeMirror.defineMode("xml", function(editorConf, config_) {
      var indentUnit = editorConf.indentUnit
      var config = {}
      var defaults = config_.htmlMode ? htmlConfig : xmlConfig
      for (var prop in defaults) config[prop] = defaults[prop]
      for (var prop in config_) config[prop] = config_[prop]

      // Return variables for tokenizers
      var type, setStyle;

      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        var ch = stream.next();
        if (ch == "<") {
          if (stream.eat("!")) {
            if (stream.eat("[")) {
              if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
              else return null;
            } else if (stream.match("--")) {
              return chain(inBlock("comment", "-->"));
            } else if (stream.match("DOCTYPE", true, true)) {
              stream.eatWhile(/[\w\._\-]/);
              return chain(doctype(1));
            } else {
              return null;
            }
          } else if (stream.eat("?")) {
            stream.eatWhile(/[\w\._\-]/);
            state.tokenize = inBlock("meta", "?>");
            return "meta";
          } else {
            type = stream.eat("/") ? "closeTag" : "openTag";
            state.tokenize = inTag;
            return "tag bracket";
          }
        } else if (ch == "&") {
          var ok;
          if (stream.eat("#")) {
            if (stream.eat("x")) {
              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
            } else {
              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
            }
          } else {
            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
          }
          return ok ? "atom" : "error";
        } else {
          stream.eatWhile(/[^&<]/);
          return null;
        }
      }
      inText.isInText = true;

      function inTag(stream, state) {
        var ch = stream.next();
        if (ch == ">" || (ch == "/" && stream.eat(">"))) {
          state.tokenize = inText;
          type = ch == ">" ? "endTag" : "selfcloseTag";
          return "tag bracket";
        } else if (ch == "=") {
          type = "equals";
          return null;
        } else if (ch == "<") {
          state.tokenize = inText;
          state.state = baseState;
          state.tagName = state.tagStart = null;
          var next = state.tokenize(stream, state);
          return next ? next + " tag error" : "tag error";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          state.stringStartCol = stream.column();
          return state.tokenize(stream, state);
        } else {
          stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
          return "word";
        }
      }

      function inAttribute(quote) {
        var closure = function(stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inTag;
              break;
            }
          }
          return "string";
        };
        closure.isInAttribute = true;
        return closure;
      }

      function inBlock(style, terminator) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }
          return style;
        }
      }

      function doctype(depth) {
        return function(stream, state) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "<") {
              state.tokenize = doctype(depth + 1);
              return state.tokenize(stream, state);
            } else if (ch == ">") {
              if (depth == 1) {
                state.tokenize = inText;
                break;
              } else {
                state.tokenize = doctype(depth - 1);
                return state.tokenize(stream, state);
              }
            }
          }
          return "meta";
        };
      }

      function Context(state, tagName, startOfLine) {
        this.prev = state.context;
        this.tagName = tagName || "";
        this.indent = state.indented;
        this.startOfLine = startOfLine;
        if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
          this.noIndent = true;
      }
      function popContext(state) {
        if (state.context) state.context = state.context.prev;
      }
      function maybePopContext(state, nextTagName) {
        var parentTagName;
        while (true) {
          if (!state.context) {
            return;
          }
          parentTagName = state.context.tagName;
          if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
              !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
            return;
          }
          popContext(state);
        }
      }

      function baseState(type, stream, state) {
        if (type == "openTag") {
          state.tagStart = stream.column();
          return tagNameState;
        } else if (type == "closeTag") {
          return closeTagNameState;
        } else {
          return baseState;
        }
      }
      function tagNameState(type, stream, state) {
        if (type == "word") {
          state.tagName = stream.current();
          setStyle = "tag";
          return attrState;
        } else if (config.allowMissingTagName && type == "endTag") {
          setStyle = "tag bracket";
          return attrState(type, stream, state);
        } else {
          setStyle = "error";
          return tagNameState;
        }
      }
      function closeTagNameState(type, stream, state) {
        if (type == "word") {
          var tagName = stream.current();
          if (state.context && state.context.tagName != tagName &&
              config.implicitlyClosed.hasOwnProperty(state.context.tagName))
            popContext(state);
          if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
            setStyle = "tag";
            return closeState;
          } else {
            setStyle = "tag error";
            return closeStateErr;
          }
        } else if (config.allowMissingTagName && type == "endTag") {
          setStyle = "tag bracket";
          return closeState(type, stream, state);
        } else {
          setStyle = "error";
          return closeStateErr;
        }
      }

      function closeState(type, _stream, state) {
        if (type != "endTag") {
          setStyle = "error";
          return closeState;
        }
        popContext(state);
        return baseState;
      }
      function closeStateErr(type, stream, state) {
        setStyle = "error";
        return closeState(type, stream, state);
      }

      function attrState(type, _stream, state) {
        if (type == "word") {
          setStyle = "attribute";
          return attrEqState;
        } else if (type == "endTag" || type == "selfcloseTag") {
          var tagName = state.tagName, tagStart = state.tagStart;
          state.tagName = state.tagStart = null;
          if (type == "selfcloseTag" ||
              config.autoSelfClosers.hasOwnProperty(tagName)) {
            maybePopContext(state, tagName);
          } else {
            maybePopContext(state, tagName);
            state.context = new Context(state, tagName, tagStart == state.indented);
          }
          return baseState;
        }
        setStyle = "error";
        return attrState;
      }
      function attrEqState(type, stream, state) {
        if (type == "equals") return attrValueState;
        if (!config.allowMissing) setStyle = "error";
        return attrState(type, stream, state);
      }
      function attrValueState(type, stream, state) {
        if (type == "string") return attrContinuedState;
        if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
        setStyle = "error";
        return attrState(type, stream, state);
      }
      function attrContinuedState(type, stream, state) {
        if (type == "string") return attrContinuedState;
        return attrState(type, stream, state);
      }

      return {
        startState: function(baseIndent) {
          var state = {tokenize: inText,
                       state: baseState,
                       indented: baseIndent || 0,
                       tagName: null, tagStart: null,
                       context: null}
          if (baseIndent != null) state.baseIndent = baseIndent
          return state
        },

        token: function(stream, state) {
          if (!state.tagName && stream.sol())
            state.indented = stream.indentation();

          if (stream.eatSpace()) return null;
          type = null;
          var style = state.tokenize(stream, state);
          if ((style || type) && style != "comment") {
            setStyle = null;
            state.state = state.state(type || style, stream, state);
            if (setStyle)
              style = setStyle == "error" ? style + " error" : setStyle;
          }
          return style;
        },

        indent: function(state, textAfter, fullLine) {
          var context = state.context;
          // Indent multi-line strings (e.g. css).
          if (state.tokenize.isInAttribute) {
            if (state.tagStart == state.indented)
              return state.stringStartCol + 1;
            else
              return state.indented + indentUnit;
          }
          if (context && context.noIndent) return CodeMirror.Pass;
          if (state.tokenize != inTag && state.tokenize != inText)
            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
          // Indent the starts of attribute names.
          if (state.tagName) {
            if (config.multilineTagIndentPastTag !== false)
              return state.tagStart + state.tagName.length + 2;
            else
              return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
          }
          if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
          var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
          if (tagAfter && tagAfter[1]) { // Closing tag spotted
            while (context) {
              if (context.tagName == tagAfter[2]) {
                context = context.prev;
                break;
              } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                context = context.prev;
              } else {
                break;
              }
            }
          } else if (tagAfter) { // Opening tag spotted
            while (context) {
              var grabbers = config.contextGrabbers[context.tagName];
              if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
                context = context.prev;
              else
                break;
            }
          }
          while (context && context.prev && !context.startOfLine)
            context = context.prev;
          if (context) return context.indent + indentUnit;
          else return state.baseIndent || 0;
        },

        electricInput: /<\/[\s\w:]+>$/,
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",

        configuration: config.htmlMode ? "html" : "xml",
        helperType: config.htmlMode ? "html" : "xml",

        skipAttribute: function(state) {
          if (state.state == attrValueState)
            state.state = attrState
        },

        xmlCurrentTag: function(state) {
          return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
        },

        xmlCurrentContext: function(state) {
          var context = []
          for (var cx = state.context; cx; cx = cx.prev)
            context.push(cx.tagName)
          return context.reverse()
        }
      };
    });

    CodeMirror.defineMIME("text/xml", "xml");
    CodeMirror.defineMIME("application/xml", "xml");
    if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
      CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-yaml-yaml.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("yaml", function() {

      var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];
      var keywordRegex = new RegExp("\\b(("+cons.join(")|(")+"))$", 'i');

      return {
        token: function(stream, state) {
          var ch = stream.peek();
          var esc = state.escaped;
          state.escaped = false;
          /* comments */
          if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
            stream.skipToEnd();
            return "comment";
          }

          if (stream.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
            return "string";

          if (state.literal && stream.indentation() > state.keyCol) {
            stream.skipToEnd(); return "string";
          } else if (state.literal) { state.literal = false; }
          if (stream.sol()) {
            state.keyCol = 0;
            state.pair = false;
            state.pairStart = false;
            /* document start */
            if(stream.match('---')) { return "def"; }
            /* document end */
            if (stream.match('...')) { return "def"; }
            /* array list item */
            if (stream.match(/\s*-\s+/)) { return 'meta'; }
          }
          /* inline pairs/lists */
          if (stream.match(/^(\{|\}|\[|\])/)) {
            if (ch == '{')
              state.inlinePairs++;
            else if (ch == '}')
              state.inlinePairs--;
            else if (ch == '[')
              state.inlineList++;
            else
              state.inlineList--;
            return 'meta';
          }

          /* list separator */
          if (state.inlineList > 0 && !esc && ch == ',') {
            stream.next();
            return 'meta';
          }
          /* pairs separator */
          if (state.inlinePairs > 0 && !esc && ch == ',') {
            state.keyCol = 0;
            state.pair = false;
            state.pairStart = false;
            stream.next();
            return 'meta';
          }

          /* start of value of a pair */
          if (state.pairStart) {
            /* block literals */
            if (stream.match(/^\s*(\||\>)\s*/)) { state.literal = true; return 'meta'; };
            /* references */
            if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) { return 'variable-2'; }
            /* numbers */
            if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) { return 'number'; }
            if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) { return 'number'; }
            /* keywords */
            if (stream.match(keywordRegex)) { return 'keyword'; }
          }

          /* pairs (associative arrays) -> key */
          if (!state.pair && stream.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/)) {
            state.pair = true;
            state.keyCol = stream.indentation();
            return "atom";
          }
          if (state.pair && stream.match(/^:\s*/)) { state.pairStart = true; return 'meta'; }

          /* nothing found, continue */
          state.pairStart = false;
          state.escaped = (ch == '\\');
          stream.next();
          return null;
        },
        startState: function() {
          return {
            pair: false,
            pairStart: false,
            keyCol: 0,
            inlinePairs: 0,
            inlineList: 0,
            literal: false,
            escaped: false
          };
        },
        lineComment: "#",
        fold: "indent"
      };
    });

    CodeMirror.defineMIME("text/x-yaml", "yaml");
    CodeMirror.defineMIME("text/yaml", "yaml");

    });
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: php-code-content-105
