apiVersion: v1
data:
  uploads-Carbon-vendor-symfony-translation-Dumper-CsvFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * CsvFileDumper generates a csv formatted string representation of a message catalogue.
     *
     * @author Stealth35
     */
    class CsvFileDumper extends FileDumper
    {
        private $delimiter = ';';
        private $enclosure = '"';

        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $handle = fopen('php://memory', 'r+');

            foreach ($messages->all($domain) as $source => $target) {
                fputcsv($handle, [$source, $target], $this->delimiter, $this->enclosure);
            }

            rewind($handle);
            $output = stream_get_contents($handle);
            fclose($handle);

            return $output;
        }

        /**
         * Sets the delimiter and escape character for CSV.
         *
         * @param string $delimiter Delimiter character
         * @param string $enclosure Enclosure character
         */
        public function setCsvControl($delimiter = ';', $enclosure = '"')
        {
            $this->delimiter = $delimiter;
            $this->enclosure = $enclosure;
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'csv';
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-DumperInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * DumperInterface is the interface implemented by all translation dumpers.
     * There is no common option.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    interface DumperInterface
    {
        /**
         * Dumps the message catalogue.
         *
         * @param array $options Options that are used by the dumper
         */
        public function dump(MessageCatalogue $messages, $options = []);
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-FileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Component\Translation\Exception\RuntimeException;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * FileDumper is an implementation of DumperInterface that dump a message catalogue to file(s).
     *
     * Options:
     * - path (mandatory): the directory where the files should be saved
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    abstract class FileDumper implements DumperInterface
    {
        /**
         * A template for the relative paths to files.
         *
         * @var string
         */
        protected $relativePathTemplate = '%domain%.%locale%.%extension%';

        /**
         * Sets the template for the relative paths to files.
         *
         * @param string $relativePathTemplate A template for the relative paths to files
         */
        public function setRelativePathTemplate($relativePathTemplate)
        {
            $this->relativePathTemplate = $relativePathTemplate;
        }

        /**
         * Sets backup flag.
         *
         * @param bool $backup
         *
         * @deprecated since Symfony 4.1
         */
        public function setBackup($backup)
        {
            @trigger_error(sprintf('The "%s()" method is deprecated since Symfony 4.1.', __METHOD__), \E_USER_DEPRECATED);

            if (false !== $backup) {
                throw new \LogicException('The backup feature is no longer supported.');
            }
        }

        /**
         * {@inheritdoc}
         */
        public function dump(MessageCatalogue $messages, $options = [])
        {
            if (!\array_key_exists('path', $options)) {
                throw new InvalidArgumentException('The file dumper needs a path option.');
            }

            // save a file for each domain
            foreach ($messages->getDomains() as $domain) {
                $fullpath = $options['path'].'/'.$this->getRelativePath($domain, $messages->getLocale());
                if (!file_exists($fullpath)) {
                    $directory = \dirname($fullpath);
                    if (!file_exists($directory) && !@mkdir($directory, 0777, true)) {
                        throw new RuntimeException(sprintf('Unable to create directory "%s".', $directory));
                    }
                }

                $intlDomain = $domain.MessageCatalogue::INTL_DOMAIN_SUFFIX;
                $intlMessages = $messages->all($intlDomain);

                if ($intlMessages) {
                    $intlPath = $options['path'].'/'.$this->getRelativePath($intlDomain, $messages->getLocale());
                    file_put_contents($intlPath, $this->formatCatalogue($messages, $intlDomain, $options));

                    $messages->replace([], $intlDomain);

                    try {
                        if ($messages->all($domain)) {
                            file_put_contents($fullpath, $this->formatCatalogue($messages, $domain, $options));
                        }
                        continue;
                    } finally {
                        $messages->replace($intlMessages, $intlDomain);
                    }
                }

                file_put_contents($fullpath, $this->formatCatalogue($messages, $domain, $options));
            }
        }

        /**
         * Transforms a domain of a message catalogue to its string representation.
         *
         * @param string $domain
         *
         * @return string representation
         */
        abstract public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = []);

        /**
         * Gets the file extension of the dumper.
         *
         * @return string file extension
         */
        abstract protected function getExtension();

        /**
         * Gets the relative file path using the template.
         */
        private function getRelativePath(string $domain, string $locale): string
        {
            return strtr($this->relativePathTemplate, [
                '%domain%' => $domain,
                '%locale%' => $locale,
                '%extension%' => $this->getExtension(),
            ]);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-IcuResFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * IcuResDumper generates an ICU ResourceBundle formatted string representation of a message catalogue.
     *
     * @author Stealth35
     */
    class IcuResFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        protected $relativePathTemplate = '%domain%/%locale%.%extension%';

        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $data = $indexes = $resources = '';

            foreach ($messages->all($domain) as $source => $target) {
                $indexes .= pack('v', \strlen($data) + 28);
                $data .= $source."\0";
            }

            $data .= $this->writePadding($data);

            $keyTop = $this->getPosition($data);

            foreach ($messages->all($domain) as $source => $target) {
                $resources .= pack('V', $this->getPosition($data));

                $data .= pack('V', \strlen($target))
                    .mb_convert_encoding($target."\0", 'UTF-16LE', 'UTF-8')
                    .$this->writePadding($data)
                      ;
            }

            $resOffset = $this->getPosition($data);

            $data .= pack('v', \count($messages->all($domain)))
                .$indexes
                .$this->writePadding($data)
                .$resources
                  ;

            $bundleTop = $this->getPosition($data);

            $root = pack('V7',
                $resOffset + (2 << 28), // Resource Offset + Resource Type
                6,                      // Index length
                $keyTop,                        // Index keys top
                $bundleTop,                     // Index resources top
                $bundleTop,                     // Index bundle top
                \count($messages->all($domain)), // Index max table length
                0                               // Index attributes
            );

            $header = pack('vC2v4C12@32',
                32,                     // Header size
                0xDA, 0x27,             // Magic number 1 and 2
                20, 0, 0, 2,            // Rest of the header, ..., Size of a char
                0x52, 0x65, 0x73, 0x42, // Data format identifier
                1, 2, 0, 0,             // Data version
                1, 4, 0, 0              // Unicode version
            );

            return $header.$root.$data;
        }

        private function writePadding(string $data): ?string
        {
            $padding = \strlen($data) % 4;

            return $padding ? str_repeat("\xAA", 4 - $padding) : null;
        }

        private function getPosition(string $data)
        {
            return (\strlen($data) + 28) / 4;
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'res';
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-IniFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * IniFileDumper generates an ini formatted string representation of a message catalogue.
     *
     * @author Stealth35
     */
    class IniFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $output = '';

            foreach ($messages->all($domain) as $source => $target) {
                $escapeTarget = str_replace('"', '\"', $target);
                $output .= $source.'="'.$escapeTarget."\"\n";
            }

            return $output;
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'ini';
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-JsonFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * JsonFileDumper generates an json formatted string representation of a message catalogue.
     *
     * @author singles
     */
    class JsonFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $flags = $options['json_encoding'] ?? \JSON_PRETTY_PRINT;

            return json_encode($messages->all($domain), $flags);
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'json';
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-MoFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\Loader\MoFileLoader;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * MoFileDumper generates a gettext formatted string representation of a message catalogue.
     *
     * @author Stealth35
     */
    class MoFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $sources = $targets = $sourceOffsets = $targetOffsets = '';
            $offsets = [];
            $size = 0;

            foreach ($messages->all($domain) as $source => $target) {
                $offsets[] = array_map('strlen', [$sources, $source, $targets, $target]);
                $sources .= "\0".$source;
                $targets .= "\0".$target;
                ++$size;
            }

            $header = [
                'magicNumber' => MoFileLoader::MO_LITTLE_ENDIAN_MAGIC,
                'formatRevision' => 0,
                'count' => $size,
                'offsetId' => MoFileLoader::MO_HEADER_SIZE,
                'offsetTranslated' => MoFileLoader::MO_HEADER_SIZE + (8 * $size),
                'sizeHashes' => 0,
                'offsetHashes' => MoFileLoader::MO_HEADER_SIZE + (16 * $size),
            ];

            $sourcesSize = \strlen($sources);
            $sourcesStart = $header['offsetHashes'] + 1;

            foreach ($offsets as $offset) {
                $sourceOffsets .= $this->writeLong($offset[1])
                              .$this->writeLong($offset[0] + $sourcesStart);
                $targetOffsets .= $this->writeLong($offset[3])
                              .$this->writeLong($offset[2] + $sourcesStart + $sourcesSize);
            }

            $output = implode('', array_map([$this, 'writeLong'], $header))
                   .$sourceOffsets
                   .$targetOffsets
                   .$sources
                   .$targets
                    ;

            return $output;
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'mo';
        }

        private function writeLong($str): string
        {
            return pack('V*', $str);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-PhpFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * PhpFileDumper generates PHP files from a message catalogue.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    class PhpFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            return "<?php\n\nreturn ".var_export($messages->all($domain), true).";\n";
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'php';
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-PoFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * PoFileDumper generates a gettext formatted string representation of a message catalogue.
     *
     * @author Stealth35
     */
    class PoFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $output = 'msgid ""'."\n";
            $output .= 'msgstr ""'."\n";
            $output .= '"Content-Type: text/plain; charset=UTF-8\n"'."\n";
            $output .= '"Content-Transfer-Encoding: 8bit\n"'."\n";
            $output .= '"Language: '.$messages->getLocale().'\n"'."\n";
            $output .= "\n";

            $newLine = false;
            foreach ($messages->all($domain) as $source => $target) {
                if ($newLine) {
                    $output .= "\n";
                } else {
                    $newLine = true;
                }
                $metadata = $messages->getMetadata($source, $domain);

                if (isset($metadata['comments'])) {
                    $output .= $this->formatComments($metadata['comments']);
                }
                if (isset($metadata['flags'])) {
                    $output .= $this->formatComments(implode(',', (array) $metadata['flags']), ',');
                }
                if (isset($metadata['sources'])) {
                    $output .= $this->formatComments(implode(' ', (array) $metadata['sources']), ':');
                }

                $sourceRules = $this->getStandardRules($source);
                $targetRules = $this->getStandardRules($target);
                if (2 == \count($sourceRules) && [] !== $targetRules) {
                    $output .= sprintf('msgid "%s"'."\n", $this->escape($sourceRules[0]));
                    $output .= sprintf('msgid_plural "%s"'."\n", $this->escape($sourceRules[1]));
                    foreach ($targetRules as $i => $targetRule) {
                        $output .= sprintf('msgstr[%d] "%s"'."\n", $i, $this->escape($targetRule));
                    }
                } else {
                    $output .= sprintf('msgid "%s"'."\n", $this->escape($source));
                    $output .= sprintf('msgstr "%s"'."\n", $this->escape($target));
                }
            }

            return $output;
        }

        private function getStandardRules(string $id)
        {
            // Partly copied from TranslatorTrait::trans.
            $parts = [];
            if (preg_match('/^\|++$/', $id)) {
                $parts = explode('|', $id);
            } elseif (preg_match_all('/(?:\|\||[^\|])++/', $id, $matches)) {
                $parts = $matches[0];
            }

            $intervalRegexp = <<<'EOF'
    /^(?P<interval>
        ({\s*
            (\-?\d+(\.\d+)?[\s*,\s*\-?\d+(\.\d+)?]*)
        \s*})

            |

        (?P<left_delimiter>[\[\]])
            \s*
            (?P<left>-Inf|\-?\d+(\.\d+)?)
            \s*,\s*
            (?P<right>\+?Inf|\-?\d+(\.\d+)?)
            \s*
        (?P<right_delimiter>[\[\]])
    )\s*(?P<message>.*?)$/xs
    EOF;

            $standardRules = [];
            foreach ($parts as $part) {
                $part = trim(str_replace('||', '|', $part));

                if (preg_match($intervalRegexp, $part)) {
                    // Explicit rule is not a standard rule.
                    return [];
                } else {
                    $standardRules[] = $part;
                }
            }

            return $standardRules;
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'po';
        }

        private function escape(string $str): string
        {
            return addcslashes($str, "\0..\37\42\134");
        }

        private function formatComments($comments, string $prefix = ''): ?string
        {
            $output = null;

            foreach ((array) $comments as $comment) {
                $output .= sprintf('#%s %s'."\n", $prefix, $comment);
            }

            return $output;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-QtFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * QtFileDumper generates ts files from a message catalogue.
     *
     * @author Benjamin Eberlei <kontakt@beberlei.de>
     */
    class QtFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $dom = new \DOMDocument('1.0', 'utf-8');
            $dom->formatOutput = true;
            $ts = $dom->appendChild($dom->createElement('TS'));
            $context = $ts->appendChild($dom->createElement('context'));
            $context->appendChild($dom->createElement('name', $domain));

            foreach ($messages->all($domain) as $source => $target) {
                $message = $context->appendChild($dom->createElement('message'));
                $metadata = $messages->getMetadata($source, $domain);
                if (isset($metadata['sources'])) {
                    foreach ((array) $metadata['sources'] as $location) {
                        $loc = explode(':', $location, 2);
                        $location = $message->appendChild($dom->createElement('location'));
                        $location->setAttribute('filename', $loc[0]);
                        if (isset($loc[1])) {
                            $location->setAttribute('line', $loc[1]);
                        }
                    }
                }
                $message->appendChild($dom->createElement('source', $source));
                $message->appendChild($dom->createElement('translation', $target));
            }

            return $dom->saveXML();
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'ts';
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-XliffFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * XliffFileDumper generates xliff files from a message catalogue.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    class XliffFileDumper extends FileDumper
    {
        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            $xliffVersion = '1.2';
            if (\array_key_exists('xliff_version', $options)) {
                $xliffVersion = $options['xliff_version'];
            }

            if (\array_key_exists('default_locale', $options)) {
                $defaultLocale = $options['default_locale'];
            } else {
                $defaultLocale = \Locale::getDefault();
            }

            if ('1.2' === $xliffVersion) {
                return $this->dumpXliff1($defaultLocale, $messages, $domain, $options);
            }
            if ('2.0' === $xliffVersion) {
                return $this->dumpXliff2($defaultLocale, $messages, $domain);
            }

            throw new InvalidArgumentException(sprintf('No support implemented for dumping XLIFF version "%s".', $xliffVersion));
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return 'xlf';
        }

        private function dumpXliff1(string $defaultLocale, MessageCatalogue $messages, ?string $domain, array $options = [])
        {
            $toolInfo = ['tool-id' => 'symfony', 'tool-name' => 'Symfony'];
            if (\array_key_exists('tool_info', $options)) {
                $toolInfo = array_merge($toolInfo, $options['tool_info']);
            }

            $dom = new \DOMDocument('1.0', 'utf-8');
            $dom->formatOutput = true;

            $xliff = $dom->appendChild($dom->createElement('xliff'));
            $xliff->setAttribute('version', '1.2');
            $xliff->setAttribute('xmlns', 'urn:oasis:names:tc:xliff:document:1.2');

            $xliffFile = $xliff->appendChild($dom->createElement('file'));
            $xliffFile->setAttribute('source-language', str_replace('_', '-', $defaultLocale));
            $xliffFile->setAttribute('target-language', str_replace('_', '-', $messages->getLocale()));
            $xliffFile->setAttribute('datatype', 'plaintext');
            $xliffFile->setAttribute('original', 'file.ext');

            $xliffHead = $xliffFile->appendChild($dom->createElement('header'));
            $xliffTool = $xliffHead->appendChild($dom->createElement('tool'));
            foreach ($toolInfo as $id => $value) {
                $xliffTool->setAttribute($id, $value);
            }

            $xliffBody = $xliffFile->appendChild($dom->createElement('body'));
            foreach ($messages->all($domain) as $source => $target) {
                $translation = $dom->createElement('trans-unit');

                $translation->setAttribute('id', strtr(substr(base64_encode(hash('sha256', $source, true)), 0, 7), '/+', '._'));
                $translation->setAttribute('resname', $source);

                $s = $translation->appendChild($dom->createElement('source'));
                $s->appendChild($dom->createTextNode($source));

                // Does the target contain characters requiring a CDATA section?
                $text = 1 === preg_match('/[&<>]/', $target) ? $dom->createCDATASection($target) : $dom->createTextNode($target);

                $targetElement = $dom->createElement('target');
                $metadata = $messages->getMetadata($source, $domain);
                if ($this->hasMetadataArrayInfo('target-attributes', $metadata)) {
                    foreach ($metadata['target-attributes'] as $name => $value) {
                        $targetElement->setAttribute($name, $value);
                    }
                }
                $t = $translation->appendChild($targetElement);
                $t->appendChild($text);

                if ($this->hasMetadataArrayInfo('notes', $metadata)) {
                    foreach ($metadata['notes'] as $note) {
                        if (!isset($note['content'])) {
                            continue;
                        }

                        $n = $translation->appendChild($dom->createElement('note'));
                        $n->appendChild($dom->createTextNode($note['content']));

                        if (isset($note['priority'])) {
                            $n->setAttribute('priority', $note['priority']);
                        }

                        if (isset($note['from'])) {
                            $n->setAttribute('from', $note['from']);
                        }
                    }
                }

                $xliffBody->appendChild($translation);
            }

            return $dom->saveXML();
        }

        private function dumpXliff2(string $defaultLocale, MessageCatalogue $messages, ?string $domain)
        {
            $dom = new \DOMDocument('1.0', 'utf-8');
            $dom->formatOutput = true;

            $xliff = $dom->appendChild($dom->createElement('xliff'));
            $xliff->setAttribute('xmlns', 'urn:oasis:names:tc:xliff:document:2.0');
            $xliff->setAttribute('version', '2.0');
            $xliff->setAttribute('srcLang', str_replace('_', '-', $defaultLocale));
            $xliff->setAttribute('trgLang', str_replace('_', '-', $messages->getLocale()));

            $xliffFile = $xliff->appendChild($dom->createElement('file'));
            if (str_ends_with($domain, MessageCatalogue::INTL_DOMAIN_SUFFIX)) {
                $xliffFile->setAttribute('id', substr($domain, 0, -\strlen(MessageCatalogue::INTL_DOMAIN_SUFFIX)).'.'.$messages->getLocale());
            } else {
                $xliffFile->setAttribute('id', $domain.'.'.$messages->getLocale());
            }

            foreach ($messages->all($domain) as $source => $target) {
                $translation = $dom->createElement('unit');
                $translation->setAttribute('id', strtr(substr(base64_encode(hash('sha256', $source, true)), 0, 7), '/+', '._'));

                if (\strlen($source) <= 80) {
                    $translation->setAttribute('name', $source);
                }

                $metadata = $messages->getMetadata($source, $domain);

                // Add notes section
                if ($this->hasMetadataArrayInfo('notes', $metadata)) {
                    $notesElement = $dom->createElement('notes');
                    foreach ($metadata['notes'] as $note) {
                        $n = $dom->createElement('note');
                        $n->appendChild($dom->createTextNode($note['content'] ?? ''));
                        unset($note['content']);

                        foreach ($note as $name => $value) {
                            $n->setAttribute($name, $value);
                        }
                        $notesElement->appendChild($n);
                    }
                    $translation->appendChild($notesElement);
                }

                $segment = $translation->appendChild($dom->createElement('segment'));

                $s = $segment->appendChild($dom->createElement('source'));
                $s->appendChild($dom->createTextNode($source));

                // Does the target contain characters requiring a CDATA section?
                $text = 1 === preg_match('/[&<>]/', $target) ? $dom->createCDATASection($target) : $dom->createTextNode($target);

                $targetElement = $dom->createElement('target');
                if ($this->hasMetadataArrayInfo('target-attributes', $metadata)) {
                    foreach ($metadata['target-attributes'] as $name => $value) {
                        $targetElement->setAttribute($name, $value);
                    }
                }
                $t = $segment->appendChild($targetElement);
                $t->appendChild($text);

                $xliffFile->appendChild($translation);
            }

            return $dom->saveXML();
        }

        private function hasMetadataArrayInfo(string $key, array $metadata = null): bool
        {
            return is_iterable($metadata[$key] ?? null);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Dumper-YamlFileDumper.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Dumper;

    use Symfony\Component\Translation\Exception\LogicException;
    use Symfony\Component\Translation\MessageCatalogue;
    use Symfony\Component\Translation\Util\ArrayConverter;
    use Symfony\Component\Yaml\Yaml;

    /**
     * YamlFileDumper generates yaml files from a message catalogue.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    class YamlFileDumper extends FileDumper
    {
        private $extension;

        public function __construct(string $extension = 'yml')
        {
            $this->extension = $extension;
        }

        /**
         * {@inheritdoc}
         */
        public function formatCatalogue(MessageCatalogue $messages, $domain, array $options = [])
        {
            if (!class_exists(Yaml::class)) {
                throw new LogicException('Dumping translations in the YAML format requires the Symfony Yaml component.');
            }

            $data = $messages->all($domain);

            if (isset($options['as_tree']) && $options['as_tree']) {
                $data = ArrayConverter::expandToTree($data);
            }

            if (isset($options['inline']) && ($inline = (int) $options['inline']) > 0) {
                return Yaml::dump($data, $inline);
            }

            return Yaml::dump($data);
        }

        /**
         * {@inheritdoc}
         */
        protected function getExtension()
        {
            return $this->extension;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Extractor-AbstractFileExtractor.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Extractor;

    use Symfony\Component\Translation\Exception\InvalidArgumentException;

    /**
     * Base class used by classes that extract translation messages from files.
     *
     * @author Marcos D. SÃ¡nchez <marcosdsanchez@gmail.com>
     */
    abstract class AbstractFileExtractor
    {
        /**
         * @param string|iterable $resource Files, a file or a directory
         *
         * @return iterable
         */
        protected function extractFiles($resource)
        {
            if (is_iterable($resource)) {
                $files = [];
                foreach ($resource as $file) {
                    if ($this->canBeExtracted($file)) {
                        $files[] = $this->toSplFileInfo($file);
                    }
                }
            } elseif (is_file($resource)) {
                $files = $this->canBeExtracted($resource) ? [$this->toSplFileInfo($resource)] : [];
            } else {
                $files = $this->extractFromDirectory($resource);
            }

            return $files;
        }

        private function toSplFileInfo(string $file): \SplFileInfo
        {
            return new \SplFileInfo($file);
        }

        /**
         * @param string $file
         *
         * @return bool
         *
         * @throws InvalidArgumentException
         */
        protected function isFile($file)
        {
            if (!is_file($file)) {
                throw new InvalidArgumentException(sprintf('The "%s" file does not exist.', $file));
            }

            return true;
        }

        /**
         * @param string $file
         *
         * @return bool
         */
        abstract protected function canBeExtracted($file);

        /**
         * @param string|array $resource Files, a file or a directory
         *
         * @return iterable files to be extracted
         */
        abstract protected function extractFromDirectory($resource);
    }
  uploads-Carbon-vendor-symfony-translation-Extractor-ChainExtractor.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Extractor;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * ChainExtractor extracts translation messages from template files.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    class ChainExtractor implements ExtractorInterface
    {
        /**
         * The extractors.
         *
         * @var ExtractorInterface[]
         */
        private $extractors = [];

        /**
         * Adds a loader to the translation extractor.
         *
         * @param string $format The format of the loader
         */
        public function addExtractor($format, ExtractorInterface $extractor)
        {
            $this->extractors[$format] = $extractor;
        }

        /**
         * {@inheritdoc}
         */
        public function setPrefix($prefix)
        {
            foreach ($this->extractors as $extractor) {
                $extractor->setPrefix($prefix);
            }
        }

        /**
         * {@inheritdoc}
         */
        public function extract($directory, MessageCatalogue $catalogue)
        {
            foreach ($this->extractors as $extractor) {
                $extractor->extract($directory, $catalogue);
            }
        }
    }
  uploads-Carbon-vendor-symfony-translation-Extractor-ExtractorInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Extractor;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * Extracts translation messages from a directory or files to the catalogue.
     * New found messages are injected to the catalogue using the prefix.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    interface ExtractorInterface
    {
        /**
         * Extracts translation messages from files, a file or a directory to the catalogue.
         *
         * @param string|iterable<string> $resource Files, a file or a directory
         */
        public function extract($resource, MessageCatalogue $catalogue);

        /**
         * Sets the prefix that should be used for new found messages.
         *
         * @param string $prefix The prefix
         */
        public function setPrefix($prefix);
    }
  uploads-Carbon-vendor-symfony-translation-Extractor-PhpExtractor.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Extractor;

    use Symfony\Component\Finder\Finder;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * PhpExtractor extracts translation messages from a PHP template.
     *
     * @author Michel Salib <michelsalib@hotmail.com>
     */
    class PhpExtractor extends AbstractFileExtractor implements ExtractorInterface
    {
        public const MESSAGE_TOKEN = 300;
        public const METHOD_ARGUMENTS_TOKEN = 1000;
        public const DOMAIN_TOKEN = 1001;

        /**
         * Prefix for new found message.
         *
         * @var string
         */
        private $prefix = '';

        /**
         * The sequence that captures translation messages.
         *
         * @var array
         */
        protected $sequences = [
            [
                '->',
                'trans',
                '(',
                self::MESSAGE_TOKEN,
                ',',
                self::METHOD_ARGUMENTS_TOKEN,
                ',',
                self::DOMAIN_TOKEN,
            ],
            [
                '->',
                'transChoice',
                '(',
                self::MESSAGE_TOKEN,
                ',',
                self::METHOD_ARGUMENTS_TOKEN,
                ',',
                self::METHOD_ARGUMENTS_TOKEN,
                ',',
                self::DOMAIN_TOKEN,
            ],
            [
                '->',
                'trans',
                '(',
                self::MESSAGE_TOKEN,
            ],
            [
                '->',
                'transChoice',
                '(',
                self::MESSAGE_TOKEN,
            ],
        ];

        /**
         * {@inheritdoc}
         */
        public function extract($resource, MessageCatalogue $catalog)
        {
            $files = $this->extractFiles($resource);
            foreach ($files as $file) {
                $this->parseTokens(token_get_all(file_get_contents($file)), $catalog, $file);

                gc_mem_caches();
            }
        }

        /**
         * {@inheritdoc}
         */
        public function setPrefix($prefix)
        {
            $this->prefix = $prefix;
        }

        /**
         * Normalizes a token.
         *
         * @param mixed $token
         *
         * @return string|null
         */
        protected function normalizeToken($token)
        {
            if (isset($token[1]) && 'b"' !== $token) {
                return $token[1];
            }

            return $token;
        }

        /**
         * Seeks to a non-whitespace token.
         */
        private function seekToNextRelevantToken(\Iterator $tokenIterator)
        {
            for (; $tokenIterator->valid(); $tokenIterator->next()) {
                $t = $tokenIterator->current();
                if (\T_WHITESPACE !== $t[0]) {
                    break;
                }
            }
        }

        private function skipMethodArgument(\Iterator $tokenIterator)
        {
            $openBraces = 0;

            for (; $tokenIterator->valid(); $tokenIterator->next()) {
                $t = $tokenIterator->current();

                if ('[' === $t[0] || '(' === $t[0]) {
                    ++$openBraces;
                }

                if (']' === $t[0] || ')' === $t[0]) {
                    --$openBraces;
                }

                if ((0 === $openBraces && ',' === $t[0]) || (-1 === $openBraces && ')' === $t[0])) {
                    break;
                }
            }
        }

        /**
         * Extracts the message from the iterator while the tokens
         * match allowed message tokens.
         */
        private function getValue(\Iterator $tokenIterator)
        {
            $message = '';
            $docToken = '';
            $docPart = '';

            for (; $tokenIterator->valid(); $tokenIterator->next()) {
                $t = $tokenIterator->current();
                if ('.' === $t) {
                    // Concatenate with next token
                    continue;
                }
                if (!isset($t[1])) {
                    break;
                }

                switch ($t[0]) {
                    case \T_START_HEREDOC:
                        $docToken = $t[1];
                        break;
                    case \T_ENCAPSED_AND_WHITESPACE:
                    case \T_CONSTANT_ENCAPSED_STRING:
                        if ('' === $docToken) {
                            $message .= PhpStringTokenParser::parse($t[1]);
                        } else {
                            $docPart = $t[1];
                        }
                        break;
                    case \T_END_HEREDOC:
                        if ($indentation = strspn($t[1], ' ')) {
                            $docPartWithLineBreaks = $docPart;
                            $docPart = '';

                            foreach (preg_split('~(\r\n|\n|\r)~', $docPartWithLineBreaks, -1, \PREG_SPLIT_DELIM_CAPTURE) as $str) {
                                if (\in_array($str, ["\r\n", "\n", "\r"], true)) {
                                    $docPart .= $str;
                                } else {
                                    $docPart .= substr($str, $indentation);
                                }
                            }
                        }

                        $message .= PhpStringTokenParser::parseDocString($docToken, $docPart);
                        $docToken = '';
                        $docPart = '';
                        break;
                    case \T_WHITESPACE:
                        break;
                    default:
                        break 2;
                }
            }

            return $message;
        }

        /**
         * Extracts trans message from PHP tokens.
         *
         * @param array  $tokens
         * @param string $filename
         */
        protected function parseTokens($tokens, MessageCatalogue $catalog/*, string $filename*/)
        {
            if (\func_num_args() < 3 && __CLASS__ !== static::class && __CLASS__ !== (new \ReflectionMethod($this, __FUNCTION__))->getDeclaringClass()->getName() && !$this instanceof \PHPUnit\Framework\MockObject\MockObject && !$this instanceof \Prophecy\Prophecy\ProphecySubjectInterface && !$this instanceof \Mockery\MockInterface) {
                @trigger_error(sprintf('The "%s()" method will have a new "string $filename" argument in version 5.0, not defining it is deprecated since Symfony 4.3.', __METHOD__), \E_USER_DEPRECATED);
            }
            $filename = 2 < \func_num_args() ? func_get_arg(2) : '';

            $tokenIterator = new \ArrayIterator($tokens);

            for ($key = 0; $key < $tokenIterator->count(); ++$key) {
                foreach ($this->sequences as $sequence) {
                    $message = '';
                    $domain = 'messages';
                    $tokenIterator->seek($key);

                    foreach ($sequence as $sequenceKey => $item) {
                        $this->seekToNextRelevantToken($tokenIterator);

                        if ($this->normalizeToken($tokenIterator->current()) === $item) {
                            $tokenIterator->next();
                            continue;
                        } elseif (self::MESSAGE_TOKEN === $item) {
                            $message = $this->getValue($tokenIterator);

                            if (\count($sequence) === ($sequenceKey + 1)) {
                                break;
                            }
                        } elseif (self::METHOD_ARGUMENTS_TOKEN === $item) {
                            $this->skipMethodArgument($tokenIterator);
                        } elseif (self::DOMAIN_TOKEN === $item) {
                            $domainToken = $this->getValue($tokenIterator);
                            if ('' !== $domainToken) {
                                $domain = $domainToken;
                            }

                            break;
                        } else {
                            break;
                        }
                    }

                    if ($message) {
                        $catalog->set($message, $this->prefix.$message, $domain);
                        $metadata = $catalog->getMetadata($message, $domain) ?? [];
                        $normalizedFilename = preg_replace('{[\\\\/]+}', '/', $filename);
                        $metadata['sources'][] = $normalizedFilename.':'.$tokens[$key][2];
                        $catalog->setMetadata($message, $metadata, $domain);
                        break;
                    }
                }
            }
        }

        /**
         * @param string $file
         *
         * @return bool
         *
         * @throws \InvalidArgumentException
         */
        protected function canBeExtracted($file)
        {
            return $this->isFile($file) && 'php' === pathinfo($file, \PATHINFO_EXTENSION);
        }

        /**
         * {@inheritdoc}
         */
        protected function extractFromDirectory($directory)
        {
            $finder = new Finder();

            return $finder->files()->name('*.php')->in($directory);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Extractor-PhpStringTokenParser.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Extractor;

    /*
     * The following is derived from code at http://github.com/nikic/PHP-Parser
     *
     * Copyright (c) 2011 by Nikita Popov
     *
     * Some rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *     * Redistributions of source code must retain the above copyright
     *       notice, this list of conditions and the following disclaimer.
     *
     *     * Redistributions in binary form must reproduce the above
     *       copyright notice, this list of conditions and the following
     *       disclaimer in the documentation and/or other materials provided
     *       with the distribution.
     *
     *     * The names of the contributors may not be used to endorse or
     *       promote products derived from this software without specific
     *       prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */

    class PhpStringTokenParser
    {
        protected static $replacements = [
            '\\' => '\\',
            '$' => '$',
            'n' => "\n",
            'r' => "\r",
            't' => "\t",
            'f' => "\f",
            'v' => "\v",
            'e' => "\x1B",
        ];

        /**
         * Parses a string token.
         *
         * @param string $str String token content
         *
         * @return string The parsed string
         */
        public static function parse($str)
        {
            $bLength = 0;
            if ('b' === $str[0]) {
                $bLength = 1;
            }

            if ('\'' === $str[$bLength]) {
                return str_replace(
                    ['\\\\', '\\\''],
                    ['\\', '\''],
                    substr($str, $bLength + 1, -1)
                );
            } else {
                return self::parseEscapeSequences(substr($str, $bLength + 1, -1), '"');
            }
        }

        /**
         * Parses escape sequences in strings (all string types apart from single quoted).
         *
         * @param string      $str   String without quotes
         * @param string|null $quote Quote type
         *
         * @return string String with escape sequences parsed
         */
        public static function parseEscapeSequences($str, $quote)
        {
            if (null !== $quote) {
                $str = str_replace('\\'.$quote, $quote, $str);
            }

            return preg_replace_callback(
                '~\\\\([\\\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3})~',
                [__CLASS__, 'parseCallback'],
                $str
            );
        }

        private static function parseCallback(array $matches): string
        {
            $str = $matches[1];

            if (isset(self::$replacements[$str])) {
                return self::$replacements[$str];
            } elseif ('x' === $str[0] || 'X' === $str[0]) {
                return \chr(hexdec($str));
            } else {
                return \chr(octdec($str));
            }
        }

        /**
         * Parses a constant doc string.
         *
         * @param string $startToken Doc string start token content (<<<SMTHG)
         * @param string $str        String token content
         *
         * @return string Parsed string
         */
        public static function parseDocString($startToken, $str)
        {
            // strip last newline (thanks tokenizer for sticking it into the string!)
            $str = preg_replace('~(\r\n|\n|\r)$~', '', $str);

            // nowdoc string
            if (str_contains($startToken, '\'')) {
                return $str;
            }

            return self::parseEscapeSequences($str, null);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Formatter-ChoiceMessageFormatterInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Formatter;

    /**
     * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>
     *
     * @deprecated since Symfony 4.2, use MessageFormatterInterface::format() with a %count% parameter instead
     */
    interface ChoiceMessageFormatterInterface
    {
        /**
         * Formats a localized message pattern with given arguments.
         *
         * @param string $message    The message (may also be an object that can be cast to string)
         * @param int    $number     The number to use to find the indice of the message
         * @param string $locale     The message locale
         * @param array  $parameters An array of parameters for the message
         *
         * @return string
         */
        public function choiceFormat($message, $number, $locale, array $parameters = []);
    }
  uploads-Carbon-vendor-symfony-translation-Formatter-IntlFormatter.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Formatter;

    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Component\Translation\Exception\LogicException;

    /**
     * @author Guilherme Blanco <guilhermeblanco@hotmail.com>
     * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>
     */
    class IntlFormatter implements IntlFormatterInterface
    {
        private $hasMessageFormatter;
        private $cache = [];

        /**
         * {@inheritdoc}
         */
        public function formatIntl(string $message, string $locale, array $parameters = []): string
        {
            // MessageFormatter constructor throws an exception if the message is empty
            if ('' === $message) {
                return '';
            }

            if (!$formatter = $this->cache[$locale][$message] ?? null) {
                if (!($this->hasMessageFormatter ?? $this->hasMessageFormatter = class_exists(\MessageFormatter::class))) {
                    throw new LogicException('Cannot parse message translation: please install the "intl" PHP extension or the "symfony/polyfill-intl-messageformatter" package.');
                }
                try {
                    $this->cache[$locale][$message] = $formatter = new \MessageFormatter($locale, $message);
                } catch (\IntlException $e) {
                    throw new InvalidArgumentException(sprintf('Invalid message format (error #%d): ', intl_get_error_code()).intl_get_error_message(), 0, $e);
                }
            }

            foreach ($parameters as $key => $value) {
                if (\in_array($key[0] ?? null, ['%', '{'], true)) {
                    unset($parameters[$key]);
                    $parameters[trim($key, '%{ }')] = $value;
                }
            }

            if (false === $message = $formatter->format($parameters)) {
                throw new InvalidArgumentException(sprintf('Unable to format message (error #%s): ', $formatter->getErrorCode()).$formatter->getErrorMessage());
            }

            return $message;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Formatter-IntlFormatterInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Formatter;

    /**
     * Formats ICU message patterns.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface IntlFormatterInterface
    {
        /**
         * Formats a localized message using rules defined by ICU MessageFormat.
         *
         * @see http://icu-project.org/apiref/icu4c/classMessageFormat.html#details
         */
        public function formatIntl(string $message, string $locale, array $parameters = []): string;
    }
  uploads-Carbon-vendor-symfony-translation-Formatter-MessageFormatter.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Formatter;

    use Symfony\Component\Translation\IdentityTranslator;
    use Symfony\Component\Translation\MessageSelector;
    use Symfony\Component\Translation\TranslatorInterface as LegacyTranslatorInterface;
    use Symfony\Contracts\Translation\TranslatorInterface;

    // Help opcache.preload discover always-needed symbols
    class_exists(IntlFormatter::class);

    /**
     * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>
     */
    class MessageFormatter implements MessageFormatterInterface, IntlFormatterInterface, ChoiceMessageFormatterInterface
    {
        private $translator;
        private $intlFormatter;

        /**
         * @param TranslatorInterface|null $translator An identity translator to use as selector for pluralization
         */
        public function __construct($translator = null, IntlFormatterInterface $intlFormatter = null)
        {
            if ($translator instanceof MessageSelector) {
                $translator = new IdentityTranslator($translator);
            } elseif (null !== $translator && !$translator instanceof TranslatorInterface && !$translator instanceof LegacyTranslatorInterface) {
                throw new \TypeError(sprintf('Argument 1 passed to "%s()" must be an instance of "%s", "%s" given.', __METHOD__, TranslatorInterface::class, \is_object($translator) ? \get_class($translator) : \gettype($translator)));
            }

            $this->translator = $translator ?? new IdentityTranslator();
            $this->intlFormatter = $intlFormatter ?? new IntlFormatter();
        }

        /**
         * {@inheritdoc}
         */
        public function format($message, $locale, array $parameters = [])
        {
            if ($this->translator instanceof TranslatorInterface) {
                return $this->translator->trans($message, $parameters, null, $locale);
            }

            return strtr($message, $parameters);
        }

        /**
         * {@inheritdoc}
         */
        public function formatIntl(string $message, string $locale, array $parameters = []): string
        {
            return $this->intlFormatter->formatIntl($message, $locale, $parameters);
        }

        /**
         * {@inheritdoc}
         *
         * @deprecated since Symfony 4.2, use format() with a %count% parameter instead
         */
        public function choiceFormat($message, $number, $locale, array $parameters = [])
        {
            @trigger_error(sprintf('The "%s()" method is deprecated since Symfony 4.2, use the format() one instead with a %%count%% parameter.', __METHOD__), \E_USER_DEPRECATED);

            $parameters = ['%count%' => $number] + $parameters;

            if ($this->translator instanceof TranslatorInterface) {
                return $this->format($message, $locale, $parameters);
            }

            return $this->format($this->translator->transChoice($message, $number, [], null, $locale), $locale, $parameters);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Formatter-MessageFormatterInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Formatter;

    /**
     * @author Guilherme Blanco <guilhermeblanco@hotmail.com>
     * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>
     */
    interface MessageFormatterInterface
    {
        /**
         * Formats a localized message pattern with given arguments.
         *
         * @param string $message    The message (may also be an object that can be cast to string)
         * @param string $locale     The message locale
         * @param array  $parameters An array of parameters for the message
         *
         * @return string
         */
        public function format($message, $locale, array $parameters = []);
    }
  uploads-Carbon-vendor-symfony-translation-IdentityTranslator.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation;

    use Symfony\Component\Translation\TranslatorInterface as LegacyTranslatorInterface;
    use Symfony\Contracts\Translation\TranslatorInterface;
    use Symfony\Contracts\Translation\TranslatorTrait;

    /**
     * IdentityTranslator does not translate anything.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class IdentityTranslator implements LegacyTranslatorInterface, TranslatorInterface
    {
        use TranslatorTrait {
            trans as private doTrans;
            setLocale as private doSetLocale;
        }

        private $selector;

        public function __construct(MessageSelector $selector = null)
        {
            $this->selector = $selector;

            if (__CLASS__ !== static::class) {
                @trigger_error(sprintf('Calling "%s()" is deprecated since Symfony 4.2.', __METHOD__), \E_USER_DEPRECATED);
            }
        }

        /**
         * {@inheritdoc}
         */
        public function trans($id, array $parameters = [], $domain = null, $locale = null)
        {
            return $this->doTrans($id, $parameters, $domain, $locale);
        }

        /**
         * {@inheritdoc}
         */
        public function setLocale($locale)
        {
            $this->doSetLocale($locale);
        }

        /**
         * {@inheritdoc}
         *
         * @deprecated since Symfony 4.2, use the trans() method instead with a %count% parameter
         */
        public function transChoice($id, $number, array $parameters = [], $domain = null, $locale = null)
        {
            @trigger_error(sprintf('The "%s()" method is deprecated since Symfony 4.2, use the trans() one instead with a "%%count%%" parameter.', __METHOD__), \E_USER_DEPRECATED);

            if ($this->selector) {
                return strtr($this->selector->choose((string) $id, $number, $locale ?: $this->getLocale()), $parameters);
            }

            return $this->trans($id, ['%count%' => $number] + $parameters, $domain, $locale);
        }

        private function getPluralizationRule(float $number, string $locale): int
        {
            return PluralizationRules::get($number, $locale, false);
        }
    }
  uploads-Carbon-vendor-symfony-translation-LICENSE: |
    Copyright (c) 2004-2021 Fabien Potencier

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is furnished
    to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
  uploads-Carbon-vendor-symfony-translation-Loader-ArrayLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * ArrayLoader loads translations from a PHP array.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class ArrayLoader implements LoaderInterface
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
            $resource = $this->flatten($resource);
            $catalogue = new MessageCatalogue($locale);
            $catalogue->add($resource, $domain);

            return $catalogue;
        }

        /**
         * Flattens an nested array of translations.
         *
         * The scheme used is:
         *   'key' => ['key2' => ['key3' => 'value']]
         * Becomes:
         *   'key.key2.key3' => 'value'
         */
        private function flatten(array $messages): array
        {
            $result = [];
            foreach ($messages as $key => $value) {
                if (\is_array($value)) {
                    foreach ($this->flatten($value) as $k => $v) {
                        $result[$key.'.'.$k] = $v;
                    }
                } else {
                    $result[$key] = $value;
                }
            }

            return $result;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-CsvFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Translation\Exception\NotFoundResourceException;

    /**
     * CsvFileLoader loads translations from CSV files.
     *
     * @author SaÅ¡a StamenkoviÄ <umpirsky@gmail.com>
     */
    class CsvFileLoader extends FileLoader
    {
        private $delimiter = ';';
        private $enclosure = '"';
        private $escape = '\\';

        /**
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            $messages = [];

            try {
                $file = new \SplFileObject($resource, 'rb');
            } catch (\RuntimeException $e) {
                throw new NotFoundResourceException(sprintf('Error opening file "%s".', $resource), 0, $e);
            }

            $file->setFlags(\SplFileObject::READ_CSV | \SplFileObject::SKIP_EMPTY);
            $file->setCsvControl($this->delimiter, $this->enclosure, $this->escape);

            foreach ($file as $data) {
                if (false === $data) {
                    continue;
                }

                if ('#' !== substr($data[0], 0, 1) && isset($data[1]) && 2 === \count($data)) {
                    $messages[$data[0]] = $data[1];
                }
            }

            return $messages;
        }

        /**
         * Sets the delimiter, enclosure, and escape character for CSV.
         *
         * @param string $delimiter Delimiter character
         * @param string $enclosure Enclosure character
         * @param string $escape    Escape character
         */
        public function setCsvControl($delimiter = ';', $enclosure = '"', $escape = '\\')
        {
            $this->delimiter = $delimiter;
            $this->enclosure = $enclosure;
            $this->escape = $escape;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-FileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Config\Resource\FileResource;
    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;

    /**
     * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>
     */
    abstract class FileLoader extends ArrayLoader
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
            if (!stream_is_local($resource)) {
                throw new InvalidResourceException(sprintf('This is not a local file "%s".', $resource));
            }

            if (!file_exists($resource)) {
                throw new NotFoundResourceException(sprintf('File "%s" not found.', $resource));
            }

            $messages = $this->loadResource($resource);

            // empty resource
            if (null === $messages) {
                $messages = [];
            }

            // not an array
            if (!\is_array($messages)) {
                throw new InvalidResourceException(sprintf('Unable to load file "%s".', $resource));
            }

            $catalogue = parent::load($messages, $locale, $domain);

            if (class_exists(FileResource::class)) {
                $catalogue->addResource(new FileResource($resource));
            }

            return $catalogue;
        }

        /**
         * @param string $resource
         *
         * @return array
         *
         * @throws InvalidResourceException if stream content has an invalid format
         */
        abstract protected function loadResource($resource);
    }
  uploads-Carbon-vendor-symfony-translation-Loader-IcuDatFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Config\Resource\FileResource;
    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * IcuResFileLoader loads translations from a resource bundle.
     *
     * @author stealth35
     */
    class IcuDatFileLoader extends IcuResFileLoader
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
            if (!stream_is_local($resource.'.dat')) {
                throw new InvalidResourceException(sprintf('This is not a local file "%s".', $resource));
            }

            if (!file_exists($resource.'.dat')) {
                throw new NotFoundResourceException(sprintf('File "%s" not found.', $resource));
            }

            try {
                $rb = new \ResourceBundle($locale, $resource);
            } catch (\Exception $e) {
                $rb = null;
            }

            if (!$rb) {
                throw new InvalidResourceException(sprintf('Cannot load resource "%s".', $resource));
            } elseif (intl_is_failure($rb->getErrorCode())) {
                throw new InvalidResourceException($rb->getErrorMessage(), $rb->getErrorCode());
            }

            $messages = $this->flatten($rb);
            $catalogue = new MessageCatalogue($locale);
            $catalogue->add($messages, $domain);

            if (class_exists(FileResource::class)) {
                $catalogue->addResource(new FileResource($resource.'.dat'));
            }

            return $catalogue;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-IcuResFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Config\Resource\DirectoryResource;
    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * IcuResFileLoader loads translations from a resource bundle.
     *
     * @author stealth35
     */
    class IcuResFileLoader implements LoaderInterface
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
            if (!stream_is_local($resource)) {
                throw new InvalidResourceException(sprintf('This is not a local file "%s".', $resource));
            }

            if (!is_dir($resource)) {
                throw new NotFoundResourceException(sprintf('File "%s" not found.', $resource));
            }

            try {
                $rb = new \ResourceBundle($locale, $resource);
            } catch (\Exception $e) {
                $rb = null;
            }

            if (!$rb) {
                throw new InvalidResourceException(sprintf('Cannot load resource "%s".', $resource));
            } elseif (intl_is_failure($rb->getErrorCode())) {
                throw new InvalidResourceException($rb->getErrorMessage(), $rb->getErrorCode());
            }

            $messages = $this->flatten($rb);
            $catalogue = new MessageCatalogue($locale);
            $catalogue->add($messages, $domain);

            if (class_exists(DirectoryResource::class)) {
                $catalogue->addResource(new DirectoryResource($resource));
            }

            return $catalogue;
        }

        /**
         * Flattens an ResourceBundle.
         *
         * The scheme used is:
         *   key { key2 { key3 { "value" } } }
         * Becomes:
         *   'key.key2.key3' => 'value'
         *
         * This function takes an array by reference and will modify it
         *
         * @param \ResourceBundle $rb       The ResourceBundle that will be flattened
         * @param array           $messages Used internally for recursive calls
         * @param string          $path     Current path being parsed, used internally for recursive calls
         *
         * @return array the flattened ResourceBundle
         */
        protected function flatten(\ResourceBundle $rb, array &$messages = [], $path = null)
        {
            foreach ($rb as $key => $value) {
                $nodePath = $path ? $path.'.'.$key : $key;
                if ($value instanceof \ResourceBundle) {
                    $this->flatten($value, $messages, $nodePath);
                } else {
                    $messages[$nodePath] = $value;
                }
            }

            return $messages;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-IniFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    /**
     * IniFileLoader loads translations from an ini file.
     *
     * @author stealth35
     */
    class IniFileLoader extends FileLoader
    {
        /**
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            return parse_ini_file($resource, true);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-JsonFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Translation\Exception\InvalidResourceException;

    /**
     * JsonFileLoader loads translations from an json file.
     *
     * @author singles
     */
    class JsonFileLoader extends FileLoader
    {
        /**
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            $messages = [];
            if ($data = file_get_contents($resource)) {
                $messages = json_decode($data, true);

                if (0 < $errorCode = json_last_error()) {
                    throw new InvalidResourceException('Error parsing JSON: '.$this->getJSONErrorMessage($errorCode));
                }
            }

            return $messages;
        }

        /**
         * Translates JSON_ERROR_* constant into meaningful message.
         */
        private function getJSONErrorMessage(int $errorCode): string
        {
            switch ($errorCode) {
                case \JSON_ERROR_DEPTH:
                    return 'Maximum stack depth exceeded';
                case \JSON_ERROR_STATE_MISMATCH:
                    return 'Underflow or the modes mismatch';
                case \JSON_ERROR_CTRL_CHAR:
                    return 'Unexpected control character found';
                case \JSON_ERROR_SYNTAX:
                    return 'Syntax error, malformed JSON';
                case \JSON_ERROR_UTF8:
                    return 'Malformed UTF-8 characters, possibly incorrectly encoded';
                default:
                    return 'Unknown error';
            }
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-LoaderInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * LoaderInterface is the interface implemented by all translation loaders.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface LoaderInterface
    {
        /**
         * Loads a locale.
         *
         * @param mixed  $resource A resource
         * @param string $locale   A locale
         * @param string $domain   The domain
         *
         * @return MessageCatalogue A MessageCatalogue instance
         *
         * @throws NotFoundResourceException when the resource cannot be found
         * @throws InvalidResourceException  when the resource cannot be loaded
         */
        public function load($resource, $locale, $domain = 'messages');
    }
  uploads-Carbon-vendor-symfony-translation-Loader-MoFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Translation\Exception\InvalidResourceException;

    /**
     * @copyright Copyright (c) 2010, Union of RAD http://union-of-rad.org (http://lithify.me/)
     */
    class MoFileLoader extends FileLoader
    {
        /**
         * Magic used for validating the format of an MO file as well as
         * detecting if the machine used to create that file was little endian.
         */
        public const MO_LITTLE_ENDIAN_MAGIC = 0x950412de;

        /**
         * Magic used for validating the format of an MO file as well as
         * detecting if the machine used to create that file was big endian.
         */
        public const MO_BIG_ENDIAN_MAGIC = 0xde120495;

        /**
         * The size of the header of an MO file in bytes.
         */
        public const MO_HEADER_SIZE = 28;

        /**
         * Parses machine object (MO) format, independent of the machine's endian it
         * was created on. Both 32bit and 64bit systems are supported.
         *
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            $stream = fopen($resource, 'r');

            $stat = fstat($stream);

            if ($stat['size'] < self::MO_HEADER_SIZE) {
                throw new InvalidResourceException('MO stream content has an invalid format.');
            }
            $magic = unpack('V1', fread($stream, 4));
            $magic = hexdec(substr(dechex(current($magic)), -8));

            if (self::MO_LITTLE_ENDIAN_MAGIC == $magic) {
                $isBigEndian = false;
            } elseif (self::MO_BIG_ENDIAN_MAGIC == $magic) {
                $isBigEndian = true;
            } else {
                throw new InvalidResourceException('MO stream content has an invalid format.');
            }

            // formatRevision
            $this->readLong($stream, $isBigEndian);
            $count = $this->readLong($stream, $isBigEndian);
            $offsetId = $this->readLong($stream, $isBigEndian);
            $offsetTranslated = $this->readLong($stream, $isBigEndian);
            // sizeHashes
            $this->readLong($stream, $isBigEndian);
            // offsetHashes
            $this->readLong($stream, $isBigEndian);

            $messages = [];

            for ($i = 0; $i < $count; ++$i) {
                $pluralId = null;
                $translated = null;

                fseek($stream, $offsetId + $i * 8);

                $length = $this->readLong($stream, $isBigEndian);
                $offset = $this->readLong($stream, $isBigEndian);

                if ($length < 1) {
                    continue;
                }

                fseek($stream, $offset);
                $singularId = fread($stream, $length);

                if (str_contains($singularId, "\000")) {
                    [$singularId, $pluralId] = explode("\000", $singularId);
                }

                fseek($stream, $offsetTranslated + $i * 8);
                $length = $this->readLong($stream, $isBigEndian);
                $offset = $this->readLong($stream, $isBigEndian);

                if ($length < 1) {
                    continue;
                }

                fseek($stream, $offset);
                $translated = fread($stream, $length);

                if (str_contains($translated, "\000")) {
                    $translated = explode("\000", $translated);
                }

                $ids = ['singular' => $singularId, 'plural' => $pluralId];
                $item = compact('ids', 'translated');

                if (!empty($item['ids']['singular'])) {
                    $id = $item['ids']['singular'];
                    if (isset($item['ids']['plural'])) {
                        $id .= '|'.$item['ids']['plural'];
                    }
                    $messages[$id] = stripcslashes(implode('|', (array) $item['translated']));
                }
            }

            fclose($stream);

            return array_filter($messages);
        }

        /**
         * Reads an unsigned long from stream respecting endianness.
         *
         * @param resource $stream
         */
        private function readLong($stream, bool $isBigEndian): int
        {
            $result = unpack($isBigEndian ? 'N1' : 'V1', fread($stream, 4));
            $result = current($result);

            return (int) substr($result, -8);
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-PhpFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    /**
     * PhpFileLoader loads translations from PHP files returning an array of translations.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class PhpFileLoader extends FileLoader
    {
        private static $cache = [];

        /**
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            if ([] === self::$cache && \function_exists('opcache_invalidate') && filter_var(ini_get('opcache.enable'), \FILTER_VALIDATE_BOOLEAN) && (!\in_array(\PHP_SAPI, ['cli', 'phpdbg'], true) || filter_var(ini_get('opcache.enable_cli'), \FILTER_VALIDATE_BOOLEAN))) {
                self::$cache = null;
            }

            if (null === self::$cache) {
                return require $resource;
            }

            if (isset(self::$cache[$resource])) {
                return self::$cache[$resource];
            }

            return self::$cache[$resource] = require $resource;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-PoFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    /**
     * @copyright Copyright (c) 2010, Union of RAD https://github.com/UnionOfRAD/lithium
     * @copyright Copyright (c) 2012, Clemens Tolboom
     */
    class PoFileLoader extends FileLoader
    {
        /**
         * Parses portable object (PO) format.
         *
         * From https://www.gnu.org/software/gettext/manual/gettext.html#PO-Files
         * we should be able to parse files having:
         *
         * white-space
         * #  translator-comments
         * #. extracted-comments
         * #: reference...
         * #, flag...
         * #| msgid previous-untranslated-string
         * msgid untranslated-string
         * msgstr translated-string
         *
         * extra or different lines are:
         *
         * #| msgctxt previous-context
         * #| msgid previous-untranslated-string
         * msgctxt context
         *
         * #| msgid previous-untranslated-string-singular
         * #| msgid_plural previous-untranslated-string-plural
         * msgid untranslated-string-singular
         * msgid_plural untranslated-string-plural
         * msgstr[0] translated-string-case-0
         * ...
         * msgstr[N] translated-string-case-n
         *
         * The definition states:
         * - white-space and comments are optional.
         * - msgid "" that an empty singleline defines a header.
         *
         * This parser sacrifices some features of the reference implementation the
         * differences to that implementation are as follows.
         * - No support for comments spanning multiple lines.
         * - Translator and extracted comments are treated as being the same type.
         * - Message IDs are allowed to have other encodings as just US-ASCII.
         *
         * Items with an empty id are ignored.
         *
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            $stream = fopen($resource, 'r');

            $defaults = [
                'ids' => [],
                'translated' => null,
            ];

            $messages = [];
            $item = $defaults;
            $flags = [];

            while ($line = fgets($stream)) {
                $line = trim($line);

                if ('' === $line) {
                    // Whitespace indicated current item is done
                    if (!\in_array('fuzzy', $flags)) {
                        $this->addMessage($messages, $item);
                    }
                    $item = $defaults;
                    $flags = [];
                } elseif ('#,' === substr($line, 0, 2)) {
                    $flags = array_map('trim', explode(',', substr($line, 2)));
                } elseif ('msgid "' === substr($line, 0, 7)) {
                    // We start a new msg so save previous
                    // TODO: this fails when comments or contexts are added
                    $this->addMessage($messages, $item);
                    $item = $defaults;
                    $item['ids']['singular'] = substr($line, 7, -1);
                } elseif ('msgstr "' === substr($line, 0, 8)) {
                    $item['translated'] = substr($line, 8, -1);
                } elseif ('"' === $line[0]) {
                    $continues = isset($item['translated']) ? 'translated' : 'ids';

                    if (\is_array($item[$continues])) {
                        end($item[$continues]);
                        $item[$continues][key($item[$continues])] .= substr($line, 1, -1);
                    } else {
                        $item[$continues] .= substr($line, 1, -1);
                    }
                } elseif ('msgid_plural "' === substr($line, 0, 14)) {
                    $item['ids']['plural'] = substr($line, 14, -1);
                } elseif ('msgstr[' === substr($line, 0, 7)) {
                    $size = strpos($line, ']');
                    $item['translated'][(int) substr($line, 7, 1)] = substr($line, $size + 3, -1);
                }
            }
            // save last item
            if (!\in_array('fuzzy', $flags)) {
                $this->addMessage($messages, $item);
            }
            fclose($stream);

            return $messages;
        }

        /**
         * Save a translation item to the messages.
         *
         * A .po file could contain by error missing plural indexes. We need to
         * fix these before saving them.
         */
        private function addMessage(array &$messages, array $item)
        {
            if (!empty($item['ids']['singular'])) {
                $id = stripcslashes($item['ids']['singular']);
                if (isset($item['ids']['plural'])) {
                    $id .= '|'.stripcslashes($item['ids']['plural']);
                }

                $translated = (array) $item['translated'];
                // PO are by definition indexed so sort by index.
                ksort($translated);
                // Make sure every index is filled.
                end($translated);
                $count = key($translated);
                // Fill missing spots with '-'.
                $empties = array_fill(0, $count + 1, '-');
                $translated += $empties;
                ksort($translated);

                $messages[$id] = stripcslashes(implode('|', $translated));
            }
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-QtFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Config\Resource\FileResource;
    use Symfony\Component\Config\Util\XmlUtils;
    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;
    use Symfony\Component\Translation\MessageCatalogue;

    /**
     * QtFileLoader loads translations from QT Translations XML files.
     *
     * @author Benjamin Eberlei <kontakt@beberlei.de>
     */
    class QtFileLoader implements LoaderInterface
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
            if (!stream_is_local($resource)) {
                throw new InvalidResourceException(sprintf('This is not a local file "%s".', $resource));
            }

            if (!file_exists($resource)) {
                throw new NotFoundResourceException(sprintf('File "%s" not found.', $resource));
            }

            try {
                $dom = XmlUtils::loadFile($resource);
            } catch (\InvalidArgumentException $e) {
                throw new InvalidResourceException(sprintf('Unable to load "%s".', $resource), $e->getCode(), $e);
            }

            $internalErrors = libxml_use_internal_errors(true);
            libxml_clear_errors();

            $xpath = new \DOMXPath($dom);
            $nodes = $xpath->evaluate('//TS/context/name[text()="'.$domain.'"]');

            $catalogue = new MessageCatalogue($locale);
            if (1 == $nodes->length) {
                $translations = $nodes->item(0)->nextSibling->parentNode->parentNode->getElementsByTagName('message');
                foreach ($translations as $translation) {
                    $translationValue = (string) $translation->getElementsByTagName('translation')->item(0)->nodeValue;

                    if (!empty($translationValue)) {
                        $catalogue->set(
                            (string) $translation->getElementsByTagName('source')->item(0)->nodeValue,
                            $translationValue,
                            $domain
                        );
                    }
                    $translation = $translation->nextSibling;
                }

                if (class_exists(FileResource::class)) {
                    $catalogue->addResource(new FileResource($resource));
                }
            }

            libxml_use_internal_errors($internalErrors);

            return $catalogue;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-XliffFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Config\Resource\FileResource;
    use Symfony\Component\Config\Util\XmlUtils;
    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;
    use Symfony\Component\Translation\MessageCatalogue;
    use Symfony\Component\Translation\Util\XliffUtils;

    /**
     * XliffFileLoader loads translations from XLIFF files.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class XliffFileLoader implements LoaderInterface
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
            if (!stream_is_local($resource)) {
                throw new InvalidResourceException(sprintf('This is not a local file "%s".', $resource));
            }

            if (!file_exists($resource)) {
                throw new NotFoundResourceException(sprintf('File "%s" not found.', $resource));
            }

            $catalogue = new MessageCatalogue($locale);
            $this->extract($resource, $catalogue, $domain);

            if (class_exists(FileResource::class)) {
                $catalogue->addResource(new FileResource($resource));
            }

            return $catalogue;
        }

        private function extract($resource, MessageCatalogue $catalogue, string $domain)
        {
            try {
                $dom = XmlUtils::loadFile($resource);
            } catch (\InvalidArgumentException $e) {
                throw new InvalidResourceException(sprintf('Unable to load "%s": ', $resource).$e->getMessage(), $e->getCode(), $e);
            }

            $xliffVersion = XliffUtils::getVersionNumber($dom);
            if ($errors = XliffUtils::validateSchema($dom)) {
                throw new InvalidResourceException(sprintf('Invalid resource provided: "%s"; Errors: ', $resource).XliffUtils::getErrorsAsString($errors));
            }

            if ('1.2' === $xliffVersion) {
                $this->extractXliff1($dom, $catalogue, $domain);
            }

            if ('2.0' === $xliffVersion) {
                $this->extractXliff2($dom, $catalogue, $domain);
            }
        }

        /**
         * Extract messages and metadata from DOMDocument into a MessageCatalogue.
         */
        private function extractXliff1(\DOMDocument $dom, MessageCatalogue $catalogue, string $domain)
        {
            $xml = simplexml_import_dom($dom);
            $encoding = $dom->encoding ? strtoupper($dom->encoding) : null;

            $namespace = 'urn:oasis:names:tc:xliff:document:1.2';
            $xml->registerXPathNamespace('xliff', $namespace);

            foreach ($xml->xpath('//xliff:file') as $file) {
                $fileAttributes = $file->attributes();

                $file->registerXPathNamespace('xliff', $namespace);

                foreach ($file->xpath('.//xliff:trans-unit') as $translation) {
                    $attributes = $translation->attributes();

                    if (!(isset($attributes['resname']) || isset($translation->source))) {
                        continue;
                    }

                    $source = isset($attributes['resname']) && $attributes['resname'] ? $attributes['resname'] : $translation->source;
                    // If the xlf file has another encoding specified, try to convert it because
                    // simple_xml will always return utf-8 encoded values
                    $target = $this->utf8ToCharset((string) ($translation->target ?? $translation->source), $encoding);

                    $catalogue->set((string) $source, $target, $domain);

                    $metadata = [
                        'source' => (string) $translation->source,
                        'file' => [
                            'original' => (string) $fileAttributes['original'],
                        ],
                    ];
                    if ($notes = $this->parseNotesMetadata($translation->note, $encoding)) {
                        $metadata['notes'] = $notes;
                    }

                    if (isset($translation->target) && $translation->target->attributes()) {
                        $metadata['target-attributes'] = [];
                        foreach ($translation->target->attributes() as $key => $value) {
                            $metadata['target-attributes'][$key] = (string) $value;
                        }
                    }

                    if (isset($attributes['id'])) {
                        $metadata['id'] = (string) $attributes['id'];
                    }

                    $catalogue->setMetadata((string) $source, $metadata, $domain);
                }
            }
        }

        private function extractXliff2(\DOMDocument $dom, MessageCatalogue $catalogue, string $domain)
        {
            $xml = simplexml_import_dom($dom);
            $encoding = $dom->encoding ? strtoupper($dom->encoding) : null;

            $xml->registerXPathNamespace('xliff', 'urn:oasis:names:tc:xliff:document:2.0');

            foreach ($xml->xpath('//xliff:unit') as $unit) {
                foreach ($unit->segment as $segment) {
                    $source = $segment->source;

                    // If the xlf file has another encoding specified, try to convert it because
                    // simple_xml will always return utf-8 encoded values
                    $target = $this->utf8ToCharset((string) ($segment->target ?? $source), $encoding);

                    $catalogue->set((string) $source, $target, $domain);

                    $metadata = [];
                    if (isset($segment->target) && $segment->target->attributes()) {
                        $metadata['target-attributes'] = [];
                        foreach ($segment->target->attributes() as $key => $value) {
                            $metadata['target-attributes'][$key] = (string) $value;
                        }
                    }

                    if (isset($unit->notes)) {
                        $metadata['notes'] = [];
                        foreach ($unit->notes->note as $noteNode) {
                            $note = [];
                            foreach ($noteNode->attributes() as $key => $value) {
                                $note[$key] = (string) $value;
                            }
                            $note['content'] = (string) $noteNode;
                            $metadata['notes'][] = $note;
                        }
                    }

                    $catalogue->setMetadata((string) $source, $metadata, $domain);
                }
            }
        }

        /**
         * Convert a UTF8 string to the specified encoding.
         */
        private function utf8ToCharset(string $content, string $encoding = null): string
        {
            if ('UTF-8' !== $encoding && !empty($encoding)) {
                return mb_convert_encoding($content, $encoding, 'UTF-8');
            }

            return $content;
        }

        private function parseNotesMetadata(\SimpleXMLElement $noteElement = null, string $encoding = null): array
        {
            $notes = [];

            if (null === $noteElement) {
                return $notes;
            }

            /** @var \SimpleXMLElement $xmlNote */
            foreach ($noteElement as $xmlNote) {
                $noteAttributes = $xmlNote->attributes();
                $note = ['content' => $this->utf8ToCharset((string) $xmlNote, $encoding)];
                if (isset($noteAttributes['priority'])) {
                    $note['priority'] = (int) $noteAttributes['priority'];
                }

                if (isset($noteAttributes['from'])) {
                    $note['from'] = (string) $noteAttributes['from'];
                }

                $notes[] = $note;
            }

            return $notes;
        }
    }
  uploads-Carbon-vendor-symfony-translation-Loader-YamlFileLoader.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Loader;

    use Symfony\Component\Translation\Exception\InvalidResourceException;
    use Symfony\Component\Translation\Exception\LogicException;
    use Symfony\Component\Yaml\Exception\ParseException;
    use Symfony\Component\Yaml\Parser as YamlParser;
    use Symfony\Component\Yaml\Yaml;

    /**
     * YamlFileLoader loads translations from Yaml files.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class YamlFileLoader extends FileLoader
    {
        private $yamlParser;

        /**
         * {@inheritdoc}
         */
        protected function loadResource($resource)
        {
            if (null === $this->yamlParser) {
                if (!class_exists(\Symfony\Component\Yaml\Parser::class)) {
                    throw new LogicException('Loading translations from the YAML format requires the Symfony Yaml component.');
                }

                $this->yamlParser = new YamlParser();
            }

            try {
                $messages = $this->yamlParser->parseFile($resource, Yaml::PARSE_CONSTANT);
            } catch (ParseException $e) {
                throw new InvalidResourceException(sprintf('The file "%s" does not contain valid YAML: ', $resource).$e->getMessage(), 0, $e);
            }

            if (null !== $messages && !\is_array($messages)) {
                throw new InvalidResourceException(sprintf('Unable to load file "%s".', $resource));
            }

            return $messages ?: [];
        }
    }
  uploads-Carbon-vendor-symfony-translation-LoggingTranslator.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation;

    use Psr\Log\LoggerInterface;
    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Component\Translation\TranslatorInterface as LegacyTranslatorInterface;
    use Symfony\Contracts\Translation\LocaleAwareInterface;
    use Symfony\Contracts\Translation\TranslatorInterface;

    /**
     * @author Abdellatif Ait boudad <a.aitboudad@gmail.com>
     */
    class LoggingTranslator implements TranslatorInterface, LegacyTranslatorInterface, TranslatorBagInterface
    {
        /**
         * @var TranslatorInterface|TranslatorBagInterface
         */
        private $translator;

        private $logger;

        /**
         * @param TranslatorInterface $translator The translator must implement TranslatorBagInterface
         */
        public function __construct($translator, LoggerInterface $logger)
        {
            if (!$translator instanceof LegacyTranslatorInterface && !$translator instanceof TranslatorInterface) {
                throw new \TypeError(sprintf('Argument 1 passed to "%s()" must be an instance of "%s", "%s" given.', __METHOD__, TranslatorInterface::class, \is_object($translator) ? \get_class($translator) : \gettype($translator)));
            }
            if (!$translator instanceof TranslatorBagInterface || !$translator instanceof LocaleAwareInterface) {
                throw new InvalidArgumentException(sprintf('The Translator "%s" must implement TranslatorInterface, TranslatorBagInterface and LocaleAwareInterface.', \get_class($translator)));
            }

            $this->translator = $translator;
            $this->logger = $logger;
        }

        /**
         * {@inheritdoc}
         */
        public function trans($id, array $parameters = [], $domain = null, $locale = null)
        {
            $trans = $this->translator->trans($id, $parameters, $domain, $locale);
            $this->log($id, $domain, $locale);

            return $trans;
        }

        /**
         * {@inheritdoc}
         *
         * @deprecated since Symfony 4.2, use the trans() method instead with a %count% parameter
         */
        public function transChoice($id, $number, array $parameters = [], $domain = null, $locale = null)
        {
            @trigger_error(sprintf('The "%s()" method is deprecated since Symfony 4.2, use the trans() one instead with a "%%count%%" parameter.', __METHOD__), \E_USER_DEPRECATED);

            if ($this->translator instanceof TranslatorInterface) {
                $trans = $this->translator->trans($id, ['%count%' => $number] + $parameters, $domain, $locale);
            } else {
                $trans = $this->translator->transChoice($id, $number, $parameters, $domain, $locale);
            }

            $this->log($id, $domain, $locale);

            return $trans;
        }

        /**
         * {@inheritdoc}
         */
        public function setLocale($locale)
        {
            $prev = $this->translator->getLocale();
            $this->translator->setLocale($locale);
            if ($prev === $locale) {
                return;
            }

            $this->logger->debug(sprintf('The locale of the translator has changed from "%s" to "%s".', $prev, $locale));
        }

        /**
         * {@inheritdoc}
         */
        public function getLocale()
        {
            return $this->translator->getLocale();
        }

        /**
         * {@inheritdoc}
         */
        public function getCatalogue($locale = null)
        {
            return $this->translator->getCatalogue($locale);
        }

        /**
         * Gets the fallback locales.
         *
         * @return array The fallback locales
         */
        public function getFallbackLocales()
        {
            if ($this->translator instanceof Translator || method_exists($this->translator, 'getFallbackLocales')) {
                return $this->translator->getFallbackLocales();
            }

            return [];
        }

        /**
         * Passes through all unknown calls onto the translator object.
         */
        public function __call($method, $args)
        {
            return $this->translator->{$method}(...$args);
        }

        /**
         * Logs for missing translations.
         */
        private function log(?string $id, ?string $domain, ?string $locale)
        {
            if (null === $domain) {
                $domain = 'messages';
            }

            $id = (string) $id;
            $catalogue = $this->translator->getCatalogue($locale);
            if ($catalogue->defines($id, $domain)) {
                return;
            }

            if ($catalogue->has($id, $domain)) {
                $this->logger->debug('Translation use fallback catalogue.', ['id' => $id, 'domain' => $domain, 'locale' => $catalogue->getLocale()]);
            } else {
                $this->logger->warning('Translation not found.', ['id' => $id, 'domain' => $domain, 'locale' => $catalogue->getLocale()]);
            }
        }
    }
  uploads-Carbon-vendor-symfony-translation-MessageSelector.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation;

    @trigger_error(sprintf('The "%s" class is deprecated since Symfony 4.2, use IdentityTranslator instead.', MessageSelector::class), \E_USER_DEPRECATED);

    use Symfony\Component\Translation\Exception\InvalidArgumentException;

    /**
     * MessageSelector.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Bernhard Schussek <bschussek@gmail.com>
     *
     * @deprecated since Symfony 4.2, use IdentityTranslator instead.
     */
    class MessageSelector
    {
        /**
         * Given a message with different plural translations separated by a
         * pipe (|), this method returns the correct portion of the message based
         * on the given number, locale and the pluralization rules in the message
         * itself.
         *
         * The message supports two different types of pluralization rules:
         *
         * interval: {0} There are no apples|{1} There is one apple|]1,Inf] There are %count% apples
         * indexed:  There is one apple|There are %count% apples
         *
         * The indexed solution can also contain labels (e.g. one: There is one apple).
         * This is purely for making the translations more clear - it does not
         * affect the functionality.
         *
         * The two methods can also be mixed:
         *     {0} There are no apples|one: There is one apple|more: There are %count% apples
         *
         * @param string    $message The message being translated
         * @param int|float $number  The number of items represented for the message
         * @param string    $locale  The locale to use for choosing
         *
         * @return string
         *
         * @throws InvalidArgumentException
         */
        public function choose($message, $number, $locale)
        {
            $parts = [];
            if (preg_match('/^\|++$/', $message)) {
                $parts = explode('|', $message);
            } elseif (preg_match_all('/(?:\|\||[^\|])++/', $message, $matches)) {
                $parts = $matches[0];
            }

            $explicitRules = [];
            $standardRules = [];
            foreach ($parts as $part) {
                $part = trim(str_replace('||', '|', $part));

                if (preg_match('/^(?P<interval>'.Interval::getIntervalRegexp().')\s*(?P<message>.*?)$/xs', $part, $matches)) {
                    $explicitRules[$matches['interval']] = $matches['message'];
                } elseif (preg_match('/^\w+\:\s*(.*?)$/', $part, $matches)) {
                    $standardRules[] = $matches[1];
                } else {
                    $standardRules[] = $part;
                }
            }

            // try to match an explicit rule, then fallback to the standard ones
            foreach ($explicitRules as $interval => $m) {
                if (Interval::test($number, $interval)) {
                    return $m;
                }
            }

            $position = PluralizationRules::get($number, $locale);

            if (!isset($standardRules[$position])) {
                // when there's exactly one rule given, and that rule is a standard
                // rule, use this rule
                if (1 === \count($parts) && isset($standardRules[0])) {
                    return $standardRules[0];
                }

                throw new InvalidArgumentException(sprintf('Unable to choose a translation for "%s" with locale "%s" for value "%d". Double check that this translation has the correct plural options (e.g. "There is one apple|There are %%count%% apples").', $message, $locale, $number));
            }

            return $standardRules[$position];
        }
    }
  uploads-Carbon-vendor-symfony-translation-PluralizationRules.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation;

    /**
     * Returns the plural rules for a given locale.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @deprecated since Symfony 4.2, use IdentityTranslator instead
     */
    class PluralizationRules
    {
        private static $rules = [];

        /**
         * Returns the plural position to use for the given locale and number.
         *
         * @param float  $number The number
         * @param string $locale The locale
         *
         * @return int The plural position
         */
        public static function get($number, $locale/*, bool $triggerDeprecation = true*/)
        {
            $number = abs($number);

            if (3 > \func_num_args() || func_get_arg(2)) {
                @trigger_error(sprintf('The "%s" class is deprecated since Symfony 4.2.', __CLASS__), \E_USER_DEPRECATED);
            }

            if ('pt_BR' === $locale) {
                // temporary set a locale for brazilian
                $locale = 'xbr';
            }

            if ('en_US_POSIX' !== $locale && \strlen($locale) > 3) {
                $locale = substr($locale, 0, -\strlen(strrchr($locale, '_')));
            }

            if (isset(self::$rules[$locale])) {
                $return = self::$rules[$locale]($number);

                if (!\is_int($return) || $return < 0) {
                    return 0;
                }

                return $return;
            }

            /*
             * The plural rules are derived from code of the Zend Framework (2010-09-25),
             * which is subject to the new BSD license (http://framework.zend.com/license/new-bsd).
             * Copyright (c) 2005-2010 Zend Technologies USA Inc. (http://www.zend.com)
             */
            switch ($locale) {
                case 'az':
                case 'bo':
                case 'dz':
                case 'id':
                case 'ja':
                case 'jv':
                case 'ka':
                case 'km':
                case 'kn':
                case 'ko':
                case 'ms':
                case 'th':
                case 'tr':
                case 'vi':
                case 'zh':
                    return 0;

                case 'af':
                case 'bn':
                case 'bg':
                case 'ca':
                case 'da':
                case 'de':
                case 'el':
                case 'en':
                case 'en_US_POSIX':
                case 'eo':
                case 'es':
                case 'et':
                case 'eu':
                case 'fa':
                case 'fi':
                case 'fo':
                case 'fur':
                case 'fy':
                case 'gl':
                case 'gu':
                case 'ha':
                case 'he':
                case 'hu':
                case 'is':
                case 'it':
                case 'ku':
                case 'lb':
                case 'ml':
                case 'mn':
                case 'mr':
                case 'nah':
                case 'nb':
                case 'ne':
                case 'nl':
                case 'nn':
                case 'no':
                case 'oc':
                case 'om':
                case 'or':
                case 'pa':
                case 'pap':
                case 'ps':
                case 'pt':
                case 'so':
                case 'sq':
                case 'sv':
                case 'sw':
                case 'ta':
                case 'te':
                case 'tk':
                case 'ur':
                case 'zu':
                    return (1 == $number) ? 0 : 1;

                case 'am':
                case 'bh':
                case 'fil':
                case 'fr':
                case 'gun':
                case 'hi':
                case 'hy':
                case 'ln':
                case 'mg':
                case 'nso':
                case 'xbr':
                case 'ti':
                case 'wa':
                    return ($number < 2) ? 0 : 1;

                case 'be':
                case 'bs':
                case 'hr':
                case 'ru':
                case 'sh':
                case 'sr':
                case 'uk':
                    return ((1 == $number % 10) && (11 != $number % 100)) ? 0 : ((($number % 10 >= 2) && ($number % 10 <= 4) && (($number % 100 < 10) || ($number % 100 >= 20))) ? 1 : 2);

                case 'cs':
                case 'sk':
                    return (1 == $number) ? 0 : ((($number >= 2) && ($number <= 4)) ? 1 : 2);

                case 'ga':
                    return (1 == $number) ? 0 : ((2 == $number) ? 1 : 2);

                case 'lt':
                    return ((1 == $number % 10) && (11 != $number % 100)) ? 0 : ((($number % 10 >= 2) && (($number % 100 < 10) || ($number % 100 >= 20))) ? 1 : 2);

                case 'sl':
                    return (1 == $number % 100) ? 0 : ((2 == $number % 100) ? 1 : (((3 == $number % 100) || (4 == $number % 100)) ? 2 : 3));

                case 'mk':
                    return (1 == $number % 10) ? 0 : 1;

                case 'mt':
                    return (1 == $number) ? 0 : (((0 == $number) || (($number % 100 > 1) && ($number % 100 < 11))) ? 1 : ((($number % 100 > 10) && ($number % 100 < 20)) ? 2 : 3));

                case 'lv':
                    return (0 == $number) ? 0 : (((1 == $number % 10) && (11 != $number % 100)) ? 1 : 2);

                case 'pl':
                    return (1 == $number) ? 0 : ((($number % 10 >= 2) && ($number % 10 <= 4) && (($number % 100 < 12) || ($number % 100 > 14))) ? 1 : 2);

                case 'cy':
                    return (1 == $number) ? 0 : ((2 == $number) ? 1 : (((8 == $number) || (11 == $number)) ? 2 : 3));

                case 'ro':
                    return (1 == $number) ? 0 : (((0 == $number) || (($number % 100 > 0) && ($number % 100 < 20))) ? 1 : 2);

                case 'ar':
                    return (0 == $number) ? 0 : ((1 == $number) ? 1 : ((2 == $number) ? 2 : ((($number % 100 >= 3) && ($number % 100 <= 10)) ? 3 : ((($number % 100 >= 11) && ($number % 100 <= 99)) ? 4 : 5))));

                default:
                    return 0;
            }
        }

        /**
         * Overrides the default plural rule for a given locale.
         *
         * @param callable $rule   A PHP callable
         * @param string   $locale The locale
         */
        public static function set(callable $rule, $locale)
        {
            @trigger_error(sprintf('The "%s" class is deprecated since Symfony 4.2.', __CLASS__), \E_USER_DEPRECATED);

            if ('pt_BR' === $locale) {
                // temporary set a locale for brazilian
                $locale = 'xbr';
            }

            if (\strlen($locale) > 3) {
                $locale = substr($locale, 0, -\strlen(strrchr($locale, '_')));
            }

            self::$rules[$locale] = $rule;
        }
    }
  uploads-Carbon-vendor-symfony-translation-README.md: |
    Translation Component
    =====================

    The Translation component provides tools to internationalize your application.

    Getting Started
    ---------------

    ```
    $ composer require symfony/translation
    ```

    ```php
    use Symfony\Component\Translation\Translator;
    use Symfony\Component\Translation\Loader\ArrayLoader;

    $translator = new Translator('fr_FR');
    $translator->addLoader('array', new ArrayLoader());
    $translator->addResource('array', [
        'Hello World!' => 'Bonjour !',
    ], 'fr_FR');

    echo $translator->trans('Hello World!'); // outputs Â«Â Bonjour !Â Â»
    ```

    Resources
    ---------

     * [Documentation](https://symfony.com/doc/current/translation.html)
     * [Contributing](https://symfony.com/doc/current/contributing/index.html)
     * [Report issues](https://github.com/symfony/symfony/issues) and
       [send Pull Requests](https://github.com/symfony/symfony/pulls)
       in the [main Symfony repository](https://github.com/symfony/symfony)
  uploads-Carbon-vendor-symfony-translation-Resources-schemas-xliff-core-1.2-strict.xsd: |
    <?xml version="1.0" encoding="UTF-8"?>

    <!--

    May-19-2004:
    - Changed the <choice> for ElemType_header, moving minOccurs="0" maxOccurs="unbounded" from its elements
    to <choice> itself.
    - Added <choice> for ElemType_trans-unit to allow "any order" for <context-group>, <count-group>, <prop-group>, <note>, and
    <alt-trans>.

    Oct-2005
    - updated version info to 1.2
    - equiv-trans attribute to <trans-unit> element
    - merged-trans attribute for <group> element
    - Add the <seg-source> element as optional in the <trans-unit> and <alt-trans> content models, at the same level as <source>
    - Create a new value "seg" for the mtype attribute of the <mrk> element
    - Add mid as an optional attribute for the <alt-trans> element

    Nov-14-2005
    - Changed name attribute for <context-group> from required to optional
    - Added extension point at <xliff>

    Jan-9-2006
    - Added alttranstype type attribute to <alt-trans>, and values

    Jan-10-2006
    - Corrected error with overwritten purposeValueList
    - Corrected name="AttrType_Version",  attribute should have been "name"

    -->
    <xsd:schema xmlns:xlf="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="urn:oasis:names:tc:xliff:document:1.2" xml:lang="en">
      <!-- Import for xml:lang and xml:space -->
      <xsd:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2001/xml.xsd"/>
      <!-- Attributes Lists -->
      <xsd:simpleType name="XTend">
        <xsd:restriction base="xsd:string">
          <xsd:pattern value="x-[^\s]+"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="context-typeValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'context-type'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="database">
            <xsd:annotation>
              <xsd:documentation>Indicates a database content.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="element">
            <xsd:annotation>
              <xsd:documentation>Indicates the content of an element within an XML document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="elementtitle">
            <xsd:annotation>
              <xsd:documentation>Indicates the name of an element within an XML document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="linenumber">
            <xsd:annotation>
              <xsd:documentation>Indicates the line number from the sourcefile (see context-type="sourcefile") where the &lt;source&gt; is found.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="numparams">
            <xsd:annotation>
              <xsd:documentation>Indicates a the number of parameters contained within the &lt;source&gt;.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="paramnotes">
            <xsd:annotation>
              <xsd:documentation>Indicates notes pertaining to the parameters in the &lt;source&gt;.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="record">
            <xsd:annotation>
              <xsd:documentation>Indicates the content of a record within a database.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="recordtitle">
            <xsd:annotation>
              <xsd:documentation>Indicates the name of a record within a database.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="sourcefile">
            <xsd:annotation>
              <xsd:documentation>Indicates the original source file in the case that multiple files are merged to form the original file from which the XLIFF file is created. This differs from the original &lt;file&gt; attribute in that this sourcefile is one of many that make up that file.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="count-typeValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'count-type'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="num-usages">
            <xsd:annotation>
              <xsd:documentation>Indicates the count units are items that are used X times in a certain context; example: this is a reusable text unit which is used 42 times in other texts.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="repetition">
            <xsd:annotation>
              <xsd:documentation>Indicates the count units are translation units existing already in the same document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="total">
            <xsd:annotation>
              <xsd:documentation>Indicates a total count.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="InlineDelimitersValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'ctype' when used other elements than &lt;ph&gt; or &lt;x&gt;.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="bold">
            <xsd:annotation>
              <xsd:documentation>Indicates a run of bolded text.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="italic">
            <xsd:annotation>
              <xsd:documentation>Indicates a run of text in italics.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="underlined">
            <xsd:annotation>
              <xsd:documentation>Indicates a run of underlined text.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="link">
            <xsd:annotation>
              <xsd:documentation>Indicates a run of hyper-text.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="InlinePlaceholdersValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'ctype' when used with &lt;ph&gt; or &lt;x&gt;.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="image">
            <xsd:annotation>
              <xsd:documentation>Indicates a inline image.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pb">
            <xsd:annotation>
              <xsd:documentation>Indicates a page break.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="lb">
            <xsd:annotation>
              <xsd:documentation>Indicates a line break.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="mime-typeValueList">
        <xsd:restriction base="xsd:string">
          <xsd:pattern value="(text|multipart|message|application|image|audio|video|model)(/.+)*"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="datatypeValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'datatype'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="asp">
            <xsd:annotation>
              <xsd:documentation>Indicates Active Server Page data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="c">
            <xsd:annotation>
              <xsd:documentation>Indicates C source file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cdf">
            <xsd:annotation>
              <xsd:documentation>Indicates Channel Definition Format (CDF) data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cfm">
            <xsd:annotation>
              <xsd:documentation>Indicates ColdFusion data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cpp">
            <xsd:annotation>
              <xsd:documentation>Indicates C++ source file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="csharp">
            <xsd:annotation>
              <xsd:documentation>Indicates C-Sharp data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cstring">
            <xsd:annotation>
              <xsd:documentation>Indicates strings from C, ASM, and driver files data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="csv">
            <xsd:annotation>
              <xsd:documentation>Indicates comma-separated values data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="database">
            <xsd:annotation>
              <xsd:documentation>Indicates database data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="documentfooter">
            <xsd:annotation>
              <xsd:documentation>Indicates portions of document that follows data and contains metadata.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="documentheader">
            <xsd:annotation>
              <xsd:documentation>Indicates portions of document that precedes data and contains metadata.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="filedialog">
            <xsd:annotation>
              <xsd:documentation>Indicates data from standard UI file operations dialogs (e.g., Open, Save, Save As, Export, Import).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="form">
            <xsd:annotation>
              <xsd:documentation>Indicates standard user input screen data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="html">
            <xsd:annotation>
              <xsd:documentation>Indicates HyperText Markup Language (HTML) data - document instance.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="htmlbody">
            <xsd:annotation>
              <xsd:documentation>Indicates content within an HTML documentâs &lt;body&gt; element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="ini">
            <xsd:annotation>
              <xsd:documentation>Indicates Windows INI file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="interleaf">
            <xsd:annotation>
              <xsd:documentation>Indicates Interleaf data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="javaclass">
            <xsd:annotation>
              <xsd:documentation>Indicates Java source file data (extension '.java').</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="javapropertyresourcebundle">
            <xsd:annotation>
              <xsd:documentation>Indicates Java property resource bundle data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="javalistresourcebundle">
            <xsd:annotation>
              <xsd:documentation>Indicates Java list resource bundle data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="javascript">
            <xsd:annotation>
              <xsd:documentation>Indicates JavaScript source file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="jscript">
            <xsd:annotation>
              <xsd:documentation>Indicates JScript source file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="layout">
            <xsd:annotation>
              <xsd:documentation>Indicates information relating to formatting.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="lisp">
            <xsd:annotation>
              <xsd:documentation>Indicates LISP source file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="margin">
            <xsd:annotation>
              <xsd:documentation>Indicates information relating to margin formats.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="menufile">
            <xsd:annotation>
              <xsd:documentation>Indicates a file containing menu.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="messagefile">
            <xsd:annotation>
              <xsd:documentation>Indicates numerically identified string table.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="mif">
            <xsd:annotation>
              <xsd:documentation>Indicates Maker Interchange Format (MIF) data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="mimetype">
            <xsd:annotation>
              <xsd:documentation>Indicates that the datatype attribute value is a MIME Type value and is defined in the mime-type attribute.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="mo">
            <xsd:annotation>
              <xsd:documentation>Indicates GNU Machine Object data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="msglib">
            <xsd:annotation>
              <xsd:documentation>Indicates Message Librarian strings created by Novell's Message Librarian Tool.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pagefooter">
            <xsd:annotation>
              <xsd:documentation>Indicates information to be displayed at the bottom of each page of a document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pageheader">
            <xsd:annotation>
              <xsd:documentation>Indicates information to be displayed at the top of each page of a document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="parameters">
            <xsd:annotation>
              <xsd:documentation>Indicates a list of property values (e.g., settings within INI files or preferences dialog).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pascal">
            <xsd:annotation>
              <xsd:documentation>Indicates Pascal source file data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="php">
            <xsd:annotation>
              <xsd:documentation>Indicates Hypertext Preprocessor data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="plaintext">
            <xsd:annotation>
              <xsd:documentation>Indicates plain text file (no formatting other than, possibly, wrapping).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="po">
            <xsd:annotation>
              <xsd:documentation>Indicates GNU Portable Object file.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="report">
            <xsd:annotation>
              <xsd:documentation>Indicates dynamically generated user defined document. e.g. Oracle Report, Crystal Report, etc.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="resources">
            <xsd:annotation>
              <xsd:documentation>Indicates Windows .NET binary resources.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="resx">
            <xsd:annotation>
              <xsd:documentation>Indicates Windows .NET Resources.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rtf">
            <xsd:annotation>
              <xsd:documentation>Indicates Rich Text Format (RTF) data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="sgml">
            <xsd:annotation>
              <xsd:documentation>Indicates Standard Generalized Markup Language (SGML) data - document instance.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="sgmldtd">
            <xsd:annotation>
              <xsd:documentation>Indicates Standard Generalized Markup Language (SGML) data - Document Type Definition (DTD).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="svg">
            <xsd:annotation>
              <xsd:documentation>Indicates Scalable Vector Graphic (SVG) data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="vbscript">
            <xsd:annotation>
              <xsd:documentation>Indicates VisualBasic Script source file.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="warning">
            <xsd:annotation>
              <xsd:documentation>Indicates warning message.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="winres">
            <xsd:annotation>
              <xsd:documentation>Indicates Windows (Win32) resources (i.e. resources extracted from an RC script, a message file, or a compiled file).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="xhtml">
            <xsd:annotation>
              <xsd:documentation>Indicates Extensible HyperText Markup Language (XHTML) data - document instance.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="xml">
            <xsd:annotation>
              <xsd:documentation>Indicates Extensible Markup Language (XML) data - document instance.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="xmldtd">
            <xsd:annotation>
              <xsd:documentation>Indicates Extensible Markup Language (XML) data - Document Type Definition (DTD).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="xsl">
            <xsd:annotation>
              <xsd:documentation>Indicates Extensible Stylesheet Language (XSL) data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="xul">
            <xsd:annotation>
              <xsd:documentation>Indicates XUL elements.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="mtypeValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'mtype'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="abbrev">
            <xsd:annotation>
              <xsd:documentation>Indicates the marked text is an abbreviation.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="abbreviated-form">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.8: A term resulting from the omission of any part of the full term while designating the same concept.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="abbreviation">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.8.1: An abbreviated form of a simple term resulting from the omission of some of its letters (e.g. 'adj.' for 'adjective').</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="acronym">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.8.4: An abbreviated form of a term made up of letters from the full form of a multiword term strung together into a sequence pronounced only syllabically (e.g. 'radar' for 'radio detecting and ranging').</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="appellation">
            <xsd:annotation>
              <xsd:documentation>ISO-12620: A proper-name term, such as the name of an agency or other proper entity.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="collocation">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.18.1: A recurrent word combination characterized by cohesion in that the components of the collocation must co-occur within an utterance or series of utterances, even though they do not necessarily have to maintain immediate proximity to one another.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="common-name">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.5: A synonym for an international scientific term that is used in general discourse in a given language.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="datetime">
            <xsd:annotation>
              <xsd:documentation>Indicates the marked text is a date and/or time.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="equation">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.15: An expression used to represent a concept based on a statement that two mathematical expressions are, for instance, equal as identified by the equal sign (=), or assigned to one another by a similar sign.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="expanded-form">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.7: The complete representation of a term for which there is an abbreviated form.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="formula">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.14: Figures, symbols or the like used to express a concept briefly, such as a mathematical or chemical formula.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="head-term">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.1: The concept designation that has been chosen to head a terminological record.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="initialism">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.8.3: An abbreviated form of a term consisting of some of the initial letters of the words making up a multiword term or the term elements making up a compound term when these letters are pronounced individually (e.g. 'BSE' for 'bovine spongiform encephalopathy').</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="international-scientific-term">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.4: A term that is part of an international scientific nomenclature as adopted by an appropriate scientific body.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="internationalism">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.6: A term that has the same or nearly identical orthographic or phonemic form in many languages.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="logical-expression">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.16: An expression used to represent a concept based on mathematical or logical relations, such as statements of inequality, set relationships, Boolean operations, and the like.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="materials-management-unit">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.17: A unit to track object.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="name">
            <xsd:annotation>
              <xsd:documentation>Indicates the marked text is a name.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="near-synonym">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.3: A term that represents the same or a very similar concept as another term in the same language, but for which interchangeability is limited to some contexts and inapplicable in others.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="part-number">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.17.2: A unique alphanumeric designation assigned to an object in a manufacturing system.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="phrase">
            <xsd:annotation>
              <xsd:documentation>Indicates the marked text is a phrase.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="phraseological-unit">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.18: Any group of two or more words that form a unit, the meaning of which frequently cannot be deduced based on the combined sense of the words making up the phrase.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="protected">
            <xsd:annotation>
              <xsd:documentation>Indicates the marked text should not be translated.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="romanized-form">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.12: A form of a term resulting from an operation whereby non-Latin writing systems are converted to the Latin alphabet.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="seg">
            <xsd:annotation>
              <xsd:documentation>Indicates that the marked text represents a segment.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="set-phrase">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.18.2: A fixed, lexicalized phrase.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="short-form">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.8.2: A variant of a multiword term that includes fewer words than the full form of the term (e.g. 'Group of Twenty-four' for 'Intergovernmental Group of Twenty-four on International Monetary Affairs').</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="sku">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.17.1: Stock keeping unit, an inventory item identified by a unique alphanumeric designation assigned to an object in an inventory control system.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="standard-text">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.19: A fixed chunk of recurring text.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="symbol">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.13: A designation of a concept by letters, numerals, pictograms or any combination thereof.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="synonym">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.2: Any term that represents the same or a very similar concept as the main entry term in a term entry.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="synonymous-phrase">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.18.3: Phraseological unit in a language that expresses the same semantic content as another phrase in that same language.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="term">
            <xsd:annotation>
              <xsd:documentation>Indicates the marked text is a term.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="transcribed-form">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.11: A form of a term resulting from an operation whereby the characters of one writing system are represented by characters from another writing system, taking into account the pronunciation of the characters converted.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="transliterated-form">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.10: A form of a term resulting from an operation whereby the characters of an alphabetic writing system are represented by characters from another alphabetic writing system.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="truncated-term">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.8.5: An abbreviated form of a term resulting from the omission of one or more term elements or syllables (e.g. 'flu' for 'influenza').</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="variant">
            <xsd:annotation>
              <xsd:documentation>ISO-12620 2.1.9: One of the alternate forms of a term.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="restypeValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'restype'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="auto3state">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC AUTO3STATE control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="autocheckbox">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC AUTOCHECKBOX control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="autoradiobutton">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC AUTORADIOBUTTON control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="bedit">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC BEDIT control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="bitmap">
            <xsd:annotation>
              <xsd:documentation>Indicates a bitmap, for example a BITMAP resource in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="button">
            <xsd:annotation>
              <xsd:documentation>Indicates a button object, for example a BUTTON control Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="caption">
            <xsd:annotation>
              <xsd:documentation>Indicates a caption, such as the caption of a dialog box.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cell">
            <xsd:annotation>
              <xsd:documentation>Indicates the cell in a table, for example the content of the &lt;td&gt; element in HTML.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="checkbox">
            <xsd:annotation>
              <xsd:documentation>Indicates check box object, for example a CHECKBOX control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="checkboxmenuitem">
            <xsd:annotation>
              <xsd:documentation>Indicates a menu item with an associated checkbox.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="checkedlistbox">
            <xsd:annotation>
              <xsd:documentation>Indicates a list box, but with a check-box for each item.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="colorchooser">
            <xsd:annotation>
              <xsd:documentation>Indicates a color selection dialog.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="combobox">
            <xsd:annotation>
              <xsd:documentation>Indicates a combination of edit box and listbox object, for example a COMBOBOX control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="comboboxexitem">
            <xsd:annotation>
              <xsd:documentation>Indicates an initialization entry of an extended combobox DLGINIT resource block. (code 0x1234).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="comboboxitem">
            <xsd:annotation>
              <xsd:documentation>Indicates an initialization entry of a combobox DLGINIT resource block (code 0x0403).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="component">
            <xsd:annotation>
              <xsd:documentation>Indicates a UI base class element that cannot be represented by any other element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="contextmenu">
            <xsd:annotation>
              <xsd:documentation>Indicates a context menu.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="ctext">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC CTEXT control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cursor">
            <xsd:annotation>
              <xsd:documentation>Indicates a cursor, for example a CURSOR resource in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="datetimepicker">
            <xsd:annotation>
              <xsd:documentation>Indicates a date/time picker.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="defpushbutton">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC DEFPUSHBUTTON control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="dialog">
            <xsd:annotation>
              <xsd:documentation>Indicates a dialog box.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="dlginit">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC DLGINIT resource block.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="edit">
            <xsd:annotation>
              <xsd:documentation>Indicates an edit box object, for example an EDIT control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="file">
            <xsd:annotation>
              <xsd:documentation>Indicates a filename.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="filechooser">
            <xsd:annotation>
              <xsd:documentation>Indicates a file dialog.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="fn">
            <xsd:annotation>
              <xsd:documentation>Indicates a footnote.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="font">
            <xsd:annotation>
              <xsd:documentation>Indicates a font name.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="footer">
            <xsd:annotation>
              <xsd:documentation>Indicates a footer.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="frame">
            <xsd:annotation>
              <xsd:documentation>Indicates a frame object.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="grid">
            <xsd:annotation>
              <xsd:documentation>Indicates a XUL grid element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="groupbox">
            <xsd:annotation>
              <xsd:documentation>Indicates a groupbox object, for example a GROUPBOX control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="header">
            <xsd:annotation>
              <xsd:documentation>Indicates a header item.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="heading">
            <xsd:annotation>
              <xsd:documentation>Indicates a heading, such has the content of &lt;h1&gt;, &lt;h2&gt;, etc. in HTML.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="hedit">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC HEDIT control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="hscrollbar">
            <xsd:annotation>
              <xsd:documentation>Indicates a horizontal scrollbar.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="icon">
            <xsd:annotation>
              <xsd:documentation>Indicates an icon, for example an ICON resource in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="iedit">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC IEDIT control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="keywords">
            <xsd:annotation>
              <xsd:documentation>Indicates keyword list, such as the content of the Keywords meta-data in HTML, or a K footnote in WinHelp RTF.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="label">
            <xsd:annotation>
              <xsd:documentation>Indicates a label object.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="linklabel">
            <xsd:annotation>
              <xsd:documentation>Indicates a label that is also a HTML link (not necessarily a URL).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="list">
            <xsd:annotation>
              <xsd:documentation>Indicates a list (a group of list-items, for example an &lt;ol&gt; or &lt;ul&gt; element in HTML).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="listbox">
            <xsd:annotation>
              <xsd:documentation>Indicates a listbox object, for example an LISTBOX control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="listitem">
            <xsd:annotation>
              <xsd:documentation>Indicates an list item (an entry in a list).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="ltext">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC LTEXT control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="menu">
            <xsd:annotation>
              <xsd:documentation>Indicates a menu (a group of menu-items).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="menubar">
            <xsd:annotation>
              <xsd:documentation>Indicates a toolbar containing one or more tope level menus.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="menuitem">
            <xsd:annotation>
              <xsd:documentation>Indicates a menu item (an entry in a menu).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="menuseparator">
            <xsd:annotation>
              <xsd:documentation>Indicates a XUL menuseparator element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="message">
            <xsd:annotation>
              <xsd:documentation>Indicates a message, for example an entry in a MESSAGETABLE resource in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="monthcalendar">
            <xsd:annotation>
              <xsd:documentation>Indicates a calendar control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="numericupdown">
            <xsd:annotation>
              <xsd:documentation>Indicates an edit box beside a spin control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="panel">
            <xsd:annotation>
              <xsd:documentation>Indicates a catch all for rectangular areas.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="popupmenu">
            <xsd:annotation>
              <xsd:documentation>Indicates a standalone menu not necessarily associated with a menubar.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pushbox">
            <xsd:annotation>
              <xsd:documentation>Indicates a pushbox object, for example a PUSHBOX control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pushbutton">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC PUSHBUTTON control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="radio">
            <xsd:annotation>
              <xsd:documentation>Indicates a radio button object.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="radiobuttonmenuitem">
            <xsd:annotation>
              <xsd:documentation>Indicates a menuitem with associated radio button.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rcdata">
            <xsd:annotation>
              <xsd:documentation>Indicates raw data resources for an application.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="row">
            <xsd:annotation>
              <xsd:documentation>Indicates a row in a table.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rtext">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC RTEXT control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="scrollpane">
            <xsd:annotation>
              <xsd:documentation>Indicates a user navigable container used to show a portion of a document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="separator">
            <xsd:annotation>
              <xsd:documentation>Indicates a generic divider object (e.g. menu group separator).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="shortcut">
            <xsd:annotation>
              <xsd:documentation>Windows accelerators, shortcuts in resource or property files.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="spinner">
            <xsd:annotation>
              <xsd:documentation>Indicates a UI control to indicate process activity but not progress.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="splitter">
            <xsd:annotation>
              <xsd:documentation>Indicates a splitter bar.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="state3">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC STATE3 control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="statusbar">
            <xsd:annotation>
              <xsd:documentation>Indicates a window for providing feedback to the users, like 'read-only', etc.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="string">
            <xsd:annotation>
              <xsd:documentation>Indicates a string, for example an entry in a STRINGTABLE resource in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="tabcontrol">
            <xsd:annotation>
              <xsd:documentation>Indicates a layers of controls with a tab to select layers.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="table">
            <xsd:annotation>
              <xsd:documentation>Indicates a display and edits regular two-dimensional tables of cells.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="textbox">
            <xsd:annotation>
              <xsd:documentation>Indicates a XUL textbox element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="togglebutton">
            <xsd:annotation>
              <xsd:documentation>Indicates a UI button that can be toggled to on or off state.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="toolbar">
            <xsd:annotation>
              <xsd:documentation>Indicates an array of controls, usually buttons.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="tooltip">
            <xsd:annotation>
              <xsd:documentation>Indicates a pop up tool tip text.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="trackbar">
            <xsd:annotation>
              <xsd:documentation>Indicates a bar with a pointer indicating a position within a certain range.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="tree">
            <xsd:annotation>
              <xsd:documentation>Indicates a control that displays a set of hierarchical data.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="uri">
            <xsd:annotation>
              <xsd:documentation>Indicates a URI (URN or URL).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="userbutton">
            <xsd:annotation>
              <xsd:documentation>Indicates a Windows RC USERBUTTON control.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="usercontrol">
            <xsd:annotation>
              <xsd:documentation>Indicates a user-defined control like CONTROL control in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="var">
            <xsd:annotation>
              <xsd:documentation>Indicates the text of a variable.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="versioninfo">
            <xsd:annotation>
              <xsd:documentation>Indicates version information about a resource like VERSIONINFO in Windows.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="vscrollbar">
            <xsd:annotation>
              <xsd:documentation>Indicates a vertical scrollbar.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="window">
            <xsd:annotation>
              <xsd:documentation>Indicates a graphical window.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="size-unitValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'size-unit'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="byte">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in 8-bit bytes.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="char">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in Unicode characters.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="col">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in columns. Used for HTML text area.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="cm">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in centimeters.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="dlgunit">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in dialog units, as defined in Windows resources.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="em">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in 'font-size' units (as defined in CSS).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="ex">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in 'x-height' units (as defined in CSS).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="glyph">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in glyphs. A glyph is considered to be one or more combined Unicode characters that represent a single displayable text character. Sometimes referred to as a 'grapheme cluster'</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="in">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in inches.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="mm">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in millimeters.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="percent">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in percentage.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="pixel">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in pixels.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="point">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in point.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="row">
            <xsd:annotation>
              <xsd:documentation>Indicates a size in rows. Used for HTML text area.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="stateValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'state'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="final">
            <xsd:annotation>
              <xsd:documentation>Indicates the terminating state.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="needs-adaptation">
            <xsd:annotation>
              <xsd:documentation>Indicates only non-textual information needs adaptation.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="needs-l10n">
            <xsd:annotation>
              <xsd:documentation>Indicates both text and non-textual information needs adaptation.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="needs-review-adaptation">
            <xsd:annotation>
              <xsd:documentation>Indicates only non-textual information needs review.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="needs-review-l10n">
            <xsd:annotation>
              <xsd:documentation>Indicates both text and non-textual information needs review.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="needs-review-translation">
            <xsd:annotation>
              <xsd:documentation>Indicates that only the text of the item needs to be reviewed.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="needs-translation">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item needs to be translated.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="new">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item is new. For example, translation units that were not in a previous version of the document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="signed-off">
            <xsd:annotation>
              <xsd:documentation>Indicates that changes are reviewed and approved.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="translated">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item has been translated.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="state-qualifierValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'state-qualifier'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="exact-match">
            <xsd:annotation>
              <xsd:documentation>Indicates an exact match. An exact match occurs when a source text of a segment is exactly the same as the source text of a segment that was translated previously.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="fuzzy-match">
            <xsd:annotation>
              <xsd:documentation>Indicates a fuzzy match. A fuzzy match occurs when a source text of a segment is very similar to the source text of a segment that was translated previously (e.g. when the difference is casing, a few changed words, white-space discripancy, etc.).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="id-match">
            <xsd:annotation>
              <xsd:documentation>Indicates a match based on matching IDs (in addition to matching text).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="leveraged-glossary">
            <xsd:annotation>
              <xsd:documentation>Indicates a translation derived from a glossary.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="leveraged-inherited">
            <xsd:annotation>
              <xsd:documentation>Indicates a translation derived from existing translation.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="leveraged-mt">
            <xsd:annotation>
              <xsd:documentation>Indicates a translation derived from machine translation.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="leveraged-repository">
            <xsd:annotation>
              <xsd:documentation>Indicates a translation derived from a translation repository.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="leveraged-tm">
            <xsd:annotation>
              <xsd:documentation>Indicates a translation derived from a translation memory.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="mt-suggestion">
            <xsd:annotation>
              <xsd:documentation>Indicates the translation is suggested by machine translation.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rejected-grammar">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item has been rejected because of incorrect grammar.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rejected-inaccurate">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item has been rejected because it is incorrect.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rejected-length">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item has been rejected because it is too long or too short.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rejected-spelling">
            <xsd:annotation>
              <xsd:documentation>Indicates that the item has been rejected because of incorrect spelling.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="tm-suggestion">
            <xsd:annotation>
              <xsd:documentation>Indicates the translation is suggested by translation memory.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="unitValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'unit'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="word">
            <xsd:annotation>
              <xsd:documentation>Refers to words.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="page">
            <xsd:annotation>
              <xsd:documentation>Refers to pages.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="trans-unit">
            <xsd:annotation>
              <xsd:documentation>Refers to &lt;trans-unit&gt; elements.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="bin-unit">
            <xsd:annotation>
              <xsd:documentation>Refers to &lt;bin-unit&gt; elements.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="glyph">
            <xsd:annotation>
              <xsd:documentation>Refers to glyphs.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="item">
            <xsd:annotation>
              <xsd:documentation>Refers to &lt;trans-unit&gt; and/or &lt;bin-unit&gt; elements.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="instance">
            <xsd:annotation>
              <xsd:documentation>Refers to the occurrences of instances defined by the count-type value.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="character">
            <xsd:annotation>
              <xsd:documentation>Refers to characters.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="line">
            <xsd:annotation>
              <xsd:documentation>Refers to lines.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="sentence">
            <xsd:annotation>
              <xsd:documentation>Refers to sentences.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="paragraph">
            <xsd:annotation>
              <xsd:documentation>Refers to paragraphs.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="segment">
            <xsd:annotation>
              <xsd:documentation>Refers to segments.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="placeable">
            <xsd:annotation>
              <xsd:documentation>Refers to placeables (inline elements).</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="priorityValueList">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'priority'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:positiveInteger">
          <xsd:enumeration value="1">
            <xsd:annotation>
              <xsd:documentation>Highest priority.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="2">
            <xsd:annotation>
              <xsd:documentation>High priority.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="3">
            <xsd:annotation>
              <xsd:documentation>High priority, but not as important as 2.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="4">
            <xsd:annotation>
              <xsd:documentation>High priority, but not as important as 3.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="5">
            <xsd:annotation>
              <xsd:documentation>Medium priority, but more important than 6.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="6">
            <xsd:annotation>
              <xsd:documentation>Medium priority, but less important than 5.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="7">
            <xsd:annotation>
              <xsd:documentation>Low priority, but more important than 8.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="8">
            <xsd:annotation>
              <xsd:documentation>Low priority, but more important than 9.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="9">
            <xsd:annotation>
              <xsd:documentation>Low priority.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="10">
            <xsd:annotation>
              <xsd:documentation>Lowest priority.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="reformatValueYesNo">
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="yes">
            <xsd:annotation>
              <xsd:documentation>This value indicates that all properties can be reformatted. This value must be used alone.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="no">
            <xsd:annotation>
              <xsd:documentation>This value indicates that no properties should be reformatted. This value must be used alone.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="reformatValueList">
        <xsd:list>
          <xsd:simpleType>
            <xsd:union memberTypes="xlf:XTend">
              <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                  <xsd:enumeration value="coord">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that all information in the coord attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="coord-x">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the x information in the coord attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="coord-y">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the y information in the coord attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="coord-cx">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the cx information in the coord attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="coord-cy">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the cy information in the coord attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="font">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that all the information in the font attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="font-name">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the name information in the font attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="font-size">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the size information in the font attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="font-weight">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the weight information in the font attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="css-style">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the information in the css-style attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="style">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the information in the style attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                  <xsd:enumeration value="ex-style">
                    <xsd:annotation>
                      <xsd:documentation>This value indicates that the information in the exstyle attribute can be modified.</xsd:documentation>
                    </xsd:annotation>
                  </xsd:enumeration>
                </xsd:restriction>
              </xsd:simpleType>
            </xsd:union>
          </xsd:simpleType>
        </xsd:list>
      </xsd:simpleType>
      <xsd:simpleType name="purposeValueList">
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="information">
            <xsd:annotation>
              <xsd:documentation>Indicates that the context is informational in nature, specifying for example, how a term should be translated. Thus, should be displayed to anyone editing the XLIFF document.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="location">
            <xsd:annotation>
              <xsd:documentation>Indicates that the context-group is used to specify where the term was found in the translatable source. Thus, it is not displayed.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="match">
            <xsd:annotation>
              <xsd:documentation>Indicates that the context information should be used during translation memory lookups. Thus, it is not displayed.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="alttranstypeValueList">
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="proposal">
            <xsd:annotation>
              <xsd:documentation>Represents a translation proposal from a translation memory or other resource.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="previous-version">
            <xsd:annotation>
              <xsd:documentation>Represents a previous version of the target element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="rejected">
            <xsd:annotation>
              <xsd:documentation>Represents a rejected version of the target element.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="reference">
            <xsd:annotation>
              <xsd:documentation>Represents a translation to be used for reference purposes only, for example from a related product or a different language.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="accepted">
            <xsd:annotation>
              <xsd:documentation>Represents a proposed translation that was used for the translation of the trans-unit, possibly modified.</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
      <!-- Other Types -->
      <xsd:complexType name="ElemType_ExternalReference">
        <xsd:choice>
          <xsd:element ref="xlf:internal-file"/>
          <xsd:element ref="xlf:external-file"/>
        </xsd:choice>
      </xsd:complexType>
      <xsd:simpleType name="AttrType_purpose">
        <xsd:list>
          <xsd:simpleType>
            <xsd:union memberTypes="xlf:purposeValueList xlf:XTend"/>
          </xsd:simpleType>
        </xsd:list>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_datatype">
        <xsd:union memberTypes="xlf:datatypeValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_restype">
        <xsd:union memberTypes="xlf:restypeValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_alttranstype">
        <xsd:union memberTypes="xlf:alttranstypeValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_context-type">
        <xsd:union memberTypes="xlf:context-typeValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_state">
        <xsd:union memberTypes="xlf:stateValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_state-qualifier">
        <xsd:union memberTypes="xlf:state-qualifierValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_count-type">
        <xsd:union memberTypes="xlf:restypeValueList xlf:count-typeValueList xlf:datatypeValueList xlf:stateValueList xlf:state-qualifierValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_InlineDelimiters">
        <xsd:union memberTypes="xlf:InlineDelimitersValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_InlinePlaceholders">
        <xsd:union memberTypes="xlf:InlinePlaceholdersValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_size-unit">
        <xsd:union memberTypes="xlf:size-unitValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_mtype">
        <xsd:union memberTypes="xlf:mtypeValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_unit">
        <xsd:union memberTypes="xlf:unitValueList xlf:XTend"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_priority">
        <xsd:union memberTypes="xlf:priorityValueList"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_reformat">
        <xsd:union memberTypes="xlf:reformatValueYesNo xlf:reformatValueList"/>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_YesNo">
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="yes"/>
          <xsd:enumeration value="no"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_Position">
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="open"/>
          <xsd:enumeration value="close"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_assoc">
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="preceding"/>
          <xsd:enumeration value="following"/>
          <xsd:enumeration value="both"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_annotates">
        <xsd:restriction base="xsd:NMTOKEN">
          <xsd:enumeration value="source"/>
          <xsd:enumeration value="target"/>
          <xsd:enumeration value="general"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_Coordinates">
        <xsd:annotation>
          <xsd:documentation>Values for the attribute 'coord'.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:pattern value="(-?\d+|#);(-?\d+|#);(-?\d+|#);(-?\d+|#)"/>
        </xsd:restriction>
      </xsd:simpleType>
      <xsd:simpleType name="AttrType_Version">
        <xsd:annotation>
          <xsd:documentation>Version values: 1.0 and 1.1 are allowed for backward compatibility.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="1.2"/>
          <xsd:enumeration value="1.1"/>
          <xsd:enumeration value="1.0"/>
        </xsd:restriction>
      </xsd:simpleType>
      <!-- Groups -->
      <xsd:group name="ElemGroup_TextContent">
        <xsd:choice>
          <xsd:element ref="xlf:g"/>
          <xsd:element ref="xlf:bpt"/>
          <xsd:element ref="xlf:ept"/>
          <xsd:element ref="xlf:ph"/>
          <xsd:element ref="xlf:it"/>
          <xsd:element ref="xlf:mrk"/>
          <xsd:element ref="xlf:x"/>
          <xsd:element ref="xlf:bx"/>
          <xsd:element ref="xlf:ex"/>
        </xsd:choice>
      </xsd:group>
      <xsd:attributeGroup name="AttrGroup_TextContent">
        <xsd:attribute name="id" type="xsd:string" use="required"/>
        <xsd:attribute name="xid" type="xsd:string" use="optional"/>
        <xsd:attribute name="equiv-text" type="xsd:string" use="optional"/>
        <xsd:anyAttribute namespace="##other" processContents="strict"/>
      </xsd:attributeGroup>
      <!-- XLIFF Structure -->
      <xsd:element name="xliff">
        <xsd:complexType>
          <xsd:sequence maxOccurs="unbounded">
            <xsd:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="strict"/>
            <xsd:element ref="xlf:file"/>
          </xsd:sequence>
          <xsd:attribute name="version" type="xlf:AttrType_Version" use="required"/>
          <xsd:attribute ref="xml:lang" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="file">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element minOccurs="0" ref="xlf:header"/>
            <xsd:element ref="xlf:body"/>
          </xsd:sequence>
          <xsd:attribute name="original" type="xsd:string" use="required"/>
          <xsd:attribute name="source-language" type="xsd:language" use="required"/>
          <xsd:attribute name="datatype" type="xlf:AttrType_datatype" use="required"/>
          <xsd:attribute name="tool-id" type="xsd:string" use="optional"/>
          <xsd:attribute name="date" type="xsd:dateTime" use="optional"/>
          <xsd:attribute ref="xml:space" use="optional"/>
          <xsd:attribute name="category" type="xsd:string" use="optional"/>
          <xsd:attribute name="target-language" type="xsd:language" use="optional"/>
          <xsd:attribute name="product-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="product-version" type="xsd:string" use="optional"/>
          <xsd:attribute name="build-num" type="xsd:string" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
        <xsd:unique name="U_group_id">
          <xsd:selector xpath=".//xlf:group"/>
          <xsd:field xpath="@id"/>
        </xsd:unique>
        <xsd:key name="K_unit_id">
          <xsd:selector xpath=".//xlf:trans-unit|.//xlf:bin-unit"/>
          <xsd:field xpath="@id"/>
        </xsd:key>
        <xsd:keyref name="KR_unit_id" refer="xlf:K_unit_id">
          <xsd:selector xpath=".//bpt|.//ept|.//it|.//ph|.//g|.//x|.//bx|.//ex|.//sub"/>
          <xsd:field xpath="@xid"/>
        </xsd:keyref>
        <xsd:key name="K_tool-id">
          <xsd:selector xpath="xlf:header/xlf:tool"/>
          <xsd:field xpath="@tool-id"/>
        </xsd:key>
        <xsd:keyref name="KR_file_tool-id" refer="xlf:K_tool-id">
          <xsd:selector xpath="."/>
          <xsd:field xpath="@tool-id"/>
        </xsd:keyref>
        <xsd:keyref name="KR_phase_tool-id" refer="xlf:K_tool-id">
          <xsd:selector xpath="xlf:header/xlf:phase-group/xlf:phase"/>
          <xsd:field xpath="@tool-id"/>
        </xsd:keyref>
        <xsd:keyref name="KR_alt-trans_tool-id" refer="xlf:K_tool-id">
          <xsd:selector xpath=".//xlf:trans-unit/xlf:alt-trans"/>
          <xsd:field xpath="@tool-id"/>
        </xsd:keyref>
        <xsd:key name="K_count-group_name">
          <xsd:selector xpath=".//xlf:count-group"/>
          <xsd:field xpath="@name"/>
        </xsd:key>
        <xsd:unique name="U_context-group_name">
          <xsd:selector xpath=".//xlf:context-group"/>
          <xsd:field xpath="@name"/>
        </xsd:unique>
        <xsd:key name="K_phase-name">
          <xsd:selector xpath="xlf:header/xlf:phase-group/xlf:phase"/>
          <xsd:field xpath="@phase-name"/>
        </xsd:key>
        <xsd:keyref name="KR_phase-name" refer="xlf:K_phase-name">
          <xsd:selector xpath=".//xlf:count|.//xlf:trans-unit|.//xlf:target|.//bin-unit|.//bin-target"/>
          <xsd:field xpath="@phase-name"/>
        </xsd:keyref>
        <xsd:unique name="U_uid">
          <xsd:selector xpath=".//xlf:external-file"/>
          <xsd:field xpath="@uid"/>
        </xsd:unique>
      </xsd:element>
      <xsd:element name="header">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element minOccurs="0" name="skl" type="xlf:ElemType_ExternalReference"/>
            <xsd:element minOccurs="0" ref="xlf:phase-group"/>
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
              <xsd:element name="glossary" type="xlf:ElemType_ExternalReference"/>
              <xsd:element name="reference" type="xlf:ElemType_ExternalReference"/>
              <xsd:element ref="xlf:count-group"/>
              <xsd:element ref="xlf:note"/>
              <xsd:element ref="xlf:tool"/>
            </xsd:choice>
            <xsd:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="strict"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="internal-file">
        <xsd:complexType>
          <xsd:simpleContent>
            <xsd:extension base="xsd:string">
              <xsd:attribute name="form" type="xsd:string"/>
              <xsd:attribute name="crc" type="xsd:NMTOKEN"/>
            </xsd:extension>
          </xsd:simpleContent>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="external-file">
        <xsd:complexType>
          <xsd:attribute name="href" type="xsd:string" use="required"/>
          <xsd:attribute name="crc" type="xsd:NMTOKEN"/>
          <xsd:attribute name="uid" type="xsd:NMTOKEN"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="note">
        <xsd:complexType>
          <xsd:simpleContent>
            <xsd:extension base="xsd:string">
              <xsd:attribute ref="xml:lang" use="optional"/>
              <xsd:attribute default="1" name="priority" type="xlf:AttrType_priority" use="optional"/>
              <xsd:attribute name="from" type="xsd:string" use="optional"/>
              <xsd:attribute default="general" name="annotates" type="xlf:AttrType_annotates" use="optional"/>
            </xsd:extension>
          </xsd:simpleContent>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="phase-group">
        <xsd:complexType>
          <xsd:sequence maxOccurs="unbounded">
            <xsd:element ref="xlf:phase"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="phase">
        <xsd:complexType>
          <xsd:sequence maxOccurs="unbounded" minOccurs="0">
            <xsd:element ref="xlf:note"/>
          </xsd:sequence>
          <xsd:attribute name="phase-name" type="xsd:string" use="required"/>
          <xsd:attribute name="process-name" type="xsd:string" use="required"/>
          <xsd:attribute name="company-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="tool-id" type="xsd:string" use="optional"/>
          <xsd:attribute name="date" type="xsd:dateTime" use="optional"/>
          <xsd:attribute name="job-id" type="xsd:string" use="optional"/>
          <xsd:attribute name="contact-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="contact-email" type="xsd:string" use="optional"/>
          <xsd:attribute name="contact-phone" type="xsd:string" use="optional"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="count-group">
        <xsd:complexType>
          <xsd:sequence maxOccurs="unbounded" minOccurs="0">
            <xsd:element ref="xlf:count"/>
          </xsd:sequence>
          <xsd:attribute name="name" type="xsd:string" use="required"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="count">
        <xsd:complexType>
          <xsd:simpleContent>
            <xsd:extension base="xsd:string">
              <xsd:attribute name="count-type" type="xlf:AttrType_count-type" use="optional"/>
              <xsd:attribute name="phase-name" type="xsd:string" use="optional"/>
              <xsd:attribute default="word" name="unit" type="xlf:AttrType_unit" use="optional"/>
            </xsd:extension>
          </xsd:simpleContent>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="context-group">
        <xsd:complexType>
          <xsd:sequence maxOccurs="unbounded">
            <xsd:element ref="xlf:context"/>
          </xsd:sequence>
          <xsd:attribute name="name" type="xsd:string" use="optional"/>
          <xsd:attribute name="crc" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="purpose" type="xlf:AttrType_purpose" use="optional"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="context">
        <xsd:complexType>
          <xsd:simpleContent>
            <xsd:extension base="xsd:string">
              <xsd:attribute name="context-type" type="xlf:AttrType_context-type" use="required"/>
              <xsd:attribute default="no" name="match-mandatory" type="xlf:AttrType_YesNo" use="optional"/>
              <xsd:attribute name="crc" type="xsd:NMTOKEN" use="optional"/>
            </xsd:extension>
          </xsd:simpleContent>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="tool">
        <xsd:complexType mixed="true">
          <xsd:sequence>
            <xsd:any namespace="##any" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
          <xsd:attribute name="tool-id" type="xsd:string" use="required"/>
          <xsd:attribute name="tool-name" type="xsd:string" use="required"/>
          <xsd:attribute name="tool-version" type="xsd:string" use="optional"/>
          <xsd:attribute name="tool-company" type="xsd:string" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="body">
        <xsd:complexType>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:group"/>
            <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:trans-unit"/>
            <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:bin-unit"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="group">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:sequence>
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:context-group"/>
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:count-group"/>
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:note"/>
              <xsd:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="strict"/>
            </xsd:sequence>
            <xsd:choice maxOccurs="unbounded">
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:group"/>
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:trans-unit"/>
              <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:bin-unit"/>
            </xsd:choice>
          </xsd:sequence>
          <xsd:attribute name="id" type="xsd:string" use="optional"/>
          <xsd:attribute name="datatype" type="xlf:AttrType_datatype" use="optional"/>
          <xsd:attribute default="default" ref="xml:space" use="optional"/>
          <xsd:attribute name="restype" type="xlf:AttrType_restype" use="optional"/>
          <xsd:attribute name="resname" type="xsd:string" use="optional"/>
          <xsd:attribute name="extradata" type="xsd:string" use="optional"/>
          <xsd:attribute name="extype" type="xsd:string" use="optional"/>
          <xsd:attribute name="help-id" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="menu" type="xsd:string" use="optional"/>
          <xsd:attribute name="menu-option" type="xsd:string" use="optional"/>
          <xsd:attribute name="menu-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="coord" type="xlf:AttrType_Coordinates" use="optional"/>
          <xsd:attribute name="font" type="xsd:string" use="optional"/>
          <xsd:attribute name="css-style" type="xsd:string" use="optional"/>
          <xsd:attribute name="style" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="exstyle" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute default="yes" name="translate" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attribute default="yes" name="reformat" type="xlf:AttrType_reformat" use="optional"/>
          <xsd:attribute default="pixel" name="size-unit" type="xlf:AttrType_size-unit" use="optional"/>
          <xsd:attribute name="maxwidth" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="minwidth" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="maxheight" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="minheight" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="maxbytes" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="minbytes" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="charclass" type="xsd:string" use="optional"/>
          <xsd:attribute default="no" name="merged-trans" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="trans-unit">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element ref="xlf:source"/>
            <xsd:element minOccurs="0" ref="xlf:seg-source"/>
            <xsd:element minOccurs="0" ref="xlf:target"/>
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
              <xsd:element ref="xlf:context-group"/>
              <xsd:element ref="xlf:count-group"/>
              <xsd:element ref="xlf:note"/>
              <xsd:element ref="xlf:alt-trans"/>
            </xsd:choice>
            <xsd:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="strict"/>
          </xsd:sequence>
          <xsd:attribute name="id" type="xsd:string" use="required"/>
          <xsd:attribute name="approved" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attribute default="yes" name="translate" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attribute default="yes" name="reformat" type="xlf:AttrType_reformat" use="optional"/>
          <xsd:attribute default="default" ref="xml:space" use="optional"/>
          <xsd:attribute name="datatype" type="xlf:AttrType_datatype" use="optional"/>
          <xsd:attribute name="phase-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="restype" type="xlf:AttrType_restype" use="optional"/>
          <xsd:attribute name="resname" type="xsd:string" use="optional"/>
          <xsd:attribute name="extradata" type="xsd:string" use="optional"/>
          <xsd:attribute name="extype" type="xsd:string" use="optional"/>
          <xsd:attribute name="help-id" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="menu" type="xsd:string" use="optional"/>
          <xsd:attribute name="menu-option" type="xsd:string" use="optional"/>
          <xsd:attribute name="menu-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="coord" type="xlf:AttrType_Coordinates" use="optional"/>
          <xsd:attribute name="font" type="xsd:string" use="optional"/>
          <xsd:attribute name="css-style" type="xsd:string" use="optional"/>
          <xsd:attribute name="style" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="exstyle" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute default="pixel" name="size-unit" type="xlf:AttrType_size-unit" use="optional"/>
          <xsd:attribute name="maxwidth" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="minwidth" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="maxheight" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="minheight" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="maxbytes" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="minbytes" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="charclass" type="xsd:string" use="optional"/>
          <xsd:attribute default="yes" name="merged-trans" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
        <xsd:unique name="U_tu_segsrc_mid">
          <xsd:selector xpath="./xlf:seg-source/xlf:mrk"/>
          <xsd:field xpath="@mid"/>
        </xsd:unique>
        <xsd:keyref name="KR_tu_segsrc_mid" refer="xlf:U_tu_segsrc_mid">
          <xsd:selector xpath="./xlf:target/xlf:mrk|./xlf:alt-trans"/>
          <xsd:field xpath="@mid"/>
        </xsd:keyref>
      </xsd:element>
      <xsd:element name="source">
        <xsd:complexType mixed="true">
          <xsd:group maxOccurs="unbounded" minOccurs="0" ref="xlf:ElemGroup_TextContent"/>
          <xsd:attribute ref="xml:lang" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
        <xsd:unique name="U_source_bpt_rid">
          <xsd:selector xpath=".//xlf:bpt"/>
          <xsd:field xpath="@rid"/>
        </xsd:unique>
        <xsd:keyref name="KR_source_ept_rid" refer="xlf:U_source_bpt_rid">
          <xsd:selector xpath=".//xlf:ept"/>
          <xsd:field xpath="@rid"/>
        </xsd:keyref>
        <xsd:unique name="U_source_bx_rid">
          <xsd:selector xpath=".//xlf:bx"/>
          <xsd:field xpath="@rid"/>
        </xsd:unique>
        <xsd:keyref name="KR_source_ex_rid" refer="xlf:U_source_bx_rid">
          <xsd:selector xpath=".//xlf:ex"/>
          <xsd:field xpath="@rid"/>
        </xsd:keyref>
      </xsd:element>
      <xsd:element name="seg-source">
        <xsd:complexType mixed="true">
          <xsd:group maxOccurs="unbounded" minOccurs="0" ref="xlf:ElemGroup_TextContent"/>
          <xsd:attribute ref="xml:lang" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
        <xsd:unique name="U_segsrc_bpt_rid">
          <xsd:selector xpath=".//xlf:bpt"/>
          <xsd:field xpath="@rid"/>
        </xsd:unique>
        <xsd:keyref name="KR_segsrc_ept_rid" refer="xlf:U_segsrc_bpt_rid">
          <xsd:selector xpath=".//xlf:ept"/>
          <xsd:field xpath="@rid"/>
        </xsd:keyref>
        <xsd:unique name="U_segsrc_bx_rid">
          <xsd:selector xpath=".//xlf:bx"/>
          <xsd:field xpath="@rid"/>
        </xsd:unique>
        <xsd:keyref name="KR_segsrc_ex_rid" refer="xlf:U_segsrc_bx_rid">
          <xsd:selector xpath=".//xlf:ex"/>
          <xsd:field xpath="@rid"/>
        </xsd:keyref>
      </xsd:element>
      <xsd:element name="target">
        <xsd:complexType mixed="true">
          <xsd:group maxOccurs="unbounded" minOccurs="0" ref="xlf:ElemGroup_TextContent"/>
          <xsd:attribute name="state" type="xlf:AttrType_state" use="optional"/>
          <xsd:attribute name="state-qualifier" type="xlf:AttrType_state-qualifier" use="optional"/>
          <xsd:attribute name="phase-name" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute ref="xml:lang" use="optional"/>
          <xsd:attribute name="resname" type="xsd:string" use="optional"/>
          <xsd:attribute name="coord" type="xlf:AttrType_Coordinates" use="optional"/>
          <xsd:attribute name="font" type="xsd:string" use="optional"/>
          <xsd:attribute name="css-style" type="xsd:string" use="optional"/>
          <xsd:attribute name="style" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="exstyle" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute default="yes" name="equiv-trans" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
        <xsd:unique name="U_target_bpt_rid">
          <xsd:selector xpath=".//xlf:bpt"/>
          <xsd:field xpath="@rid"/>
        </xsd:unique>
        <xsd:keyref name="KR_target_ept_rid" refer="xlf:U_target_bpt_rid">
          <xsd:selector xpath=".//xlf:ept"/>
          <xsd:field xpath="@rid"/>
        </xsd:keyref>
        <xsd:unique name="U_target_bx_rid">
          <xsd:selector xpath=".//xlf:bx"/>
          <xsd:field xpath="@rid"/>
        </xsd:unique>
        <xsd:keyref name="KR_target_ex_rid" refer="xlf:U_target_bx_rid">
          <xsd:selector xpath=".//xlf:ex"/>
          <xsd:field xpath="@rid"/>
        </xsd:keyref>
      </xsd:element>
      <xsd:element name="alt-trans">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element minOccurs="0" ref="xlf:source"/>
            <xsd:element minOccurs="0" ref="xlf:seg-source"/>
            <xsd:element maxOccurs="1" ref="xlf:target"/>
            <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:context-group"/>
            <xsd:element maxOccurs="unbounded" minOccurs="0" ref="xlf:note"/>
            <xsd:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="strict"/>
          </xsd:sequence>
          <xsd:attribute name="match-quality" type="xsd:string" use="optional"/>
          <xsd:attribute name="tool-id" type="xsd:string" use="optional"/>
          <xsd:attribute name="crc" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute ref="xml:lang" use="optional"/>
          <xsd:attribute name="origin" type="xsd:string" use="optional"/>
          <xsd:attribute name="datatype" type="xlf:AttrType_datatype" use="optional"/>
          <xsd:attribute default="default" ref="xml:space" use="optional"/>
          <xsd:attribute name="restype" type="xlf:AttrType_restype" use="optional"/>
          <xsd:attribute name="resname" type="xsd:string" use="optional"/>
          <xsd:attribute name="extradata" type="xsd:string" use="optional"/>
          <xsd:attribute name="extype" type="xsd:string" use="optional"/>
          <xsd:attribute name="help-id" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="menu" type="xsd:string" use="optional"/>
          <xsd:attribute name="menu-option" type="xsd:string" use="optional"/>
          <xsd:attribute name="menu-name" type="xsd:string" use="optional"/>
          <xsd:attribute name="mid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="coord" type="xlf:AttrType_Coordinates" use="optional"/>
          <xsd:attribute name="font" type="xsd:string" use="optional"/>
          <xsd:attribute name="css-style" type="xsd:string" use="optional"/>
          <xsd:attribute name="style" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="exstyle" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="phase-name" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute default="proposal" name="alttranstype" type="xlf:AttrType_alttranstype" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
        <xsd:unique name="U_at_segsrc_mid">
          <xsd:selector xpath="./xlf:seg-source/xlf:mrk"/>
          <xsd:field xpath="@mid"/>
        </xsd:unique>
        <xsd:keyref name="KR_at_segsrc_mid" refer="xlf:U_at_segsrc_mid">
          <xsd:selector xpath="./xlf:target/xlf:mrk"/>
          <xsd:field xpath="@mid"/>
        </xsd:keyref>
      </xsd:element>
      <xsd:element name="bin-unit">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element ref="xlf:bin-source"/>
            <xsd:element minOccurs="0" ref="xlf:bin-target"/>
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
              <xsd:element ref="xlf:context-group"/>
              <xsd:element ref="xlf:count-group"/>
              <xsd:element ref="xlf:note"/>
              <xsd:element ref="xlf:trans-unit"/>
            </xsd:choice>
            <xsd:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="strict"/>
          </xsd:sequence>
          <xsd:attribute name="id" type="xsd:string" use="required"/>
          <xsd:attribute name="mime-type" type="xlf:mime-typeValueList" use="required"/>
          <xsd:attribute name="approved" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attribute default="yes" name="translate" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attribute default="yes" name="reformat" type="xlf:AttrType_reformat" use="optional"/>
          <xsd:attribute name="restype" type="xlf:AttrType_restype" use="optional"/>
          <xsd:attribute name="resname" type="xsd:string" use="optional"/>
          <xsd:attribute name="phase-name" type="xsd:string" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="bin-source">
        <xsd:complexType>
          <xsd:choice>
            <xsd:element ref="xlf:internal-file"/>
            <xsd:element ref="xlf:external-file"/>
          </xsd:choice>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="bin-target">
        <xsd:complexType>
          <xsd:choice>
            <xsd:element ref="xlf:internal-file"/>
            <xsd:element ref="xlf:external-file"/>
          </xsd:choice>
          <xsd:attribute name="mime-type" type="xlf:mime-typeValueList" use="optional"/>
          <xsd:attribute name="state" type="xlf:AttrType_state" use="optional"/>
          <xsd:attribute name="state-qualifier" type="xlf:AttrType_state-qualifier" use="optional"/>
          <xsd:attribute name="phase-name" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="restype" type="xlf:AttrType_restype" use="optional"/>
          <xsd:attribute name="resname" type="xsd:string" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
      <!-- Element for inline codes -->
      <xsd:element name="g">
        <xsd:complexType mixed="true">
          <xsd:group maxOccurs="unbounded" minOccurs="0" ref="xlf:ElemGroup_TextContent"/>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlineDelimiters" use="optional"/>
          <xsd:attribute default="yes" name="clone" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="x">
        <xsd:complexType>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlinePlaceholders" use="optional"/>
          <xsd:attribute default="yes" name="clone" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="bx">
        <xsd:complexType>
          <xsd:attribute name="rid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlineDelimiters" use="optional"/>
          <xsd:attribute default="yes" name="clone" type="xlf:AttrType_YesNo" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="ex">
        <xsd:complexType>
          <xsd:attribute name="rid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="ph">
        <xsd:complexType mixed="true">
          <xsd:sequence maxOccurs="unbounded" minOccurs="0">
            <xsd:element ref="xlf:sub"/>
          </xsd:sequence>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlinePlaceholders" use="optional"/>
          <xsd:attribute name="crc" type="xsd:string" use="optional"/>
          <xsd:attribute name="assoc" type="xlf:AttrType_assoc" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="bpt">
        <xsd:complexType mixed="true">
          <xsd:sequence maxOccurs="unbounded" minOccurs="0">
            <xsd:element ref="xlf:sub"/>
          </xsd:sequence>
          <xsd:attribute name="rid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlineDelimiters" use="optional"/>
          <xsd:attribute name="crc" type="xsd:string" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="ept">
        <xsd:complexType mixed="true">
          <xsd:sequence maxOccurs="unbounded" minOccurs="0">
            <xsd:element ref="xlf:sub"/>
          </xsd:sequence>
          <xsd:attribute name="rid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="crc" type="xsd:string" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="it">
        <xsd:complexType mixed="true">
          <xsd:sequence maxOccurs="unbounded" minOccurs="0">
            <xsd:element ref="xlf:sub"/>
          </xsd:sequence>
          <xsd:attribute name="pos" type="xlf:AttrType_Position" use="required"/>
          <xsd:attribute name="rid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlineDelimiters" use="optional"/>
          <xsd:attribute name="crc" type="xsd:string" use="optional"/>
          <xsd:attributeGroup ref="xlf:AttrGroup_TextContent"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="sub">
        <xsd:complexType mixed="true">
          <xsd:group maxOccurs="unbounded" minOccurs="0" ref="xlf:ElemGroup_TextContent"/>
          <xsd:attribute name="datatype" type="xlf:AttrType_datatype" use="optional"/>
          <xsd:attribute name="ctype" type="xlf:AttrType_InlineDelimiters" use="optional"/>
          <xsd:attribute name="xid" type="xsd:string" use="optional"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="mrk">
        <xsd:complexType mixed="true">
          <xsd:group maxOccurs="unbounded" minOccurs="0" ref="xlf:ElemGroup_TextContent"/>
          <xsd:attribute name="mtype" type="xlf:AttrType_mtype" use="required"/>
          <xsd:attribute name="mid" type="xsd:NMTOKEN" use="optional"/>
          <xsd:attribute name="comment" type="xsd:string" use="optional"/>
          <xsd:anyAttribute namespace="##other" processContents="strict"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>
  uploads-Carbon-vendor-symfony-translation-Resources-schemas-xliff-core-2.0.xsd: |
    <?xml version="1.0" encoding="UTF-8"?>
    <!--

        XLIFF Version 2.0
        OASIS Standard
        05 August 2014
        Copyright (c) OASIS Open 2014. All rights reserved.
        Source: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/schemas/
         -->
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        elementFormDefault="qualified"
        xmlns:xlf="urn:oasis:names:tc:xliff:document:2.0"
        targetNamespace="urn:oasis:names:tc:xliff:document:2.0">

      <!-- Import -->

      <xs:import namespace="http://www.w3.org/XML/1998/namespace"
          schemaLocation="informativeCopiesOf3rdPartySchemas/w3c/xml.xsd"/>

      <!-- Element Group -->

      <xs:group name="inline">
        <xs:choice>
          <xs:element ref="xlf:cp"/>
          <xs:element ref="xlf:ph"/>
          <xs:element ref="xlf:pc"/>
          <xs:element ref="xlf:sc"/>
          <xs:element ref="xlf:ec"/>
          <xs:element ref="xlf:mrk"/>
          <xs:element ref="xlf:sm"/>
          <xs:element ref="xlf:em"/>
        </xs:choice>
      </xs:group>

      <!-- Attribute Types -->

      <xs:simpleType name="yesNo">
        <xs:restriction base="xs:string">
          <xs:enumeration value="yes"/>
          <xs:enumeration value="no"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="yesNoFirstNo">
        <xs:restriction base="xs:string">
          <xs:enumeration value="yes"/>
          <xs:enumeration value="firstNo"/>
          <xs:enumeration value="no"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="dirValue">
        <xs:restriction base="xs:string">
          <xs:enumeration value="ltr"/>
          <xs:enumeration value="rtl"/>
          <xs:enumeration value="auto"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="appliesTo">
        <xs:restriction base="xs:string">
          <xs:enumeration value="source"/>
          <xs:enumeration value="target"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="userDefinedValue">
        <xs:restriction base="xs:string">
          <xs:pattern value="[^\s:]+:[^\s:]+"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="attrType_type">
        <xs:restriction base="xs:string">
          <xs:enumeration value="fmt"/>
          <xs:enumeration value="ui"/>
          <xs:enumeration value="quote"/>
          <xs:enumeration value="link"/>
          <xs:enumeration value="image"/>
          <xs:enumeration value="other"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="typeForMrkValues">
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="generic"/>
          <xs:enumeration value="comment"/>
          <xs:enumeration value="term"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="attrType_typeForMrk">
        <xs:union memberTypes="xlf:typeForMrkValues xlf:userDefinedValue"/>
      </xs:simpleType>

      <xs:simpleType name="priorityValue">
        <xs:restriction base="xs:positiveInteger">
          <xs:minInclusive value="1"/>
          <xs:maxInclusive value="10"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="stateType">
        <xs:restriction base="xs:string">
          <xs:enumeration value="initial"/>
          <xs:enumeration value="translated"/>
          <xs:enumeration value="reviewed"/>
          <xs:enumeration value="final"/>
        </xs:restriction>
      </xs:simpleType>

      <!-- Structural Elements -->

      <xs:element name="xliff">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" ref="xlf:file"/>
          </xs:sequence>
          <xs:attribute name="version" use="required"/>
          <xs:attribute name="srcLang" use="required"/>
          <xs:attribute name="trgLang" use="optional"/>
          <xs:attribute ref="xml:space" use="optional" default="default"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="file">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:skeleton"/>
            <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##other"
                processContents="lax"/>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:notes"/>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
              <xs:element ref="xlf:unit"/>
              <xs:element ref="xlf:group"/>
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="canResegment" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="original" use="optional"/>
          <xs:attribute name="translate" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="srcDir" use="optional" type="xlf:dirValue" default="auto"/>
          <xs:attribute name="trgDir" use="optional" type="xlf:dirValue" default="auto"/>
          <xs:attribute ref="xml:space" use="optional"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="skeleton">
        <xs:complexType mixed="true">
          <xs:sequence>
            <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##other"
                processContents="lax"/>
          </xs:sequence>
          <xs:attribute name="href" use="optional"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="group">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##other"
                processContents="lax"/>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:notes"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="xlf:unit"/>
              <xs:element ref="xlf:group"/>
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="name" use="optional"/>
          <xs:attribute name="canResegment" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="translate" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="srcDir" use="optional" type="xlf:dirValue"/>
          <xs:attribute name="trgDir" use="optional" type="xlf:dirValue"/>
          <xs:attribute name="type" use="optional" type="xlf:userDefinedValue"/>
          <xs:attribute ref="xml:space" use="optional"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="unit">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##other"
                processContents="lax"/>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:notes"/>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:originalData"/>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
              <xs:element ref="xlf:segment"/>
              <xs:element ref="xlf:ignorable"/>
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="name" use="optional"/>
          <xs:attribute name="canResegment" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="translate" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="srcDir" use="optional" type="xlf:dirValue"/>
          <xs:attribute name="trgDir" use="optional" type="xlf:dirValue"/>
          <xs:attribute ref="xml:space" use="optional"/>
          <xs:attribute name="type" use="optional" type="xlf:userDefinedValue"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="segment">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="1" ref="xlf:source"/>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:target"/>
          </xs:sequence>
          <xs:attribute name="id" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="canResegment" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="state" use="optional" type="xlf:stateType" default="initial"/>
          <xs:attribute name="subState" use="optional"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="ignorable">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="1" ref="xlf:source"/>
            <xs:element minOccurs="0" maxOccurs="1" ref="xlf:target"/>
          </xs:sequence>
          <xs:attribute name="id" use="optional" type="xs:NMTOKEN"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="notes">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" ref="xlf:note"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="note">
        <xs:complexType mixed="true">
          <xs:attribute name="id" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="appliesTo" use="optional" type="xlf:appliesTo"/>
          <xs:attribute name="category" use="optional"/>
          <xs:attribute name="priority" use="optional" type="xlf:priorityValue" default="1"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="originalData">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" ref="xlf:data"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="data">
        <xs:complexType mixed="true">
          <xs:sequence>
            <xs:element minOccurs="0" maxOccurs="unbounded" ref="xlf:cp"/>
          </xs:sequence>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="dir" use="optional" type="xlf:dirValue" default="auto"/>
          <xs:attribute ref="xml:space" use="optional" fixed="preserve"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="source">
        <xs:complexType mixed="true">
          <xs:group ref="xlf:inline" minOccurs="0" maxOccurs="unbounded"/>
          <xs:attribute ref="xml:lang" use="optional"/>
          <xs:attribute ref="xml:space" use="optional"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="target">
        <xs:complexType mixed="true">
          <xs:group ref="xlf:inline" minOccurs="0" maxOccurs="unbounded"/>
          <xs:attribute ref="xml:lang" use="optional"/>
          <xs:attribute ref="xml:space" use="optional"/>
          <xs:attribute name="order" use="optional" type="xs:positiveInteger"/>
        </xs:complexType>
      </xs:element>

      <!-- Inline Elements -->

      <xs:element name="cp">
        <!-- Code Point -->
        <xs:complexType mixed="false">
          <xs:attribute name="hex" use="required" type="xs:hexBinary"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="ph">
        <!-- Placeholder -->
        <xs:complexType mixed="false">
          <xs:attribute name="canCopy" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canDelete" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canReorder" use="optional" type="xlf:yesNoFirstNo" default="yes"/>
          <xs:attribute name="copyOf" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="disp" use="optional"/>
          <xs:attribute name="equiv" use="optional"/>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="dataRef" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="subFlows" use="optional" type="xs:NMTOKENS"/>
          <xs:attribute name="subType" use="optional" type="xlf:userDefinedValue"/>
          <xs:attribute name="type" use="optional" type="xlf:attrType_type"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="pc">
        <!-- Paired Code -->
        <xs:complexType mixed="true">
          <xs:group ref="xlf:inline" minOccurs="0" maxOccurs="unbounded"/>
          <xs:attribute name="canCopy" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canDelete" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canOverlap" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="canReorder" use="optional" type="xlf:yesNoFirstNo" default="yes"/>
          <xs:attribute name="copyOf" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="dispEnd" use="optional"/>
          <xs:attribute name="dispStart" use="optional"/>
          <xs:attribute name="equivEnd" use="optional"/>
          <xs:attribute name="equivStart" use="optional"/>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="dataRefEnd" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="dataRefStart" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="subFlowsEnd" use="optional" type="xs:NMTOKENS"/>
          <xs:attribute name="subFlowsStart" use="optional" type="xs:NMTOKENS"/>
          <xs:attribute name="subType" use="optional" type="xlf:userDefinedValue"/>
          <xs:attribute name="type" use="optional" type="xlf:attrType_type"/>
          <xs:attribute name="dir" use="optional" type="xlf:dirValue"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="sc">
        <!-- Start Code -->
        <xs:complexType mixed="false">
          <xs:attribute name="canCopy" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canDelete" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canOverlap" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canReorder" use="optional" type="xlf:yesNoFirstNo" default="yes"/>
          <xs:attribute name="copyOf" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="dataRef" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="dir" use="optional" type="xlf:dirValue"/>
          <xs:attribute name="disp" use="optional"/>
          <xs:attribute name="equiv" use="optional"/>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="isolated" use="optional" type="xlf:yesNo" default="no"/>
          <xs:attribute name="subFlows" use="optional" type="xs:NMTOKENS"/>
          <xs:attribute name="subType" use="optional" type="xlf:userDefinedValue"/>
          <xs:attribute name="type" use="optional" type="xlf:attrType_type"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="ec">
        <!-- End Code -->
        <xs:complexType mixed="false">
          <xs:attribute name="canCopy" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canDelete" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canOverlap" use="optional" type="xlf:yesNo" default="yes"/>
          <xs:attribute name="canReorder" use="optional" type="xlf:yesNoFirstNo" default="yes"/>
          <xs:attribute name="copyOf" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="dataRef" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="dir" use="optional" type="xlf:dirValue"/>
          <xs:attribute name="disp" use="optional"/>
          <xs:attribute name="equiv" use="optional"/>
          <xs:attribute name="id" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="isolated" use="optional" type="xlf:yesNo" default="no"/>
          <xs:attribute name="startRef" use="optional" type="xs:NMTOKEN"/>
          <xs:attribute name="subFlows" use="optional" type="xs:NMTOKENS"/>
          <xs:attribute name="subType" use="optional" type="xlf:userDefinedValue"/>
          <xs:attribute name="type" use="optional" type="xlf:attrType_type"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="mrk">
        <!-- Annotation Marker -->
        <xs:complexType mixed="true">
          <xs:group ref="xlf:inline" minOccurs="0" maxOccurs="unbounded"/>
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="translate" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="type" use="optional" type="xlf:attrType_typeForMrk"/>
          <xs:attribute name="ref" use="optional" type="xs:anyURI"/>
          <xs:attribute name="value" use="optional"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="sm">
        <!-- Start Annotation Marker -->
        <xs:complexType mixed="false">
          <xs:attribute name="id" use="required" type="xs:NMTOKEN"/>
          <xs:attribute name="translate" use="optional" type="xlf:yesNo"/>
          <xs:attribute name="type" use="optional" type="xlf:attrType_typeForMrk"/>
          <xs:attribute name="ref" use="optional" type="xs:anyURI"/>
          <xs:attribute name="value" use="optional"/>
          <xs:anyAttribute namespace="##other" processContents="lax"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="em">
        <!-- End Annotation Marker -->
        <xs:complexType mixed="false">
          <xs:attribute name="startRef" use="required" type="xs:NMTOKEN"/>
        </xs:complexType>
      </xs:element>

    </xs:schema>
  uploads-Carbon-vendor-symfony-translation-Resources-schemas-xml.xsd: "<?xml version='1.0'?>\n<?xml-stylesheet
    href=\"../2008/09/xsd.xsl\" type=\"text/xsl\"?>\n<xs:schema targetNamespace=\"http://www.w3.org/XML/1998/namespace\"
    \n  xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" \n  xmlns =\"http://www.w3.org/1999/xhtml\"\n
    \ xml:lang=\"en\">\n\n <xs:annotation>\n  <xs:documentation>\n   <div>\n    <h1>About
    the XML namespace</h1>\n\n    <div class=\"bodytext\">\n     <p>\n\n      This
    schema document describes the XML namespace, in a form\n      suitable for import
    by other schema documents.\n     </p>\n     <p>\n      See <a href=\"http://www.w3.org/XML/1998/namespace.html\">\n
    \     http://www.w3.org/XML/1998/namespace.html</a> and\n      <a href=\"http://www.w3.org/TR/REC-xml\">\n
    \     http://www.w3.org/TR/REC-xml</a> for information \n      about this namespace.\n
    \    </p>\n\n     <p>\n      Note that local names in this namespace are intended
    to be\n      defined only by the World Wide Web Consortium or its subgroups.\n
    \     The names currently defined in this namespace are listed below.\n      They
    should not be used with conflicting semantics by any Working\n      Group, specification,
    or document instance.\n     </p>\n     <p>   \n      See further below in this
    document for more information about <a\n      href=\"#usage\">how to refer to
    this schema document from your own\n      XSD schema documents</a> and about <a
    href=\"#nsversioning\">the\n      namespace-versioning policy governing this schema
    document</a>.\n     </p>\n    </div>\n   </div>\n\n  </xs:documentation>\n </xs:annotation>\n\n
    <xs:attribute name=\"lang\">\n  <xs:annotation>\n   <xs:documentation>\n    <div>\n
    \    \n      <h3>lang (as an attribute name)</h3>\n      <p>\n\n       denotes
    an attribute whose value\n       is a language code for the natural language of
    the content of\n       any element; its value is inherited.  This name is reserved\n
    \      by virtue of its definition in the XML specification.</p>\n     \n    </div>\n
    \   <div>\n     <h4>Notes</h4>\n     <p>\n      Attempting to install the relevant
    ISO 2- and 3-letter\n      codes as the enumerated possible values is probably
    never\n      going to be a realistic possibility.  \n     </p>\n     <p>\n\n      See
    BCP 47 at <a href=\"http://www.rfc-editor.org/rfc/bcp/bcp47.txt\">\n       http://www.rfc-editor.org/rfc/bcp/bcp47.txt</a>\n
    \     and the IANA language subtag registry at\n      <a href=\"http://www.iana.org/assignments/language-subtag-registry\">\n
    \      http://www.iana.org/assignments/language-subtag-registry</a>\n      for
    further information.\n     </p>\n     <p>\n\n      The union allows for the 'un-declaration'
    of xml:lang with\n      the empty string.\n     </p>\n    </div>\n   </xs:documentation>\n
    \ </xs:annotation>\n  <xs:simpleType>\n   <xs:union memberTypes=\"xs:language\">\n
    \   <xs:simpleType>    \n     <xs:restriction base=\"xs:string\">\n      <xs:enumeration
    value=\"\"/>\n\n     </xs:restriction>\n    </xs:simpleType>\n   </xs:union>\n
    \ </xs:simpleType>\n </xs:attribute>\n\n <xs:attribute name=\"space\">\n  <xs:annotation>\n
    \  <xs:documentation>\n\n    <div>\n     \n      <h3>space (as an attribute name)</h3>\n
    \     <p>\n       denotes an attribute whose\n       value is a keyword indicating
    what whitespace processing\n       discipline is intended for the content of the
    element; its\n       value is inherited.  This name is reserved by virtue of its\n
    \      definition in the XML specification.</p>\n     \n    </div>\n   </xs:documentation>\n
    \ </xs:annotation>\n  <xs:simpleType>\n\n   <xs:restriction base=\"xs:NCName\">\n
    \   <xs:enumeration value=\"default\"/>\n    <xs:enumeration value=\"preserve\"/>\n
    \  </xs:restriction>\n  </xs:simpleType>\n </xs:attribute>\n \n <xs:attribute
    name=\"base\" type=\"xs:anyURI\"> <xs:annotation>\n   <xs:documentation>\n\n    <div>\n
    \    \n      <h3>base (as an attribute name)</h3>\n      <p>\n       denotes an
    attribute whose value\n       provides a URI to be used as the base for interpreting
    any\n       relative URIs in the scope of the element on which it\n       appears;
    its value is inherited.  This name is reserved\n       by virtue of its definition
    in the XML Base specification.</p>\n     \n     <p>\n      See <a\n      href=\"http://www.w3.org/TR/xmlbase/\">http://www.w3.org/TR/xmlbase/</a>\n
    \     for information about this attribute.\n     </p>\n\n    </div>\n   </xs:documentation>\n
    \ </xs:annotation>\n </xs:attribute>\n \n <xs:attribute name=\"id\" type=\"xs:ID\">\n
    \ <xs:annotation>\n   <xs:documentation>\n    <div>\n     \n      <h3>id (as an
    attribute name)</h3> \n      <p>\n\n       denotes an attribute whose value\n
    \      should be interpreted as if declared to be of type ID.\n       This name
    is reserved by virtue of its definition in the\n       xml:id specification.</p>\n
    \    \n     <p>\n      See <a\n      href=\"http://www.w3.org/TR/xml-id/\">http://www.w3.org/TR/xml-id/</a>\n
    \     for information about this attribute.\n     </p>\n    </div>\n   </xs:documentation>\n
    \ </xs:annotation>\n\n </xs:attribute>\n\n <xs:attributeGroup name=\"specialAttrs\">\n
    \ <xs:attribute ref=\"xml:base\"/>\n  <xs:attribute ref=\"xml:lang\"/>\n  <xs:attribute
    ref=\"xml:space\"/>\n  <xs:attribute ref=\"xml:id\"/>\n </xs:attributeGroup>\n\n
    <xs:annotation>\n\n  <xs:documentation>\n   <div>\n   \n    <h3>Father (in any
    context at all)</h3> \n\n    <div class=\"bodytext\">\n     <p>\n      denotes
    Jon Bosak, the chair of \n      the original XML Working Group.  This name is
    reserved by \n      the following decision of the W3C XML Plenary and \n      XML
    Coordination groups:\n     </p>\n     <blockquote>\n       <p>\n\n\tIn appreciation
    for his vision, leadership and\n\tdedication the W3C XML Plenary on this 10th
    day of\n\tFebruary, 2000, reserves for Jon Bosak in perpetuity\n\tthe XML name
    \"xml:Father\".\n       </p>\n     </blockquote>\n    </div>\n   </div>\n  </xs:documentation>\n
    </xs:annotation>\n\n <xs:annotation>\n  <xs:documentation>\n\n   <div xml:id=\"usage\"
    id=\"usage\">\n    <h2><a name=\"usage\">About this schema document</a></h2>\n\n
    \   <div class=\"bodytext\">\n     <p>\n      This schema defines attributes and
    an attribute group suitable\n      for use by schemas wishing to allow <code>xml:base</code>,\n
    \     <code>xml:lang</code>, <code>xml:space</code> or\n      <code>xml:id</code>
    attributes on elements they define.\n     </p>\n\n     <p>\n      To enable this,
    such a schema must import this schema for\n      the XML namespace, e.g. as follows:\n
    \    </p>\n     <pre>\n          &lt;schema.. .>\n          .. .\n           &lt;import
    namespace=\"http://www.w3.org/XML/1998/namespace\"\n                      schemaLocation=\"http://www.w3.org/2001/xml.xsd\"/>\n
    \    </pre>\n     <p>\n      or\n     </p>\n     <pre>\n\n           &lt;import
    namespace=\"http://www.w3.org/XML/1998/namespace\"\n                      schemaLocation=\"http://www.w3.org/2009/01/xml.xsd\"/>\n
    \    </pre>\n     <p>\n      Subsequently, qualified reference to any of the attributes
    or the\n      group defined below will have the desired effect, e.g.\n     </p>\n
    \    <pre>\n          &lt;type.. .>\n          .. .\n           &lt;attributeGroup
    ref=\"xml:specialAttrs\"/>\n     </pre>\n     <p>\n      will define a type which
    will schema-validate an instance element\n      with any of those attributes.\n
    \    </p>\n\n    </div>\n   </div>\n  </xs:documentation>\n </xs:annotation>\n\n
    <xs:annotation>\n  <xs:documentation>\n   <div id=\"nsversioning\" xml:id=\"nsversioning\">\n
    \   <h2><a name=\"nsversioning\">Versioning policy for this schema document</a></h2>\n\n
    \   <div class=\"bodytext\">\n     <p>\n      In keeping with the XML Schema WG's
    standard versioning\n      policy, this schema document will persist at\n      <a
    href=\"http://www.w3.org/2009/01/xml.xsd\">\n       http://www.w3.org/2009/01/xml.xsd</a>.\n
    \    </p>\n     <p>\n      At the date of issue it can also be found at\n      <a
    href=\"http://www.w3.org/2001/xml.xsd\">\n       http://www.w3.org/2001/xml.xsd</a>.\n
    \    </p>\n\n     <p>\n      The schema document at that URI may however change
    in the future,\n      in order to remain compatible with the latest version of
    XML\n      Schema itself, or with the XML namespace itself.  In other words,\n
    \     if the XML Schema or XML namespaces change, the version of this\n      document
    at <a href=\"http://www.w3.org/2001/xml.xsd\">\n       http://www.w3.org/2001/xml.xsd
    \n      </a> \n      will change accordingly; the version at \n      <a href=\"http://www.w3.org/2009/01/xml.xsd\">\n
    \      http://www.w3.org/2009/01/xml.xsd \n      </a> \n      will not change.\n
    \    </p>\n     <p>\n\n      Previous dated (and unchanging) versions of this
    schema \n      document are at:\n     </p>\n     <ul>\n      <li><a href=\"http://www.w3.org/2009/01/xml.xsd\">\n\thttp://www.w3.org/2009/01/xml.xsd</a></li>\n
    \     <li><a href=\"http://www.w3.org/2007/08/xml.xsd\">\n\thttp://www.w3.org/2007/08/xml.xsd</a></li>\n
    \     <li><a href=\"http://www.w3.org/2004/10/xml.xsd\">\n\n\thttp://www.w3.org/2004/10/xml.xsd</a></li>\n
    \     <li><a href=\"http://www.w3.org/2001/03/xml.xsd\">\n\thttp://www.w3.org/2001/03/xml.xsd</a></li>\n
    \    </ul>\n    </div>\n   </div>\n  </xs:documentation>\n </xs:annotation>\n\n</xs:schema>\n"
  uploads-Carbon-vendor-symfony-translation-Translator.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation;

    use Symfony\Component\Config\ConfigCacheFactory;
    use Symfony\Component\Config\ConfigCacheFactoryInterface;
    use Symfony\Component\Config\ConfigCacheInterface;
    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Component\Translation\Exception\LogicException;
    use Symfony\Component\Translation\Exception\NotFoundResourceException;
    use Symfony\Component\Translation\Exception\RuntimeException;
    use Symfony\Component\Translation\Formatter\ChoiceMessageFormatterInterface;
    use Symfony\Component\Translation\Formatter\IntlFormatterInterface;
    use Symfony\Component\Translation\Formatter\MessageFormatter;
    use Symfony\Component\Translation\Formatter\MessageFormatterInterface;
    use Symfony\Component\Translation\Loader\LoaderInterface;
    use Symfony\Component\Translation\TranslatorInterface as LegacyTranslatorInterface;
    use Symfony\Contracts\Translation\TranslatorInterface;

    /**
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Translator implements LegacyTranslatorInterface, TranslatorInterface, TranslatorBagInterface
    {
        /**
         * @var MessageCatalogueInterface[]
         */
        protected $catalogues = [];

        /**
         * @var string
         */
        private $locale;

        /**
         * @var array
         */
        private $fallbackLocales = [];

        /**
         * @var LoaderInterface[]
         */
        private $loaders = [];

        /**
         * @var array
         */
        private $resources = [];

        /**
         * @var MessageFormatterInterface
         */
        private $formatter;

        /**
         * @var string
         */
        private $cacheDir;

        /**
         * @var bool
         */
        private $debug;

        private $cacheVary;

        /**
         * @var ConfigCacheFactoryInterface|null
         */
        private $configCacheFactory;

        /**
         * @var array|null
         */
        private $parentLocales;

        private $hasIntlFormatter;

        /**
         * @throws InvalidArgumentException If a locale contains invalid characters
         */
        public function __construct(?string $locale, MessageFormatterInterface $formatter = null, string $cacheDir = null, bool $debug = false, array $cacheVary = [])
        {
            if (null === $locale) {
                @trigger_error(sprintf('Passing "null" as the $locale argument to %s() is deprecated since Symfony 4.4.', __METHOD__), \E_USER_DEPRECATED);
            }

            $this->setLocale($locale, false);

            if (null === $formatter) {
                $formatter = new MessageFormatter();
            }

            $this->formatter = $formatter;
            $this->cacheDir = $cacheDir;
            $this->debug = $debug;
            $this->cacheVary = $cacheVary;
            $this->hasIntlFormatter = $formatter instanceof IntlFormatterInterface;
        }

        public function setConfigCacheFactory(ConfigCacheFactoryInterface $configCacheFactory)
        {
            $this->configCacheFactory = $configCacheFactory;
        }

        /**
         * Adds a Loader.
         *
         * @param string $format The name of the loader (@see addResource())
         */
        public function addLoader($format, LoaderInterface $loader)
        {
            $this->loaders[$format] = $loader;
        }

        /**
         * Adds a Resource.
         *
         * @param string $format   The name of the loader (@see addLoader())
         * @param mixed  $resource The resource name
         * @param string $locale   The locale
         * @param string $domain   The domain
         *
         * @throws InvalidArgumentException If the locale contains invalid characters
         */
        public function addResource($format, $resource, $locale, $domain = null)
        {
            if (null === $domain) {
                $domain = 'messages';
            }

            if (null === $locale) {
                @trigger_error(sprintf('Passing "null" to the third argument of the "%s" method has been deprecated since Symfony 4.4 and will throw an error in 5.0.', __METHOD__), \E_USER_DEPRECATED);
            }

            $this->assertValidLocale($locale);
            $locale ?: $locale = class_exists(\Locale::class) ? \Locale::getDefault() : 'en';

            $this->resources[$locale][] = [$format, $resource, $domain];

            if (\in_array($locale, $this->fallbackLocales)) {
                $this->catalogues = [];
            } else {
                unset($this->catalogues[$locale]);
            }
        }

        /**
         * {@inheritdoc}
         */
        public function setLocale($locale)
        {
            if (null === $locale && (2 > \func_num_args() || func_get_arg(1))) {
                @trigger_error(sprintf('Passing "null" as the $locale argument to %s() is deprecated since Symfony 4.4.', __METHOD__), \E_USER_DEPRECATED);
            }

            $this->assertValidLocale($locale);
            $this->locale = $locale;
        }

        /**
         * {@inheritdoc}
         */
        public function getLocale()
        {
            return $this->locale ?: (class_exists(\Locale::class) ? \Locale::getDefault() : 'en');
        }

        /**
         * Sets the fallback locales.
         *
         * @throws InvalidArgumentException If a locale contains invalid characters
         */
        public function setFallbackLocales(array $locales)
        {
            // needed as the fallback locales are linked to the already loaded catalogues
            $this->catalogues = [];

            foreach ($locales as $locale) {
                if (null === $locale) {
                    @trigger_error(sprintf('Passing "null" as the $locale argument to %s() is deprecated since Symfony 4.4.', __METHOD__), \E_USER_DEPRECATED);
                }
                $this->assertValidLocale($locale);
            }

            $this->fallbackLocales = $this->cacheVary['fallback_locales'] = $locales;
        }

        /**
         * Gets the fallback locales.
         *
         * @internal since Symfony 4.2
         *
         * @return array The fallback locales
         */
        public function getFallbackLocales()
        {
            return $this->fallbackLocales;
        }

        /**
         * {@inheritdoc}
         */
        public function trans($id, array $parameters = [], $domain = null, $locale = null)
        {
            if ('' === $id = (string) $id) {
                return '';
            }

            if (null === $domain) {
                $domain = 'messages';
            }

            $catalogue = $this->getCatalogue($locale);
            $locale = $catalogue->getLocale();
            while (!$catalogue->defines($id, $domain)) {
                if ($cat = $catalogue->getFallbackCatalogue()) {
                    $catalogue = $cat;
                    $locale = $catalogue->getLocale();
                } else {
                    break;
                }
            }

            if ($this->hasIntlFormatter && $catalogue->defines($id, $domain.MessageCatalogue::INTL_DOMAIN_SUFFIX)) {
                return $this->formatter->formatIntl($catalogue->get($id, $domain), $locale, $parameters);
            }

            return $this->formatter->format($catalogue->get($id, $domain), $locale, $parameters);
        }

        /**
         * {@inheritdoc}
         *
         * @deprecated since Symfony 4.2, use the trans() method instead with a %count% parameter
         */
        public function transChoice($id, $number, array $parameters = [], $domain = null, $locale = null)
        {
            @trigger_error(sprintf('The "%s()" method is deprecated since Symfony 4.2, use the trans() one instead with a "%%count%%" parameter.', __METHOD__), \E_USER_DEPRECATED);

            if ('' === $id = (string) $id) {
                return '';
            }

            if (!$this->formatter instanceof ChoiceMessageFormatterInterface) {
                throw new LogicException(sprintf('The formatter "%s" does not support plural translations.', \get_class($this->formatter)));
            }

            if (null === $domain) {
                $domain = 'messages';
            }

            $catalogue = $this->getCatalogue($locale);
            $locale = $catalogue->getLocale();
            while (!$catalogue->defines($id, $domain)) {
                if ($cat = $catalogue->getFallbackCatalogue()) {
                    $catalogue = $cat;
                    $locale = $catalogue->getLocale();
                } else {
                    break;
                }
            }

            if ($this->hasIntlFormatter && $catalogue->defines($id, $domain.MessageCatalogue::INTL_DOMAIN_SUFFIX)) {
                return $this->formatter->formatIntl($catalogue->get($id, $domain), $locale, ['%count%' => $number] + $parameters);
            }

            return $this->formatter->choiceFormat($catalogue->get($id, $domain), $number, $locale, $parameters);
        }

        /**
         * {@inheritdoc}
         */
        public function getCatalogue($locale = null)
        {
            if (!$locale) {
                $locale = $this->getLocale();
            } else {
                $this->assertValidLocale($locale);
            }

            if (!isset($this->catalogues[$locale])) {
                $this->loadCatalogue($locale);
            }

            return $this->catalogues[$locale];
        }

        /**
         * Gets the loaders.
         *
         * @return array LoaderInterface[]
         */
        protected function getLoaders()
        {
            return $this->loaders;
        }

        /**
         * @param string $locale
         */
        protected function loadCatalogue($locale)
        {
            if (null === $this->cacheDir) {
                $this->initializeCatalogue($locale);
            } else {
                $this->initializeCacheCatalogue($locale);
            }
        }

        /**
         * @param string $locale
         */
        protected function initializeCatalogue($locale)
        {
            $this->assertValidLocale($locale);

            try {
                $this->doLoadCatalogue($locale);
            } catch (NotFoundResourceException $e) {
                if (!$this->computeFallbackLocales($locale)) {
                    throw $e;
                }
            }
            $this->loadFallbackCatalogues($locale);
        }

        private function initializeCacheCatalogue(string $locale): void
        {
            if (isset($this->catalogues[$locale])) {
                /* Catalogue already initialized. */
                return;
            }

            $this->assertValidLocale($locale);
            $cache = $this->getConfigCacheFactory()->cache($this->getCatalogueCachePath($locale),
                function (ConfigCacheInterface $cache) use ($locale) {
                    $this->dumpCatalogue($locale, $cache);
                }
            );

            if (isset($this->catalogues[$locale])) {
                /* Catalogue has been initialized as it was written out to cache. */
                return;
            }

            /* Read catalogue from cache. */
            $this->catalogues[$locale] = include $cache->getPath();
        }

        private function dumpCatalogue(string $locale, ConfigCacheInterface $cache): void
        {
            $this->initializeCatalogue($locale);
            $fallbackContent = $this->getFallbackContent($this->catalogues[$locale]);

            $content = sprintf(<<<EOF
    <?php

    use Symfony\Component\Translation\MessageCatalogue;

    \$catalogue = new MessageCatalogue('%s', %s);

    %s
    return \$catalogue;

    EOF
                ,
                $locale,
                var_export($this->getAllMessages($this->catalogues[$locale]), true),
                $fallbackContent
            );

            $cache->write($content, $this->catalogues[$locale]->getResources());
        }

        private function getFallbackContent(MessageCatalogue $catalogue): string
        {
            $fallbackContent = '';
            $current = '';
            $replacementPattern = '/[^a-z0-9_]/i';
            $fallbackCatalogue = $catalogue->getFallbackCatalogue();
            while ($fallbackCatalogue) {
                $fallback = $fallbackCatalogue->getLocale();
                $fallbackSuffix = ucfirst(preg_replace($replacementPattern, '_', $fallback));
                $currentSuffix = ucfirst(preg_replace($replacementPattern, '_', $current));

                $fallbackContent .= sprintf(<<<'EOF'
    $catalogue%s = new MessageCatalogue('%s', %s);
    $catalogue%s->addFallbackCatalogue($catalogue%s);

    EOF
                    ,
                    $fallbackSuffix,
                    $fallback,
                    var_export($this->getAllMessages($fallbackCatalogue), true),
                    $currentSuffix,
                    $fallbackSuffix
                );
                $current = $fallbackCatalogue->getLocale();
                $fallbackCatalogue = $fallbackCatalogue->getFallbackCatalogue();
            }

            return $fallbackContent;
        }

        private function getCatalogueCachePath(string $locale): string
        {
            return $this->cacheDir.'/catalogue.'.$locale.'.'.strtr(substr(base64_encode(hash('sha256', serialize($this->cacheVary), true)), 0, 7), '/', '_').'.php';
        }

        /**
         * @internal
         */
        protected function doLoadCatalogue(string $locale): void
        {
            $this->catalogues[$locale] = new MessageCatalogue($locale);

            if (isset($this->resources[$locale])) {
                foreach ($this->resources[$locale] as $resource) {
                    if (!isset($this->loaders[$resource[0]])) {
                        if (\is_string($resource[1])) {
                            throw new RuntimeException(sprintf('No loader is registered for the "%s" format when loading the "%s" resource.', $resource[0], $resource[1]));
                        }

                        throw new RuntimeException(sprintf('No loader is registered for the "%s" format.', $resource[0]));
                    }
                    $this->catalogues[$locale]->addCatalogue($this->loaders[$resource[0]]->load($resource[1], $locale, $resource[2]));
                }
            }
        }

        private function loadFallbackCatalogues(string $locale): void
        {
            $current = $this->catalogues[$locale];

            foreach ($this->computeFallbackLocales($locale) as $fallback) {
                if (!isset($this->catalogues[$fallback])) {
                    $this->initializeCatalogue($fallback);
                }

                $fallbackCatalogue = new MessageCatalogue($fallback, $this->getAllMessages($this->catalogues[$fallback]));
                foreach ($this->catalogues[$fallback]->getResources() as $resource) {
                    $fallbackCatalogue->addResource($resource);
                }
                $current->addFallbackCatalogue($fallbackCatalogue);
                $current = $fallbackCatalogue;
            }
        }

        protected function computeFallbackLocales($locale)
        {
            if (null === $this->parentLocales) {
                $this->parentLocales = json_decode(file_get_contents(__DIR__.'/Resources/data/parents.json'), true);
            }

            $originLocale = $locale;
            $locales = [];

            while ($locale) {
                $parent = $this->parentLocales[$locale] ?? null;

                if ($parent) {
                    $locale = 'root' !== $parent ? $parent : null;
                } elseif (\function_exists('locale_parse')) {
                    $localeSubTags = locale_parse($locale);
                    $locale = null;
                    if (1 < \count($localeSubTags)) {
                        array_pop($localeSubTags);
                        $locale = locale_compose($localeSubTags) ?: null;
                    }
                } elseif ($i = strrpos($locale, '_') ?: strrpos($locale, '-')) {
                    $locale = substr($locale, 0, $i);
                } else {
                    $locale = null;
                }

                if (null !== $locale) {
                    $locales[] = $locale;
                }
            }

            foreach ($this->fallbackLocales as $fallback) {
                if ($fallback === $originLocale) {
                    continue;
                }

                $locales[] = $fallback;
            }

            return array_unique($locales);
        }

        /**
         * Asserts that the locale is valid, throws an Exception if not.
         *
         * @param string $locale Locale to tests
         *
         * @throws InvalidArgumentException If the locale contains invalid characters
         */
        protected function assertValidLocale($locale)
        {
            if (!preg_match('/^[a-z0-9@_\\.\\-]*$/i', (string) $locale)) {
                throw new InvalidArgumentException(sprintf('Invalid "%s" locale.', $locale));
            }
        }

        /**
         * Provides the ConfigCache factory implementation, falling back to a
         * default implementation if necessary.
         */
        private function getConfigCacheFactory(): ConfigCacheFactoryInterface
        {
            if (!$this->configCacheFactory) {
                $this->configCacheFactory = new ConfigCacheFactory($this->debug);
            }

            return $this->configCacheFactory;
        }

        private function getAllMessages(MessageCatalogueInterface $catalogue): array
        {
            $allMessages = [];

            foreach ($catalogue->all() as $domain => $messages) {
                if ($intlMessages = $catalogue->all($domain.MessageCatalogue::INTL_DOMAIN_SUFFIX)) {
                    $allMessages[$domain.MessageCatalogue::INTL_DOMAIN_SUFFIX] = $intlMessages;
                    $messages = array_diff_key($messages, $intlMessages);
                }
                if ($messages) {
                    $allMessages[$domain] = $messages;
                }
            }

            return $allMessages;
        }
    }
  uploads-Carbon-vendor-symfony-translation-TranslatorInterface.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation;

    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Contracts\Translation\LocaleAwareInterface;

    /**
     * TranslatorInterface.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @deprecated since Symfony 4.2, use Symfony\Contracts\Translation\TranslatorInterface instead
     */
    interface TranslatorInterface extends LocaleAwareInterface
    {
        /**
         * Translates the given message.
         *
         * @param string      $id         The message id (may also be an object that can be cast to string)
         * @param array       $parameters An array of parameters for the message
         * @param string|null $domain     The domain for the message or null to use the default
         * @param string|null $locale     The locale or null to use the default
         *
         * @return string The translated string
         *
         * @throws InvalidArgumentException If the locale contains invalid characters
         */
        public function trans($id, array $parameters = [], $domain = null, $locale = null);

        /**
         * Translates the given choice message by choosing a translation according to a number.
         *
         * @param string      $id         The message id (may also be an object that can be cast to string)
         * @param int         $number     The number to use to find the index of the message
         * @param array       $parameters An array of parameters for the message
         * @param string|null $domain     The domain for the message or null to use the default
         * @param string|null $locale     The locale or null to use the default
         *
         * @return string The translated string
         *
         * @throws InvalidArgumentException If the locale contains invalid characters
         */
        public function transChoice($id, $number, array $parameters = [], $domain = null, $locale = null);

        /**
         * Sets the current locale.
         *
         * @param string $locale The locale
         *
         * @throws InvalidArgumentException If the locale contains invalid characters
         */
        public function setLocale($locale);

        /**
         * Returns the current locale.
         *
         * @return string The locale
         */
        public function getLocale();
    }
  uploads-Carbon-vendor-symfony-translation-Util-ArrayConverter.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Util;

    /**
     * ArrayConverter generates tree like structure from a message catalogue.
     * e.g. this
     *   'foo.bar1' => 'test1',
     *   'foo.bar2' => 'test2'
     * converts to follows:
     *   foo:
     *     bar1: test1
     *     bar2: test2.
     *
     * @author Gennady Telegin <gtelegin@gmail.com>
     */
    class ArrayConverter
    {
        /**
         * Converts linear messages array to tree-like array.
         * For example this array('foo.bar' => 'value') will be converted to ['foo' => ['bar' => 'value']].
         *
         * @param array $messages Linear messages array
         *
         * @return array Tree-like messages array
         */
        public static function expandToTree(array $messages)
        {
            $tree = [];

            foreach ($messages as $id => $value) {
                $referenceToElement = &self::getElementByPath($tree, explode('.', $id));

                $referenceToElement = $value;

                unset($referenceToElement);
            }

            return $tree;
        }

        private static function &getElementByPath(array &$tree, array $parts)
        {
            $elem = &$tree;
            $parentOfElem = null;

            foreach ($parts as $i => $part) {
                if (isset($elem[$part]) && \is_string($elem[$part])) {
                    /* Process next case:
                     *    'foo': 'test1',
                     *    'foo.bar': 'test2'
                     *
                     * $tree['foo'] was string before we found array {bar: test2}.
                     *  Treat new element as string too, e.g. add $tree['foo.bar'] = 'test2';
                     */
                    $elem = &$elem[implode('.', \array_slice($parts, $i))];
                    break;
                }
                $parentOfElem = &$elem;
                $elem = &$elem[$part];
            }

            if ($elem && \is_array($elem) && $parentOfElem) {
                /* Process next case:
                 *    'foo.bar': 'test1'
                 *    'foo': 'test2'
                 *
                 * $tree['foo'] was array = {bar: 'test1'} before we found string constant `foo`.
                 * Cancel treating $tree['foo'] as array and cancel back it expansion,
                 *  e.g. make it $tree['foo.bar'] = 'test1' again.
                 */
                self::cancelExpand($parentOfElem, $part, $elem);
            }

            return $elem;
        }

        private static function cancelExpand(array &$tree, $prefix, array $node)
        {
            $prefix .= '.';

            foreach ($node as $id => $value) {
                if (\is_string($value)) {
                    $tree[$prefix.$id] = $value;
                } else {
                    self::cancelExpand($tree, $prefix.$id, $value);
                }
            }
        }
    }
  uploads-Carbon-vendor-symfony-translation-Util-XliffUtils.php: |
    <?php

    /*
     * This file is part of the Symfony package.
     *
     * (c) Fabien Potencier <fabien@symfony.com>
     *
     * For the full copyright and license information, please view the LICENSE
     * file that was distributed with this source code.
     */

    namespace Symfony\Component\Translation\Util;

    use Symfony\Component\Translation\Exception\InvalidArgumentException;
    use Symfony\Component\Translation\Exception\InvalidResourceException;

    /**
     * Provides some utility methods for XLIFF translation files, such as validating
     * their contents according to the XSD schema.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class XliffUtils
    {
        /**
         * Gets xliff file version based on the root "version" attribute.
         *
         * Defaults to 1.2 for backwards compatibility.
         *
         * @throws InvalidArgumentException
         */
        public static function getVersionNumber(\DOMDocument $dom): string
        {
            /** @var \DOMNode $xliff */
            foreach ($dom->getElementsByTagName('xliff') as $xliff) {
                $version = $xliff->attributes->getNamedItem('version');
                if ($version) {
                    return $version->nodeValue;
                }

                $namespace = $xliff->attributes->getNamedItem('xmlns');
                if ($namespace) {
                    if (0 !== substr_compare('urn:oasis:names:tc:xliff:document:', $namespace->nodeValue, 0, 34)) {
                        throw new InvalidArgumentException(sprintf('Not a valid XLIFF namespace "%s".', $namespace));
                    }

                    return substr($namespace, 34);
                }
            }

            // Falls back to v1.2
            return '1.2';
        }

        /**
         * Validates and parses the given file into a DOMDocument.
         *
         * @throws InvalidResourceException
         */
        public static function validateSchema(\DOMDocument $dom): array
        {
            $xliffVersion = static::getVersionNumber($dom);
            $internalErrors = libxml_use_internal_errors(true);
            if ($shouldEnable = self::shouldEnableEntityLoader()) {
                $disableEntities = libxml_disable_entity_loader(false);
            }
            try {
                $isValid = @$dom->schemaValidateSource(self::getSchema($xliffVersion));
                if (!$isValid) {
                    return self::getXmlErrors($internalErrors);
                }
            } finally {
                if ($shouldEnable) {
                    libxml_disable_entity_loader($disableEntities);
                }
            }

            $dom->normalizeDocument();

            libxml_clear_errors();
            libxml_use_internal_errors($internalErrors);

            return [];
        }

        private static function shouldEnableEntityLoader(): bool
        {
            // Version prior to 8.0 can be enabled without deprecation
            if (\PHP_VERSION_ID < 80000) {
                return true;
            }

            static $dom, $schema;
            if (null === $dom) {
                $dom = new \DOMDocument();
                $dom->loadXML('<?xml version="1.0"?><test/>');

                $tmpfile = tempnam(sys_get_temp_dir(), 'symfony');
                register_shutdown_function(static function () use ($tmpfile) {
                    @unlink($tmpfile);
                });
                $schema = '<?xml version="1.0" encoding="utf-8"?>
    <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:include schemaLocation="file:///'.str_replace('\\', '/', $tmpfile).'" />
    </xsd:schema>';
                file_put_contents($tmpfile, '<?xml version="1.0" encoding="utf-8"?>
    <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:element name="test" type="testType" />
      <xsd:complexType name="testType"/>
    </xsd:schema>');
            }

            return !@$dom->schemaValidateSource($schema);
        }

        public static function getErrorsAsString(array $xmlErrors): string
        {
            $errorsAsString = '';

            foreach ($xmlErrors as $error) {
                $errorsAsString .= sprintf("[%s %s] %s (in %s - line %d, column %d)\n",
                    \LIBXML_ERR_WARNING === $error['level'] ? 'WARNING' : 'ERROR',
                    $error['code'],
                    $error['message'],
                    $error['file'],
                    $error['line'],
                    $error['column']
                );
            }

            return $errorsAsString;
        }

        private static function getSchema(string $xliffVersion): string
        {
            if ('1.2' === $xliffVersion) {
                $schemaSource = file_get_contents(__DIR__.'/../Resources/schemas/xliff-core-1.2-strict.xsd');
                $xmlUri = 'http://www.w3.org/2001/xml.xsd';
            } elseif ('2.0' === $xliffVersion) {
                $schemaSource = file_get_contents(__DIR__.'/../Resources/schemas/xliff-core-2.0.xsd');
                $xmlUri = 'informativeCopiesOf3rdPartySchemas/w3c/xml.xsd';
            } else {
                throw new InvalidArgumentException(sprintf('No support implemented for loading XLIFF version "%s".', $xliffVersion));
            }

            return self::fixXmlLocation($schemaSource, $xmlUri);
        }

        /**
         * Internally changes the URI of a dependent xsd to be loaded locally.
         */
        private static function fixXmlLocation(string $schemaSource, string $xmlUri): string
        {
            $newPath = str_replace('\\', '/', __DIR__).'/../Resources/schemas/xml.xsd';
            $parts = explode('/', $newPath);
            $locationstart = 'file:///';
            if (0 === stripos($newPath, 'phar://')) {
                $tmpfile = tempnam(sys_get_temp_dir(), 'symfony');
                if ($tmpfile) {
                    copy($newPath, $tmpfile);
                    $parts = explode('/', str_replace('\\', '/', $tmpfile));
                } else {
                    array_shift($parts);
                    $locationstart = 'phar:///';
                }
            }

            $drive = '\\' === \DIRECTORY_SEPARATOR ? array_shift($parts).'/' : '';
            $newPath = $locationstart.$drive.implode('/', array_map('rawurlencode', $parts));

            return str_replace($xmlUri, $newPath, $schemaSource);
        }

        /**
         * Returns the XML errors of the internal XML parser.
         */
        private static function getXmlErrors(bool $internalErrors): array
        {
            $errors = [];
            foreach (libxml_get_errors() as $error) {
                $errors[] = [
                    'level' => \LIBXML_ERR_WARNING == $error->level ? 'WARNING' : 'ERROR',
                    'code' => $error->code,
                    'message' => trim($error->message),
                    'file' => $error->file ?: 'n/a',
                    'line' => $error->line,
                    'column' => $error->column,
                ];
            }

            libxml_clear_errors();
            libxml_use_internal_errors($internalErrors);

            return $errors;
        }
    }
  uploads-Carbon-vendor-symfony-translation-composer.json: |
    {
        "name": "symfony/translation",
        "type": "library",
        "description": "Provides tools to internationalize your application",
        "keywords": [],
        "homepage": "https://symfony.com",
        "license": "MIT",
        "authors": [
            {
                "name": "Fabien Potencier",
                "email": "fabien@symfony.com"
            },
            {
                "name": "Symfony Community",
                "homepage": "https://symfony.com/contributors"
            }
        ],
        "require": {
            "php": ">=7.1.3",
            "symfony/polyfill-mbstring": "~1.0",
            "symfony/polyfill-php80": "^1.16",
            "symfony/translation-contracts": "^1.1.6|^2"
        },
        "require-dev": {
            "symfony/config": "^3.4|^4.0|^5.0",
            "symfony/console": "^3.4|^4.0|^5.0",
            "symfony/dependency-injection": "^3.4|^4.0|^5.0",
            "symfony/http-kernel": "^4.4",
            "symfony/intl": "^3.4|^4.0|^5.0",
            "symfony/service-contracts": "^1.1.2|^2",
            "symfony/yaml": "^3.4|^4.0|^5.0",
            "symfony/finder": "~2.8|~3.0|~4.0|^5.0",
            "psr/log": "^1|^2|^3"
        },
        "conflict": {
            "symfony/config": "<3.4",
            "symfony/dependency-injection": "<3.4",
            "symfony/http-kernel": "<4.4",
            "symfony/yaml": "<3.4"
        },
        "provide": {
            "symfony/translation-implementation": "1.0|2.0"
        },
        "suggest": {
            "symfony/config": "",
            "symfony/yaml": "",
            "psr/log-implementation": "To use logging capability in translator"
        },
        "autoload": {
            "psr-4": { "Symfony\\Component\\Translation\\": "" },
            "exclude-from-classmap": [
                "/Tests/"
            ]
        },
        "minimum-stability": "dev"
    }
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: php-code-content-132
