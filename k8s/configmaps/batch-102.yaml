apiVersion: v1
data:
  uploads-admin-Public-Admin-plugins-codemirror-addon-comment-comment.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var noOptions = {};
      var nonWS = /[^\s\u00a0]/;
      var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;

      function firstNonWS(str) {
        var found = str.search(nonWS);
        return found == -1 ? 0 : found;
      }

      CodeMirror.commands.toggleComment = function(cm) {
        cm.toggleComment();
      };

      CodeMirror.defineExtension("toggleComment", function(options) {
        if (!options) options = noOptions;
        var cm = this;
        var minLine = Infinity, ranges = this.listSelections(), mode = null;
        for (var i = ranges.length - 1; i >= 0; i--) {
          var from = ranges[i].from(), to = ranges[i].to();
          if (from.line >= minLine) continue;
          if (to.line >= minLine) to = Pos(minLine, 0);
          minLine = from.line;
          if (mode == null) {
            if (cm.uncomment(from, to, options)) mode = "un";
            else { cm.lineComment(from, to, options); mode = "line"; }
          } else if (mode == "un") {
            cm.uncomment(from, to, options);
          } else {
            cm.lineComment(from, to, options);
          }
        }
      });

      // Rough heuristic to try and detect lines that are part of multi-line string
      function probablyInsideString(cm, pos, line) {
        return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line)
      }

      function getMode(cm, pos) {
        var mode = cm.getMode()
        return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)
      }

      CodeMirror.defineExtension("lineComment", function(from, to, options) {
        if (!options) options = noOptions;
        var self = this, mode = getMode(self, from);
        var firstLine = self.getLine(from.line);
        if (firstLine == null || probablyInsideString(self, from, firstLine)) return;

        var commentString = options.lineComment || mode.lineComment;
        if (!commentString) {
          if (options.blockCommentStart || mode.blockCommentStart) {
            options.fullLines = true;
            self.blockComment(from, to, options);
          }
          return;
        }

        var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
        var pad = options.padding == null ? " " : options.padding;
        var blankLines = options.commentBlankLines || from.line == to.line;

        self.operation(function() {
          if (options.indent) {
            var baseString = null;
            for (var i = from.line; i < end; ++i) {
              var line = self.getLine(i);
              var whitespace = line.slice(0, firstNonWS(line));
              if (baseString == null || baseString.length > whitespace.length) {
                baseString = whitespace;
              }
            }
            for (var i = from.line; i < end; ++i) {
              var line = self.getLine(i), cut = baseString.length;
              if (!blankLines && !nonWS.test(line)) continue;
              if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
              self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
            }
          } else {
            for (var i = from.line; i < end; ++i) {
              if (blankLines || nonWS.test(self.getLine(i)))
                self.replaceRange(commentString + pad, Pos(i, 0));
            }
          }
        });
      });

      CodeMirror.defineExtension("blockComment", function(from, to, options) {
        if (!options) options = noOptions;
        var self = this, mode = getMode(self, from);
        var startString = options.blockCommentStart || mode.blockCommentStart;
        var endString = options.blockCommentEnd || mode.blockCommentEnd;
        if (!startString || !endString) {
          if ((options.lineComment || mode.lineComment) && options.fullLines != false)
            self.lineComment(from, to, options);
          return;
        }
        if (/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return

        var end = Math.min(to.line, self.lastLine());
        if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;

        var pad = options.padding == null ? " " : options.padding;
        if (from.line > end) return;

        self.operation(function() {
          if (options.fullLines != false) {
            var lastLineHasText = nonWS.test(self.getLine(end));
            self.replaceRange(pad + endString, Pos(end));
            self.replaceRange(startString + pad, Pos(from.line, 0));
            var lead = options.blockCommentLead || mode.blockCommentLead;
            if (lead != null) for (var i = from.line + 1; i <= end; ++i)
              if (i != end || lastLineHasText)
                self.replaceRange(lead + pad, Pos(i, 0));
          } else {
            var atCursor = cmp(self.getCursor("to"), to) == 0, empty = !self.somethingSelected()
            self.replaceRange(endString, to);
            if (atCursor) self.setSelection(empty ? to : self.getCursor("from"), to)
            self.replaceRange(startString, from);
          }
        });
      });

      CodeMirror.defineExtension("uncomment", function(from, to, options) {
        if (!options) options = noOptions;
        var self = this, mode = getMode(self, from);
        var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);

        // Try finding line comments
        var lineString = options.lineComment || mode.lineComment, lines = [];
        var pad = options.padding == null ? " " : options.padding, didSomething;
        lineComment: {
          if (!lineString) break lineComment;
          for (var i = start; i <= end; ++i) {
            var line = self.getLine(i);
            var found = line.indexOf(lineString);
            if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
            if (found == -1 && nonWS.test(line)) break lineComment;
            if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
            lines.push(line);
          }
          self.operation(function() {
            for (var i = start; i <= end; ++i) {
              var line = lines[i - start];
              var pos = line.indexOf(lineString), endPos = pos + lineString.length;
              if (pos < 0) continue;
              if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
              didSomething = true;
              self.replaceRange("", Pos(i, pos), Pos(i, endPos));
            }
          });
          if (didSomething) return true;
        }

        // Try block comments
        var startString = options.blockCommentStart || mode.blockCommentStart;
        var endString = options.blockCommentEnd || mode.blockCommentEnd;
        if (!startString || !endString) return false;
        var lead = options.blockCommentLead || mode.blockCommentLead;
        var startLine = self.getLine(start), open = startLine.indexOf(startString)
        if (open == -1) return false
        var endLine = end == start ? startLine : self.getLine(end)
        var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
        var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)
        if (close == -1 ||
            !/comment/.test(self.getTokenTypeAt(insideStart)) ||
            !/comment/.test(self.getTokenTypeAt(insideEnd)) ||
            self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
          return false;

        // Avoid killing block comments completely outside the selection.
        // Positions of the last startString before the start of the selection, and the first endString after it.
        var lastStart = startLine.lastIndexOf(startString, from.ch);
        var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
        if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;
        // Positions of the first endString after the end of the selection, and the last startString before it.
        firstEnd = endLine.indexOf(endString, to.ch);
        var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
        lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;
        if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;

        self.operation(function() {
          self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),
                            Pos(end, close + endString.length));
          var openEnd = open + startString.length;
          if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
          self.replaceRange("", Pos(start, open), Pos(start, openEnd));
          if (lead) for (var i = start + 1; i <= end; ++i) {
            var line = self.getLine(i), found = line.indexOf(lead);
            if (found == -1 || nonWS.test(line.slice(0, found))) continue;
            var foundEnd = found + lead.length;
            if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
            self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
          }
        });
        return true;
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-comment-continuecomment.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      var nonspace = /\S/g;
      var repeat = String.prototype.repeat || function (n) { return Array(n + 1).join(this); };
      function continueComment(cm) {
        if (cm.getOption("disableInput")) return CodeMirror.Pass;
        var ranges = cm.listSelections(), mode, inserts = [];
        for (var i = 0; i < ranges.length; i++) {
          var pos = ranges[i].head
          if (!/\bcomment\b/.test(cm.getTokenTypeAt(pos))) return CodeMirror.Pass;
          var modeHere = cm.getModeAt(pos)
          if (!mode) mode = modeHere;
          else if (mode != modeHere) return CodeMirror.Pass;

          var insert = null, line, found;
          var blockStart = mode.blockCommentStart, lineCmt = mode.lineComment;
          if (blockStart && mode.blockCommentContinue) {
            line = cm.getLine(pos.line);
            var end = line.lastIndexOf(mode.blockCommentEnd, pos.ch - mode.blockCommentEnd.length);
            // 1. if this block comment ended
            // 2. if this is actually inside a line comment
            if (end != -1 && end == pos.ch - mode.blockCommentEnd.length ||
                lineCmt && (found = line.lastIndexOf(lineCmt, pos.ch - 1)) > -1 &&
                /\bcomment\b/.test(cm.getTokenTypeAt({line: pos.line, ch: found + 1}))) {
              // ...then don't continue it
            } else if (pos.ch >= blockStart.length &&
                       (found = line.lastIndexOf(blockStart, pos.ch - blockStart.length)) > -1 &&
                       found > end) {
              // reuse the existing leading spaces/tabs/mixed
              // or build the correct indent using CM's tab/indent options
              if (nonspaceAfter(0, line) >= found) {
                insert = line.slice(0, found);
              } else {
                var tabSize = cm.options.tabSize, numTabs;
                found = CodeMirror.countColumn(line, found, tabSize);
                insert = !cm.options.indentWithTabs ? repeat.call(" ", found) :
                  repeat.call("\t", (numTabs = Math.floor(found / tabSize))) +
                  repeat.call(" ", found - tabSize * numTabs);
              }
            } else if ((found = line.indexOf(mode.blockCommentContinue)) > -1 &&
                       found <= pos.ch &&
                       found <= nonspaceAfter(0, line)) {
              insert = line.slice(0, found);
            }
            if (insert != null) insert += mode.blockCommentContinue
          }
          if (insert == null && lineCmt && continueLineCommentEnabled(cm)) {
            if (line == null) line = cm.getLine(pos.line);
            found = line.indexOf(lineCmt);
            // cursor at pos 0, line comment also at pos 0 => shift it down, don't continue
            if (!pos.ch && !found) insert = "";
            // continue only if the line starts with an optional space + line comment
            else if (found > -1 && nonspaceAfter(0, line) >= found) {
              // don't continue if there's only space(s) after cursor or the end of the line
              insert = nonspaceAfter(pos.ch, line) > -1;
              // but always continue if the next line starts with a line comment too
              if (!insert) {
                var next = cm.getLine(pos.line + 1) || '',
                    nextFound = next.indexOf(lineCmt);
                insert = nextFound > -1 && nonspaceAfter(0, next) >= nextFound || null;
              }
              if (insert) {
                insert = line.slice(0, found) + lineCmt +
                         line.slice(found + lineCmt.length).match(/^\s*/)[0];
              }
            }
          }
          if (insert == null) return CodeMirror.Pass;
          inserts[i] = "\n" + insert;
        }

        cm.operation(function() {
          for (var i = ranges.length - 1; i >= 0; i--)
            cm.replaceRange(inserts[i], ranges[i].from(), ranges[i].to(), "+insert");
        });
      }

      function nonspaceAfter(ch, str) {
        nonspace.lastIndex = ch;
        var m = nonspace.exec(str);
        return m ? m.index : -1;
      }

      function continueLineCommentEnabled(cm) {
        var opt = cm.getOption("continueComments");
        if (opt && typeof opt == "object")
          return opt.continueLineComment !== false;
        return true;
      }

      CodeMirror.defineOption("continueComments", null, function(cm, val, prev) {
        if (prev && prev != CodeMirror.Init)
          cm.removeKeyMap("continueComment");
        if (val) {
          var key = "Enter";
          if (typeof val == "string")
            key = val;
          else if (typeof val == "object" && val.key)
            key = val.key;
          var map = {name: "continueComment"};
          map[key] = continueComment;
          cm.addKeyMap(map);
        }
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-dialog-dialog.css: |
    .CodeMirror-dialog {
      position: absolute;
      left: 0; right: 0;
      background: inherit;
      z-index: 15;
      padding: .1em .8em;
      overflow: hidden;
      color: inherit;
    }

    .CodeMirror-dialog-top {
      border-bottom: 1px solid #eee;
      top: 0;
    }

    .CodeMirror-dialog-bottom {
      border-top: 1px solid #eee;
      bottom: 0;
    }

    .CodeMirror-dialog input {
      border: none;
      outline: none;
      background: transparent;
      width: 20em;
      color: inherit;
      font-family: monospace;
    }

    .CodeMirror-dialog button {
      font-size: 70%;
    }
  uploads-admin-Public-Admin-plugins-codemirror-addon-dialog-dialog.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Open simple dialogs on top of an editor. Relies on dialog.css.

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      function dialogDiv(cm, template, bottom) {
        var wrap = cm.getWrapperElement();
        var dialog;
        dialog = wrap.appendChild(document.createElement("div"));
        if (bottom)
          dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
        else
          dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

        if (typeof template == "string") {
          dialog.innerHTML = template;
        } else { // Assuming it's a detached DOM element.
          dialog.appendChild(template);
        }
        CodeMirror.addClass(wrap, 'dialog-opened');
        return dialog;
      }

      function closeNotification(cm, newVal) {
        if (cm.state.currentNotificationClose)
          cm.state.currentNotificationClose();
        cm.state.currentNotificationClose = newVal;
      }

      CodeMirror.defineExtension("openDialog", function(template, callback, options) {
        if (!options) options = {};

        closeNotification(this, null);

        var dialog = dialogDiv(this, template, options.bottom);
        var closed = false, me = this;
        function close(newVal) {
          if (typeof newVal == 'string') {
            inp.value = newVal;
          } else {
            if (closed) return;
            closed = true;
            CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
            dialog.parentNode.removeChild(dialog);
            me.focus();

            if (options.onClose) options.onClose(dialog);
          }
        }

        var inp = dialog.getElementsByTagName("input")[0], button;
        if (inp) {
          inp.focus();

          if (options.value) {
            inp.value = options.value;
            if (options.selectValueOnOpen !== false) {
              inp.select();
            }
          }

          if (options.onInput)
            CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});
          if (options.onKeyUp)
            CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});

          CodeMirror.on(inp, "keydown", function(e) {
            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
              inp.blur();
              CodeMirror.e_stop(e);
              close();
            }
            if (e.keyCode == 13) callback(inp.value, e);
          });

          if (options.closeOnBlur !== false) CodeMirror.on(dialog, "focusout", function (evt) {
            if (evt.relatedTarget !== null) close();
          });
        } else if (button = dialog.getElementsByTagName("button")[0]) {
          CodeMirror.on(button, "click", function() {
            close();
            me.focus();
          });

          if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

          button.focus();
        }
        return close;
      });

      CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var buttons = dialog.getElementsByTagName("button");
        var closed = false, me = this, blurring = 1;
        function close() {
          if (closed) return;
          closed = true;
          CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
          dialog.parentNode.removeChild(dialog);
          me.focus();
        }
        buttons[0].focus();
        for (var i = 0; i < buttons.length; ++i) {
          var b = buttons[i];
          (function(callback) {
            CodeMirror.on(b, "click", function(e) {
              CodeMirror.e_preventDefault(e);
              close();
              if (callback) callback(me);
            });
          })(callbacks[i]);
          CodeMirror.on(b, "blur", function() {
            --blurring;
            setTimeout(function() { if (blurring <= 0) close(); }, 200);
          });
          CodeMirror.on(b, "focus", function() { ++blurring; });
        }
      });

      /*
       * openNotification
       * Opens a notification, that can be closed with an optional timer
       * (default 5000ms timer) and always closes on click.
       *
       * If a notification is opened while another is opened, it will close the
       * currently opened one and open the new one immediately.
       */
      CodeMirror.defineExtension("openNotification", function(template, options) {
        closeNotification(this, close);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var closed = false, doneTimer;
        var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

        function close() {
          if (closed) return;
          closed = true;
          clearTimeout(doneTimer);
          CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
          dialog.parentNode.removeChild(dialog);
        }

        CodeMirror.on(dialog, 'click', function(e) {
          CodeMirror.e_preventDefault(e);
          close();
        });

        if (duration)
          doneTimer = setTimeout(close, duration);

        return close;
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-display-fullscreen.css: |
    .CodeMirror-fullscreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      height: auto;
      z-index: 9;
    }
  uploads-admin-Public-Admin-plugins-codemirror-addon-edit-closebrackets.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      var defaults = {
        pairs: "()[]{}''\"\"",
        closeBefore: ")]}'\":;>",
        triples: "",
        explode: "[]{}"
      };

      var Pos = CodeMirror.Pos;

      CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
        if (old && old != CodeMirror.Init) {
          cm.removeKeyMap(keyMap);
          cm.state.closeBrackets = null;
        }
        if (val) {
          ensureBound(getOption(val, "pairs"))
          cm.state.closeBrackets = val;
          cm.addKeyMap(keyMap);
        }
      });

      function getOption(conf, name) {
        if (name == "pairs" && typeof conf == "string") return conf;
        if (typeof conf == "object" && conf[name] != null) return conf[name];
        return defaults[name];
      }

      var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
      function ensureBound(chars) {
        for (var i = 0; i < chars.length; i++) {
          var ch = chars.charAt(i), key = "'" + ch + "'"
          if (!keyMap[key]) keyMap[key] = handler(ch)
        }
      }
      ensureBound(defaults.pairs + "`")

      function handler(ch) {
        return function(cm) { return handleChar(cm, ch); };
      }

      function getConfig(cm) {
        var deflt = cm.state.closeBrackets;
        if (!deflt || deflt.override) return deflt;
        var mode = cm.getModeAt(cm.getCursor());
        return mode.closeBrackets || deflt;
      }

      function handleBackspace(cm) {
        var conf = getConfig(cm);
        if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

        var pairs = getOption(conf, "pairs");
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) return CodeMirror.Pass;
          var around = charsAround(cm, ranges[i].head);
          if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
        }
        for (var i = ranges.length - 1; i >= 0; i--) {
          var cur = ranges[i].head;
          cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
        }
      }

      function handleEnter(cm) {
        var conf = getConfig(cm);
        var explode = conf && getOption(conf, "explode");
        if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;

        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) return CodeMirror.Pass;
          var around = charsAround(cm, ranges[i].head);
          if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
        }
        cm.operation(function() {
          var linesep = cm.lineSeparator() || "\n";
          cm.replaceSelection(linesep + linesep, null);
          moveSel(cm, -1)
          ranges = cm.listSelections();
          for (var i = 0; i < ranges.length; i++) {
            var line = ranges[i].head.line;
            cm.indentLine(line, null, true);
            cm.indentLine(line + 1, null, true);
          }
        });
      }

      function moveSel(cm, dir) {
        var newRanges = [], ranges = cm.listSelections(), primary = 0
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i]
          if (range.head == cm.getCursor()) primary = i
          var pos = range.head.ch || dir > 0 ? {line: range.head.line, ch: range.head.ch + dir} : {line: range.head.line - 1}
          newRanges.push({anchor: pos, head: pos})
        }
        cm.setSelections(newRanges, primary)
      }

      function contractSelection(sel) {
        var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
        return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
                head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
      }

      function handleChar(cm, ch) {
        var conf = getConfig(cm);
        if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

        var pairs = getOption(conf, "pairs");
        var pos = pairs.indexOf(ch);
        if (pos == -1) return CodeMirror.Pass;

        var closeBefore = getOption(conf,"closeBefore");

        var triples = getOption(conf, "triples");

        var identical = pairs.charAt(pos + 1) == ch;
        var ranges = cm.listSelections();
        var opening = pos % 2 == 0;

        var type;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], cur = range.head, curType;
          var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
          if (opening && !range.empty()) {
            curType = "surround";
          } else if ((identical || !opening) && next == ch) {
            if (identical && stringStartsAfter(cm, cur))
              curType = "both";
            else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
              curType = "skipThree";
            else
              curType = "skip";
          } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
                     cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
            if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
            curType = "addFour";
          } else if (identical) {
            var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur)
            if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";
            else return CodeMirror.Pass;
          } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
            curType = "both";
          } else {
            return CodeMirror.Pass;
          }
          if (!type) type = curType;
          else if (type != curType) return CodeMirror.Pass;
        }

        var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
        var right = pos % 2 ? ch : pairs.charAt(pos + 1);
        cm.operation(function() {
          if (type == "skip") {
            moveSel(cm, 1)
          } else if (type == "skipThree") {
            moveSel(cm, 3)
          } else if (type == "surround") {
            var sels = cm.getSelections();
            for (var i = 0; i < sels.length; i++)
              sels[i] = left + sels[i] + right;
            cm.replaceSelections(sels, "around");
            sels = cm.listSelections().slice();
            for (var i = 0; i < sels.length; i++)
              sels[i] = contractSelection(sels[i]);
            cm.setSelections(sels);
          } else if (type == "both") {
            cm.replaceSelection(left + right, null);
            cm.triggerElectric(left + right);
            moveSel(cm, -1)
          } else if (type == "addFour") {
            cm.replaceSelection(left + left + left + left, "before");
            moveSel(cm, 1)
          }
        });
      }

      function charsAround(cm, pos) {
        var str = cm.getRange(Pos(pos.line, pos.ch - 1),
                              Pos(pos.line, pos.ch + 1));
        return str.length == 2 ? str : null;
      }

      function stringStartsAfter(cm, pos) {
        var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))
        return /\bstring/.test(token.type) && token.start == pos.ch &&
          (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)))
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-edit-closetag.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Tag-closer extension for CodeMirror.
     *
     * This extension adds an "autoCloseTags" option that can be set to
     * either true to get the default behavior, or an object to further
     * configure its behavior.
     *
     * These are supported options:
     *
     * `whenClosing` (default true)
     *   Whether to autoclose when the '/' of a closing tag is typed.
     * `whenOpening` (default true)
     *   Whether to autoclose the tag when the final '>' of an opening
     *   tag is typed.
     * `dontCloseTags` (default is empty tags for HTML, none for XML)
     *   An array of tag names that should not be autoclosed.
     * `indentTags` (default is block tags for HTML, none for XML)
     *   An array of tag names that should, when opened, cause a
     *   blank line to be added inside the tag, and the blank line and
     *   closing line to be indented.
     * `emptyTags` (default is none)
     *   An array of XML tag names that should be autoclosed with '/>'.
     *
     * See demos/closetag.html for a usage example.
     */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../fold/xml-fold"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../fold/xml-fold"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      CodeMirror.defineOption("autoCloseTags", false, function(cm, val, old) {
        if (old != CodeMirror.Init && old)
          cm.removeKeyMap("autoCloseTags");
        if (!val) return;
        var map = {name: "autoCloseTags"};
        if (typeof val != "object" || val.whenClosing !== false)
          map["'/'"] = function(cm) { return autoCloseSlash(cm); };
        if (typeof val != "object" || val.whenOpening !== false)
          map["'>'"] = function(cm) { return autoCloseGT(cm); };
        cm.addKeyMap(map);
      });

      var htmlDontClose = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param",
                           "source", "track", "wbr"];
      var htmlIndent = ["applet", "blockquote", "body", "button", "div", "dl", "fieldset", "form", "frameset", "h1", "h2", "h3", "h4",
                        "h5", "h6", "head", "html", "iframe", "layer", "legend", "object", "ol", "p", "select", "table", "ul"];

      function autoCloseGT(cm) {
        if (cm.getOption("disableInput")) return CodeMirror.Pass;
        var ranges = cm.listSelections(), replacements = [];
        var opt = cm.getOption("autoCloseTags");
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) return CodeMirror.Pass;
          var pos = ranges[i].head, tok = cm.getTokenAt(pos);
          var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
          var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state)
          var tagName = tagInfo && tagInfo.name
          if (!tagName) return CodeMirror.Pass

          var html = inner.mode.configuration == "html";
          var dontCloseTags = (typeof opt == "object" && opt.dontCloseTags) || (html && htmlDontClose);
          var indentTags = (typeof opt == "object" && opt.indentTags) || (html && htmlIndent);

          if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);
          var lowerTagName = tagName.toLowerCase();
          // Don't process the '>' at the end of an end-tag or self-closing tag
          if (!tagName ||
              tok.type == "string" && (tok.end != pos.ch || !/[\"\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||
              tok.type == "tag" && tagInfo.close ||
              tok.string.indexOf("/") == (pos.ch - tok.start - 1) || // match something like <someTagName />
              dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||
              closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state) || [], tagName, pos, true))
            return CodeMirror.Pass;

          var emptyTags = typeof opt == "object" && opt.emptyTags;
          if (emptyTags && indexOf(emptyTags, tagName) > -1) {
            replacements[i] = { text: "/>", newPos: CodeMirror.Pos(pos.line, pos.ch + 2) };
            continue;
          }

          var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;
          replacements[i] = {indent: indent,
                             text: ">" + (indent ? "\n\n" : "") + "</" + tagName + ">",
                             newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};
        }

        var dontIndentOnAutoClose = (typeof opt == "object" && opt.dontIndentOnAutoClose);
        for (var i = ranges.length - 1; i >= 0; i--) {
          var info = replacements[i];
          cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");
          var sel = cm.listSelections().slice(0);
          sel[i] = {head: info.newPos, anchor: info.newPos};
          cm.setSelections(sel);
          if (!dontIndentOnAutoClose && info.indent) {
            cm.indentLine(info.newPos.line, null, true);
            cm.indentLine(info.newPos.line + 1, null, true);
          }
        }
      }

      function autoCloseCurrent(cm, typingSlash) {
        var ranges = cm.listSelections(), replacements = [];
        var head = typingSlash ? "/" : "</";
        var opt = cm.getOption("autoCloseTags");
        var dontIndentOnAutoClose = (typeof opt == "object" && opt.dontIndentOnSlash);
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) return CodeMirror.Pass;
          var pos = ranges[i].head, tok = cm.getTokenAt(pos);
          var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;
          if (typingSlash && (tok.type == "string" || tok.string.charAt(0) != "<" ||
                              tok.start != pos.ch - 1))
            return CodeMirror.Pass;
          // Kludge to get around the fact that we are not in XML mode
          // when completing in JS/CSS snippet in htmlmixed mode. Does not
          // work for other XML embedded languages (there is no general
          // way to go from a mixed mode to its current XML state).
          var replacement, mixed = inner.mode.name != "xml" && cm.getMode().name == "htmlmixed"
          if (mixed && inner.mode.name == "javascript") {
            replacement = head + "script";
          } else if (mixed && inner.mode.name == "css") {
            replacement = head + "style";
          } else {
            var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state)
            var top = context.length ? context[context.length - 1] : ""
            if (!context || (context.length && closingTagExists(cm, context, top, pos)))
              return CodeMirror.Pass;
            replacement = head + top
          }
          if (cm.getLine(pos.line).charAt(tok.end) != ">") replacement += ">";
          replacements[i] = replacement;
        }
        cm.replaceSelections(replacements);
        ranges = cm.listSelections();
        if (!dontIndentOnAutoClose) {
            for (var i = 0; i < ranges.length; i++)
                if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)
                    cm.indentLine(ranges[i].head.line);
        }
      }

      function autoCloseSlash(cm) {
        if (cm.getOption("disableInput")) return CodeMirror.Pass;
        return autoCloseCurrent(cm, true);
      }

      CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };

      function indexOf(collection, elt) {
        if (collection.indexOf) return collection.indexOf(elt);
        for (var i = 0, e = collection.length; i < e; ++i)
          if (collection[i] == elt) return i;
        return -1;
      }

      // If xml-fold is loaded, we use its functionality to try and verify
      // whether a given tag is actually unclosed.
      function closingTagExists(cm, context, tagName, pos, newTag) {
        if (!CodeMirror.scanForClosingTag) return false;
        var end = Math.min(cm.lastLine() + 1, pos.line + 500);
        var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);
        if (!nextClose || nextClose.tag != tagName) return false;
        // If the immediate wrapping context contains onCx instances of
        // the same tag, a closing tag only exists if there are at least
        // that many closing tags of that type following.
        var onCx = newTag ? 1 : 0
        for (var i = context.length - 1; i >= 0; i--) {
          if (context[i] == tagName) ++onCx
          else break
        }
        pos = nextClose.to;
        for (var i = 1; i < onCx; i++) {
          var next = CodeMirror.scanForClosingTag(cm, pos, null, end);
          if (!next || next.tag != tagName) return false;
          pos = next.to;
        }
        return true;
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-edit-continuelist.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/,
          emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/,
          unorderedListRE = /[*+-]\s/;

      CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {
        if (cm.getOption("disableInput")) return CodeMirror.Pass;
        var ranges = cm.listSelections(), replacements = [];
        for (var i = 0; i < ranges.length; i++) {
          var pos = ranges[i].head;

          // If we're not in Markdown mode, fall back to normal newlineAndIndent
          var eolState = cm.getStateAfter(pos.line);
          var inner = CodeMirror.innerMode(cm.getMode(), eolState);
          if (inner.mode.name !== "markdown") {
            cm.execCommand("newlineAndIndent");
            return;
          } else {
            eolState = inner.state;
          }

          var inList = eolState.list !== false;
          var inQuote = eolState.quote !== 0;

          var line = cm.getLine(pos.line), match = listRE.exec(line);
          var cursorBeforeBullet = /^\s*$/.test(line.slice(0, pos.ch));
          if (!ranges[i].empty() || (!inList && !inQuote) || !match || cursorBeforeBullet) {
            cm.execCommand("newlineAndIndent");
            return;
          }
          if (emptyListRE.test(line)) {
            var endOfQuote = inQuote && />\s*$/.test(line)
            var endOfList = !/>\s*$/.test(line)
            if (endOfQuote || endOfList) cm.replaceRange("", {
              line: pos.line, ch: 0
            }, {
              line: pos.line, ch: pos.ch + 1
            });
            replacements[i] = "\n";
          } else {
            var indent = match[1], after = match[5];
            var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0);
            var bullet = numbered ? (parseInt(match[3], 10) + 1) + match[4] : match[2].replace("x", " ");
            replacements[i] = "\n" + indent + bullet + after;

            if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);
          }
        }

        cm.replaceSelections(replacements);
      };

      // Auto-updating Markdown list numbers when a new item is added to the
      // middle of a list
      function incrementRemainingMarkdownListNumbers(cm, pos) {
        var startLine = pos.line, lookAhead = 0, skipCount = 0;
        var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];

        do {
          lookAhead += 1;
          var nextLineNumber = startLine + lookAhead;
          var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);

          if (nextItem) {
            var nextIndent = nextItem[1];
            var newNumber = (parseInt(startItem[3], 10) + lookAhead - skipCount);
            var nextNumber = (parseInt(nextItem[3], 10)), itemNumber = nextNumber;

            if (startIndent === nextIndent && !isNaN(nextNumber)) {
              if (newNumber === nextNumber) itemNumber = nextNumber + 1;
              if (newNumber > nextNumber) itemNumber = newNumber + 1;
              cm.replaceRange(
                nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),
              {
                line: nextLineNumber, ch: 0
              }, {
                line: nextLineNumber, ch: nextLine.length
              });
            } else {
              if (startIndent.length > nextIndent.length) return;
              // This doesn't run if the next line immediately indents, as it is
              // not clear of the users intention (new indented item or same level)
              if ((startIndent.length < nextIndent.length) && (lookAhead === 1)) return;
              skipCount += 1;
            }
          }
        } while (nextItem);
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-edit-matchbrackets.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
        (document.documentMode == null || document.documentMode < 8);

      var Pos = CodeMirror.Pos;

      var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<"};

      function bracketRegex(config) {
        return config && config.bracketRegex || /[(){}[\]]/
      }

      function findMatchingBracket(cm, where, config) {
        var line = cm.getLineHandle(where.line), pos = where.ch - 1;
        var afterCursor = config && config.afterCursor
        if (afterCursor == null)
          afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)
        var re = bracketRegex(config)

        // A cursor is defined as between two characters, but in in vim command mode
        // (i.e. not insert mode), the cursor is visually represented as a
        // highlighted box on top of the 2nd character. Otherwise, we allow matches
        // from before or after the cursor.
        var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||
            re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
        if (!match) return null;
        var dir = match.charAt(1) == ">" ? 1 : -1;
        if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;
        var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

        var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);
        if (found == null) return null;
        return {from: Pos(where.line, pos), to: found && found.pos,
                match: found && found.ch == match.charAt(0), forward: dir > 0};
      }

      // bracketRegex is used to specify which type of bracket to scan
      // should be a regexp, e.g. /[[\]]/
      //
      // Note: If "where" is on an open bracket, then this bracket is ignored.
      //
      // Returns false when no bracket was found, null when it reached
      // maxScanLines and gave up
      function scanForBracket(cm, where, dir, style, config) {
        var maxScanLen = (config && config.maxScanLineLength) || 10000;
        var maxScanLines = (config && config.maxScanLines) || 1000;

        var stack = [];
        var re = bracketRegex(config)
        var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
                              : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
        for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
          var line = cm.getLine(lineNo);
          if (!line) continue;
          var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
          if (line.length > maxScanLen) continue;
          if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
          for (; pos != end; pos += dir) {
            var ch = line.charAt(pos);
            if (re.test(ch) && (style === undefined ||
                                (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
              var match = matching[ch];
              if (match && (match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
              else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
              else stack.pop();
            }
          }
        }
        return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
      }

      function matchBrackets(cm, autoclear, config) {
        // Disable brace matching in long lines, since it'll cause hugely slow updates
        var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,
          highlightNonMatching = config && config.highlightNonMatching;
        var marks = [], ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
          if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
            var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
            marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
            if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
              marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
          }
        }

        if (marks.length) {
          // Kludge to work around the IE bug from issue #1193, where text
          // input stops going to the textarea whenever this fires.
          if (ie_lt8 && cm.state.focused) cm.focus();

          var clear = function() {
            cm.operation(function() {
              for (var i = 0; i < marks.length; i++) marks[i].clear();
            });
          };
          if (autoclear) setTimeout(clear, 800);
          else return clear;
        }
      }

      function doMatchBrackets(cm) {
        cm.operation(function() {
          if (cm.state.matchBrackets.currentlyHighlighted) {
            cm.state.matchBrackets.currentlyHighlighted();
            cm.state.matchBrackets.currentlyHighlighted = null;
          }
          cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
        });
      }

      function clearHighlighted(cm) {
        if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
          cm.state.matchBrackets.currentlyHighlighted();
          cm.state.matchBrackets.currentlyHighlighted = null;
        }
      }

      CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
        if (old && old != CodeMirror.Init) {
          cm.off("cursorActivity", doMatchBrackets);
          cm.off("focus", doMatchBrackets)
          cm.off("blur", clearHighlighted)
          clearHighlighted(cm);
        }
        if (val) {
          cm.state.matchBrackets = typeof val == "object" ? val : {};
          cm.on("cursorActivity", doMatchBrackets);
          cm.on("focus", doMatchBrackets)
          cm.on("blur", clearHighlighted)
        }
      });

      CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
      CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig){
        // Backwards-compatibility kludge
        if (oldConfig || typeof config == "boolean") {
          if (!oldConfig) {
            config = config ? {strict: true} : null
          } else {
            oldConfig.strict = config
            config = oldConfig
          }
        }
        return findMatchingBracket(this, pos, config)
      });
      CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
        return scanForBracket(this, pos, dir, style, config);
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-edit-matchtags.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../fold/xml-fold"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../fold/xml-fold"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineOption("matchTags", false, function(cm, val, old) {
        if (old && old != CodeMirror.Init) {
          cm.off("cursorActivity", doMatchTags);
          cm.off("viewportChange", maybeUpdateMatch);
          clear(cm);
        }
        if (val) {
          cm.state.matchBothTags = typeof val == "object" && val.bothTags;
          cm.on("cursorActivity", doMatchTags);
          cm.on("viewportChange", maybeUpdateMatch);
          doMatchTags(cm);
        }
      });

      function clear(cm) {
        if (cm.state.tagHit) cm.state.tagHit.clear();
        if (cm.state.tagOther) cm.state.tagOther.clear();
        cm.state.tagHit = cm.state.tagOther = null;
      }

      function doMatchTags(cm) {
        cm.state.failedTagMatch = false;
        cm.operation(function() {
          clear(cm);
          if (cm.somethingSelected()) return;
          var cur = cm.getCursor(), range = cm.getViewport();
          range.from = Math.min(range.from, cur.line); range.to = Math.max(cur.line + 1, range.to);
          var match = CodeMirror.findMatchingTag(cm, cur, range);
          if (!match) return;
          if (cm.state.matchBothTags) {
            var hit = match.at == "open" ? match.open : match.close;
            if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {className: "CodeMirror-matchingtag"});
          }
          var other = match.at == "close" ? match.open : match.close;
          if (other)
            cm.state.tagOther = cm.markText(other.from, other.to, {className: "CodeMirror-matchingtag"});
          else
            cm.state.failedTagMatch = true;
        });
      }

      function maybeUpdateMatch(cm) {
        if (cm.state.failedTagMatch) doMatchTags(cm);
      }

      CodeMirror.commands.toMatchingTag = function(cm) {
        var found = CodeMirror.findMatchingTag(cm, cm.getCursor());
        if (found) {
          var other = found.at == "close" ? found.open : found.close;
          if (other) cm.extendSelection(other.to, other.from);
        }
      };
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-edit-trailingspace.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      CodeMirror.defineOption("showTrailingSpace", false, function(cm, val, prev) {
        if (prev == CodeMirror.Init) prev = false;
        if (prev && !val)
          cm.removeOverlay("trailingspace");
        else if (!prev && val)
          cm.addOverlay({
            token: function(stream) {
              for (var l = stream.string.length, i = l; i && /\s/.test(stream.string.charAt(i - 1)); --i) {}
              if (i > stream.pos) { stream.pos = i; return null; }
              stream.pos = l;
              return "trailingspace";
            },
            name: "trailingspace"
          });
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-anyword-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var WORD = /[\w$]+/, RANGE = 500;

      CodeMirror.registerHelper("hint", "anyword", function(editor, options) {
        var word = options && options.word || WORD;
        var range = options && options.range || RANGE;
        var cur = editor.getCursor(), curLine = editor.getLine(cur.line);
        var end = cur.ch, start = end;
        while (start && word.test(curLine.charAt(start - 1))) --start;
        var curWord = start != end && curLine.slice(start, end);

        var list = options && options.list || [], seen = {};
        var re = new RegExp(word.source, "g");
        for (var dir = -1; dir <= 1; dir += 2) {
          var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;
          for (; line != endLine; line += dir) {
            var text = editor.getLine(line), m;
            while (m = re.exec(text)) {
              if (line == cur.line && m[0] === curWord) continue;
              if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {
                seen[m[0]] = true;
                list.push(m[0]);
              }
            }
          }
        }
        return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-css-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../mode/css/css"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../mode/css/css"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var pseudoClasses = {"active":1, "after":1, "before":1, "checked":1, "default":1,
        "disabled":1, "empty":1, "enabled":1, "first-child":1, "first-letter":1,
        "first-line":1, "first-of-type":1, "focus":1, "hover":1, "in-range":1,
        "indeterminate":1, "invalid":1, "lang":1, "last-child":1, "last-of-type":1,
        "link":1, "not":1, "nth-child":1, "nth-last-child":1, "nth-last-of-type":1,
        "nth-of-type":1, "only-of-type":1, "only-child":1, "optional":1, "out-of-range":1,
        "placeholder":1, "read-only":1, "read-write":1, "required":1, "root":1,
        "selection":1, "target":1, "valid":1, "visited":1
      };

      CodeMirror.registerHelper("hint", "css", function(cm) {
        var cur = cm.getCursor(), token = cm.getTokenAt(cur);
        var inner = CodeMirror.innerMode(cm.getMode(), token.state);
        if (inner.mode.name != "css") return;

        if (token.type == "keyword" && "!important".indexOf(token.string) == 0)
          return {list: ["!important"], from: CodeMirror.Pos(cur.line, token.start),
                  to: CodeMirror.Pos(cur.line, token.end)};

        var start = token.start, end = cur.ch, word = token.string.slice(0, end - start);
        if (/[^\w$_-]/.test(word)) {
          word = ""; start = end = cur.ch;
        }

        var spec = CodeMirror.resolveMode("text/css");

        var result = [];
        function add(keywords) {
          for (var name in keywords)
            if (!word || name.lastIndexOf(word, 0) == 0)
              result.push(name);
        }

        var st = inner.state.state;
        if (st == "pseudo" || token.type == "variable-3") {
          add(pseudoClasses);
        } else if (st == "block" || st == "maybeprop") {
          add(spec.propertyKeywords);
        } else if (st == "prop" || st == "parens" || st == "at" || st == "params") {
          add(spec.valueKeywords);
          add(spec.colorKeywords);
        } else if (st == "media" || st == "media_parens") {
          add(spec.mediaTypes);
          add(spec.mediaFeatures);
        }

        if (result.length) return {
          list: result,
          from: CodeMirror.Pos(cur.line, start),
          to: CodeMirror.Pos(cur.line, end)
        };
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-html-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("./xml-hint"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "./xml-hint"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var langs = "ab aa af ak sq am ar an hy as av ae ay az bm ba eu be bn bh bi bs br bg my ca ch ce ny zh cv kw co cr hr cs da dv nl dz en eo et ee fo fj fi fr ff gl ka de el gn gu ht ha he hz hi ho hu ia id ie ga ig ik io is it iu ja jv kl kn kr ks kk km ki rw ky kv kg ko ku kj la lb lg li ln lo lt lu lv gv mk mg ms ml mt mi mr mh mn na nv nb nd ne ng nn no ii nr oc oj cu om or os pa pi fa pl ps pt qu rm rn ro ru sa sc sd se sm sg sr gd sn si sk sl so st es su sw ss sv ta te tg th ti bo tk tl tn to tr ts tt tw ty ug uk ur uz ve vi vo wa cy wo fy xh yi yo za zu".split(" ");
      var targets = ["_blank", "_self", "_top", "_parent"];
      var charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
      var methods = ["get", "post", "put", "delete"];
      var encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
      var media = ["all", "screen", "print", "embossed", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "speech",
                   "3d-glasses", "resolution [>][<][=] [X]", "device-aspect-ratio: X/Y", "orientation:portrait",
                   "orientation:landscape", "device-height: [X]", "device-width: [X]"];
      var s = { attrs: {} }; // Simple tag, reused for a whole lot of tags

      var data = {
        a: {
          attrs: {
            href: null, ping: null, type: null,
            media: media,
            target: targets,
            hreflang: langs
          }
        },
        abbr: s,
        acronym: s,
        address: s,
        applet: s,
        area: {
          attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: media, hreflang: langs, type: null,
            shape: ["default", "rect", "circle", "poly"]
          }
        },
        article: s,
        aside: s,
        audio: {
          attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["", "autoplay"],
            loop: ["", "loop"],
            controls: ["", "controls"]
          }
        },
        b: s,
        base: { attrs: { href: null, target: targets } },
        basefont: s,
        bdi: s,
        bdo: s,
        big: s,
        blockquote: { attrs: { cite: null } },
        body: s,
        br: s,
        button: {
          attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["", "autofocus"],
            disabled: ["", "autofocus"],
            formenctype: encs,
            formmethod: methods,
            formnovalidate: ["", "novalidate"],
            formtarget: targets,
            type: ["submit", "reset", "button"]
          }
        },
        canvas: { attrs: { width: null, height: null } },
        caption: s,
        center: s,
        cite: s,
        code: s,
        col: { attrs: { span: null } },
        colgroup: { attrs: { span: null } },
        command: {
          attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["", "disabled"],
            checked: ["", "checked"]
          }
        },
        data: { attrs: { value: null } },
        datagrid: { attrs: { disabled: ["", "disabled"], multiple: ["", "multiple"] } },
        datalist: { attrs: { data: null } },
        dd: s,
        del: { attrs: { cite: null, datetime: null } },
        details: { attrs: { open: ["", "open"] } },
        dfn: s,
        dir: s,
        div: s,
        dialog: { attrs: { open: null } },
        dl: s,
        dt: s,
        em: s,
        embed: { attrs: { src: null, type: null, width: null, height: null } },
        eventsource: { attrs: { src: null } },
        fieldset: { attrs: { disabled: ["", "disabled"], form: null, name: null } },
        figcaption: s,
        figure: s,
        font: s,
        footer: s,
        form: {
          attrs: {
            action: null, name: null,
            "accept-charset": charsets,
            autocomplete: ["on", "off"],
            enctype: encs,
            method: methods,
            novalidate: ["", "novalidate"],
            target: targets
          }
        },
        frame: s,
        frameset: s,
        h1: s, h2: s, h3: s, h4: s, h5: s, h6: s,
        head: {
          attrs: {},
          children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
        },
        header: s,
        hgroup: s,
        hr: s,
        html: {
          attrs: { manifest: null },
          children: ["head", "body"]
        },
        i: s,
        iframe: {
          attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["", "seamless"]
          }
        },
        img: {
          attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
          }
        },
        input: {
          attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["", "autofocus"],
            checked: ["", "checked"],
            disabled: ["", "disabled"],
            formenctype: encs,
            formmethod: methods,
            formnovalidate: ["", "novalidate"],
            formtarget: targets,
            multiple: ["", "multiple"],
            readonly: ["", "readonly"],
            required: ["", "required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                   "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                   "file", "submit", "image", "reset", "button"]
          }
        },
        ins: { attrs: { cite: null, datetime: null } },
        kbd: s,
        keygen: {
          attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["", "autofocus"],
            disabled: ["", "disabled"],
            keytype: ["RSA"]
          }
        },
        label: { attrs: { "for": null, form: null } },
        legend: s,
        li: { attrs: { value: null } },
        link: {
          attrs: {
            href: null, type: null,
            hreflang: langs,
            media: media,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
          }
        },
        map: { attrs: { name: null } },
        mark: s,
        menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
        meta: {
          attrs: {
            content: null,
            charset: charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
          }
        },
        meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
        nav: s,
        noframes: s,
        noscript: s,
        object: {
          attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["", "typemustmatch"]
          }
        },
        ol: { attrs: { reversed: ["", "reversed"], start: null, type: ["1", "a", "A", "i", "I"] } },
        optgroup: { attrs: { disabled: ["", "disabled"], label: null } },
        option: { attrs: { disabled: ["", "disabled"], label: null, selected: ["", "selected"], value: null } },
        output: { attrs: { "for": null, form: null, name: null } },
        p: s,
        param: { attrs: { name: null, value: null } },
        pre: s,
        progress: { attrs: { value: null, max: null } },
        q: { attrs: { cite: null } },
        rp: s,
        rt: s,
        ruby: s,
        s: s,
        samp: s,
        script: {
          attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["", "async"],
            defer: ["", "defer"],
            charset: charsets
          }
        },
        section: s,
        select: {
          attrs: {
            form: null, name: null, size: null,
            autofocus: ["", "autofocus"],
            disabled: ["", "disabled"],
            multiple: ["", "multiple"]
          }
        },
        small: s,
        source: { attrs: { src: null, type: null, media: null } },
        span: s,
        strike: s,
        strong: s,
        style: {
          attrs: {
            type: ["text/css"],
            media: media,
            scoped: null
          }
        },
        sub: s,
        summary: s,
        sup: s,
        table: s,
        tbody: s,
        td: { attrs: { colspan: null, rowspan: null, headers: null } },
        textarea: {
          attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["", "autofocus"],
            disabled: ["", "disabled"],
            readonly: ["", "readonly"],
            required: ["", "required"],
            wrap: ["soft", "hard"]
          }
        },
        tfoot: s,
        th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
        thead: s,
        time: { attrs: { datetime: null } },
        title: s,
        tr: s,
        track: {
          attrs: {
            src: null, label: null, "default": null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: langs
          }
        },
        tt: s,
        u: s,
        ul: s,
        "var": s,
        video: {
          attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["", "autoplay"],
            mediagroup: ["movie"],
            muted: ["", "muted"],
            controls: ["", "controls"]
          }
        },
        wbr: s
      };

      var globalAttrs = {
        accesskey: ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
        "class": null,
        contenteditable: ["true", "false"],
        contextmenu: null,
        dir: ["ltr", "rtl", "auto"],
        draggable: ["true", "false", "auto"],
        dropzone: ["copy", "move", "link", "string:", "file:"],
        hidden: ["hidden"],
        id: null,
        inert: ["inert"],
        itemid: null,
        itemprop: null,
        itemref: null,
        itemscope: ["itemscope"],
        itemtype: null,
        lang: ["en", "es"],
        spellcheck: ["true", "false"],
        autocorrect: ["true", "false"],
        autocapitalize: ["true", "false"],
        style: null,
        tabindex: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
        title: null,
        translate: ["yes", "no"],
        onclick: null,
        rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"]
      };
      function populate(obj) {
        for (var attr in globalAttrs) if (globalAttrs.hasOwnProperty(attr))
          obj.attrs[attr] = globalAttrs[attr];
      }

      populate(s);
      for (var tag in data) if (data.hasOwnProperty(tag) && data[tag] != s)
        populate(data[tag]);

      CodeMirror.htmlSchema = data;
      function htmlHint(cm, options) {
        var local = {schemaInfo: data};
        if (options) for (var opt in options) local[opt] = options[opt];
        return CodeMirror.hint.xml(cm, local);
      }
      CodeMirror.registerHelper("hint", "html", htmlHint);
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-javascript-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      var Pos = CodeMirror.Pos;

      function forEach(arr, f) {
        for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);
      }

      function arrayContains(arr, item) {
        if (!Array.prototype.indexOf) {
          var i = arr.length;
          while (i--) {
            if (arr[i] === item) {
              return true;
            }
          }
          return false;
        }
        return arr.indexOf(item) != -1;
      }

      function scriptHint(editor, keywords, getToken, options) {
        // Find the token at the cursor
        var cur = editor.getCursor(), token = getToken(editor, cur);
        if (/\b(?:string|comment)\b/.test(token.type)) return;
        var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);
        if (innerMode.mode.helperType === "json") return;
        token.state = innerMode.state;

        // If it's not a 'word-style' token, ignore the token.
        if (!/^[\w$_]*$/.test(token.string)) {
          token = {start: cur.ch, end: cur.ch, string: "", state: token.state,
                   type: token.string == "." ? "property" : null};
        } else if (token.end > cur.ch) {
          token.end = cur.ch;
          token.string = token.string.slice(0, cur.ch - token.start);
        }

        var tprop = token;
        // If it is a property, find out what it is a property of.
        while (tprop.type == "property") {
          tprop = getToken(editor, Pos(cur.line, tprop.start));
          if (tprop.string != ".") return;
          tprop = getToken(editor, Pos(cur.line, tprop.start));
          if (!context) var context = [];
          context.push(tprop);
        }
        return {list: getCompletions(token, context, keywords, options),
                from: Pos(cur.line, token.start),
                to: Pos(cur.line, token.end)};
      }

      function javascriptHint(editor, options) {
        return scriptHint(editor, javascriptKeywords,
                          function (e, cur) {return e.getTokenAt(cur);},
                          options);
      };
      CodeMirror.registerHelper("hint", "javascript", javascriptHint);

      function getCoffeeScriptToken(editor, cur) {
      // This getToken, it is for coffeescript, imitates the behavior of
      // getTokenAt method in javascript.js, that is, returning "property"
      // type and treat "." as independent token.
        var token = editor.getTokenAt(cur);
        if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {
          token.end = token.start;
          token.string = '.';
          token.type = "property";
        }
        else if (/^\.[\w$_]*$/.test(token.string)) {
          token.type = "property";
          token.start++;
          token.string = token.string.replace(/\./, '');
        }
        return token;
      }

      function coffeescriptHint(editor, options) {
        return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);
      }
      CodeMirror.registerHelper("hint", "coffeescript", coffeescriptHint);

      var stringProps = ("charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight " +
                         "toUpperCase toLowerCase split concat match replace search").split(" ");
      var arrayProps = ("length concat join splice push pop shift unshift slice reverse sort indexOf " +
                        "lastIndexOf every some filter forEach map reduce reduceRight ").split(" ");
      var funcProps = "prototype apply call bind".split(" ");
      var javascriptKeywords = ("break case catch class const continue debugger default delete do else export extends false finally for function " +
                      "if in import instanceof new null return super switch this throw true try typeof var void while with yield").split(" ");
      var coffeescriptKeywords = ("and break catch class continue delete do else extends false finally for " +
                      "if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes").split(" ");

      function forAllProps(obj, callback) {
        if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
          for (var name in obj) callback(name)
        } else {
          for (var o = obj; o; o = Object.getPrototypeOf(o))
            Object.getOwnPropertyNames(o).forEach(callback)
        }
      }

      function getCompletions(token, context, keywords, options) {
        var found = [], start = token.string, global = options && options.globalScope || window;
        function maybeAdd(str) {
          if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);
        }
        function gatherCompletions(obj) {
          if (typeof obj == "string") forEach(stringProps, maybeAdd);
          else if (obj instanceof Array) forEach(arrayProps, maybeAdd);
          else if (obj instanceof Function) forEach(funcProps, maybeAdd);
          forAllProps(obj, maybeAdd)
        }

        if (context && context.length) {
          // If this is a property, see if it belongs to some object we can
          // find in the current environment.
          var obj = context.pop(), base;
          if (obj.type && obj.type.indexOf("variable") === 0) {
            if (options && options.additionalContext)
              base = options.additionalContext[obj.string];
            if (!options || options.useGlobalScope !== false)
              base = base || global[obj.string];
          } else if (obj.type == "string") {
            base = "";
          } else if (obj.type == "atom") {
            base = 1;
          } else if (obj.type == "function") {
            if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&
                (typeof global.jQuery == 'function'))
              base = global.jQuery();
            else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))
              base = global._();
          }
          while (base != null && context.length)
            base = base[context.pop().string];
          if (base != null) gatherCompletions(base);
        } else {
          // If not, just look in the global object, any local scope, and optional additional-context
          // (reading into JS mode internals to get at the local and global variables)
          for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);
          for (var c = token.state.context; c; c = c.prev)
            for (var v = c.vars; v; v = v.next) maybeAdd(v.name)
          for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);
          if (options && options.additionalContext != null)
            for (var key in options.additionalContext)
              maybeAdd(key);
          if (!options || options.useGlobalScope !== false)
            gatherCompletions(global);
          forEach(keywords, maybeAdd);
        }
        return found;
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-show-hint.css: |
    .CodeMirror-hints {
      position: absolute;
      z-index: 10;
      overflow: hidden;
      list-style: none;

      margin: 0;
      padding: 2px;

      -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
      -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
      box-shadow: 2px 3px 5px rgba(0,0,0,.2);
      border-radius: 3px;
      border: 1px solid silver;

      background: white;
      font-size: 90%;
      font-family: monospace;

      max-height: 20em;
      overflow-y: auto;
    }

    .CodeMirror-hint {
      margin: 0;
      padding: 0 4px;
      border-radius: 2px;
      white-space: pre;
      color: black;
      cursor: pointer;
    }

    li.CodeMirror-hint-active {
      background: #08f;
      color: white;
    }
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-show-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // declare global: DOMRect

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
      var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

      // This is the old interface, kept around for now to stay
      // backwards-compatible.
      CodeMirror.showHint = function(cm, getHints, options) {
        if (!getHints) return cm.showHint(options);
        if (options && options.async) getHints.async = true;
        var newOpts = {hint: getHints};
        if (options) for (var prop in options) newOpts[prop] = options[prop];
        return cm.showHint(newOpts);
      };

      CodeMirror.defineExtension("showHint", function(options) {
        options = parseOptions(this, this.getCursor("start"), options);
        var selections = this.listSelections()
        if (selections.length > 1) return;
        // By default, don't allow completion when something is selected.
        // A hint function can have a `supportsSelection` property to
        // indicate that it can handle selections.
        if (this.somethingSelected()) {
          if (!options.hint.supportsSelection) return;
          // Don't try with cross-line selections
          for (var i = 0; i < selections.length; i++)
            if (selections[i].head.line != selections[i].anchor.line) return;
        }

        if (this.state.completionActive) this.state.completionActive.close();
        var completion = this.state.completionActive = new Completion(this, options);
        if (!completion.options.hint) return;

        CodeMirror.signal(this, "startCompletion", this);
        completion.update(true);
      });

      CodeMirror.defineExtension("closeHint", function() {
        if (this.state.completionActive) this.state.completionActive.close()
      })

      function Completion(cm, options) {
        this.cm = cm;
        this.options = options;
        this.widget = null;
        this.debounce = 0;
        this.tick = 0;
        this.startPos = this.cm.getCursor("start");
        this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

        if (this.options.updateOnCursorActivity) {
          var self = this;
          cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
        }
      }

      var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
        return setTimeout(fn, 1000/60);
      };
      var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

      Completion.prototype = {
        close: function() {
          if (!this.active()) return;
          this.cm.state.completionActive = null;
          this.tick = null;
          if (this.options.updateOnCursorActivity) {
            this.cm.off("cursorActivity", this.activityFunc);
          }

          if (this.widget && this.data) CodeMirror.signal(this.data, "close");
          if (this.widget) this.widget.close();
          CodeMirror.signal(this.cm, "endCompletion", this.cm);
        },

        active: function() {
          return this.cm.state.completionActive == this;
        },

        pick: function(data, i) {
          var completion = data.list[i], self = this;
          this.cm.operation(function() {
            if (completion.hint)
              completion.hint(self.cm, data, completion);
            else
              self.cm.replaceRange(getText(completion), completion.from || data.from,
                                   completion.to || data.to, "complete");
            CodeMirror.signal(data, "pick", completion);
            self.cm.scrollIntoView();
          });
          if (this.options.closeOnPick) {
            this.close();
          }
        },

        cursorActivity: function() {
          if (this.debounce) {
            cancelAnimationFrame(this.debounce);
            this.debounce = 0;
          }

          var identStart = this.startPos;
          if(this.data) {
            identStart = this.data.from;
          }

          var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
          if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
              pos.ch < identStart.ch || this.cm.somethingSelected() ||
              (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
            this.close();
          } else {
            var self = this;
            this.debounce = requestAnimationFrame(function() {self.update();});
            if (this.widget) this.widget.disable();
          }
        },

        update: function(first) {
          if (this.tick == null) return
          var self = this, myTick = ++this.tick
          fetchHints(this.options.hint, this.cm, this.options, function(data) {
            if (self.tick == myTick) self.finishUpdate(data, first)
          })
        },

        finishUpdate: function(data, first) {
          if (this.data) CodeMirror.signal(this.data, "update");

          var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
          if (this.widget) this.widget.close();

          this.data = data;

          if (data && data.list.length) {
            if (picked && data.list.length == 1) {
              this.pick(data, 0);
            } else {
              this.widget = new Widget(this, data);
              CodeMirror.signal(data, "shown");
            }
          }
        }
      };

      function parseOptions(cm, pos, options) {
        var editor = cm.options.hintOptions;
        var out = {};
        for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
        if (editor) for (var prop in editor)
          if (editor[prop] !== undefined) out[prop] = editor[prop];
        if (options) for (var prop in options)
          if (options[prop] !== undefined) out[prop] = options[prop];
        if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
        return out;
      }

      function getText(completion) {
        if (typeof completion == "string") return completion;
        else return completion.text;
      }

      function buildKeyMap(completion, handle) {
        var baseMap = {
          Up: function() {handle.moveFocus(-1);},
          Down: function() {handle.moveFocus(1);},
          PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
          PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
          Home: function() {handle.setFocus(0);},
          End: function() {handle.setFocus(handle.length - 1);},
          Enter: handle.pick,
          Tab: handle.pick,
          Esc: handle.close
        };

        var mac = /Mac/.test(navigator.platform);

        if (mac) {
          baseMap["Ctrl-P"] = function() {handle.moveFocus(-1);};
          baseMap["Ctrl-N"] = function() {handle.moveFocus(1);};
        }

        var custom = completion.options.customKeys;
        var ourMap = custom ? {} : baseMap;
        function addBinding(key, val) {
          var bound;
          if (typeof val != "string")
            bound = function(cm) { return val(cm, handle); };
          // This mechanism is deprecated
          else if (baseMap.hasOwnProperty(val))
            bound = baseMap[val];
          else
            bound = val;
          ourMap[key] = bound;
        }
        if (custom)
          for (var key in custom) if (custom.hasOwnProperty(key))
            addBinding(key, custom[key]);
        var extra = completion.options.extraKeys;
        if (extra)
          for (var key in extra) if (extra.hasOwnProperty(key))
            addBinding(key, extra[key]);
        return ourMap;
      }

      function getHintElement(hintsElement, el) {
        while (el && el != hintsElement) {
          if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
          el = el.parentNode;
        }
      }

      function Widget(completion, data) {
        this.id = "cm-complete-" + Math.floor(Math.random(1e6))
        this.completion = completion;
        this.data = data;
        this.picked = false;
        var widget = this, cm = completion.cm;
        var ownerDocument = cm.getInputField().ownerDocument;
        var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;

        var hints = this.hints = ownerDocument.createElement("ul");
        hints.setAttribute("role", "listbox")
        hints.setAttribute("aria-expanded", "true")
        hints.id = this.id
        var theme = completion.cm.options.theme;
        hints.className = "CodeMirror-hints " + theme;
        this.selectedHint = data.selectedHint || 0;

        var completions = data.list;
        for (var i = 0; i < completions.length; ++i) {
          var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
          var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
          if (cur.className != null) className = cur.className + " " + className;
          elt.className = className;
          if (i == this.selectedHint) elt.setAttribute("aria-selected", "true")
          elt.id = this.id + "-" + i
          elt.setAttribute("role", "option")
          if (cur.render) cur.render(elt, data, cur);
          else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
          elt.hintId = i;
        }

        var container = completion.options.container || ownerDocument.body;
        var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
        var left = pos.left, top = pos.bottom, below = true;
        var offsetLeft = 0, offsetTop = 0;
        if (container !== ownerDocument.body) {
          // We offset the cursor position because left and top are relative to the offsetParent's top left corner.
          var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
          var offsetParent = isContainerPositioned ? container : container.offsetParent;
          var offsetParentPosition = offsetParent.getBoundingClientRect();
          var bodyPosition = ownerDocument.body.getBoundingClientRect();
          offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);
          offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);
        }
        hints.style.left = (left - offsetLeft) + "px";
        hints.style.top = (top - offsetTop) + "px";

        // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
        var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
        var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
        container.appendChild(hints);
        cm.getInputField().setAttribute("aria-autocomplete", "list")
        cm.getInputField().setAttribute("aria-owns", this.id)
        cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint)

        var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
        var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;

        // Compute in the timeout to avoid reflow on init
        var startScroll;
        setTimeout(function() { startScroll = cm.getScrollInfo(); });

        var overlapY = box.bottom - winH;
        if (overlapY > 0) {
          var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
          if (curTop - height > 0) { // Fits above cursor
            hints.style.top = (top = pos.top - height - offsetTop) + "px";
            below = false;
          } else if (height > winH) {
            hints.style.height = (winH - 5) + "px";
            hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";
            var cursor = cm.getCursor();
            if (data.from.ch != cursor.ch) {
              pos = cm.cursorCoords(cursor);
              hints.style.left = (left = pos.left - offsetLeft) + "px";
              box = hints.getBoundingClientRect();
            }
          }
        }
        var overlapX = box.right - winW;
        if (scrolls) overlapX += cm.display.nativeBarWidth;
        if (overlapX > 0) {
          if (box.right - box.left > winW) {
            hints.style.width = (winW - 5) + "px";
            overlapX -= (box.right - box.left) - winW;
          }
          hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
        }
        if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
          node.style.paddingRight = cm.display.nativeBarWidth + "px"

        cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
          moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
          setFocus: function(n) { widget.changeActive(n); },
          menuSize: function() { return widget.screenAmount(); },
          length: completions.length,
          close: function() { completion.close(); },
          pick: function() { widget.pick(); },
          data: data
        }));

        if (completion.options.closeOnUnfocus) {
          var closingOnBlur;
          cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
          cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
        }

        cm.on("scroll", this.onScroll = function() {
          var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
          if (!startScroll) startScroll = cm.getScrollInfo();
          var newTop = top + startScroll.top - curScroll.top;
          var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
          if (!below) point += hints.offsetHeight;
          if (point <= editor.top || point >= editor.bottom) return completion.close();
          hints.style.top = newTop + "px";
          hints.style.left = (left + startScroll.left - curScroll.left) + "px";
        });

        CodeMirror.on(hints, "dblclick", function(e) {
          var t = getHintElement(hints, e.target || e.srcElement);
          if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
        });

        CodeMirror.on(hints, "click", function(e) {
          var t = getHintElement(hints, e.target || e.srcElement);
          if (t && t.hintId != null) {
            widget.changeActive(t.hintId);
            if (completion.options.completeOnSingleClick) widget.pick();
          }
        });

        CodeMirror.on(hints, "mousedown", function() {
          setTimeout(function(){cm.focus();}, 20);
        });

        // The first hint doesn't need to be scrolled to on init
        var selectedHintRange = this.getSelectedHintRange();
        if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
          this.scrollToActive();
        }

        CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
        return true;
      }

      Widget.prototype = {
        close: function() {
          if (this.completion.widget != this) return;
          this.completion.widget = null;
          if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);
          this.completion.cm.removeKeyMap(this.keyMap);
          var input = this.completion.cm.getInputField()
          input.removeAttribute("aria-activedescendant")
          input.removeAttribute("aria-owns")

          var cm = this.completion.cm;
          if (this.completion.options.closeOnUnfocus) {
            cm.off("blur", this.onBlur);
            cm.off("focus", this.onFocus);
          }
          cm.off("scroll", this.onScroll);
        },

        disable: function() {
          this.completion.cm.removeKeyMap(this.keyMap);
          var widget = this;
          this.keyMap = {Enter: function() { widget.picked = true; }};
          this.completion.cm.addKeyMap(this.keyMap);
        },

        pick: function() {
          this.completion.pick(this.data, this.selectedHint);
        },

        changeActive: function(i, avoidWrap) {
          if (i >= this.data.list.length)
            i = avoidWrap ? this.data.list.length - 1 : 0;
          else if (i < 0)
            i = avoidWrap ? 0  : this.data.list.length - 1;
          if (this.selectedHint == i) return;
          var node = this.hints.childNodes[this.selectedHint];
          if (node) {
            node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
            node.removeAttribute("aria-selected")
          }
          node = this.hints.childNodes[this.selectedHint = i];
          node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
          node.setAttribute("aria-selected", "true")
          this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id)
          this.scrollToActive()
          CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
        },

        scrollToActive: function() {
          var selectedHintRange = this.getSelectedHintRange();
          var node1 = this.hints.childNodes[selectedHintRange.from];
          var node2 = this.hints.childNodes[selectedHintRange.to];
          var firstNode = this.hints.firstChild;
          if (node1.offsetTop < this.hints.scrollTop)
            this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
          else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
            this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
        },

        screenAmount: function() {
          return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
        },

        getSelectedHintRange: function() {
          var margin = this.completion.options.scrollMargin || 0;
          return {
            from: Math.max(0, this.selectedHint - margin),
            to: Math.min(this.data.list.length - 1, this.selectedHint + margin),
          };
        }
      };

      function applicableHelpers(cm, helpers) {
        if (!cm.somethingSelected()) return helpers
        var result = []
        for (var i = 0; i < helpers.length; i++)
          if (helpers[i].supportsSelection) result.push(helpers[i])
        return result
      }

      function fetchHints(hint, cm, options, callback) {
        if (hint.async) {
          hint(cm, callback, options)
        } else {
          var result = hint(cm, options)
          if (result && result.then) result.then(callback)
          else callback(result)
        }
      }

      function resolveAutoHints(cm, pos) {
        var helpers = cm.getHelpers(pos, "hint"), words
        if (helpers.length) {
          var resolved = function(cm, callback, options) {
            var app = applicableHelpers(cm, helpers);
            function run(i) {
              if (i == app.length) return callback(null)
              fetchHints(app[i], cm, options, function(result) {
                if (result && result.list.length > 0) callback(result)
                else run(i + 1)
              })
            }
            run(0)
          }
          resolved.async = true
          resolved.supportsSelection = true
          return resolved
        } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
          return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
        } else if (CodeMirror.hint.anyword) {
          return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
        } else {
          return function() {}
        }
      }

      CodeMirror.registerHelper("hint", "auto", {
        resolve: resolveAutoHints
      });

      CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
        var cur = cm.getCursor(), token = cm.getTokenAt(cur)
        var term, from = CodeMirror.Pos(cur.line, token.start), to = cur
        if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
          term = token.string.substr(0, cur.ch - token.start)
        } else {
          term = ""
          from = cur
        }
        var found = [];
        for (var i = 0; i < options.words.length; i++) {
          var word = options.words[i];
          if (word.slice(0, term.length) == term)
            found.push(word);
        }

        if (found.length) return {list: found, from: from, to: to};
      });

      CodeMirror.commands.autocomplete = CodeMirror.showHint;

      var defaultOptions = {
        hint: CodeMirror.hint.auto,
        completeSingle: true,
        alignWithWord: true,
        closeCharacters: /[\s()\[\]{};:>,]/,
        closeOnPick: true,
        closeOnUnfocus: true,
        updateOnCursorActivity: true,
        completeOnSingleClick: true,
        container: null,
        customKeys: null,
        extraKeys: null,
        paddingForScrollbar: true,
        moveOnOverlap: true,
      };

      CodeMirror.defineOption("hintOptions", null);
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-sql-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../mode/sql/sql"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../mode/sql/sql"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var tables;
      var defaultTable;
      var keywords;
      var identifierQuote;
      var CONS = {
        QUERY_DIV: ";",
        ALIAS_KEYWORD: "AS"
      };
      var Pos = CodeMirror.Pos, cmpPos = CodeMirror.cmpPos;

      function isArray(val) { return Object.prototype.toString.call(val) == "[object Array]" }

      function getKeywords(editor) {
        var mode = editor.doc.modeOption;
        if (mode === "sql") mode = "text/x-sql";
        return CodeMirror.resolveMode(mode).keywords;
      }

      function getIdentifierQuote(editor) {
        var mode = editor.doc.modeOption;
        if (mode === "sql") mode = "text/x-sql";
        return CodeMirror.resolveMode(mode).identifierQuote || "`";
      }

      function getText(item) {
        return typeof item == "string" ? item : item.text;
      }

      function wrapTable(name, value) {
        if (isArray(value)) value = {columns: value}
        if (!value.text) value.text = name
        return value
      }

      function parseTables(input) {
        var result = {}
        if (isArray(input)) {
          for (var i = input.length - 1; i >= 0; i--) {
            var item = input[i]
            result[getText(item).toUpperCase()] = wrapTable(getText(item), item)
          }
        } else if (input) {
          for (var name in input)
            result[name.toUpperCase()] = wrapTable(name, input[name])
        }
        return result
      }

      function getTable(name) {
        return tables[name.toUpperCase()]
      }

      function shallowClone(object) {
        var result = {};
        for (var key in object) if (object.hasOwnProperty(key))
          result[key] = object[key];
        return result;
      }

      function match(string, word) {
        var len = string.length;
        var sub = getText(word).substr(0, len);
        return string.toUpperCase() === sub.toUpperCase();
      }

      function addMatches(result, search, wordlist, formatter) {
        if (isArray(wordlist)) {
          for (var i = 0; i < wordlist.length; i++)
            if (match(search, wordlist[i])) result.push(formatter(wordlist[i]))
        } else {
          for (var word in wordlist) if (wordlist.hasOwnProperty(word)) {
            var val = wordlist[word]
            if (!val || val === true)
              val = word
            else
              val = val.displayText ? {text: val.text, displayText: val.displayText} : val.text
            if (match(search, val)) result.push(formatter(val))
          }
        }
      }

      function cleanName(name) {
        // Get rid name from identifierQuote and preceding dot(.)
        if (name.charAt(0) == ".") {
          name = name.substr(1);
        }
        // replace duplicated identifierQuotes with single identifierQuotes
        // and remove single identifierQuotes
        var nameParts = name.split(identifierQuote+identifierQuote);
        for (var i = 0; i < nameParts.length; i++)
          nameParts[i] = nameParts[i].replace(new RegExp(identifierQuote,"g"), "");
        return nameParts.join(identifierQuote);
      }

      function insertIdentifierQuotes(name) {
        var nameParts = getText(name).split(".");
        for (var i = 0; i < nameParts.length; i++)
          nameParts[i] = identifierQuote +
            // duplicate identifierQuotes
            nameParts[i].replace(new RegExp(identifierQuote,"g"), identifierQuote+identifierQuote) +
            identifierQuote;
        var escaped = nameParts.join(".");
        if (typeof name == "string") return escaped;
        name = shallowClone(name);
        name.text = escaped;
        return name;
      }

      function nameCompletion(cur, token, result, editor) {
        // Try to complete table, column names and return start position of completion
        var useIdentifierQuotes = false;
        var nameParts = [];
        var start = token.start;
        var cont = true;
        while (cont) {
          cont = (token.string.charAt(0) == ".");
          useIdentifierQuotes = useIdentifierQuotes || (token.string.charAt(0) == identifierQuote);

          start = token.start;
          nameParts.unshift(cleanName(token.string));

          token = editor.getTokenAt(Pos(cur.line, token.start));
          if (token.string == ".") {
            cont = true;
            token = editor.getTokenAt(Pos(cur.line, token.start));
          }
        }

        // Try to complete table names
        var string = nameParts.join(".");
        addMatches(result, string, tables, function(w) {
          return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
        });

        // Try to complete columns from defaultTable
        addMatches(result, string, defaultTable, function(w) {
          return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
        });

        // Try to complete columns
        string = nameParts.pop();
        var table = nameParts.join(".");

        var alias = false;
        var aliasTable = table;
        // Check if table is available. If not, find table by Alias
        if (!getTable(table)) {
          var oldTable = table;
          table = findTableByAlias(table, editor);
          if (table !== oldTable) alias = true;
        }

        var columns = getTable(table);
        if (columns && columns.columns)
          columns = columns.columns;

        if (columns) {
          addMatches(result, string, columns, function(w) {
            var tableInsert = table;
            if (alias == true) tableInsert = aliasTable;
            if (typeof w == "string") {
              w = tableInsert + "." + w;
            } else {
              w = shallowClone(w);
              w.text = tableInsert + "." + w.text;
            }
            return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
          });
        }

        return start;
      }

      function eachWord(lineText, f) {
        var words = lineText.split(/\s+/)
        for (var i = 0; i < words.length; i++)
          if (words[i]) f(words[i].replace(/[`,;]/g, ''))
      }

      function findTableByAlias(alias, editor) {
        var doc = editor.doc;
        var fullQuery = doc.getValue();
        var aliasUpperCase = alias.toUpperCase();
        var previousWord = "";
        var table = "";
        var separator = [];
        var validRange = {
          start: Pos(0, 0),
          end: Pos(editor.lastLine(), editor.getLineHandle(editor.lastLine()).length)
        };

        //add separator
        var indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV);
        while(indexOfSeparator != -1) {
          separator.push(doc.posFromIndex(indexOfSeparator));
          indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV, indexOfSeparator+1);
        }
        separator.unshift(Pos(0, 0));
        separator.push(Pos(editor.lastLine(), editor.getLineHandle(editor.lastLine()).text.length));

        //find valid range
        var prevItem = null;
        var current = editor.getCursor()
        for (var i = 0; i < separator.length; i++) {
          if ((prevItem == null || cmpPos(current, prevItem) > 0) && cmpPos(current, separator[i]) <= 0) {
            validRange = {start: prevItem, end: separator[i]};
            break;
          }
          prevItem = separator[i];
        }

        if (validRange.start) {
          var query = doc.getRange(validRange.start, validRange.end, false);

          for (var i = 0; i < query.length; i++) {
            var lineText = query[i];
            eachWord(lineText, function(word) {
              var wordUpperCase = word.toUpperCase();
              if (wordUpperCase === aliasUpperCase && getTable(previousWord))
                table = previousWord;
              if (wordUpperCase !== CONS.ALIAS_KEYWORD)
                previousWord = word;
            });
            if (table) break;
          }
        }
        return table;
      }

      CodeMirror.registerHelper("hint", "sql", function(editor, options) {
        tables = parseTables(options && options.tables)
        var defaultTableName = options && options.defaultTable;
        var disableKeywords = options && options.disableKeywords;
        defaultTable = defaultTableName && getTable(defaultTableName);
        keywords = getKeywords(editor);
        identifierQuote = getIdentifierQuote(editor);

        if (defaultTableName && !defaultTable)
          defaultTable = findTableByAlias(defaultTableName, editor);

        defaultTable = defaultTable || [];

        if (defaultTable.columns)
          defaultTable = defaultTable.columns;

        var cur = editor.getCursor();
        var result = [];
        var token = editor.getTokenAt(cur), start, end, search;
        if (token.end > cur.ch) {
          token.end = cur.ch;
          token.string = token.string.slice(0, cur.ch - token.start);
        }

        if (token.string.match(/^[.`"'\w@][\w$#]*$/g)) {
          search = token.string;
          start = token.start;
          end = token.end;
        } else {
          start = end = cur.ch;
          search = "";
        }
        if (search.charAt(0) == "." || search.charAt(0) == identifierQuote) {
          start = nameCompletion(cur, token, result, editor);
        } else {
          var objectOrClass = function(w, className) {
            if (typeof w === "object") {
              w.className = className;
            } else {
              w = { text: w, className: className };
            }
            return w;
          };
        addMatches(result, search, defaultTable, function(w) {
            return objectOrClass(w, "CodeMirror-hint-table CodeMirror-hint-default-table");
        });
        addMatches(
            result,
            search,
            tables, function(w) {
              return objectOrClass(w, "CodeMirror-hint-table");
            }
        );
        if (!disableKeywords)
          addMatches(result, search, keywords, function(w) {
              return objectOrClass(w.toUpperCase(), "CodeMirror-hint-keyword");
          });
      }

        return {list: result, from: Pos(cur.line, start), to: Pos(cur.line, end)};
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-hint-xml-hint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var Pos = CodeMirror.Pos;

      function matches(hint, typed, matchInMiddle) {
        if (matchInMiddle) return hint.indexOf(typed) >= 0;
        else return hint.lastIndexOf(typed, 0) == 0;
      }

      function getHints(cm, options) {
        var tags = options && options.schemaInfo;
        var quote = (options && options.quoteChar) || '"';
        var matchInMiddle = options && options.matchInMiddle;
        if (!tags) return;
        var cur = cm.getCursor(), token = cm.getTokenAt(cur);
        if (token.end > cur.ch) {
          token.end = cur.ch;
          token.string = token.string.slice(0, cur.ch - token.start);
        }
        var inner = CodeMirror.innerMode(cm.getMode(), token.state);
        if (!inner.mode.xmlCurrentTag) return
        var result = [], replaceToken = false, prefix;
        var tag = /\btag\b/.test(token.type) && !/>$/.test(token.string);
        var tagName = tag && /^\w/.test(token.string), tagStart;

        if (tagName) {
          var before = cm.getLine(cur.line).slice(Math.max(0, token.start - 2), token.start);
          var tagType = /<\/$/.test(before) ? "close" : /<$/.test(before) ? "open" : null;
          if (tagType) tagStart = token.start - (tagType == "close" ? 2 : 1);
        } else if (tag && token.string == "<") {
          tagType = "open";
        } else if (tag && token.string == "</") {
          tagType = "close";
        }

        var tagInfo = inner.mode.xmlCurrentTag(inner.state)
        if (!tag && !tagInfo || tagType) {
          if (tagName)
            prefix = token.string;
          replaceToken = tagType;
          var context = inner.mode.xmlCurrentContext ? inner.mode.xmlCurrentContext(inner.state) : []
          var inner = context.length && context[context.length - 1]
          var curTag = inner && tags[inner]
          var childList = inner ? curTag && curTag.children : tags["!top"];
          if (childList && tagType != "close") {
            for (var i = 0; i < childList.length; ++i) if (!prefix || matches(childList[i], prefix, matchInMiddle))
              result.push("<" + childList[i]);
          } else if (tagType != "close") {
            for (var name in tags)
              if (tags.hasOwnProperty(name) && name != "!top" && name != "!attrs" && (!prefix || matches(name, prefix, matchInMiddle)))
                result.push("<" + name);
          }
          if (inner && (!prefix || tagType == "close" && matches(inner, prefix, matchInMiddle)))
            result.push("</" + inner + ">");
        } else {
          // Attribute completion
          var curTag = tagInfo && tags[tagInfo.name], attrs = curTag && curTag.attrs;
          var globalAttrs = tags["!attrs"];
          if (!attrs && !globalAttrs) return;
          if (!attrs) {
            attrs = globalAttrs;
          } else if (globalAttrs) { // Combine tag-local and global attributes
            var set = {};
            for (var nm in globalAttrs) if (globalAttrs.hasOwnProperty(nm)) set[nm] = globalAttrs[nm];
            for (var nm in attrs) if (attrs.hasOwnProperty(nm)) set[nm] = attrs[nm];
            attrs = set;
          }
          if (token.type == "string" || token.string == "=") { // A value
            var before = cm.getRange(Pos(cur.line, Math.max(0, cur.ch - 60)),
                                     Pos(cur.line, token.type == "string" ? token.start : token.end));
            var atName = before.match(/([^\s\u00a0=<>\"\']+)=$/), atValues;
            if (!atName || !attrs.hasOwnProperty(atName[1]) || !(atValues = attrs[atName[1]])) return;
            if (typeof atValues == 'function') atValues = atValues.call(this, cm); // Functions can be used to supply values for autocomplete widget
            if (token.type == "string") {
              prefix = token.string;
              var n = 0;
              if (/['"]/.test(token.string.charAt(0))) {
                quote = token.string.charAt(0);
                prefix = token.string.slice(1);
                n++;
              }
              var len = token.string.length;
              if (/['"]/.test(token.string.charAt(len - 1))) {
                quote = token.string.charAt(len - 1);
                prefix = token.string.substr(n, len - 2);
              }
              if (n) { // an opening quote
                var line = cm.getLine(cur.line);
                if (line.length > token.end && line.charAt(token.end) == quote) token.end++; // include a closing quote
              }
              replaceToken = true;
            }
            var returnHintsFromAtValues = function(atValues) {
              if (atValues)
                for (var i = 0; i < atValues.length; ++i) if (!prefix || matches(atValues[i], prefix, matchInMiddle))
                  result.push(quote + atValues[i] + quote);
              return returnHints();
            };
            if (atValues && atValues.then) return atValues.then(returnHintsFromAtValues);
            return returnHintsFromAtValues(atValues);
          } else { // An attribute name
            if (token.type == "attribute") {
              prefix = token.string;
              replaceToken = true;
            }
            for (var attr in attrs) if (attrs.hasOwnProperty(attr) && (!prefix || matches(attr, prefix, matchInMiddle)))
              result.push(attr);
          }
        }
        function returnHints() {
          return {
            list: result,
            from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,
            to: replaceToken ? Pos(cur.line, token.end) : cur
          };
        }
        return returnHints();
      }

      CodeMirror.registerHelper("hint", "xml", getHints);
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-coffeescript-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Depends on coffeelint.js from http://www.coffeelint.org/js/coffeelint.js

    // declare global: coffeelint

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.registerHelper("lint", "coffeescript", function(text) {
      var found = [];
      if (!window.coffeelint) {
        if (window.console) {
          window.console.error("Error: window.coffeelint not defined, CodeMirror CoffeeScript linting cannot run.");
        }
        return found;
      }
      var parseError = function(err) {
        var loc = err.lineNumber;
        found.push({from: CodeMirror.Pos(loc-1, 0),
                    to: CodeMirror.Pos(loc, 0),
                    severity: err.level,
                    message: err.message});
      };
      try {
        var res = coffeelint.lint(text);
        for(var i = 0; i < res.length; i++) {
          parseError(res[i]);
        }
      } catch(e) {
        found.push({from: CodeMirror.Pos(e.location.first_line, 0),
                    to: CodeMirror.Pos(e.location.last_line, e.location.last_column),
                    severity: 'error',
                    message: e.message});
      }
      return found;
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-css-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Depends on csslint.js from https://github.com/stubbornella/csslint

    // declare global: CSSLint

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.registerHelper("lint", "css", function(text, options) {
      var found = [];
      if (!window.CSSLint) {
        if (window.console) {
            window.console.error("Error: window.CSSLint not defined, CodeMirror CSS linting cannot run.");
        }
        return found;
      }
      var results = CSSLint.verify(text, options), messages = results.messages, message = null;
      for ( var i = 0; i < messages.length; i++) {
        message = messages[i];
        var startLine = message.line -1, endLine = message.line -1, startCol = message.col -1, endCol = message.col;
        found.push({
          from: CodeMirror.Pos(startLine, startCol),
          to: CodeMirror.Pos(endLine, endCol),
          message: message.message,
          severity : message.type
        });
      }
      return found;
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-html-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Depends on htmlhint.js from http://htmlhint.com/js/htmlhint.js

    // declare global: HTMLHint

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("htmlhint"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "htmlhint"], mod);
      else // Plain browser env
        mod(CodeMirror, window.HTMLHint);
    })(function(CodeMirror, HTMLHint) {
      "use strict";

      var defaultRules = {
        "tagname-lowercase": true,
        "attr-lowercase": true,
        "attr-value-double-quotes": true,
        "doctype-first": false,
        "tag-pair": true,
        "spec-char-escape": true,
        "id-unique": true,
        "src-not-empty": true,
        "attr-no-duplication": true
      };

      CodeMirror.registerHelper("lint", "html", function(text, options) {
        var found = [];
        if (HTMLHint && !HTMLHint.verify) {
          if(typeof HTMLHint.default !== 'undefined') {
            HTMLHint = HTMLHint.default;
          } else {
            HTMLHint = HTMLHint.HTMLHint;
          }
        }
        if (!HTMLHint) HTMLHint = window.HTMLHint;
        if (!HTMLHint) {
          if (window.console) {
              window.console.error("Error: HTMLHint not found, not defined on window, or not available through define/require, CodeMirror HTML linting cannot run.");
          }
          return found;
        }
        var messages = HTMLHint.verify(text, options && options.rules || defaultRules);
        for (var i = 0; i < messages.length; i++) {
          var message = messages[i];
          var startLine = message.line - 1, endLine = message.line - 1, startCol = message.col - 1, endCol = message.col;
          found.push({
            from: CodeMirror.Pos(startLine, startCol),
            to: CodeMirror.Pos(endLine, endCol),
            message: message.message,
            severity : message.type
          });
        }
        return found;
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-javascript-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Depends on jshint.js from https://github.com/jshint/jshint

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";
      // declare global: JSHINT

      function validator(text, options) {
        if (!window.JSHINT) {
          if (window.console) {
            window.console.error("Error: window.JSHINT not defined, CodeMirror JavaScript linting cannot run.");
          }
          return [];
        }
        if (!options.indent) // JSHint error.character actually is a column index, this fixes underlining on lines using tabs for indentation
          options.indent = 1; // JSHint default value is 4
        JSHINT(text, options, options.globals);
        var errors = JSHINT.data().errors, result = [];
        if (errors) parseErrors(errors, result);
        return result;
      }

      CodeMirror.registerHelper("lint", "javascript", validator);

      function parseErrors(errors, output) {
        for ( var i = 0; i < errors.length; i++) {
          var error = errors[i];
          if (error) {
            if (error.line <= 0) {
              if (window.console) {
                window.console.warn("Cannot display JSHint error (invalid line " + error.line + ")", error);
              }
              continue;
            }

            var start = error.character - 1, end = start + 1;
            if (error.evidence) {
              var index = error.evidence.substring(start).search(/.\b/);
              if (index > -1) {
                end += index;
              }
            }

            // Convert to format expected by validation service
            var hint = {
              message: error.reason,
              severity: error.code ? (error.code.startsWith('W') ? "warning" : "error") : "error",
              from: CodeMirror.Pos(error.line - 1, start),
              to: CodeMirror.Pos(error.line - 1, end)
            };

            output.push(hint);
          }
        }
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-json-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Depends on jsonlint.js from https://github.com/zaach/jsonlint

    // declare global: jsonlint

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.registerHelper("lint", "json", function(text) {
      var found = [];
      if (!window.jsonlint) {
        if (window.console) {
          window.console.error("Error: window.jsonlint not defined, CodeMirror JSON linting cannot run.");
        }
        return found;
      }
      // for jsonlint's web dist jsonlint is exported as an object with a single property parser, of which parseError
      // is a subproperty
      var jsonlint = window.jsonlint.parser || window.jsonlint
      jsonlint.parseError = function(str, hash) {
        var loc = hash.loc;
        found.push({from: CodeMirror.Pos(loc.first_line - 1, loc.first_column),
                    to: CodeMirror.Pos(loc.last_line - 1, loc.last_column),
                    message: str});
      };
      try { jsonlint.parse(text); }
      catch(e) {}
      return found;
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-lint.css: |
    /* The lint marker gutter */
    .CodeMirror-lint-markers {
      width: 16px;
    }

    .CodeMirror-lint-tooltip {
      background-color: #ffd;
      border: 1px solid black;
      border-radius: 4px 4px 4px 4px;
      color: black;
      font-family: monospace;
      font-size: 10pt;
      overflow: hidden;
      padding: 2px 5px;
      position: fixed;
      white-space: pre;
      white-space: pre-wrap;
      z-index: 100;
      max-width: 600px;
      opacity: 0;
      transition: opacity .4s;
      -moz-transition: opacity .4s;
      -webkit-transition: opacity .4s;
      -o-transition: opacity .4s;
      -ms-transition: opacity .4s;
    }

    .CodeMirror-lint-mark {
      background-position: left bottom;
      background-repeat: repeat-x;
    }

    .CodeMirror-lint-mark-warning {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
    }

    .CodeMirror-lint-mark-error {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==");
    }

    .CodeMirror-lint-marker {
      background-position: center center;
      background-repeat: no-repeat;
      cursor: pointer;
      display: inline-block;
      height: 16px;
      width: 16px;
      vertical-align: middle;
      position: relative;
    }

    .CodeMirror-lint-message {
      padding-left: 18px;
      background-position: top left;
      background-repeat: no-repeat;
    }

    .CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=");
    }

    .CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=");
    }

    .CodeMirror-lint-marker-multiple {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC");
      background-repeat: no-repeat;
      background-position: right bottom;
      width: 100%; height: 100%;
    }

    .CodeMirror-lint-line-error {
      background-color: rgba(183, 76, 81, 0.08);
    }

    .CodeMirror-lint-line-warning {
      background-color: rgba(255, 211, 0, 0.1);
    }
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";
      var GUTTER_ID = "CodeMirror-lint-markers";
      var LINT_LINE_ID = "CodeMirror-lint-line-";

      function showTooltip(cm, e, content) {
        var tt = document.createElement("div");
        tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;
        tt.appendChild(content.cloneNode(true));
        if (cm.state.lint.options.selfContain)
          cm.getWrapperElement().appendChild(tt);
        else
          document.body.appendChild(tt);

        function position(e) {
          if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
          tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
          tt.style.left = (e.clientX + 5) + "px";
        }
        CodeMirror.on(document, "mousemove", position);
        position(e);
        if (tt.style.opacity != null) tt.style.opacity = 1;
        return tt;
      }
      function rm(elt) {
        if (elt.parentNode) elt.parentNode.removeChild(elt);
      }
      function hideTooltip(tt) {
        if (!tt.parentNode) return;
        if (tt.style.opacity == null) rm(tt);
        tt.style.opacity = 0;
        setTimeout(function() { rm(tt); }, 600);
      }

      function showTooltipFor(cm, e, content, node) {
        var tooltip = showTooltip(cm, e, content);
        function hide() {
          CodeMirror.off(node, "mouseout", hide);
          if (tooltip) { hideTooltip(tooltip); tooltip = null; }
        }
        var poll = setInterval(function() {
          if (tooltip) for (var n = node;; n = n.parentNode) {
            if (n && n.nodeType == 11) n = n.host;
            if (n == document.body) return;
            if (!n) { hide(); break; }
          }
          if (!tooltip) return clearInterval(poll);
        }, 400);
        CodeMirror.on(node, "mouseout", hide);
      }

      function LintState(cm, conf, hasGutter) {
        this.marked = [];
        if (conf instanceof Function) conf = {getAnnotations: conf};
        if (!conf || conf === true) conf = {};
        this.options = {};
        this.linterOptions = conf.options || {};
        for (var prop in defaults) this.options[prop] = defaults[prop];
        for (var prop in conf) {
          if (defaults.hasOwnProperty(prop)) {
            if (conf[prop] != null) this.options[prop] = conf[prop];
          } else if (!conf.options) {
            this.linterOptions[prop] = conf[prop];
          }
        }
        this.timeout = null;
        this.hasGutter = hasGutter;
        this.onMouseOver = function(e) { onMouseOver(cm, e); };
        this.waitingFor = 0
      }

      var defaults = {
        highlightLines: false,
        tooltips: true,
        delay: 500,
        lintOnChange: true,
        getAnnotations: null,
        async: false,
        selfContain: null,
        formatAnnotation: null,
        onUpdateLinting: null
      }

      function clearMarks(cm) {
        var state = cm.state.lint;
        if (state.hasGutter) cm.clearGutter(GUTTER_ID);
        if (state.options.highlightLines) clearErrorLines(cm);
        for (var i = 0; i < state.marked.length; ++i)
          state.marked[i].clear();
        state.marked.length = 0;
      }

      function clearErrorLines(cm) {
        cm.eachLine(function(line) {
          var has = line.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(line.wrapClass);
          if (has) cm.removeLineClass(line, "wrap", has[0]);
        })
      }

      function makeMarker(cm, labels, severity, multiple, tooltips) {
        var marker = document.createElement("div"), inner = marker;
        marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
        if (multiple) {
          inner = marker.appendChild(document.createElement("div"));
          inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
        }

        if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
          showTooltipFor(cm, e, labels, inner);
        });

        return marker;
      }

      function getMaxSeverity(a, b) {
        if (a == "error") return a;
        else return b;
      }

      function groupByLine(annotations) {
        var lines = [];
        for (var i = 0; i < annotations.length; ++i) {
          var ann = annotations[i], line = ann.from.line;
          (lines[line] || (lines[line] = [])).push(ann);
        }
        return lines;
      }

      function annotationTooltip(ann) {
        var severity = ann.severity;
        if (!severity) severity = "error";
        var tip = document.createElement("div");
        tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
        if (typeof ann.messageHTML != 'undefined') {
          tip.innerHTML = ann.messageHTML;
        } else {
          tip.appendChild(document.createTextNode(ann.message));
        }
        return tip;
      }

      function lintAsync(cm, getAnnotations) {
        var state = cm.state.lint
        var id = ++state.waitingFor
        function abort() {
          id = -1
          cm.off("change", abort)
        }
        cm.on("change", abort)
        getAnnotations(cm.getValue(), function(annotations, arg2) {
          cm.off("change", abort)
          if (state.waitingFor != id) return
          if (arg2 && annotations instanceof CodeMirror) annotations = arg2
          cm.operation(function() {updateLinting(cm, annotations)})
        }, state.linterOptions, cm);
      }

      function startLinting(cm) {
        var state = cm.state.lint;
        if (!state) return;
        var options = state.options;
        /*
         * Passing rules in `options` property prevents JSHint (and other linters) from complaining
         * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
         */
        var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
        if (!getAnnotations) return;
        if (options.async || getAnnotations.async) {
          lintAsync(cm, getAnnotations)
        } else {
          var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);
          if (!annotations) return;
          if (annotations.then) annotations.then(function(issues) {
            cm.operation(function() {updateLinting(cm, issues)})
          });
          else cm.operation(function() {updateLinting(cm, annotations)})
        }
      }

      function updateLinting(cm, annotationsNotSorted) {
        var state = cm.state.lint;
        if (!state) return;
        var options = state.options;
        clearMarks(cm);

        var annotations = groupByLine(annotationsNotSorted);

        for (var line = 0; line < annotations.length; ++line) {
          var anns = annotations[line];
          if (!anns) continue;

          // filter out duplicate messages
          var message = [];
          anns = anns.filter(function(item) { return message.indexOf(item.message) > -1 ? false : message.push(item.message) });

          var maxSeverity = null;
          var tipLabel = state.hasGutter && document.createDocumentFragment();

          for (var i = 0; i < anns.length; ++i) {
            var ann = anns[i];
            var severity = ann.severity;
            if (!severity) severity = "error";
            maxSeverity = getMaxSeverity(maxSeverity, severity);

            if (options.formatAnnotation) ann = options.formatAnnotation(ann);
            if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

            if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
              className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,
              __annotation: ann
            }));
          }
          // use original annotations[line] to show multiple messages
          if (state.hasGutter)
            cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations[line].length > 1,
                                                           options.tooltips));

          if (options.highlightLines)
            cm.addLineClass(line, "wrap", LINT_LINE_ID + maxSeverity);
        }
        if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
      }

      function onChange(cm) {
        var state = cm.state.lint;
        if (!state) return;
        clearTimeout(state.timeout);
        state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);
      }

      function popupTooltips(cm, annotations, e) {
        var target = e.target || e.srcElement;
        var tooltip = document.createDocumentFragment();
        for (var i = 0; i < annotations.length; i++) {
          var ann = annotations[i];
          tooltip.appendChild(annotationTooltip(ann));
        }
        showTooltipFor(cm, e, tooltip, target);
      }

      function onMouseOver(cm, e) {
        var target = e.target || e.srcElement;
        if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
        var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
        var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

        var annotations = [];
        for (var i = 0; i < spans.length; ++i) {
          var ann = spans[i].__annotation;
          if (ann) annotations.push(ann);
        }
        if (annotations.length) popupTooltips(cm, annotations, e);
      }

      CodeMirror.defineOption("lint", false, function(cm, val, old) {
        if (old && old != CodeMirror.Init) {
          clearMarks(cm);
          if (cm.state.lint.options.lintOnChange !== false)
            cm.off("change", onChange);
          CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
          clearTimeout(cm.state.lint.timeout);
          delete cm.state.lint;
        }

        if (val) {
          var gutters = cm.getOption("gutters"), hasLintGutter = false;
          for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
          var state = cm.state.lint = new LintState(cm, val, hasLintGutter);
          if (state.options.lintOnChange)
            cm.on("change", onChange);
          if (state.options.tooltips != false && state.options.tooltips != "gutter")
            CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

          startLinting(cm);
        }
      });

      CodeMirror.defineExtension("performLint", function() {
        startLinting(this);
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-lint-yaml-lint.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    // Depends on js-yaml.js from https://github.com/nodeca/js-yaml

    // declare global: jsyaml

    CodeMirror.registerHelper("lint", "yaml", function(text) {
      var found = [];
      if (!window.jsyaml) {
        if (window.console) {
          window.console.error("Error: window.jsyaml not defined, CodeMirror YAML linting cannot run.");
        }
        return found;
      }
      try { jsyaml.loadAll(text); }
      catch(e) {
          var loc = e.mark,
              // js-yaml YAMLException doesn't always provide an accurate lineno
              // e.g., when there are multiple yaml docs
              // ---
              // ---
              // foo:bar
              from = loc ? CodeMirror.Pos(loc.line, loc.column) : CodeMirror.Pos(0, 0),
              to = from;
          found.push({ from: from, to: to, message: e.message });
      }
      return found;
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-merge-merge.css: |
    .CodeMirror-merge {
      position: relative;
      border: 1px solid #ddd;
      white-space: pre;
    }

    .CodeMirror-merge, .CodeMirror-merge .CodeMirror {
      height: 350px;
    }

    .CodeMirror-merge-2pane .CodeMirror-merge-pane { width: 47%; }
    .CodeMirror-merge-2pane .CodeMirror-merge-gap { width: 6%; }
    .CodeMirror-merge-3pane .CodeMirror-merge-pane { width: 31%; }
    .CodeMirror-merge-3pane .CodeMirror-merge-gap { width: 3.5%; }

    .CodeMirror-merge-pane {
      display: inline-block;
      white-space: normal;
      vertical-align: top;
    }
    .CodeMirror-merge-pane-rightmost {
      position: absolute;
      right: 0px;
      z-index: 1;
    }

    .CodeMirror-merge-gap {
      z-index: 2;
      display: inline-block;
      height: 100%;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
      overflow: hidden;
      border-left: 1px solid #ddd;
      border-right: 1px solid #ddd;
      position: relative;
      background: #f8f8f8;
    }

    .CodeMirror-merge-scrolllock-wrap {
      position: absolute;
      bottom: 0; left: 50%;
    }
    .CodeMirror-merge-scrolllock {
      position: relative;
      left: -50%;
      cursor: pointer;
      color: #555;
      line-height: 1;
    }
    .CodeMirror-merge-scrolllock:after {
      content: "\21db\00a0\00a0\21da";
    }
    .CodeMirror-merge-scrolllock.CodeMirror-merge-scrolllock-enabled:after {
      content: "\21db\21da";
    }

    .CodeMirror-merge-copybuttons-left, .CodeMirror-merge-copybuttons-right {
      position: absolute;
      left: 0; top: 0;
      right: 0; bottom: 0;
      line-height: 1;
    }

    .CodeMirror-merge-copy {
      position: absolute;
      cursor: pointer;
      color: #44c;
      z-index: 3;
    }

    .CodeMirror-merge-copy-reverse {
      position: absolute;
      cursor: pointer;
      color: #44c;
    }

    .CodeMirror-merge-copybuttons-left .CodeMirror-merge-copy { left: 2px; }
    .CodeMirror-merge-copybuttons-right .CodeMirror-merge-copy { right: 2px; }

    .CodeMirror-merge-r-inserted, .CodeMirror-merge-l-inserted {
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAYAAACddGYaAAAAGUlEQVQI12MwuCXy3+CWyH8GBgYGJgYkAABZbAQ9ELXurwAAAABJRU5ErkJggg==);
      background-position: bottom left;
      background-repeat: repeat-x;
    }

    .CodeMirror-merge-r-deleted, .CodeMirror-merge-l-deleted {
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAYAAACddGYaAAAAGUlEQVQI12M4Kyb2/6yY2H8GBgYGJgYkAABURgPz6Ks7wQAAAABJRU5ErkJggg==);
      background-position: bottom left;
      background-repeat: repeat-x;
    }

    .CodeMirror-merge-r-chunk { background: #ffffe0; }
    .CodeMirror-merge-r-chunk-start { border-top: 1px solid #ee8; }
    .CodeMirror-merge-r-chunk-end { border-bottom: 1px solid #ee8; }
    .CodeMirror-merge-r-connect { fill: #ffffe0; stroke: #ee8; stroke-width: 1px; }

    .CodeMirror-merge-l-chunk { background: #eef; }
    .CodeMirror-merge-l-chunk-start { border-top: 1px solid #88e; }
    .CodeMirror-merge-l-chunk-end { border-bottom: 1px solid #88e; }
    .CodeMirror-merge-l-connect { fill: #eef; stroke: #88e; stroke-width: 1px; }

    .CodeMirror-merge-l-chunk.CodeMirror-merge-r-chunk { background: #dfd; }
    .CodeMirror-merge-l-chunk-start.CodeMirror-merge-r-chunk-start { border-top: 1px solid #4e4; }
    .CodeMirror-merge-l-chunk-end.CodeMirror-merge-r-chunk-end { border-bottom: 1px solid #4e4; }

    .CodeMirror-merge-collapsed-widget:before {
      content: "(...)";
    }
    .CodeMirror-merge-collapsed-widget {
      cursor: pointer;
      color: #88b;
      background: #eef;
      border: 1px solid #ddf;
      font-size: 90%;
      padding: 0 3px;
      border-radius: 4px;
    }
    .CodeMirror-merge-collapsed-line .CodeMirror-gutter-elt { display: none; }
  uploads-admin-Public-Admin-plugins-codemirror-addon-merge-merge.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // declare global: diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror")); // Note non-packaged dependency diff_match_patch
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "diff_match_patch"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";
      var Pos = CodeMirror.Pos;
      var svgNS = "http://www.w3.org/2000/svg";

      function DiffView(mv, type) {
        this.mv = mv;
        this.type = type;
        this.classes = type == "left"
          ? {chunk: "CodeMirror-merge-l-chunk",
             start: "CodeMirror-merge-l-chunk-start",
             end: "CodeMirror-merge-l-chunk-end",
             insert: "CodeMirror-merge-l-inserted",
             del: "CodeMirror-merge-l-deleted",
             connect: "CodeMirror-merge-l-connect"}
          : {chunk: "CodeMirror-merge-r-chunk",
             start: "CodeMirror-merge-r-chunk-start",
             end: "CodeMirror-merge-r-chunk-end",
             insert: "CodeMirror-merge-r-inserted",
             del: "CodeMirror-merge-r-deleted",
             connect: "CodeMirror-merge-r-connect"};
      }

      DiffView.prototype = {
        constructor: DiffView,
        init: function(pane, orig, options) {
          this.edit = this.mv.edit;
          ;(this.edit.state.diffViews || (this.edit.state.diffViews = [])).push(this);
          this.orig = CodeMirror(pane, copyObj({value: orig, readOnly: !this.mv.options.allowEditingOriginals}, copyObj(options)));
          if (this.mv.options.connect == "align") {
            if (!this.edit.state.trackAlignable) this.edit.state.trackAlignable = new TrackAlignable(this.edit)
            this.orig.state.trackAlignable = new TrackAlignable(this.orig)
          }
          this.lockButton.title = this.edit.phrase("Toggle locked scrolling");

          this.orig.state.diffViews = [this];
          var classLocation = options.chunkClassLocation || "background";
          if (Object.prototype.toString.call(classLocation) != "[object Array]") classLocation = [classLocation]
          this.classes.classLocation = classLocation

          this.diff = getDiff(asString(orig), asString(options.value), this.mv.options.ignoreWhitespace);
          this.chunks = getChunks(this.diff);
          this.diffOutOfDate = this.dealigned = false;
          this.needsScrollSync = null

          this.showDifferences = options.showDifferences !== false;
        },
        registerEvents: function(otherDv) {
          this.forceUpdate = registerUpdate(this);
          setScrollLock(this, true, false);
          registerScroll(this, otherDv);
        },
        setShowDifferences: function(val) {
          val = val !== false;
          if (val != this.showDifferences) {
            this.showDifferences = val;
            this.forceUpdate("full");
          }
        }
      };

      function ensureDiff(dv) {
        if (dv.diffOutOfDate) {
          dv.diff = getDiff(dv.orig.getValue(), dv.edit.getValue(), dv.mv.options.ignoreWhitespace);
          dv.chunks = getChunks(dv.diff);
          dv.diffOutOfDate = false;
          CodeMirror.signal(dv.edit, "updateDiff", dv.diff);
        }
      }

      var updating = false;
      function registerUpdate(dv) {
        var edit = {from: 0, to: 0, marked: []};
        var orig = {from: 0, to: 0, marked: []};
        var debounceChange, updatingFast = false;
        function update(mode) {
          updating = true;
          updatingFast = false;
          if (mode == "full") {
            if (dv.svg) clear(dv.svg);
            if (dv.copyButtons) clear(dv.copyButtons);
            clearMarks(dv.edit, edit.marked, dv.classes);
            clearMarks(dv.orig, orig.marked, dv.classes);
            edit.from = edit.to = orig.from = orig.to = 0;
          }
          ensureDiff(dv);
          if (dv.showDifferences) {
            updateMarks(dv.edit, dv.diff, edit, DIFF_INSERT, dv.classes);
            updateMarks(dv.orig, dv.diff, orig, DIFF_DELETE, dv.classes);
          }

          if (dv.mv.options.connect == "align")
            alignChunks(dv);
          makeConnections(dv);
          if (dv.needsScrollSync != null) syncScroll(dv, dv.needsScrollSync)

          updating = false;
        }
        function setDealign(fast) {
          if (updating) return;
          dv.dealigned = true;
          set(fast);
        }
        function set(fast) {
          if (updating || updatingFast) return;
          clearTimeout(debounceChange);
          if (fast === true) updatingFast = true;
          debounceChange = setTimeout(update, fast === true ? 20 : 250);
        }
        function change(_cm, change) {
          if (!dv.diffOutOfDate) {
            dv.diffOutOfDate = true;
            edit.from = edit.to = orig.from = orig.to = 0;
          }
          // Update faster when a line was added/removed
          setDealign(change.text.length - 1 != change.to.line - change.from.line);
        }
        function swapDoc() {
          dv.diffOutOfDate = true;
          dv.dealigned = true;
          update("full");
        }
        dv.edit.on("change", change);
        dv.orig.on("change", change);
        dv.edit.on("swapDoc", swapDoc);
        dv.orig.on("swapDoc", swapDoc);
        if (dv.mv.options.connect == "align") {
          CodeMirror.on(dv.edit.state.trackAlignable, "realign", setDealign)
          CodeMirror.on(dv.orig.state.trackAlignable, "realign", setDealign)
        }
        dv.edit.on("viewportChange", function() { set(false); });
        dv.orig.on("viewportChange", function() { set(false); });
        update();
        return update;
      }

      function registerScroll(dv, otherDv) {
        dv.edit.on("scroll", function() {
          syncScroll(dv, true) && makeConnections(dv);
        });
        dv.orig.on("scroll", function() {
          syncScroll(dv, false) && makeConnections(dv);
          if (otherDv) syncScroll(otherDv, true) && makeConnections(otherDv);
        });
      }

      function syncScroll(dv, toOrig) {
        // Change handler will do a refresh after a timeout when diff is out of date
        if (dv.diffOutOfDate) {
          if (dv.lockScroll && dv.needsScrollSync == null) dv.needsScrollSync = toOrig
          return false
        }
        dv.needsScrollSync = null
        if (!dv.lockScroll) return true;
        var editor, other, now = +new Date;
        if (toOrig) { editor = dv.edit; other = dv.orig; }
        else { editor = dv.orig; other = dv.edit; }
        // Don't take action if the position of this editor was recently set
        // (to prevent feedback loops)
        if (editor.state.scrollSetBy == dv && (editor.state.scrollSetAt || 0) + 250 > now) return false;

        var sInfo = editor.getScrollInfo();
        if (dv.mv.options.connect == "align") {
          targetPos = sInfo.top;
        } else {
          var halfScreen = .5 * sInfo.clientHeight, midY = sInfo.top + halfScreen;
          var mid = editor.lineAtHeight(midY, "local");
          var around = chunkBoundariesAround(dv.chunks, mid, toOrig);
          var off = getOffsets(editor, toOrig ? around.edit : around.orig);
          var offOther = getOffsets(other, toOrig ? around.orig : around.edit);
          var ratio = (midY - off.top) / (off.bot - off.top);
          var targetPos = (offOther.top - halfScreen) + ratio * (offOther.bot - offOther.top);

          var botDist, mix;
          // Some careful tweaking to make sure no space is left out of view
          // when scrolling to top or bottom.
          if (targetPos > sInfo.top && (mix = sInfo.top / halfScreen) < 1) {
            targetPos = targetPos * mix + sInfo.top * (1 - mix);
          } else if ((botDist = sInfo.height - sInfo.clientHeight - sInfo.top) < halfScreen) {
            var otherInfo = other.getScrollInfo();
            var botDistOther = otherInfo.height - otherInfo.clientHeight - targetPos;
            if (botDistOther > botDist && (mix = botDist / halfScreen) < 1)
              targetPos = targetPos * mix + (otherInfo.height - otherInfo.clientHeight - botDist) * (1 - mix);
          }
        }

        other.scrollTo(sInfo.left, targetPos);
        other.state.scrollSetAt = now;
        other.state.scrollSetBy = dv;
        return true;
      }

      function getOffsets(editor, around) {
        var bot = around.after;
        if (bot == null) bot = editor.lastLine() + 1;
        return {top: editor.heightAtLine(around.before || 0, "local"),
                bot: editor.heightAtLine(bot, "local")};
      }

      function setScrollLock(dv, val, action) {
        dv.lockScroll = val;
        if (val && action != false) syncScroll(dv, DIFF_INSERT) && makeConnections(dv);
        (val ? CodeMirror.addClass : CodeMirror.rmClass)(dv.lockButton, "CodeMirror-merge-scrolllock-enabled");
      }

      // Updating the marks for editor content

      function removeClass(editor, line, classes) {
        var locs = classes.classLocation
        for (var i = 0; i < locs.length; i++) {
          editor.removeLineClass(line, locs[i], classes.chunk);
          editor.removeLineClass(line, locs[i], classes.start);
          editor.removeLineClass(line, locs[i], classes.end);
        }
      }

      function clearMarks(editor, arr, classes) {
        for (var i = 0; i < arr.length; ++i) {
          var mark = arr[i];
          if (mark instanceof CodeMirror.TextMarker)
            mark.clear();
          else if (mark.parent)
            removeClass(editor, mark, classes);
        }
        arr.length = 0;
      }

      // FIXME maybe add a margin around viewport to prevent too many updates
      function updateMarks(editor, diff, state, type, classes) {
        var vp = editor.getViewport();
        editor.operation(function() {
          if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
            clearMarks(editor, state.marked, classes);
            markChanges(editor, diff, type, state.marked, vp.from, vp.to, classes);
            state.from = vp.from; state.to = vp.to;
          } else {
            if (vp.from < state.from) {
              markChanges(editor, diff, type, state.marked, vp.from, state.from, classes);
              state.from = vp.from;
            }
            if (vp.to > state.to) {
              markChanges(editor, diff, type, state.marked, state.to, vp.to, classes);
              state.to = vp.to;
            }
          }
        });
      }

      function addClass(editor, lineNr, classes, main, start, end) {
        var locs = classes.classLocation, line = editor.getLineHandle(lineNr);
        for (var i = 0; i < locs.length; i++) {
          if (main) editor.addLineClass(line, locs[i], classes.chunk);
          if (start) editor.addLineClass(line, locs[i], classes.start);
          if (end) editor.addLineClass(line, locs[i], classes.end);
        }
        return line;
      }

      function markChanges(editor, diff, type, marks, from, to, classes) {
        var pos = Pos(0, 0);
        var top = Pos(from, 0), bot = editor.clipPos(Pos(to - 1));
        var cls = type == DIFF_DELETE ? classes.del : classes.insert;
        function markChunk(start, end) {
          var bfrom = Math.max(from, start), bto = Math.min(to, end);
          for (var i = bfrom; i < bto; ++i)
            marks.push(addClass(editor, i, classes, true, i == start, i == end - 1));
          // When the chunk is empty, make sure a horizontal line shows up
          if (start == end && bfrom == end && bto == end) {
            if (bfrom)
              marks.push(addClass(editor, bfrom - 1, classes, false, false, true));
            else
              marks.push(addClass(editor, bfrom, classes, false, true, false));
          }
        }

        var chunkStart = 0, pending = false;
        for (var i = 0; i < diff.length; ++i) {
          var part = diff[i], tp = part[0], str = part[1];
          if (tp == DIFF_EQUAL) {
            var cleanFrom = pos.line + (startOfLineClean(diff, i) ? 0 : 1);
            moveOver(pos, str);
            var cleanTo = pos.line + (endOfLineClean(diff, i) ? 1 : 0);
            if (cleanTo > cleanFrom) {
              if (pending) { markChunk(chunkStart, cleanFrom); pending = false }
              chunkStart = cleanTo;
            }
          } else {
            pending = true
            if (tp == type) {
              var end = moveOver(pos, str, true);
              var a = posMax(top, pos), b = posMin(bot, end);
              if (!posEq(a, b))
                marks.push(editor.markText(a, b, {className: cls}));
              pos = end;
            }
          }
        }
        if (pending) markChunk(chunkStart, pos.line + 1);
      }

      // Updating the gap between editor and original

      function makeConnections(dv) {
        if (!dv.showDifferences) return;

        if (dv.svg) {
          clear(dv.svg);
          var w = dv.gap.offsetWidth;
          attrs(dv.svg, "width", w, "height", dv.gap.offsetHeight);
        }
        if (dv.copyButtons) clear(dv.copyButtons);

        var vpEdit = dv.edit.getViewport(), vpOrig = dv.orig.getViewport();
        var outerTop = dv.mv.wrap.getBoundingClientRect().top
        var sTopEdit = outerTop - dv.edit.getScrollerElement().getBoundingClientRect().top + dv.edit.getScrollInfo().top
        var sTopOrig = outerTop - dv.orig.getScrollerElement().getBoundingClientRect().top + dv.orig.getScrollInfo().top;
        for (var i = 0; i < dv.chunks.length; i++) {
          var ch = dv.chunks[i];
          if (ch.editFrom <= vpEdit.to && ch.editTo >= vpEdit.from &&
              ch.origFrom <= vpOrig.to && ch.origTo >= vpOrig.from)
            drawConnectorsForChunk(dv, ch, sTopOrig, sTopEdit, w);
        }
      }

      function getMatchingOrigLine(editLine, chunks) {
        var editStart = 0, origStart = 0;
        for (var i = 0; i < chunks.length; i++) {
          var chunk = chunks[i];
          if (chunk.editTo > editLine && chunk.editFrom <= editLine) return null;
          if (chunk.editFrom > editLine) break;
          editStart = chunk.editTo;
          origStart = chunk.origTo;
        }
        return origStart + (editLine - editStart);
      }

      // Combines information about chunks and widgets/markers to return
      // an array of lines, in a single editor, that probably need to be
      // aligned with their counterparts in the editor next to it.
      function alignableFor(cm, chunks, isOrig) {
        var tracker = cm.state.trackAlignable
        var start = cm.firstLine(), trackI = 0
        var result = []
        for (var i = 0;; i++) {
          var chunk = chunks[i]
          var chunkStart = !chunk ? 1e9 : isOrig ? chunk.origFrom : chunk.editFrom
          for (; trackI < tracker.alignable.length; trackI += 2) {
            var n = tracker.alignable[trackI] + 1
            if (n <= start) continue
            if (n <= chunkStart) result.push(n)
            else break
          }
          if (!chunk) break
          result.push(start = isOrig ? chunk.origTo : chunk.editTo)
        }
        return result
      }

      // Given information about alignable lines in two editors, fill in
      // the result (an array of three-element arrays) to reflect the
      // lines that need to be aligned with each other.
      function mergeAlignable(result, origAlignable, chunks, setIndex) {
        var rI = 0, origI = 0, chunkI = 0, diff = 0
        outer: for (;; rI++) {
          var nextR = result[rI], nextO = origAlignable[origI]
          if (!nextR && nextO == null) break

          var rLine = nextR ? nextR[0] : 1e9, oLine = nextO == null ? 1e9 : nextO
          while (chunkI < chunks.length) {
            var chunk = chunks[chunkI]
            if (chunk.origFrom <= oLine && chunk.origTo > oLine) {
              origI++
              rI--
              continue outer;
            }
            if (chunk.editTo > rLine) {
              if (chunk.editFrom <= rLine) continue outer;
              break
            }
            diff += (chunk.origTo - chunk.origFrom) - (chunk.editTo - chunk.editFrom)
            chunkI++
          }
          if (rLine == oLine - diff) {
            nextR[setIndex] = oLine
            origI++
          } else if (rLine < oLine - diff) {
            nextR[setIndex] = rLine + diff
          } else {
            var record = [oLine - diff, null, null]
            record[setIndex] = oLine
            result.splice(rI, 0, record)
            origI++
          }
        }
      }

      function findAlignedLines(dv, other) {
        var alignable = alignableFor(dv.edit, dv.chunks, false), result = []
        if (other) for (var i = 0, j = 0; i < other.chunks.length; i++) {
          var n = other.chunks[i].editTo
          while (j < alignable.length && alignable[j] < n) j++
          if (j == alignable.length || alignable[j] != n) alignable.splice(j++, 0, n)
        }
        for (var i = 0; i < alignable.length; i++)
          result.push([alignable[i], null, null])

        mergeAlignable(result, alignableFor(dv.orig, dv.chunks, true), dv.chunks, 1)
        if (other)
          mergeAlignable(result, alignableFor(other.orig, other.chunks, true), other.chunks, 2)

        return result
      }

      function alignChunks(dv, force) {
        if (!dv.dealigned && !force) return;
        if (!dv.orig.curOp) return dv.orig.operation(function() {
          alignChunks(dv, force);
        });

        dv.dealigned = false;
        var other = dv.mv.left == dv ? dv.mv.right : dv.mv.left;
        if (other) {
          ensureDiff(other);
          other.dealigned = false;
        }
        var linesToAlign = findAlignedLines(dv, other);

        // Clear old aligners
        var aligners = dv.mv.aligners;
        for (var i = 0; i < aligners.length; i++)
          aligners[i].clear();
        aligners.length = 0;

        var cm = [dv.edit, dv.orig], scroll = [], offset = []
        if (other) cm.push(other.orig);
        for (var i = 0; i < cm.length; i++) {
          scroll.push(cm[i].getScrollInfo().top);
          offset.push(-cm[i].getScrollerElement().getBoundingClientRect().top)
        }

        if (offset[0] != offset[1] || cm.length == 3 && offset[1] != offset[2])
          alignLines(cm, offset, [0, 0, 0], aligners)
        for (var ln = 0; ln < linesToAlign.length; ln++)
          alignLines(cm, offset, linesToAlign[ln], aligners);

        for (var i = 0; i < cm.length; i++)
          cm[i].scrollTo(null, scroll[i]);
      }

      function alignLines(cm, cmOffset, lines, aligners) {
        var maxOffset = -1e8, offset = [];
        for (var i = 0; i < cm.length; i++) if (lines[i] != null) {
          var off = cm[i].heightAtLine(lines[i], "local") - cmOffset[i];
          offset[i] = off;
          maxOffset = Math.max(maxOffset, off);
        }
        for (var i = 0; i < cm.length; i++) if (lines[i] != null) {
          var diff = maxOffset - offset[i];
          if (diff > 1)
            aligners.push(padAbove(cm[i], lines[i], diff));
        }
      }

      function padAbove(cm, line, size) {
        var above = true;
        if (line > cm.lastLine()) {
          line--;
          above = false;
        }
        var elt = document.createElement("div");
        elt.className = "CodeMirror-merge-spacer";
        elt.style.height = size + "px"; elt.style.minWidth = "1px";
        return cm.addLineWidget(line, elt, {height: size, above: above, mergeSpacer: true, handleMouseEvents: true});
      }

      function drawConnectorsForChunk(dv, chunk, sTopOrig, sTopEdit, w) {
        var flip = dv.type == "left";
        var top = dv.orig.heightAtLine(chunk.origFrom, "local", true) - sTopOrig;
        if (dv.svg) {
          var topLpx = top;
          var topRpx = dv.edit.heightAtLine(chunk.editFrom, "local", true) - sTopEdit;
          if (flip) { var tmp = topLpx; topLpx = topRpx; topRpx = tmp; }
          var botLpx = dv.orig.heightAtLine(chunk.origTo, "local", true) - sTopOrig;
          var botRpx = dv.edit.heightAtLine(chunk.editTo, "local", true) - sTopEdit;
          if (flip) { var tmp = botLpx; botLpx = botRpx; botRpx = tmp; }
          var curveTop = " C " + w/2 + " " + topRpx + " " + w/2 + " " + topLpx + " " + (w + 2) + " " + topLpx;
          var curveBot = " C " + w/2 + " " + botLpx + " " + w/2 + " " + botRpx + " -1 " + botRpx;
          attrs(dv.svg.appendChild(document.createElementNS(svgNS, "path")),
                "d", "M -1 " + topRpx + curveTop + " L " + (w + 2) + " " + botLpx + curveBot + " z",
                "class", dv.classes.connect);
        }
        if (dv.copyButtons) {
          var copy = dv.copyButtons.appendChild(elt("div", dv.type == "left" ? "\u21dd" : "\u21dc",
                                                    "CodeMirror-merge-copy"));
          var editOriginals = dv.mv.options.allowEditingOriginals;
          copy.title = dv.edit.phrase(editOriginals ? "Push to left" : "Revert chunk");
          copy.chunk = chunk;
          copy.style.top = (chunk.origTo > chunk.origFrom ? top : dv.edit.heightAtLine(chunk.editFrom, "local") - sTopEdit) + "px";
          copy.setAttribute("role", "button");

          if (editOriginals) {
            var topReverse = dv.edit.heightAtLine(chunk.editFrom, "local") - sTopEdit;
            var copyReverse = dv.copyButtons.appendChild(elt("div", dv.type == "right" ? "\u21dd" : "\u21dc",
                                                             "CodeMirror-merge-copy-reverse"));
            copyReverse.title = "Push to right";
            copyReverse.chunk = {editFrom: chunk.origFrom, editTo: chunk.origTo,
                                 origFrom: chunk.editFrom, origTo: chunk.editTo};
            copyReverse.style.top = topReverse + "px";
            dv.type == "right" ? copyReverse.style.left = "2px" : copyReverse.style.right = "2px";
            copyReverse.setAttribute("role", "button");
          }
        }
      }

      function copyChunk(dv, to, from, chunk) {
        if (dv.diffOutOfDate) return;
        var origStart = chunk.origTo > from.lastLine() ? Pos(chunk.origFrom - 1) : Pos(chunk.origFrom, 0)
        var origEnd = Pos(chunk.origTo, 0)
        var editStart = chunk.editTo > to.lastLine() ? Pos(chunk.editFrom - 1) : Pos(chunk.editFrom, 0)
        var editEnd = Pos(chunk.editTo, 0)
        var handler = dv.mv.options.revertChunk
        if (handler)
          handler(dv.mv, from, origStart, origEnd, to, editStart, editEnd)
        else
          to.replaceRange(from.getRange(origStart, origEnd), editStart, editEnd)
      }

      // Merge view, containing 0, 1, or 2 diff views.

      var MergeView = CodeMirror.MergeView = function(node, options) {
        if (!(this instanceof MergeView)) return new MergeView(node, options);

        this.options = options;
        var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;

        var hasLeft = origLeft != null, hasRight = origRight != null;
        var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
        var wrap = [], left = this.left = null, right = this.right = null;
        var self = this;

        if (hasLeft) {
          left = this.left = new DiffView(this, "left");
          var leftPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-left");
          wrap.push(leftPane);
          wrap.push(buildGap(left));
        }

        var editPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor");
        wrap.push(editPane);

        if (hasRight) {
          right = this.right = new DiffView(this, "right");
          wrap.push(buildGap(right));
          var rightPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-right");
          wrap.push(rightPane);
        }

        (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";

        wrap.push(elt("div", null, null, "height: 0; clear: both;"));

        var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
        this.edit = CodeMirror(editPane, copyObj(options));

        if (left) left.init(leftPane, origLeft, options);
        if (right) right.init(rightPane, origRight, options);
        if (options.collapseIdentical)
          this.editor().operation(function() {
            collapseIdenticalStretches(self, options.collapseIdentical);
          });
        if (options.connect == "align") {
          this.aligners = [];
          alignChunks(this.left || this.right, true);
        }
        if (left) left.registerEvents(right)
        if (right) right.registerEvents(left)


        var onResize = function() {
          if (left) makeConnections(left);
          if (right) makeConnections(right);
        };
        CodeMirror.on(window, "resize", onResize);
        var resizeInterval = setInterval(function() {
          for (var p = wrapElt.parentNode; p && p != document.body; p = p.parentNode) {}
          if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, "resize", onResize); }
        }, 5000);
      };

      function buildGap(dv) {
        var lock = dv.lockButton = elt("div", null, "CodeMirror-merge-scrolllock");
        lock.setAttribute("role", "button");
        var lockWrap = elt("div", [lock], "CodeMirror-merge-scrolllock-wrap");
        CodeMirror.on(lock, "click", function() { setScrollLock(dv, !dv.lockScroll); });
        var gapElts = [lockWrap];
        if (dv.mv.options.revertButtons !== false) {
          dv.copyButtons = elt("div", null, "CodeMirror-merge-copybuttons-" + dv.type);
          CodeMirror.on(dv.copyButtons, "click", function(e) {
            var node = e.target || e.srcElement;
            if (!node.chunk) return;
            if (node.className == "CodeMirror-merge-copy-reverse") {
              copyChunk(dv, dv.orig, dv.edit, node.chunk);
              return;
            }
            copyChunk(dv, dv.edit, dv.orig, node.chunk);
          });
          gapElts.unshift(dv.copyButtons);
        }
        if (dv.mv.options.connect != "align") {
          var svg = document.createElementNS && document.createElementNS(svgNS, "svg");
          if (svg && !svg.createSVGRect) svg = null;
          dv.svg = svg;
          if (svg) gapElts.push(svg);
        }

        return dv.gap = elt("div", gapElts, "CodeMirror-merge-gap");
      }

      MergeView.prototype = {
        constructor: MergeView,
        editor: function() { return this.edit; },
        rightOriginal: function() { return this.right && this.right.orig; },
        leftOriginal: function() { return this.left && this.left.orig; },
        setShowDifferences: function(val) {
          if (this.right) this.right.setShowDifferences(val);
          if (this.left) this.left.setShowDifferences(val);
        },
        rightChunks: function() {
          if (this.right) { ensureDiff(this.right); return this.right.chunks; }
        },
        leftChunks: function() {
          if (this.left) { ensureDiff(this.left); return this.left.chunks; }
        }
      };

      function asString(obj) {
        if (typeof obj == "string") return obj;
        else return obj.getValue();
      }

      // Operations on diffs
      var dmp;
      function getDiff(a, b, ignoreWhitespace) {
        if (!dmp) dmp = new diff_match_patch();

        var diff = dmp.diff_main(a, b);
        // The library sometimes leaves in empty parts, which confuse the algorithm
        for (var i = 0; i < diff.length; ++i) {
          var part = diff[i];
          if (ignoreWhitespace ? !/[^ \t]/.test(part[1]) : !part[1]) {
            diff.splice(i--, 1);
          } else if (i && diff[i - 1][0] == part[0]) {
            diff.splice(i--, 1);
            diff[i][1] += part[1];
          }
        }
        return diff;
      }

      function getChunks(diff) {
        var chunks = [];
        if (!diff.length) return chunks;
        var startEdit = 0, startOrig = 0;
        var edit = Pos(0, 0), orig = Pos(0, 0);
        for (var i = 0; i < diff.length; ++i) {
          var part = diff[i], tp = part[0];
          if (tp == DIFF_EQUAL) {
            var startOff = !startOfLineClean(diff, i) || edit.line < startEdit || orig.line < startOrig ? 1 : 0;
            var cleanFromEdit = edit.line + startOff, cleanFromOrig = orig.line + startOff;
            moveOver(edit, part[1], null, orig);
            var endOff = endOfLineClean(diff, i) ? 1 : 0;
            var cleanToEdit = edit.line + endOff, cleanToOrig = orig.line + endOff;
            if (cleanToEdit > cleanFromEdit) {
              if (i) chunks.push({origFrom: startOrig, origTo: cleanFromOrig,
                                  editFrom: startEdit, editTo: cleanFromEdit});
              startEdit = cleanToEdit; startOrig = cleanToOrig;
            }
          } else {
            moveOver(tp == DIFF_INSERT ? edit : orig, part[1]);
          }
        }
        if (startEdit <= edit.line || startOrig <= orig.line)
          chunks.push({origFrom: startOrig, origTo: orig.line + 1,
                       editFrom: startEdit, editTo: edit.line + 1});
        return chunks;
      }

      function endOfLineClean(diff, i) {
        if (i == diff.length - 1) return true;
        var next = diff[i + 1][1];
        if ((next.length == 1 && i < diff.length - 2) || next.charCodeAt(0) != 10) return false;
        if (i == diff.length - 2) return true;
        next = diff[i + 2][1];
        return (next.length > 1 || i == diff.length - 3) && next.charCodeAt(0) == 10;
      }

      function startOfLineClean(diff, i) {
        if (i == 0) return true;
        var last = diff[i - 1][1];
        if (last.charCodeAt(last.length - 1) != 10) return false;
        if (i == 1) return true;
        last = diff[i - 2][1];
        return last.charCodeAt(last.length - 1) == 10;
      }

      function chunkBoundariesAround(chunks, n, nInEdit) {
        var beforeE, afterE, beforeO, afterO;
        for (var i = 0; i < chunks.length; i++) {
          var chunk = chunks[i];
          var fromLocal = nInEdit ? chunk.editFrom : chunk.origFrom;
          var toLocal = nInEdit ? chunk.editTo : chunk.origTo;
          if (afterE == null) {
            if (fromLocal > n) { afterE = chunk.editFrom; afterO = chunk.origFrom; }
            else if (toLocal > n) { afterE = chunk.editTo; afterO = chunk.origTo; }
          }
          if (toLocal <= n) { beforeE = chunk.editTo; beforeO = chunk.origTo; }
          else if (fromLocal <= n) { beforeE = chunk.editFrom; beforeO = chunk.origFrom; }
        }
        return {edit: {before: beforeE, after: afterE}, orig: {before: beforeO, after: afterO}};
      }

      function collapseSingle(cm, from, to) {
        cm.addLineClass(from, "wrap", "CodeMirror-merge-collapsed-line");
        var widget = document.createElement("span");
        widget.className = "CodeMirror-merge-collapsed-widget";
        widget.title = cm.phrase("Identical text collapsed. Click to expand.");
        var mark = cm.markText(Pos(from, 0), Pos(to - 1), {
          inclusiveLeft: true,
          inclusiveRight: true,
          replacedWith: widget,
          clearOnEnter: true
        });
        function clear() {
          mark.clear();
          cm.removeLineClass(from, "wrap", "CodeMirror-merge-collapsed-line");
        }
        if (mark.explicitlyCleared) clear();
        CodeMirror.on(widget, "click", clear);
        mark.on("clear", clear);
        CodeMirror.on(widget, "click", clear);
        return {mark: mark, clear: clear};
      }

      function collapseStretch(size, editors) {
        var marks = [];
        function clear() {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        }
        for (var i = 0; i < editors.length; i++) {
          var editor = editors[i];
          var mark = collapseSingle(editor.cm, editor.line, editor.line + size);
          marks.push(mark);
          mark.mark.on("clear", clear);
        }
        return marks[0].mark;
      }

      function unclearNearChunks(dv, margin, off, clear) {
        for (var i = 0; i < dv.chunks.length; i++) {
          var chunk = dv.chunks[i];
          for (var l = chunk.editFrom - margin; l < chunk.editTo + margin; l++) {
            var pos = l + off;
            if (pos >= 0 && pos < clear.length) clear[pos] = false;
          }
        }
      }

      function collapseIdenticalStretches(mv, margin) {
        if (typeof margin != "number") margin = 2;
        var clear = [], edit = mv.editor(), off = edit.firstLine();
        for (var l = off, e = edit.lastLine(); l <= e; l++) clear.push(true);
        if (mv.left) unclearNearChunks(mv.left, margin, off, clear);
        if (mv.right) unclearNearChunks(mv.right, margin, off, clear);

        for (var i = 0; i < clear.length; i++) {
          if (clear[i]) {
            var line = i + off;
            for (var size = 1; i < clear.length - 1 && clear[i + 1]; i++, size++) {}
            if (size > margin) {
              var editors = [{line: line, cm: edit}];
              if (mv.left) editors.push({line: getMatchingOrigLine(line, mv.left.chunks), cm: mv.left.orig});
              if (mv.right) editors.push({line: getMatchingOrigLine(line, mv.right.chunks), cm: mv.right.orig});
              var mark = collapseStretch(size, editors);
              if (mv.options.onCollapse) mv.options.onCollapse(mv, line, size, mark);
            }
          }
        }
      }

      // General utilities

      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) e.className = className;
        if (style) e.style.cssText = style;
        if (typeof content == "string") e.appendChild(document.createTextNode(content));
        else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
        return e;
      }

      function clear(node) {
        for (var count = node.childNodes.length; count > 0; --count)
          node.removeChild(node.firstChild);
      }

      function attrs(elt) {
        for (var i = 1; i < arguments.length; i += 2)
          elt.setAttribute(arguments[i], arguments[i+1]);
      }

      function copyObj(obj, target) {
        if (!target) target = {};
        for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
        return target;
      }

      function moveOver(pos, str, copy, other) {
        var out = copy ? Pos(pos.line, pos.ch) : pos, at = 0;
        for (;;) {
          var nl = str.indexOf("\n", at);
          if (nl == -1) break;
          ++out.line;
          if (other) ++other.line;
          at = nl + 1;
        }
        out.ch = (at ? 0 : out.ch) + (str.length - at);
        if (other) other.ch = (at ? 0 : other.ch) + (str.length - at);
        return out;
      }

      // Tracks collapsed markers and line widgets, in order to be able to
      // accurately align the content of two editors.

      var F_WIDGET = 1, F_WIDGET_BELOW = 2, F_MARKER = 4

      function TrackAlignable(cm) {
        this.cm = cm
        this.alignable = []
        this.height = cm.doc.height
        var self = this
        cm.on("markerAdded", function(_, marker) {
          if (!marker.collapsed) return
          var found = marker.find(1)
          if (found != null) self.set(found.line, F_MARKER)
        })
        cm.on("markerCleared", function(_, marker, _min, max) {
          if (max != null && marker.collapsed)
            self.check(max, F_MARKER, self.hasMarker)
        })
        cm.on("markerChanged", this.signal.bind(this))
        cm.on("lineWidgetAdded", function(_, widget, lineNo) {
          if (widget.mergeSpacer) return
          if (widget.above) self.set(lineNo - 1, F_WIDGET_BELOW)
          else self.set(lineNo, F_WIDGET)
        })
        cm.on("lineWidgetCleared", function(_, widget, lineNo) {
          if (widget.mergeSpacer) return
          if (widget.above) self.check(lineNo - 1, F_WIDGET_BELOW, self.hasWidgetBelow)
          else self.check(lineNo, F_WIDGET, self.hasWidget)
        })
        cm.on("lineWidgetChanged", this.signal.bind(this))
        cm.on("change", function(_, change) {
          var start = change.from.line, nBefore = change.to.line - change.from.line
          var nAfter = change.text.length - 1, end = start + nAfter
          if (nBefore || nAfter) self.map(start, nBefore, nAfter)
          self.check(end, F_MARKER, self.hasMarker)
          if (nBefore || nAfter) self.check(change.from.line, F_MARKER, self.hasMarker)
        })
        cm.on("viewportChange", function() {
          if (self.cm.doc.height != self.height) self.signal()
        })
      }

      TrackAlignable.prototype = {
        signal: function() {
          CodeMirror.signal(this, "realign")
          this.height = this.cm.doc.height
        },

        set: function(n, flags) {
          var pos = -1
          for (; pos < this.alignable.length; pos += 2) {
            var diff = this.alignable[pos] - n
            if (diff == 0) {
              if ((this.alignable[pos + 1] & flags) == flags) return
              this.alignable[pos + 1] |= flags
              this.signal()
              return
            }
            if (diff > 0) break
          }
          this.signal()
          this.alignable.splice(pos, 0, n, flags)
        },

        find: function(n) {
          for (var i = 0; i < this.alignable.length; i += 2)
            if (this.alignable[i] == n) return i
          return -1
        },

        check: function(n, flag, pred) {
          var found = this.find(n)
          if (found == -1 || !(this.alignable[found + 1] & flag)) return
          if (!pred.call(this, n)) {
            this.signal()
            var flags = this.alignable[found + 1] & ~flag
            if (flags) this.alignable[found + 1] = flags
            else this.alignable.splice(found, 2)
          }
        },

        hasMarker: function(n) {
          var handle = this.cm.getLineHandle(n)
          if (handle.markedSpans) for (var i = 0; i < handle.markedSpans.length; i++)
            if (handle.markedSpans[i].marker.collapsed && handle.markedSpans[i].to != null)
              return true
          return false
        },

        hasWidget: function(n) {
          var handle = this.cm.getLineHandle(n)
          if (handle.widgets) for (var i = 0; i < handle.widgets.length; i++)
            if (!handle.widgets[i].above && !handle.widgets[i].mergeSpacer) return true
          return false
        },

        hasWidgetBelow: function(n) {
          if (n == this.cm.lastLine()) return false
          var handle = this.cm.getLineHandle(n + 1)
          if (handle.widgets) for (var i = 0; i < handle.widgets.length; i++)
            if (handle.widgets[i].above && !handle.widgets[i].mergeSpacer) return true
          return false
        },

        map: function(from, nBefore, nAfter) {
          var diff = nAfter - nBefore, to = from + nBefore, widgetFrom = -1, widgetTo = -1
          for (var i = 0; i < this.alignable.length; i += 2) {
            var n = this.alignable[i]
            if (n == from && (this.alignable[i + 1] & F_WIDGET_BELOW)) widgetFrom = i
            if (n == to && (this.alignable[i + 1] & F_WIDGET_BELOW)) widgetTo = i
            if (n <= from) continue
            else if (n < to) this.alignable.splice(i--, 2)
            else this.alignable[i] += diff
          }
          if (widgetFrom > -1) {
            var flags = this.alignable[widgetFrom + 1]
            if (flags == F_WIDGET_BELOW) this.alignable.splice(widgetFrom, 2)
            else this.alignable[widgetFrom + 1] = flags & ~F_WIDGET_BELOW
          }
          if (widgetTo > -1 && nAfter)
            this.set(from + nAfter, F_WIDGET_BELOW)
        }
      }

      function posMin(a, b) { return (a.line - b.line || a.ch - b.ch) < 0 ? a : b; }
      function posMax(a, b) { return (a.line - b.line || a.ch - b.ch) > 0 ? a : b; }
      function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }

      function findPrevDiff(chunks, start, isOrig) {
        for (var i = chunks.length - 1; i >= 0; i--) {
          var chunk = chunks[i];
          var to = (isOrig ? chunk.origTo : chunk.editTo) - 1;
          if (to < start) return to;
        }
      }

      function findNextDiff(chunks, start, isOrig) {
        for (var i = 0; i < chunks.length; i++) {
          var chunk = chunks[i];
          var from = (isOrig ? chunk.origFrom : chunk.editFrom);
          if (from > start) return from;
        }
      }

      function goNearbyDiff(cm, dir) {
        var found = null, views = cm.state.diffViews, line = cm.getCursor().line;
        if (views) for (var i = 0; i < views.length; i++) {
          var dv = views[i], isOrig = cm == dv.orig;
          ensureDiff(dv);
          var pos = dir < 0 ? findPrevDiff(dv.chunks, line, isOrig) : findNextDiff(dv.chunks, line, isOrig);
          if (pos != null && (found == null || (dir < 0 ? pos > found : pos < found)))
            found = pos;
        }
        if (found != null)
          cm.setCursor(found, 0);
        else
          return CodeMirror.Pass;
      }

      CodeMirror.commands.goNextDiff = function(cm) {
        return goNearbyDiff(cm, 1);
      };
      CodeMirror.commands.goPrevDiff = function(cm) {
        return goNearbyDiff(cm, -1);
      };
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-mode-loadmode.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), "cjs");
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], function(CM) { mod(CM, "amd"); });
      else // Plain browser env
        mod(CodeMirror, "plain");
    })(function(CodeMirror, env) {
      if (!CodeMirror.modeURL) CodeMirror.modeURL = "../mode/%N/%N.js";

      var loading = {};
      function splitCallback(cont, n) {
        var countDown = n;
        return function() { if (--countDown == 0) cont(); };
      }
      function ensureDeps(mode, cont, options) {
        var modeObj = CodeMirror.modes[mode], deps = modeObj && modeObj.dependencies;
        if (!deps) return cont();
        var missing = [];
        for (var i = 0; i < deps.length; ++i) {
          if (!CodeMirror.modes.hasOwnProperty(deps[i]))
            missing.push(deps[i]);
        }
        if (!missing.length) return cont();
        var split = splitCallback(cont, missing.length);
        for (var i = 0; i < missing.length; ++i)
          CodeMirror.requireMode(missing[i], split, options);
      }

      CodeMirror.requireMode = function(mode, cont, options) {
        if (typeof mode != "string") mode = mode.name;
        if (CodeMirror.modes.hasOwnProperty(mode)) return ensureDeps(mode, cont, options);
        if (loading.hasOwnProperty(mode)) return loading[mode].push(cont);

        var file = options && options.path ? options.path(mode) : CodeMirror.modeURL.replace(/%N/g, mode);
        if (options && options.loadMode) {
          options.loadMode(file, function() { ensureDeps(mode, cont, options) })
        } else if (env == "plain") {
          var script = document.createElement("script");
          script.src = file;
          var others = document.getElementsByTagName("script")[0];
          var list = loading[mode] = [cont];
          CodeMirror.on(script, "load", function() {
            ensureDeps(mode, function() {
              for (var i = 0; i < list.length; ++i) list[i]();
            }, options);
          });
          others.parentNode.insertBefore(script, others);
        } else if (env == "cjs") {
          require(file);
          cont();
        } else if (env == "amd") {
          requirejs([file], cont);
        }
      };

      CodeMirror.autoLoadMode = function(instance, mode, options) {
        if (!CodeMirror.modes.hasOwnProperty(mode))
          CodeMirror.requireMode(mode, function() {
            instance.setOption("mode", instance.getOption("mode"));
          }, options);
      };
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-mode-multiplex.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.multiplexingMode = function(outer /*, others */) {
      // Others should be {open, close, mode [, delimStyle] [, innerStyle] [, parseDelimiters]} objects
      var others = Array.prototype.slice.call(arguments, 1);

      function indexOf(string, pattern, from, returnEnd) {
        if (typeof pattern == "string") {
          var found = string.indexOf(pattern, from);
          return returnEnd && found > -1 ? found + pattern.length : found;
        }
        var m = pattern.exec(from ? string.slice(from) : string);
        return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;
      }

      return {
        startState: function() {
          return {
            outer: CodeMirror.startState(outer),
            innerActive: null,
            inner: null,
            startingInner: false
          };
        },

        copyState: function(state) {
          return {
            outer: CodeMirror.copyState(outer, state.outer),
            innerActive: state.innerActive,
            inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner),
            startingInner: state.startingInner
          };
        },

        token: function(stream, state) {
          if (!state.innerActive) {
            var cutOff = Infinity, oldContent = stream.string;
            for (var i = 0; i < others.length; ++i) {
              var other = others[i];
              var found = indexOf(oldContent, other.open, stream.pos);
              if (found == stream.pos) {
                if (!other.parseDelimiters) stream.match(other.open);
                state.startingInner = !!other.parseDelimiters
                state.innerActive = other;

                // Get the outer indent, making sure to handle CodeMirror.Pass
                var outerIndent = 0;
                if (outer.indent) {
                  var possibleOuterIndent = outer.indent(state.outer, "", "");
                  if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;
                }

                state.inner = CodeMirror.startState(other.mode, outerIndent);
                return other.delimStyle && (other.delimStyle + " " + other.delimStyle + "-open");
              } else if (found != -1 && found < cutOff) {
                cutOff = found;
              }
            }
            if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);
            var outerToken = outer.token(stream, state.outer);
            if (cutOff != Infinity) stream.string = oldContent;
            return outerToken;
          } else {
            var curInner = state.innerActive, oldContent = stream.string;
            if (!curInner.close && stream.sol()) {
              state.innerActive = state.inner = null;
              return this.token(stream, state);
            }
            var found = curInner.close && !state.startingInner ?
                indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;
            if (found == stream.pos && !curInner.parseDelimiters) {
              stream.match(curInner.close);
              state.innerActive = state.inner = null;
              return curInner.delimStyle && (curInner.delimStyle + " " + curInner.delimStyle + "-close");
            }
            if (found > -1) stream.string = oldContent.slice(0, found);
            var innerToken = curInner.mode.token(stream, state.inner);
            if (found > -1) stream.string = oldContent;
            else if (stream.pos > stream.start) state.startingInner = false

            if (found == stream.pos && curInner.parseDelimiters)
              state.innerActive = state.inner = null;

            if (curInner.innerStyle) {
              if (innerToken) innerToken = innerToken + " " + curInner.innerStyle;
              else innerToken = curInner.innerStyle;
            }

            return innerToken;
          }
        },

        indent: function(state, textAfter, line) {
          var mode = state.innerActive ? state.innerActive.mode : outer;
          if (!mode.indent) return CodeMirror.Pass;
          return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);
        },

        blankLine: function(state) {
          var mode = state.innerActive ? state.innerActive.mode : outer;
          if (mode.blankLine) {
            mode.blankLine(state.innerActive ? state.inner : state.outer);
          }
          if (!state.innerActive) {
            for (var i = 0; i < others.length; ++i) {
              var other = others[i];
              if (other.open === "\n") {
                state.innerActive = other;
                state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "", "") : 0);
              }
            }
          } else if (state.innerActive.close === "\n") {
            state.innerActive = state.inner = null;
          }
        },

        electricChars: outer.electricChars,

        innerMode: function(state) {
          return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};
        }
      };
    };

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-mode-multiplex_test.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function() {
      CodeMirror.defineMode("markdown_with_stex", function(){
        var inner = CodeMirror.getMode({}, "stex");
        var outer = CodeMirror.getMode({}, "markdown");

        var innerOptions = {
          open: '$',
          close: '$',
          mode: inner,
          delimStyle: 'delim',
          innerStyle: 'inner'
        };

        return CodeMirror.multiplexingMode(outer, innerOptions);
      });

      var mode = CodeMirror.getMode({}, "markdown_with_stex");

      function MT(name) {
        test.mode(
          name,
          mode,
          Array.prototype.slice.call(arguments, 1),
          'multiplexing');
      }

      MT(
        "stexInsideMarkdown",
        "[strong **Equation:**] [delim&delim-open $][inner&tag \\pi][delim&delim-close $]");

      CodeMirror.defineMode("identical_delim_multiplex", function() {
        return CodeMirror.multiplexingMode(CodeMirror.getMode({indentUnit: 2}, "javascript"), {
          open: "#",
          close: "#",
          mode: CodeMirror.getMode({}, "markdown"),
          parseDelimiters: true,
          innerStyle: "q"
        });
      });

      var mode2 = CodeMirror.getMode({}, "identical_delim_multiplex");

      test.mode("identical_delimiters_with_parseDelimiters", mode2, [
        "[keyword let] [def x] [operator =] [q #foo][q&em *bar*][q #];"
      ], "multiplexing")
    })();
  uploads-admin-Public-Admin-plugins-codemirror-addon-mode-overlay.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Utility function that allows modes to be combined. The mode given
    // as the base argument takes care of most of the normal mode
    // functionality, but a second (typically simple) mode is used, which
    // can override the style of text. Both modes get to parse all of the
    // text, but when both assign a non-null style to a piece of code, the
    // overlay wins, unless the combine argument was true and not overridden,
    // or state.overlay.combineTokens was true, in which case the styles are
    // combined.

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.overlayMode = function(base, overlay, combine) {
      return {
        startState: function() {
          return {
            base: CodeMirror.startState(base),
            overlay: CodeMirror.startState(overlay),
            basePos: 0, baseCur: null,
            overlayPos: 0, overlayCur: null,
            streamSeen: null
          };
        },
        copyState: function(state) {
          return {
            base: CodeMirror.copyState(base, state.base),
            overlay: CodeMirror.copyState(overlay, state.overlay),
            basePos: state.basePos, baseCur: null,
            overlayPos: state.overlayPos, overlayCur: null
          };
        },

        token: function(stream, state) {
          if (stream != state.streamSeen ||
              Math.min(state.basePos, state.overlayPos) < stream.start) {
            state.streamSeen = stream;
            state.basePos = state.overlayPos = stream.start;
          }

          if (stream.start == state.basePos) {
            state.baseCur = base.token(stream, state.base);
            state.basePos = stream.pos;
          }
          if (stream.start == state.overlayPos) {
            stream.pos = stream.start;
            state.overlayCur = overlay.token(stream, state.overlay);
            state.overlayPos = stream.pos;
          }
          stream.pos = Math.min(state.basePos, state.overlayPos);

          // state.overlay.combineTokens always takes precedence over combine,
          // unless set to null
          if (state.overlayCur == null) return state.baseCur;
          else if (state.baseCur != null &&
                   state.overlay.combineTokens ||
                   combine && state.overlay.combineTokens == null)
            return state.baseCur + " " + state.overlayCur;
          else return state.overlayCur;
        },

        indent: base.indent && function(state, textAfter, line) {
          return base.indent(state.base, textAfter, line);
        },
        electricChars: base.electricChars,

        innerMode: function(state) { return {state: state.base, mode: base}; },

        blankLine: function(state) {
          var baseToken, overlayToken;
          if (base.blankLine) baseToken = base.blankLine(state.base);
          if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);

          return overlayToken == null ?
            baseToken :
            (combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken);
        }
      };
    };

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-mode-simple.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineSimpleMode = function(name, states) {
        CodeMirror.defineMode(name, function(config) {
          return CodeMirror.simpleMode(config, states);
        });
      };

      CodeMirror.simpleMode = function(config, states) {
        ensureState(states, "start");
        var states_ = {}, meta = states.meta || {}, hasIndentation = false;
        for (var state in states) if (state != meta && states.hasOwnProperty(state)) {
          var list = states_[state] = [], orig = states[state];
          for (var i = 0; i < orig.length; i++) {
            var data = orig[i];
            list.push(new Rule(data, states));
            if (data.indent || data.dedent) hasIndentation = true;
          }
        }
        var mode = {
          startState: function() {
            return {state: "start", pending: null,
                    local: null, localState: null,
                    indent: hasIndentation ? [] : null};
          },
          copyState: function(state) {
            var s = {state: state.state, pending: state.pending,
                     local: state.local, localState: null,
                     indent: state.indent && state.indent.slice(0)};
            if (state.localState)
              s.localState = CodeMirror.copyState(state.local.mode, state.localState);
            if (state.stack)
              s.stack = state.stack.slice(0);
            for (var pers = state.persistentStates; pers; pers = pers.next)
              s.persistentStates = {mode: pers.mode,
                                    spec: pers.spec,
                                    state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                                    next: s.persistentStates};
            return s;
          },
          token: tokenFunction(states_, config),
          innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },
          indent: indentFunction(states_, meta)
        };
        if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))
          mode[prop] = meta[prop];
        return mode;
      };

      function ensureState(states, name) {
        if (!states.hasOwnProperty(name))
          throw new Error("Undefined state " + name + " in simple mode");
      }

      function toRegex(val, caret) {
        if (!val) return /(?:)/;
        var flags = "";
        if (val instanceof RegExp) {
          if (val.ignoreCase) flags = "i";
          if (val.unicode) flags += "u"
          val = val.source;
        } else {
          val = String(val);
        }
        return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
      }

      function asToken(val) {
        if (!val) return null;
        if (val.apply) return val
        if (typeof val == "string") return val.replace(/\./g, " ");
        var result = [];
        for (var i = 0; i < val.length; i++)
          result.push(val[i] && val[i].replace(/\./g, " "));
        return result;
      }

      function Rule(data, states) {
        if (data.next || data.push) ensureState(states, data.next || data.push);
        this.regex = toRegex(data.regex);
        this.token = asToken(data.token);
        this.data = data;
      }

      function tokenFunction(states, config) {
        return function(stream, state) {
          if (state.pending) {
            var pend = state.pending.shift();
            if (state.pending.length == 0) state.pending = null;
            stream.pos += pend.text.length;
            return pend.token;
          }

          if (state.local) {
            if (state.local.end && stream.match(state.local.end)) {
              var tok = state.local.endToken || null;
              state.local = state.localState = null;
              return tok;
            } else {
              var tok = state.local.mode.token(stream, state.localState), m;
              if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
                stream.pos = stream.start + m.index;
              return tok;
            }
          }

          var curState = states[state.state];
          for (var i = 0; i < curState.length; i++) {
            var rule = curState[i];
            var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
            if (matches) {
              if (rule.data.next) {
                state.state = rule.data.next;
              } else if (rule.data.push) {
                (state.stack || (state.stack = [])).push(state.state);
                state.state = rule.data.push;
              } else if (rule.data.pop && state.stack && state.stack.length) {
                state.state = state.stack.pop();
              }

              if (rule.data.mode)
                enterLocalMode(config, state, rule.data.mode, rule.token);
              if (rule.data.indent)
                state.indent.push(stream.indentation() + config.indentUnit);
              if (rule.data.dedent)
                state.indent.pop();
              var token = rule.token
              if (token && token.apply) token = token(matches)
              if (matches.length > 2 && rule.token && typeof rule.token != "string") {
                for (var j = 2; j < matches.length; j++)
                  if (matches[j])
                    (state.pending || (state.pending = [])).push({text: matches[j], token: rule.token[j - 1]});
                stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                return token[0];
              } else if (token && token.join) {
                return token[0];
              } else {
                return token;
              }
            }
          }
          stream.next();
          return null;
        };
      }

      function cmp(a, b) {
        if (a === b) return true;
        if (!a || typeof a != "object" || !b || typeof b != "object") return false;
        var props = 0;
        for (var prop in a) if (a.hasOwnProperty(prop)) {
          if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;
          props++;
        }
        for (var prop in b) if (b.hasOwnProperty(prop)) props--;
        return props == 0;
      }

      function enterLocalMode(config, state, spec, token) {
        var pers;
        if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)
          if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;
        var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);
        var lState = pers ? pers.state : CodeMirror.startState(mode);
        if (spec.persistent && !pers)
          state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};

        state.localState = lState;
        state.local = {mode: mode,
                       end: spec.end && toRegex(spec.end),
                       endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
                       endToken: token && token.join ? token[token.length - 1] : token};
      }

      function indexOf(val, arr) {
        for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;
      }

      function indentFunction(states, meta) {
        return function(state, textAfter, line) {
          if (state.local && state.local.mode.indent)
            return state.local.mode.indent(state.localState, textAfter, line);
          if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)
            return CodeMirror.Pass;

          var pos = state.indent.length - 1, rules = states[state.state];
          scan: for (;;) {
            for (var i = 0; i < rules.length; i++) {
              var rule = rules[i];
              if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                var m = rule.regex.exec(textAfter);
                if (m && m[0]) {
                  pos--;
                  if (rule.next || rule.push) rules = states[rule.next || rule.push];
                  textAfter = textAfter.slice(m[0].length);
                  continue scan;
                }
              }
            }
            break;
          }
          return pos < 0 ? 0 : state.indent[pos];
        };
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-runmode-colorize.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("./runmode"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "./runmode"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var isBlock = /^(p|li|div|h\\d|pre|blockquote|td)$/;

      function textContent(node, out) {
        if (node.nodeType == 3) return out.push(node.nodeValue);
        for (var ch = node.firstChild; ch; ch = ch.nextSibling) {
          textContent(ch, out);
          if (isBlock.test(node.nodeType)) out.push("\n");
        }
      }

      CodeMirror.colorize = function(collection, defaultMode) {
        if (!collection) collection = document.body.getElementsByTagName("pre");

        for (var i = 0; i < collection.length; ++i) {
          var node = collection[i];
          var mode = node.getAttribute("data-lang") || defaultMode;
          if (!mode) continue;

          var text = [];
          textContent(node, text);
          node.innerHTML = "";
          CodeMirror.runMode(text.join(""), mode, node);

          node.className += " cm-s-default";
        }
      };
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-runmode-runmode-standalone.js: |
    (function () {
      'use strict';

      function copyObj(obj, target, overwrite) {
        if (!target) { target = {}; }
        for (var prop in obj)
          { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
            { target[prop] = obj[prop]; } }
        return target
      }

      // Counts the column offset in a string, taking tabs into account.
      // Used mostly to find indentation.
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) { end = string.length; }
        }
        for (var i = startIndex || 0, n = startValue || 0;;) {
          var nextTab = string.indexOf("\t", i);
          if (nextTab < 0 || nextTab >= end)
            { return n + (end - i) }
          n += nextTab - i;
          n += tabSize - (n % tabSize);
          i = nextTab + 1;
        }
      }

      function nothing() {}

      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props) { copyObj(props, inst); }
        return inst
      }

      // STRING STREAM

      // Fed to the mode parsers, provides helper functions to make
      // parsers more succinct.

      var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };

      StringStream.prototype.eol = function () {return this.pos >= this.string.length};
      StringStream.prototype.sol = function () {return this.pos == this.lineStart};
      StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
      StringStream.prototype.next = function () {
        if (this.pos < this.string.length)
          { return this.string.charAt(this.pos++) }
      };
      StringStream.prototype.eat = function (match) {
        var ch = this.string.charAt(this.pos);
        var ok;
        if (typeof match == "string") { ok = ch == match; }
        else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
        if (ok) {++this.pos; return ch}
      };
      StringStream.prototype.eatWhile = function (match) {
        var start = this.pos;
        while (this.eat(match)){}
        return this.pos > start
      };
      StringStream.prototype.eatSpace = function () {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
        return this.pos > start
      };
      StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
      StringStream.prototype.skipTo = function (ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {this.pos = found; return true}
      };
      StringStream.prototype.backUp = function (n) {this.pos -= n;};
      StringStream.prototype.column = function () {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
      };
      StringStream.prototype.indentation = function () {
        return countColumn(this.string, null, this.tabSize) -
          (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
      };
      StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) { this.pos += pattern.length; }
            return true
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);
          if (match && match.index > 0) { return null }
          if (match && consume !== false) { this.pos += match[0].length; }
          return match
        }
      };
      StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
      StringStream.prototype.hideFirstChars = function (n, inner) {
        this.lineStart += n;
        try { return inner() }
        finally { this.lineStart -= n; }
      };
      StringStream.prototype.lookAhead = function (n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n)
      };
      StringStream.prototype.baseToken = function () {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos)
      };

      // Known modes, by name and by MIME
      var modes = {}, mimeModes = {};

      // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)
      function defineMode(name, mode) {
        if (arguments.length > 2)
          { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
        modes[name] = mode;
      }

      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      }

      // Given a MIME type, a {name, ...options} config object, or a name
      // string, return a mode config object.
      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string") { found = {name: found}; }
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml")
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json")
        }
        if (typeof spec == "string") { return {name: spec} }
        else { return spec || {name: "null"} }
      }

      // Given a mode spec (anything that resolveMode accepts), find and
      // initialize an actual mode object.
      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) { return getMode(options, "text/plain") }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) { continue }
            if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType) { modeObj.helperType = spec.helperType; }
        if (spec.modeProps) { for (var prop$1 in spec.modeProps)
          { modeObj[prop$1] = spec.modeProps[prop$1]; } }

        return modeObj
      }

      // This can be used to attach properties to mode objects from
      // outside the actual mode definition.
      var modeExtensions = {};
      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
        copyObj(properties, exts);
      }

      function copyState(mode, state) {
        if (state === true) { return state }
        if (mode.copyState) { return mode.copyState(state) }
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) { val = val.concat([]); }
          nstate[n] = val;
        }
        return nstate
      }

      // Given a mode and a state (for that mode), find the inner mode and
      // state at the position that the state refers to.
      function innerMode(mode, state) {
        var info;
        while (mode.innerMode) {
          info = mode.innerMode(state);
          if (!info || info.mode == mode) { break }
          state = info.state;
          mode = info.mode;
        }
        return info || {mode: mode, state: state}
      }

      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true
      }

      var modeMethods = ({
        __proto__: null,
        modes: modes,
        mimeModes: mimeModes,
        defineMode: defineMode,
        defineMIME: defineMIME,
        resolveMode: resolveMode,
        getMode: getMode,
        modeExtensions: modeExtensions,
        extendMode: extendMode,
        copyState: copyState,
        innerMode: innerMode,
        startState: startState
      });

      // declare global: globalThis, CodeMirror

      // Create a minimal CodeMirror needed to use runMode, and assign to root.
      var root = typeof globalThis !== 'undefined' ? globalThis : window;
      root.CodeMirror = {};

      // Copy StringStream and mode methods into CodeMirror object.
      CodeMirror.StringStream = StringStream;
      for (var exported in modeMethods) { CodeMirror[exported] = modeMethods[exported]; }

      // Minimal default mode.
      CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
      CodeMirror.defineMIME("text/plain", "null");

      CodeMirror.registerHelper = CodeMirror.registerGlobalHelper = Math.min;
      CodeMirror.splitLines = function(string) { return string.split(/\r?\n|\r/) };
      CodeMirror.countColumn = countColumn;

      CodeMirror.defaults = { indentUnit: 2 };

      // CodeMirror, copyright (c) by Marijn Haverbeke and others
      // Distributed under an MIT license: https://codemirror.net/LICENSE

      (function(mod) {
        if (typeof exports == "object" && typeof module == "object") // CommonJS
          { mod(require("../../lib/codemirror")); }
        else if (typeof define == "function" && define.amd) // AMD
          { define(["../../lib/codemirror"], mod); }
        else // Plain browser env
          { mod(CodeMirror); }
      })(function(CodeMirror) {

      CodeMirror.runMode = function(string, modespec, callback, options) {
        var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);
        var tabSize = (options && options.tabSize) || CodeMirror.defaults.tabSize;

        // Create a tokenizing callback function if passed-in callback is a DOM element.
        if (callback.appendChild) {
          var ie = /MSIE \d/.test(navigator.userAgent);
          var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
          var node = callback, col = 0;
          node.innerHTML = "";
          callback = function(text, style) {
            if (text == "\n") {
              // Emitting LF or CRLF on IE8 or earlier results in an incorrect display.
              // Emitting a carriage return makes everything ok.
              node.appendChild(document.createTextNode(ie_lt9 ? '\r' : text));
              col = 0;
              return;
            }
            var content = "";
            // replace tabs
            for (var pos = 0;;) {
              var idx = text.indexOf("\t", pos);
              if (idx == -1) {
                content += text.slice(pos);
                col += text.length - pos;
                break;
              } else {
                col += idx - pos;
                content += text.slice(pos, idx);
                var size = tabSize - col % tabSize;
                col += size;
                for (var i = 0; i < size; ++i) { content += " "; }
                pos = idx + 1;
              }
            }
            // Create a node with token style and append it to the callback DOM element.
            if (style) {
              var sp = node.appendChild(document.createElement("span"));
              sp.className = "cm-" + style.replace(/ +/g, " cm-");
              sp.appendChild(document.createTextNode(content));
            } else {
              node.appendChild(document.createTextNode(content));
            }
          };
        }

        var lines = CodeMirror.splitLines(string), state = (options && options.state) || CodeMirror.startState(mode);
        for (var i = 0, e = lines.length; i < e; ++i) {
          if (i) { callback("\n"); }
          var stream = new CodeMirror.StringStream(lines[i], null, {
            lookAhead: function(n) { return lines[i + n] },
            baseToken: function() {}
          });
          if (!stream.string && mode.blankLine) { mode.blankLine(state); }
          while (!stream.eol()) {
            var style = mode.token(stream, state);
            callback(stream.current(), style, i, stream.start, state, mode);
            stream.start = stream.pos;
          }
        }
      };

      });

    }());
  uploads-admin-Public-Admin-plugins-codemirror-addon-runmode-runmode.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.runMode = function(string, modespec, callback, options) {
      var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);
      var tabSize = (options && options.tabSize) || CodeMirror.defaults.tabSize;

      // Create a tokenizing callback function if passed-in callback is a DOM element.
      if (callback.appendChild) {
        var ie = /MSIE \d/.test(navigator.userAgent);
        var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
        var node = callback, col = 0;
        node.innerHTML = "";
        callback = function(text, style) {
          if (text == "\n") {
            // Emitting LF or CRLF on IE8 or earlier results in an incorrect display.
            // Emitting a carriage return makes everything ok.
            node.appendChild(document.createTextNode(ie_lt9 ? '\r' : text));
            col = 0;
            return;
          }
          var content = "";
          // replace tabs
          for (var pos = 0;;) {
            var idx = text.indexOf("\t", pos);
            if (idx == -1) {
              content += text.slice(pos);
              col += text.length - pos;
              break;
            } else {
              col += idx - pos;
              content += text.slice(pos, idx);
              var size = tabSize - col % tabSize;
              col += size;
              for (var i = 0; i < size; ++i) content += " ";
              pos = idx + 1;
            }
          }
          // Create a node with token style and append it to the callback DOM element.
          if (style) {
            var sp = node.appendChild(document.createElement("span"));
            sp.className = "cm-" + style.replace(/ +/g, " cm-");
            sp.appendChild(document.createTextNode(content));
          } else {
            node.appendChild(document.createTextNode(content));
          }
        };
      }

      var lines = CodeMirror.splitLines(string), state = (options && options.state) || CodeMirror.startState(mode);
      for (var i = 0, e = lines.length; i < e; ++i) {
        if (i) callback("\n");
        var stream = new CodeMirror.StringStream(lines[i], null, {
          lookAhead: function(n) { return lines[i + n] },
          baseToken: function() {}
        });
        if (!stream.string && mode.blankLine) mode.blankLine(state);
        while (!stream.eol()) {
          var style = mode.token(stream, state);
          callback(stream.current(), style, i, stream.start, state, mode);
          stream.start = stream.pos;
        }
      }
    };

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-runmode-runmode.node.js: |
    'use strict';

    function copyObj(obj, target, overwrite) {
      if (!target) { target = {}; }
      for (var prop in obj)
        { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
          { target[prop] = obj[prop]; } }
      return target
    }

    // Counts the column offset in a string, taking tabs into account.
    // Used mostly to find indentation.
    function countColumn(string, end, tabSize, startIndex, startValue) {
      if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1) { end = string.length; }
      }
      for (var i = startIndex || 0, n = startValue || 0;;) {
        var nextTab = string.indexOf("\t", i);
        if (nextTab < 0 || nextTab >= end)
          { return n + (end - i) }
        n += nextTab - i;
        n += tabSize - (n % tabSize);
        i = nextTab + 1;
      }
    }

    function nothing() {}

    function createObj(base, props) {
      var inst;
      if (Object.create) {
        inst = Object.create(base);
      } else {
        nothing.prototype = base;
        inst = new nothing();
      }
      if (props) { copyObj(props, inst); }
      return inst
    }

    // STRING STREAM

    // Fed to the mode parsers, provides helper functions to make
    // parsers more succinct.

    var StringStream = function(string, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };

    StringStream.prototype.eol = function () {return this.pos >= this.string.length};
    StringStream.prototype.sol = function () {return this.pos == this.lineStart};
    StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
    StringStream.prototype.next = function () {
      if (this.pos < this.string.length)
        { return this.string.charAt(this.pos++) }
    };
    StringStream.prototype.eat = function (match) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match == "string") { ok = ch == match; }
      else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
      if (ok) {++this.pos; return ch}
    };
    StringStream.prototype.eatWhile = function (match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start
    };
    StringStream.prototype.eatSpace = function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
      return this.pos > start
    };
    StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
    StringStream.prototype.skipTo = function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true}
    };
    StringStream.prototype.backUp = function (n) {this.pos -= n;};
    StringStream.prototype.column = function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
    };
    StringStream.prototype.indentation = function () {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
    };
    StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) { this.pos += pattern.length; }
          return true
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) { return null }
        if (match && consume !== false) { this.pos += match[0].length; }
        return match
      }
    };
    StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
    StringStream.prototype.hideFirstChars = function (n, inner) {
      this.lineStart += n;
      try { return inner() }
      finally { this.lineStart -= n; }
    };
    StringStream.prototype.lookAhead = function (n) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n)
    };
    StringStream.prototype.baseToken = function () {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos)
    };

    // Known modes, by name and by MIME
    var modes = {}, mimeModes = {};

    // Extra arguments are stored as the mode's dependencies, which is
    // used by (legacy) mechanisms like loadmode.js to automatically
    // load a mode. (Preferred mechanism is the require/define calls.)
    function defineMode(name, mode) {
      if (arguments.length > 2)
        { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
      modes[name] = mode;
    }

    function defineMIME(mime, spec) {
      mimeModes[mime] = spec;
    }

    // Given a MIME type, a {name, ...options} config object, or a name
    // string, return a mode config object.
    function resolveMode(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") { found = {name: found}; }
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode("application/xml")
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode("application/json")
      }
      if (typeof spec == "string") { return {name: spec} }
      else { return spec || {name: "null"} }
    }

    // Given a mode spec (anything that resolveMode accepts), find and
    // initialize an actual mode object.
    function getMode(options, spec) {
      spec = resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) { return getMode(options, "text/plain") }
      var modeObj = mfactory(options, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop in exts) {
          if (!exts.hasOwnProperty(prop)) { continue }
          if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
          modeObj[prop] = exts[prop];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) { modeObj.helperType = spec.helperType; }
      if (spec.modeProps) { for (var prop$1 in spec.modeProps)
        { modeObj[prop$1] = spec.modeProps[prop$1]; } }

      return modeObj
    }

    // This can be used to attach properties to mode objects from
    // outside the actual mode definition.
    var modeExtensions = {};
    function extendMode(mode, properties) {
      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
      copyObj(properties, exts);
    }

    function copyState(mode, state) {
      if (state === true) { return state }
      if (mode.copyState) { return mode.copyState(state) }
      var nstate = {};
      for (var n in state) {
        var val = state[n];
        if (val instanceof Array) { val = val.concat([]); }
        nstate[n] = val;
      }
      return nstate
    }

    // Given a mode and a state (for that mode), find the inner mode and
    // state at the position that the state refers to.
    function innerMode(mode, state) {
      var info;
      while (mode.innerMode) {
        info = mode.innerMode(state);
        if (!info || info.mode == mode) { break }
        state = info.state;
        mode = info.mode;
      }
      return info || {mode: mode, state: state}
    }

    function startState(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true
    }

    var modeMethods = ({
      __proto__: null,
      modes: modes,
      mimeModes: mimeModes,
      defineMode: defineMode,
      defineMIME: defineMIME,
      resolveMode: resolveMode,
      getMode: getMode,
      modeExtensions: modeExtensions,
      extendMode: extendMode,
      copyState: copyState,
      innerMode: innerMode,
      startState: startState
    });

    // Copy StringStream and mode methods into exports (CodeMirror) object.
    exports.StringStream = StringStream;
    exports.countColumn = countColumn;
    for (var exported in modeMethods) { exports[exported] = modeMethods[exported]; }

    // Shim library CodeMirror with the minimal CodeMirror defined above.
    require.cache[require.resolve("../../lib/codemirror")] = require.cache[require.resolve("./runmode.node")];
    require.cache[require.resolve("../../addon/runmode/runmode")] = require.cache[require.resolve("./runmode.node")];

    // Minimal default mode.
    exports.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
    exports.defineMIME("text/plain", "null");

    exports.registerHelper = exports.registerGlobalHelper = Math.min;
    exports.splitLines = function(string) { return string.split(/\r?\n|\r/) };

    exports.defaults = { indentUnit: 2 };

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        { mod(require("../../lib/codemirror")); }
      else if (typeof define == "function" && define.amd) // AMD
        { define(["../../lib/codemirror"], mod); }
      else // Plain browser env
        { mod(CodeMirror); }
    })(function(CodeMirror) {

    CodeMirror.runMode = function(string, modespec, callback, options) {
      var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);
      var tabSize = (options && options.tabSize) || CodeMirror.defaults.tabSize;

      // Create a tokenizing callback function if passed-in callback is a DOM element.
      if (callback.appendChild) {
        var ie = /MSIE \d/.test(navigator.userAgent);
        var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
        var node = callback, col = 0;
        node.innerHTML = "";
        callback = function(text, style) {
          if (text == "\n") {
            // Emitting LF or CRLF on IE8 or earlier results in an incorrect display.
            // Emitting a carriage return makes everything ok.
            node.appendChild(document.createTextNode(ie_lt9 ? '\r' : text));
            col = 0;
            return;
          }
          var content = "";
          // replace tabs
          for (var pos = 0;;) {
            var idx = text.indexOf("\t", pos);
            if (idx == -1) {
              content += text.slice(pos);
              col += text.length - pos;
              break;
            } else {
              col += idx - pos;
              content += text.slice(pos, idx);
              var size = tabSize - col % tabSize;
              col += size;
              for (var i = 0; i < size; ++i) { content += " "; }
              pos = idx + 1;
            }
          }
          // Create a node with token style and append it to the callback DOM element.
          if (style) {
            var sp = node.appendChild(document.createElement("span"));
            sp.className = "cm-" + style.replace(/ +/g, " cm-");
            sp.appendChild(document.createTextNode(content));
          } else {
            node.appendChild(document.createTextNode(content));
          }
        };
      }

      var lines = CodeMirror.splitLines(string), state = (options && options.state) || CodeMirror.startState(mode);
      for (var i = 0, e = lines.length; i < e; ++i) {
        if (i) { callback("\n"); }
        var stream = new CodeMirror.StringStream(lines[i], null, {
          lookAhead: function(n) { return lines[i + n] },
          baseToken: function() {}
        });
        if (!stream.string && mode.blankLine) { mode.blankLine(state); }
        while (!stream.eol()) {
          var style = mode.token(stream, state);
          callback(stream.current(), style, i, stream.start, state, mode);
          stream.start = stream.pos;
        }
      }
    };

    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-selection-active-line.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";
      var WRAP_CLASS = "CodeMirror-activeline";
      var BACK_CLASS = "CodeMirror-activeline-background";
      var GUTT_CLASS = "CodeMirror-activeline-gutter";

      CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
        var prev = old == CodeMirror.Init ? false : old;
        if (val == prev) return
        if (prev) {
          cm.off("beforeSelectionChange", selectionChange);
          clearActiveLines(cm);
          delete cm.state.activeLines;
        }
        if (val) {
          cm.state.activeLines = [];
          updateActiveLines(cm, cm.listSelections());
          cm.on("beforeSelectionChange", selectionChange);
        }
      });

      function clearActiveLines(cm) {
        for (var i = 0; i < cm.state.activeLines.length; i++) {
          cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
          cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
          cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
        }
      }

      function sameArray(a, b) {
        if (a.length != b.length) return false;
        for (var i = 0; i < a.length; i++)
          if (a[i] != b[i]) return false;
        return true;
      }

      function updateActiveLines(cm, ranges) {
        var active = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          var option = cm.getOption("styleActiveLine");
          if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())
            continue
          var line = cm.getLineHandleVisualStart(range.head.line);
          if (active[active.length - 1] != line) active.push(line);
        }
        if (sameArray(cm.state.activeLines, active)) return;
        cm.operation(function() {
          clearActiveLines(cm);
          for (var i = 0; i < active.length; i++) {
            cm.addLineClass(active[i], "wrap", WRAP_CLASS);
            cm.addLineClass(active[i], "background", BACK_CLASS);
            cm.addLineClass(active[i], "gutter", GUTT_CLASS);
          }
          cm.state.activeLines = active;
        });
      }

      function selectionChange(cm, sel) {
        updateActiveLines(cm, sel.ranges);
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-selection-mark-selection.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Because sometimes you need to mark the selected *text*.
    //
    // Adds an option 'styleSelectedText' which, when enabled, gives
    // selected text the CSS class given as option value, or
    // "CodeMirror-selectedtext" when the value is not a string.

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {
        var prev = old && old != CodeMirror.Init;
        if (val && !prev) {
          cm.state.markedSelection = [];
          cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
          reset(cm);
          cm.on("cursorActivity", onCursorActivity);
          cm.on("change", onChange);
        } else if (!val && prev) {
          cm.off("cursorActivity", onCursorActivity);
          cm.off("change", onChange);
          clear(cm);
          cm.state.markedSelection = cm.state.markedSelectionStyle = null;
        }
      });

      function onCursorActivity(cm) {
        if (cm.state.markedSelection)
          cm.operation(function() { update(cm); });
      }

      function onChange(cm) {
        if (cm.state.markedSelection && cm.state.markedSelection.length)
          cm.operation(function() { clear(cm); });
      }

      var CHUNK_SIZE = 8;
      var Pos = CodeMirror.Pos;
      var cmp = CodeMirror.cmpPos;

      function coverRange(cm, from, to, addAt) {
        if (cmp(from, to) == 0) return;
        var array = cm.state.markedSelection;
        var cls = cm.state.markedSelectionStyle;
        for (var line = from.line;;) {
          var start = line == from.line ? from : Pos(line, 0);
          var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
          var end = atEnd ? to : Pos(endLine, 0);
          var mark = cm.markText(start, end, {className: cls});
          if (addAt == null) array.push(mark);
          else array.splice(addAt++, 0, mark);
          if (atEnd) break;
          line = endLine;
        }
      }

      function clear(cm) {
        var array = cm.state.markedSelection;
        for (var i = 0; i < array.length; ++i) array[i].clear();
        array.length = 0;
      }

      function reset(cm) {
        clear(cm);
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++)
          coverRange(cm, ranges[i].from(), ranges[i].to());
      }

      function update(cm) {
        if (!cm.somethingSelected()) return clear(cm);
        if (cm.listSelections().length > 1) return reset(cm);

        var from = cm.getCursor("start"), to = cm.getCursor("end");

        var array = cm.state.markedSelection;
        if (!array.length) return coverRange(cm, from, to);

        var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
        if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||
            cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
          return reset(cm);

        while (cmp(from, coverStart.from) > 0) {
          array.shift().clear();
          coverStart = array[0].find();
        }
        if (cmp(from, coverStart.from) < 0) {
          if (coverStart.to.line - from.line < CHUNK_SIZE) {
            array.shift().clear();
            coverRange(cm, from, coverStart.to, 0);
          } else {
            coverRange(cm, from, coverStart.from, 0);
          }
        }

        while (cmp(to, coverEnd.to) < 0) {
          array.pop().clear();
          coverEnd = array[array.length - 1].find();
        }
        if (cmp(to, coverEnd.to) > 0) {
          if (to.line - coverEnd.from.line < CHUNK_SIZE) {
            array.pop().clear();
            coverRange(cm, coverEnd.from, to);
          } else {
            coverRange(cm, coverEnd.to, to);
          }
        }
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-selection-selection-pointer.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineOption("selectionPointer", false, function(cm, val) {
        var data = cm.state.selectionPointer;
        if (data) {
          CodeMirror.off(cm.getWrapperElement(), "mousemove", data.mousemove);
          CodeMirror.off(cm.getWrapperElement(), "mouseout", data.mouseout);
          CodeMirror.off(window, "scroll", data.windowScroll);
          cm.off("cursorActivity", reset);
          cm.off("scroll", reset);
          cm.state.selectionPointer = null;
          cm.display.lineDiv.style.cursor = "";
        }
        if (val) {
          data = cm.state.selectionPointer = {
            value: typeof val == "string" ? val : "default",
            mousemove: function(event) { mousemove(cm, event); },
            mouseout: function(event) { mouseout(cm, event); },
            windowScroll: function() { reset(cm); },
            rects: null,
            mouseX: null, mouseY: null,
            willUpdate: false
          };
          CodeMirror.on(cm.getWrapperElement(), "mousemove", data.mousemove);
          CodeMirror.on(cm.getWrapperElement(), "mouseout", data.mouseout);
          CodeMirror.on(window, "scroll", data.windowScroll);
          cm.on("cursorActivity", reset);
          cm.on("scroll", reset);
        }
      });

      function mousemove(cm, event) {
        var data = cm.state.selectionPointer;
        if (event.buttons == null ? event.which : event.buttons) {
          data.mouseX = data.mouseY = null;
        } else {
          data.mouseX = event.clientX;
          data.mouseY = event.clientY;
        }
        scheduleUpdate(cm);
      }

      function mouseout(cm, event) {
        if (!cm.getWrapperElement().contains(event.relatedTarget)) {
          var data = cm.state.selectionPointer;
          data.mouseX = data.mouseY = null;
          scheduleUpdate(cm);
        }
      }

      function reset(cm) {
        cm.state.selectionPointer.rects = null;
        scheduleUpdate(cm);
      }

      function scheduleUpdate(cm) {
        if (!cm.state.selectionPointer.willUpdate) {
          cm.state.selectionPointer.willUpdate = true;
          setTimeout(function() {
            update(cm);
            cm.state.selectionPointer.willUpdate = false;
          }, 50);
        }
      }

      function update(cm) {
        var data = cm.state.selectionPointer;
        if (!data) return;
        if (data.rects == null && data.mouseX != null) {
          data.rects = [];
          if (cm.somethingSelected()) {
            for (var sel = cm.display.selectionDiv.firstChild; sel; sel = sel.nextSibling)
              data.rects.push(sel.getBoundingClientRect());
          }
        }
        var inside = false;
        if (data.mouseX != null) for (var i = 0; i < data.rects.length; i++) {
          var rect = data.rects[i];
          if (rect.left <= data.mouseX && rect.right >= data.mouseX &&
              rect.top <= data.mouseY && rect.bottom >= data.mouseY)
            inside = true;
        }
        var cursor = inside ? data.value : "";
        if (cm.display.lineDiv.style.cursor != cursor)
          cm.display.lineDiv.style.cursor = cursor;
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-tern-tern.css: |
    .CodeMirror-Tern-completion {
      padding-left: 22px;
      position: relative;
      line-height: 1.5;
    }
    .CodeMirror-Tern-completion:before {
      position: absolute;
      left: 2px;
      bottom: 2px;
      border-radius: 50%;
      font-size: 12px;
      font-weight: bold;
      height: 15px;
      width: 15px;
      line-height: 16px;
      text-align: center;
      color: white;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .CodeMirror-Tern-completion-unknown:before {
      content: "?";
      background: #4bb;
    }
    .CodeMirror-Tern-completion-object:before {
      content: "O";
      background: #77c;
    }
    .CodeMirror-Tern-completion-fn:before {
      content: "F";
      background: #7c7;
    }
    .CodeMirror-Tern-completion-array:before {
      content: "A";
      background: #c66;
    }
    .CodeMirror-Tern-completion-number:before {
      content: "1";
      background: #999;
    }
    .CodeMirror-Tern-completion-string:before {
      content: "S";
      background: #999;
    }
    .CodeMirror-Tern-completion-bool:before {
      content: "B";
      background: #999;
    }

    .CodeMirror-Tern-completion-guess {
      color: #999;
    }

    .CodeMirror-Tern-tooltip {
      border: 1px solid silver;
      border-radius: 3px;
      color: #444;
      padding: 2px 5px;
      font-size: 90%;
      font-family: monospace;
      background-color: white;
      white-space: pre-wrap;

      max-width: 40em;
      position: absolute;
      z-index: 10;
      -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
      -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
      box-shadow: 2px 3px 5px rgba(0,0,0,.2);

      transition: opacity 1s;
      -moz-transition: opacity 1s;
      -webkit-transition: opacity 1s;
      -o-transition: opacity 1s;
      -ms-transition: opacity 1s;
    }

    .CodeMirror-Tern-hint-doc {
      max-width: 25em;
      margin-top: -3px;
    }

    .CodeMirror-Tern-fname { color: black; }
    .CodeMirror-Tern-farg { color: #70a; }
    .CodeMirror-Tern-farg-current { text-decoration: underline; }
    .CodeMirror-Tern-type { color: #07c; }
    .CodeMirror-Tern-fhint-guess { opacity: .7; }
  uploads-admin-Public-Admin-plugins-codemirror-addon-tern-tern.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Glue code between CodeMirror and Tern.
    //
    // Create a CodeMirror.TernServer to wrap an actual Tern server,
    // register open documents (CodeMirror.Doc instances) with it, and
    // call its methods to activate the assisting functions that Tern
    // provides.
    //
    // Options supported (all optional):
    // * defs: An array of JSON definition data structures.
    // * plugins: An object mapping plugin names to configuration
    //   options.
    // * getFile: A function(name, c) that can be used to access files in
    //   the project that haven't been loaded yet. Simply do c(null) to
    //   indicate that a file is not available.
    // * fileFilter: A function(value, docName, doc) that will be applied
    //   to documents before passing them on to Tern.
    // * switchToDoc: A function(name, doc) that should, when providing a
    //   multi-file view, switch the view or focus to the named file.
    // * showError: A function(editor, message) that can be used to
    //   override the way errors are displayed.
    // * completionTip: Customize the content in tooltips for completions.
    //   Is passed a single argument—the completion's data as returned by
    //   Tern—and may return a string, DOM node, or null to indicate that
    //   no tip should be shown. By default the docstring is shown.
    // * typeTip: Like completionTip, but for the tooltips shown for type
    //   queries.
    // * responseFilter: A function(doc, query, request, error, data) that
    //   will be applied to the Tern responses before treating them
    //
    //
    // It is possible to run the Tern server in a web worker by specifying
    // these additional options:
    // * useWorker: Set to true to enable web worker mode. You'll probably
    //   want to feature detect the actual value you use here, for example
    //   !!window.Worker.
    // * workerScript: The main script of the worker. Point this to
    //   wherever you are hosting worker.js from this directory.
    // * workerDeps: An array of paths pointing (relative to workerScript)
    //   to the Acorn and Tern libraries and any Tern plugins you want to
    //   load. Or, if you minified those into a single script and included
    //   them in the workerScript, simply leave this undefined.

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";
      // declare global: tern

      CodeMirror.TernServer = function(options) {
        var self = this;
        this.options = options || {};
        var plugins = this.options.plugins || (this.options.plugins = {});
        if (!plugins.doc_comment) plugins.doc_comment = true;
        this.docs = Object.create(null);
        if (this.options.useWorker) {
          this.server = new WorkerServer(this);
        } else {
          this.server = new tern.Server({
            getFile: function(name, c) { return getFile(self, name, c); },
            async: true,
            defs: this.options.defs || [],
            plugins: plugins
          });
        }
        this.trackChange = function(doc, change) { trackChange(self, doc, change); };

        this.cachedArgHints = null;
        this.activeArgHints = null;
        this.jumpStack = [];

        this.getHint = function(cm, c) { return hint(self, cm, c); };
        this.getHint.async = true;
      };

      CodeMirror.TernServer.prototype = {
        addDoc: function(name, doc) {
          var data = {doc: doc, name: name, changed: null};
          this.server.addFile(name, docValue(this, data));
          CodeMirror.on(doc, "change", this.trackChange);
          return this.docs[name] = data;
        },

        delDoc: function(id) {
          var found = resolveDoc(this, id);
          if (!found) return;
          CodeMirror.off(found.doc, "change", this.trackChange);
          delete this.docs[found.name];
          this.server.delFile(found.name);
        },

        hideDoc: function(id) {
          closeArgHints(this);
          var found = resolveDoc(this, id);
          if (found && found.changed) sendDoc(this, found);
        },

        complete: function(cm) {
          cm.showHint({hint: this.getHint});
        },

        showType: function(cm, pos, c) { showContextInfo(this, cm, pos, "type", c); },

        showDocs: function(cm, pos, c) { showContextInfo(this, cm, pos, "documentation", c); },

        updateArgHints: function(cm) { updateArgHints(this, cm); },

        jumpToDef: function(cm) { jumpToDef(this, cm); },

        jumpBack: function(cm) { jumpBack(this, cm); },

        rename: function(cm) { rename(this, cm); },

        selectName: function(cm) { selectName(this, cm); },

        request: function (cm, query, c, pos) {
          var self = this;
          var doc = findDoc(this, cm.getDoc());
          var request = buildRequest(this, doc, query, pos);
          var extraOptions = request.query && this.options.queryOptions && this.options.queryOptions[request.query.type]
          if (extraOptions) for (var prop in extraOptions) request.query[prop] = extraOptions[prop];

          this.server.request(request, function (error, data) {
            if (!error && self.options.responseFilter)
              data = self.options.responseFilter(doc, query, request, error, data);
            c(error, data);
          });
        },

        destroy: function () {
          closeArgHints(this)
          if (this.worker) {
            this.worker.terminate();
            this.worker = null;
          }
        }
      };

      var Pos = CodeMirror.Pos;
      var cls = "CodeMirror-Tern-";
      var bigDoc = 250;

      function getFile(ts, name, c) {
        var buf = ts.docs[name];
        if (buf)
          c(docValue(ts, buf));
        else if (ts.options.getFile)
          ts.options.getFile(name, c);
        else
          c(null);
      }

      function findDoc(ts, doc, name) {
        for (var n in ts.docs) {
          var cur = ts.docs[n];
          if (cur.doc == doc) return cur;
        }
        if (!name) for (var i = 0;; ++i) {
          n = "[doc" + (i || "") + "]";
          if (!ts.docs[n]) { name = n; break; }
        }
        return ts.addDoc(name, doc);
      }

      function resolveDoc(ts, id) {
        if (typeof id == "string") return ts.docs[id];
        if (id instanceof CodeMirror) id = id.getDoc();
        if (id instanceof CodeMirror.Doc) return findDoc(ts, id);
      }

      function trackChange(ts, doc, change) {
        var data = findDoc(ts, doc);

        var argHints = ts.cachedArgHints;
        if (argHints && argHints.doc == doc && cmpPos(argHints.start, change.to) >= 0)
          ts.cachedArgHints = null;

        var changed = data.changed;
        if (changed == null)
          data.changed = changed = {from: change.from.line, to: change.from.line};
        var end = change.from.line + (change.text.length - 1);
        if (change.from.line < changed.to) changed.to = changed.to - (change.to.line - end);
        if (end >= changed.to) changed.to = end + 1;
        if (changed.from > change.from.line) changed.from = change.from.line;

        if (doc.lineCount() > bigDoc && change.to - changed.from > 100) setTimeout(function() {
          if (data.changed && data.changed.to - data.changed.from > 100) sendDoc(ts, data);
        }, 200);
      }

      function sendDoc(ts, doc) {
        ts.server.request({files: [{type: "full", name: doc.name, text: docValue(ts, doc)}]}, function(error) {
          if (error) window.console.error(error);
          else doc.changed = null;
        });
      }

      // Completion

      function hint(ts, cm, c) {
        ts.request(cm, {type: "completions", types: true, docs: true, urls: true}, function(error, data) {
          if (error) return showError(ts, cm, error);
          var completions = [], after = "";
          var from = data.start, to = data.end;
          if (cm.getRange(Pos(from.line, from.ch - 2), from) == "[\"" &&
              cm.getRange(to, Pos(to.line, to.ch + 2)) != "\"]")
            after = "\"]";

          for (var i = 0; i < data.completions.length; ++i) {
            var completion = data.completions[i], className = typeToIcon(completion.type);
            if (data.guess) className += " " + cls + "guess";
            completions.push({text: completion.name + after,
                              displayText: completion.displayName || completion.name,
                              className: className,
                              data: completion});
          }

          var obj = {from: from, to: to, list: completions};
          var tooltip = null;
          CodeMirror.on(obj, "close", function() { remove(tooltip); });
          CodeMirror.on(obj, "update", function() { remove(tooltip); });
          CodeMirror.on(obj, "select", function(cur, node) {
            remove(tooltip);
            var content = ts.options.completionTip ? ts.options.completionTip(cur.data) : cur.data.doc;
            if (content) {
              tooltip = makeTooltip(node.parentNode.getBoundingClientRect().right + window.pageXOffset,
                                    node.getBoundingClientRect().top + window.pageYOffset, content, cm, cls + "hint-doc");
            }
          });
          c(obj);
        });
      }

      function typeToIcon(type) {
        var suffix;
        if (type == "?") suffix = "unknown";
        else if (type == "number" || type == "string" || type == "bool") suffix = type;
        else if (/^fn\(/.test(type)) suffix = "fn";
        else if (/^\[/.test(type)) suffix = "array";
        else suffix = "object";
        return cls + "completion " + cls + "completion-" + suffix;
      }

      // Type queries

      function showContextInfo(ts, cm, pos, queryName, c) {
        ts.request(cm, queryName, function(error, data) {
          if (error) return showError(ts, cm, error);
          if (ts.options.typeTip) {
            var tip = ts.options.typeTip(data);
          } else {
            var tip = elt("span", null, elt("strong", null, data.type || "not found"));
            if (data.doc)
              tip.appendChild(document.createTextNode(" — " + data.doc));
            if (data.url) {
              tip.appendChild(document.createTextNode(" "));
              var child = tip.appendChild(elt("a", null, "[docs]"));
              child.href = data.url;
              child.target = "_blank";
            }
          }
          tempTooltip(cm, tip, ts);
          if (c) c();
        }, pos);
      }

      // Maintaining argument hints

      function updateArgHints(ts, cm) {
        closeArgHints(ts);

        if (cm.somethingSelected()) return;
        var state = cm.getTokenAt(cm.getCursor()).state;
        var inner = CodeMirror.innerMode(cm.getMode(), state);
        if (inner.mode.name != "javascript") return;
        var lex = inner.state.lexical;
        if (lex.info != "call") return;

        var ch, argPos = lex.pos || 0, tabSize = cm.getOption("tabSize");
        for (var line = cm.getCursor().line, e = Math.max(0, line - 9), found = false; line >= e; --line) {
          var str = cm.getLine(line), extra = 0;
          for (var pos = 0;;) {
            var tab = str.indexOf("\t", pos);
            if (tab == -1) break;
            extra += tabSize - (tab + extra) % tabSize - 1;
            pos = tab + 1;
          }
          ch = lex.column - extra;
          if (str.charAt(ch) == "(") {found = true; break;}
        }
        if (!found) return;

        var start = Pos(line, ch);
        var cache = ts.cachedArgHints;
        if (cache && cache.doc == cm.getDoc() && cmpPos(start, cache.start) == 0)
          return showArgHints(ts, cm, argPos);

        ts.request(cm, {type: "type", preferFunction: true, end: start}, function(error, data) {
          if (error || !data.type || !(/^fn\(/).test(data.type)) return;
          ts.cachedArgHints = {
            start: start,
            type: parseFnType(data.type),
            name: data.exprName || data.name || "fn",
            guess: data.guess,
            doc: cm.getDoc()
          };
          showArgHints(ts, cm, argPos);
        });
      }

      function showArgHints(ts, cm, pos) {
        closeArgHints(ts);

        var cache = ts.cachedArgHints, tp = cache.type;
        var tip = elt("span", cache.guess ? cls + "fhint-guess" : null,
                      elt("span", cls + "fname", cache.name), "(");
        for (var i = 0; i < tp.args.length; ++i) {
          if (i) tip.appendChild(document.createTextNode(", "));
          var arg = tp.args[i];
          tip.appendChild(elt("span", cls + "farg" + (i == pos ? " " + cls + "farg-current" : ""), arg.name || "?"));
          if (arg.type != "?") {
            tip.appendChild(document.createTextNode(":\u00a0"));
            tip.appendChild(elt("span", cls + "type", arg.type));
          }
        }
        tip.appendChild(document.createTextNode(tp.rettype ? ") ->\u00a0" : ")"));
        if (tp.rettype) tip.appendChild(elt("span", cls + "type", tp.rettype));
        var place = cm.cursorCoords(null, "page");
        var tooltip = ts.activeArgHints = makeTooltip(place.right + 1, place.bottom, tip, cm)
        setTimeout(function() {
          tooltip.clear = onEditorActivity(cm, function() {
            if (ts.activeArgHints == tooltip) closeArgHints(ts) })
        }, 20)
      }

      function parseFnType(text) {
        var args = [], pos = 3;

        function skipMatching(upto) {
          var depth = 0, start = pos;
          for (;;) {
            var next = text.charAt(pos);
            if (upto.test(next) && !depth) return text.slice(start, pos);
            if (/[{\[\(]/.test(next)) ++depth;
            else if (/[}\]\)]/.test(next)) --depth;
            ++pos;
          }
        }

        // Parse arguments
        if (text.charAt(pos) != ")") for (;;) {
          var name = text.slice(pos).match(/^([^, \(\[\{]+): /);
          if (name) {
            pos += name[0].length;
            name = name[1];
          }
          args.push({name: name, type: skipMatching(/[\),]/)});
          if (text.charAt(pos) == ")") break;
          pos += 2;
        }

        var rettype = text.slice(pos).match(/^\) -> (.*)$/);

        return {args: args, rettype: rettype && rettype[1]};
      }

      // Moving to the definition of something

      function jumpToDef(ts, cm) {
        function inner(varName) {
          var req = {type: "definition", variable: varName || null};
          var doc = findDoc(ts, cm.getDoc());
          ts.server.request(buildRequest(ts, doc, req), function(error, data) {
            if (error) return showError(ts, cm, error);
            if (!data.file && data.url) { window.open(data.url); return; }

            if (data.file) {
              var localDoc = ts.docs[data.file], found;
              if (localDoc && (found = findContext(localDoc.doc, data))) {
                ts.jumpStack.push({file: doc.name,
                                   start: cm.getCursor("from"),
                                   end: cm.getCursor("to")});
                moveTo(ts, doc, localDoc, found.start, found.end);
                return;
              }
            }
            showError(ts, cm, "Could not find a definition.");
          });
        }

        if (!atInterestingExpression(cm))
          dialog(cm, "Jump to variable", function(name) { if (name) inner(name); });
        else
          inner();
      }

      function jumpBack(ts, cm) {
        var pos = ts.jumpStack.pop(), doc = pos && ts.docs[pos.file];
        if (!doc) return;
        moveTo(ts, findDoc(ts, cm.getDoc()), doc, pos.start, pos.end);
      }

      function moveTo(ts, curDoc, doc, start, end) {
        doc.doc.setSelection(start, end);
        if (curDoc != doc && ts.options.switchToDoc) {
          closeArgHints(ts);
          ts.options.switchToDoc(doc.name, doc.doc);
        }
      }

      // The {line,ch} representation of positions makes this rather awkward.
      function findContext(doc, data) {
        var before = data.context.slice(0, data.contextOffset).split("\n");
        var startLine = data.start.line - (before.length - 1);
        var start = Pos(startLine, (before.length == 1 ? data.start.ch : doc.getLine(startLine).length) - before[0].length);

        var text = doc.getLine(startLine).slice(start.ch);
        for (var cur = startLine + 1; cur < doc.lineCount() && text.length < data.context.length; ++cur)
          text += "\n" + doc.getLine(cur);
        if (text.slice(0, data.context.length) == data.context) return data;

        var cursor = doc.getSearchCursor(data.context, 0, false);
        var nearest, nearestDist = Infinity;
        while (cursor.findNext()) {
          var from = cursor.from(), dist = Math.abs(from.line - start.line) * 10000;
          if (!dist) dist = Math.abs(from.ch - start.ch);
          if (dist < nearestDist) { nearest = from; nearestDist = dist; }
        }
        if (!nearest) return null;

        if (before.length == 1)
          nearest.ch += before[0].length;
        else
          nearest = Pos(nearest.line + (before.length - 1), before[before.length - 1].length);
        if (data.start.line == data.end.line)
          var end = Pos(nearest.line, nearest.ch + (data.end.ch - data.start.ch));
        else
          var end = Pos(nearest.line + (data.end.line - data.start.line), data.end.ch);
        return {start: nearest, end: end};
      }

      function atInterestingExpression(cm) {
        var pos = cm.getCursor("end"), tok = cm.getTokenAt(pos);
        if (tok.start < pos.ch && tok.type == "comment") return false;
        return /[\w)\]]/.test(cm.getLine(pos.line).slice(Math.max(pos.ch - 1, 0), pos.ch + 1));
      }

      // Variable renaming

      function rename(ts, cm) {
        var token = cm.getTokenAt(cm.getCursor());
        if (!/\w/.test(token.string)) return showError(ts, cm, "Not at a variable");
        dialog(cm, "New name for " + token.string, function(newName) {
          ts.request(cm, {type: "rename", newName: newName, fullDocs: true}, function(error, data) {
            if (error) return showError(ts, cm, error);
            applyChanges(ts, data.changes);
          });
        });
      }

      function selectName(ts, cm) {
        var name = findDoc(ts, cm.doc).name;
        ts.request(cm, {type: "refs"}, function(error, data) {
          if (error) return showError(ts, cm, error);
          var ranges = [], cur = 0;
          var curPos = cm.getCursor();
          for (var i = 0; i < data.refs.length; i++) {
            var ref = data.refs[i];
            if (ref.file == name) {
              ranges.push({anchor: ref.start, head: ref.end});
              if (cmpPos(curPos, ref.start) >= 0 && cmpPos(curPos, ref.end) <= 0)
                cur = ranges.length - 1;
            }
          }
          cm.setSelections(ranges, cur);
        });
      }

      var nextChangeOrig = 0;
      function applyChanges(ts, changes) {
        var perFile = Object.create(null);
        for (var i = 0; i < changes.length; ++i) {
          var ch = changes[i];
          (perFile[ch.file] || (perFile[ch.file] = [])).push(ch);
        }
        for (var file in perFile) {
          var known = ts.docs[file], chs = perFile[file];;
          if (!known) continue;
          chs.sort(function(a, b) { return cmpPos(b.start, a.start); });
          var origin = "*rename" + (++nextChangeOrig);
          for (var i = 0; i < chs.length; ++i) {
            var ch = chs[i];
            known.doc.replaceRange(ch.text, ch.start, ch.end, origin);
          }
        }
      }

      // Generic request-building helper

      function buildRequest(ts, doc, query, pos) {
        var files = [], offsetLines = 0, allowFragments = !query.fullDocs;
        if (!allowFragments) delete query.fullDocs;
        if (typeof query == "string") query = {type: query};
        query.lineCharPositions = true;
        if (query.end == null) {
          query.end = pos || doc.doc.getCursor("end");
          if (doc.doc.somethingSelected())
            query.start = doc.doc.getCursor("start");
        }
        var startPos = query.start || query.end;

        if (doc.changed) {
          if (doc.doc.lineCount() > bigDoc && allowFragments !== false &&
              doc.changed.to - doc.changed.from < 100 &&
              doc.changed.from <= startPos.line && doc.changed.to > query.end.line) {
            files.push(getFragmentAround(doc, startPos, query.end));
            query.file = "#0";
            var offsetLines = files[0].offsetLines;
            if (query.start != null) query.start = Pos(query.start.line - -offsetLines, query.start.ch);
            query.end = Pos(query.end.line - offsetLines, query.end.ch);
          } else {
            files.push({type: "full",
                        name: doc.name,
                        text: docValue(ts, doc)});
            query.file = doc.name;
            doc.changed = null;
          }
        } else {
          query.file = doc.name;
        }
        for (var name in ts.docs) {
          var cur = ts.docs[name];
          if (cur.changed && cur != doc) {
            files.push({type: "full", name: cur.name, text: docValue(ts, cur)});
            cur.changed = null;
          }
        }

        return {query: query, files: files};
      }

      function getFragmentAround(data, start, end) {
        var doc = data.doc;
        var minIndent = null, minLine = null, endLine, tabSize = 4;
        for (var p = start.line - 1, min = Math.max(0, p - 50); p >= min; --p) {
          var line = doc.getLine(p), fn = line.search(/\bfunction\b/);
          if (fn < 0) continue;
          var indent = CodeMirror.countColumn(line, null, tabSize);
          if (minIndent != null && minIndent <= indent) continue;
          minIndent = indent;
          minLine = p;
        }
        if (minLine == null) minLine = min;
        var max = Math.min(doc.lastLine(), end.line + 20);
        if (minIndent == null || minIndent == CodeMirror.countColumn(doc.getLine(start.line), null, tabSize))
          endLine = max;
        else for (endLine = end.line + 1; endLine < max; ++endLine) {
          var indent = CodeMirror.countColumn(doc.getLine(endLine), null, tabSize);
          if (indent <= minIndent) break;
        }
        var from = Pos(minLine, 0);

        return {type: "part",
                name: data.name,
                offsetLines: from.line,
                text: doc.getRange(from, Pos(endLine, end.line == endLine ? null : 0))};
      }

      // Generic utilities

      var cmpPos = CodeMirror.cmpPos;

      function elt(tagname, cls /*, ... elts*/) {
        var e = document.createElement(tagname);
        if (cls) e.className = cls;
        for (var i = 2; i < arguments.length; ++i) {
          var elt = arguments[i];
          if (typeof elt == "string") elt = document.createTextNode(elt);
          e.appendChild(elt);
        }
        return e;
      }

      function dialog(cm, text, f) {
        if (cm.openDialog)
          cm.openDialog(text + ": <input type=text>", f);
        else
          f(prompt(text, ""));
      }

      // Tooltips

      function tempTooltip(cm, content, ts) {
        if (cm.state.ternTooltip) remove(cm.state.ternTooltip);
        var where = cm.cursorCoords();
        var tip = cm.state.ternTooltip = makeTooltip(where.right + 1, where.bottom, content, cm);
        function maybeClear() {
          old = true;
          if (!mouseOnTip) clear();
        }
        function clear() {
          cm.state.ternTooltip = null;
          if (tip.parentNode) fadeOut(tip)
          clearActivity()
        }
        var mouseOnTip = false, old = false;
        CodeMirror.on(tip, "mousemove", function() { mouseOnTip = true; });
        CodeMirror.on(tip, "mouseout", function(e) {
          var related = e.relatedTarget || e.toElement
          if (!related || !CodeMirror.contains(tip, related)) {
            if (old) clear();
            else mouseOnTip = false;
          }
        });
        setTimeout(maybeClear, ts.options.hintDelay ? ts.options.hintDelay : 1700);
        var clearActivity = onEditorActivity(cm, clear)
      }

      function onEditorActivity(cm, f) {
        cm.on("cursorActivity", f)
        cm.on("blur", f)
        cm.on("scroll", f)
        cm.on("setDoc", f)
        return function() {
          cm.off("cursorActivity", f)
          cm.off("blur", f)
          cm.off("scroll", f)
          cm.off("setDoc", f)
        }
      }

      function makeTooltip(x, y, content, cm, className) {
        var node = elt("div", cls + "tooltip" + " " + (className || ""), content);
        node.style.left = x + "px";
        node.style.top = y + "px";
        var container = ((cm.options || {}).hintOptions || {}).container || document.body;
        container.appendChild(node);

        var pos = cm.cursorCoords();
        var winW = window.innerWidth;
        var winH = window.innerHeight;
        var box = node.getBoundingClientRect();
        var hints = document.querySelector(".CodeMirror-hints");
        var overlapY = box.bottom - winH;
        var overlapX = box.right - winW;

        if (hints && overlapX > 0) {
          node.style.left = 0;
          var box = node.getBoundingClientRect();
          node.style.left = (x = x - hints.offsetWidth - box.width) + "px";
          overlapX = box.right - winW;
        }
        if (overlapY > 0) {
          var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
          if (curTop - height > 0) { // Fits above cursor
            node.style.top = (pos.top - height) + "px";
          } else if (height > winH) {
            node.style.height = (winH - 5) + "px";
            node.style.top = (pos.bottom - box.top) + "px";
          }
        }
        if (overlapX > 0) {
          if (box.right - box.left > winW) {
            node.style.width = (winW - 5) + "px";
            overlapX -= (box.right - box.left) - winW;
          }
          node.style.left = (x - overlapX) + "px";
        }

        return node;
      }

      function remove(node) {
        var p = node && node.parentNode;
        if (p) p.removeChild(node);
      }

      function fadeOut(tooltip) {
        tooltip.style.opacity = "0";
        setTimeout(function() { remove(tooltip); }, 1100);
      }

      function showError(ts, cm, msg) {
        if (ts.options.showError)
          ts.options.showError(cm, msg);
        else
          tempTooltip(cm, String(msg), ts);
      }

      function closeArgHints(ts) {
        if (ts.activeArgHints) {
          if (ts.activeArgHints.clear) ts.activeArgHints.clear()
          remove(ts.activeArgHints)
          ts.activeArgHints = null
        }
      }

      function docValue(ts, doc) {
        var val = doc.doc.getValue();
        if (ts.options.fileFilter) val = ts.options.fileFilter(val, doc.name, doc.doc);
        return val;
      }

      // Worker wrapper

      function WorkerServer(ts) {
        var worker = ts.worker = new Worker(ts.options.workerScript);
        worker.postMessage({type: "init",
                            defs: ts.options.defs,
                            plugins: ts.options.plugins,
                            scripts: ts.options.workerDeps});
        var msgId = 0, pending = {};

        function send(data, c) {
          if (c) {
            data.id = ++msgId;
            pending[msgId] = c;
          }
          worker.postMessage(data);
        }
        worker.onmessage = function(e) {
          var data = e.data;
          if (data.type == "getFile") {
            getFile(ts, data.name, function(err, text) {
              send({type: "getFile", err: String(err), text: text, id: data.id});
            });
          } else if (data.type == "debug") {
            window.console.log(data.message);
          } else if (data.id && pending[data.id]) {
            pending[data.id](data.err, data.body);
            delete pending[data.id];
          }
        };
        worker.onerror = function(e) {
          for (var id in pending) pending[id](e);
          pending = {};
        };

        this.addFile = function(name, text) { send({type: "add", name: name, text: text}); };
        this.delFile = function(name) { send({type: "del", name: name}); };
        this.request = function(body, c) { send({type: "req", body: body}, c); };
      }
    });
  uploads-admin-Public-Admin-plugins-codemirror-addon-tern-worker.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // declare global: tern, server

    var server;

    this.onmessage = function(e) {
      var data = e.data;
      switch (data.type) {
      case "init": return startServer(data.defs, data.plugins, data.scripts);
      case "add": return server.addFile(data.name, data.text);
      case "del": return server.delFile(data.name);
      case "req": return server.request(data.body, function(err, reqData) {
        postMessage({id: data.id, body: reqData, err: err && String(err)});
      });
      case "getFile":
        var c = pending[data.id];
        delete pending[data.id];
        return c(data.err, data.text);
      default: throw new Error("Unknown message type: " + data.type);
      }
    };

    var nextId = 0, pending = {};
    function getFile(file, c) {
      postMessage({type: "getFile", name: file, id: ++nextId});
      pending[nextId] = c;
    }

    function startServer(defs, plugins, scripts) {
      if (scripts) importScripts.apply(null, scripts);

      server = new tern.Server({
        getFile: getFile,
        async: true,
        defs: defs,
        plugins: plugins
      });
    }

    this.console = {
      log: function(v) { postMessage({type: "debug", message: v}); }
    };
  uploads-admin-Public-Admin-plugins-codemirror-addon-wrap-hardwrap.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var Pos = CodeMirror.Pos;

      function findParagraph(cm, pos, options) {
        var startRE = options.paragraphStart || cm.getHelper(pos, "paragraphStart");
        for (var start = pos.line, first = cm.firstLine(); start > first; --start) {
          var line = cm.getLine(start);
          if (startRE && startRE.test(line)) break;
          if (!/\S/.test(line)) { ++start; break; }
        }
        var endRE = options.paragraphEnd || cm.getHelper(pos, "paragraphEnd");
        for (var end = pos.line + 1, last = cm.lastLine(); end <= last; ++end) {
          var line = cm.getLine(end);
          if (endRE && endRE.test(line)) { ++end; break; }
          if (!/\S/.test(line)) break;
        }
        return {from: start, to: end};
      }

      function findBreakPoint(text, column, wrapOn, killTrailingSpace, forceBreak) {
        var at = column
        while (at < text.length && text.charAt(at) == " ") at++
        for (; at > 0; --at)
          if (wrapOn.test(text.slice(at - 1, at + 1))) break;

        if (!forceBreak && at <= text.match(/^[ \t]*/)[0].length) {
          // didn't find a break point before column, in non-forceBreak mode try to
          // find one after 'column'.
          for (at = column + 1; at < text.length - 1; ++at) {
            if (wrapOn.test(text.slice(at - 1, at + 1))) break;
          }
        }

        for (var first = true;; first = false) {
          var endOfText = at;
          if (killTrailingSpace)
            while (text.charAt(endOfText - 1) == " ") --endOfText;
          if (endOfText == 0 && first) at = column;
          else return {from: endOfText, to: at};
        }
      }

      function wrapRange(cm, from, to, options) {
        from = cm.clipPos(from); to = cm.clipPos(to);
        var column = options.column || 80;
        var wrapOn = options.wrapOn || /\s\S|-[^\.\d]/;
        var forceBreak = options.forceBreak !== false;
        var killTrailing = options.killTrailingSpace !== false;
        var changes = [], curLine = "", curNo = from.line;
        var lines = cm.getRange(from, to, false);
        if (!lines.length) return null;
        var leadingSpace = lines[0].match(/^[ \t]*/)[0];
        if (leadingSpace.length >= column) column = leadingSpace.length + 1

        for (var i = 0; i < lines.length; ++i) {
          var text = lines[i], oldLen = curLine.length, spaceInserted = 0;
          if (curLine && text && !wrapOn.test(curLine.charAt(curLine.length - 1) + text.charAt(0))) {
            curLine += " ";
            spaceInserted = 1;
          }
          var spaceTrimmed = "";
          if (i) {
            spaceTrimmed = text.match(/^\s*/)[0];
            text = text.slice(spaceTrimmed.length);
          }
          curLine += text;
          if (i) {
            var firstBreak = curLine.length > column && leadingSpace == spaceTrimmed &&
              findBreakPoint(curLine, column, wrapOn, killTrailing, forceBreak);
            // If this isn't broken, or is broken at a different point, remove old break
            if (!firstBreak || firstBreak.from != oldLen || firstBreak.to != oldLen + spaceInserted) {
              changes.push({text: [spaceInserted ? " " : ""],
                            from: Pos(curNo, oldLen),
                            to: Pos(curNo + 1, spaceTrimmed.length)});
            } else {
              curLine = leadingSpace + text;
              ++curNo;
            }
          }
          while (curLine.length > column) {
            var bp = findBreakPoint(curLine, column, wrapOn, killTrailing, forceBreak);
            if (bp.from != bp.to ||
                forceBreak && leadingSpace !== curLine.slice(0, bp.to)) {
              changes.push({text: ["", leadingSpace],
                            from: Pos(curNo, bp.from),
                            to: Pos(curNo, bp.to)});
              curLine = leadingSpace + curLine.slice(bp.to);
              ++curNo;
            } else {
              break;
            }
          }
        }
        if (changes.length) cm.operation(function() {
          for (var i = 0; i < changes.length; ++i) {
            var change = changes[i];
            if (change.text || CodeMirror.cmpPos(change.from, change.to))
              cm.replaceRange(change.text, change.from, change.to);
          }
        });
        return changes.length ? {from: changes[0].from, to: CodeMirror.changeEnd(changes[changes.length - 1])} : null;
      }

      CodeMirror.defineExtension("wrapParagraph", function(pos, options) {
        options = options || {};
        if (!pos) pos = this.getCursor();
        var para = findParagraph(this, pos, options);
        return wrapRange(this, Pos(para.from, 0), Pos(para.to - 1), options);
      });

      CodeMirror.commands.wrapLines = function(cm) {
        cm.operation(function() {
          var ranges = cm.listSelections(), at = cm.lastLine() + 1;
          for (var i = ranges.length - 1; i >= 0; i--) {
            var range = ranges[i], span;
            if (range.empty()) {
              var para = findParagraph(cm, range.head, {});
              span = {from: Pos(para.from, 0), to: Pos(para.to - 1)};
            } else {
              span = {from: range.from(), to: range.to()};
            }
            if (span.to.line >= at) continue;
            at = span.from.line;
            wrapRange(cm, span.from, span.to, {});
          }
        });
      };

      CodeMirror.defineExtension("wrapRange", function(from, to, options) {
        return wrapRange(this, from, to, options || {});
      });

      CodeMirror.defineExtension("wrapParagraphsInRange", function(from, to, options) {
        options = options || {};
        var cm = this, paras = [];
        for (var line = from.line; line <= to.line;) {
          var para = findParagraph(cm, Pos(line, 0), options);
          paras.push(para);
          line = para.to;
        }
        var madeChange = false;
        if (paras.length) cm.operation(function() {
          for (var i = paras.length - 1; i >= 0; --i)
            madeChange = madeChange || wrapRange(cm, Pos(paras[i].from, 0), Pos(paras[i].to - 1), options);
        });
        return madeChange;
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-theme-ambiance.css: |
    /* ambiance theme for codemirror */

    /* Color scheme */

    .cm-s-ambiance .cm-header { color: blue; }
    .cm-s-ambiance .cm-quote { color: #24C2C7; }

    .cm-s-ambiance .cm-keyword { color: #cda869; }
    .cm-s-ambiance .cm-atom { color: #CF7EA9; }
    .cm-s-ambiance .cm-number { color: #78CF8A; }
    .cm-s-ambiance .cm-def { color: #aac6e3; }
    .cm-s-ambiance .cm-variable { color: #ffb795; }
    .cm-s-ambiance .cm-variable-2 { color: #eed1b3; }
    .cm-s-ambiance .cm-variable-3, .cm-s-ambiance .cm-type { color: #faded3; }
    .cm-s-ambiance .cm-property { color: #eed1b3; }
    .cm-s-ambiance .cm-operator { color: #fa8d6a; }
    .cm-s-ambiance .cm-comment { color: #555; font-style:italic; }
    .cm-s-ambiance .cm-string { color: #8f9d6a; }
    .cm-s-ambiance .cm-string-2 { color: #9d937c; }
    .cm-s-ambiance .cm-meta { color: #D2A8A1; }
    .cm-s-ambiance .cm-qualifier { color: yellow; }
    .cm-s-ambiance .cm-builtin { color: #9999cc; }
    .cm-s-ambiance .cm-bracket { color: #24C2C7; }
    .cm-s-ambiance .cm-tag { color: #fee4ff; }
    .cm-s-ambiance .cm-attribute { color: #9B859D; }
    .cm-s-ambiance .cm-hr { color: pink; }
    .cm-s-ambiance .cm-link { color: #F4C20B; }
    .cm-s-ambiance .cm-special { color: #FF9D00; }
    .cm-s-ambiance .cm-error { color: #AF2018; }

    .cm-s-ambiance .CodeMirror-matchingbracket { color: #0f0; }
    .cm-s-ambiance .CodeMirror-nonmatchingbracket { color: #f22; }

    .cm-s-ambiance div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }
    .cm-s-ambiance.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }
    .cm-s-ambiance .CodeMirror-line::selection, .cm-s-ambiance .CodeMirror-line > span::selection, .cm-s-ambiance .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }
    .cm-s-ambiance .CodeMirror-line::-moz-selection, .cm-s-ambiance .CodeMirror-line > span::-moz-selection, .cm-s-ambiance .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }

    /* Editor styling */

    .cm-s-ambiance.CodeMirror {
      line-height: 1.40em;
      color: #E6E1DC;
      background-color: #202020;
      -webkit-box-shadow: inset 0 0 10px black;
      -moz-box-shadow: inset 0 0 10px black;
      box-shadow: inset 0 0 10px black;
    }

    .cm-s-ambiance .CodeMirror-gutters {
      background: #3D3D3D;
      border-right: 1px solid #4D4D4D;
      box-shadow: 0 10px 20px black;
    }

    .cm-s-ambiance .CodeMirror-linenumber {
      text-shadow: 0px 1px 1px #4d4d4d;
      color: #111;
      padding: 0 5px;
    }

    .cm-s-ambiance .CodeMirror-guttermarker { color: #aaa; }
    .cm-s-ambiance .CodeMirror-guttermarker-subtle { color: #111; }

    .cm-s-ambiance .CodeMirror-cursor { border-left: 1px solid #7991E8; }

    .cm-s-ambiance .CodeMirror-activeline-background {
      background: none repeat scroll 0% 0% rgba(255, 255, 255, 0.031);
    }

    .cm-s-ambiance.CodeMirror,
    .cm-s-ambiance .CodeMirror-gutters {
      background-image: url("data:image/png;base64,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");
    }
  uploads-admin-Public-Admin-plugins-codemirror-theme-base16-light.css: |
    /*

        Name:       Base16 Default Light
        Author:     Chris Kempson (http://chriskempson.com)

        CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)
        Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)

    */

    .cm-s-base16-light.CodeMirror { background: #f5f5f5; color: #202020; }
    .cm-s-base16-light div.CodeMirror-selected { background: #e0e0e0; }
    .cm-s-base16-light .CodeMirror-line::selection, .cm-s-base16-light .CodeMirror-line > span::selection, .cm-s-base16-light .CodeMirror-line > span > span::selection { background: #e0e0e0; }
    .cm-s-base16-light .CodeMirror-line::-moz-selection, .cm-s-base16-light .CodeMirror-line > span::-moz-selection, .cm-s-base16-light .CodeMirror-line > span > span::-moz-selection { background: #e0e0e0; }
    .cm-s-base16-light .CodeMirror-gutters { background: #f5f5f5; border-right: 0px; }
    .cm-s-base16-light .CodeMirror-guttermarker { color: #ac4142; }
    .cm-s-base16-light .CodeMirror-guttermarker-subtle { color: #b0b0b0; }
    .cm-s-base16-light .CodeMirror-linenumber { color: #b0b0b0; }
    .cm-s-base16-light .CodeMirror-cursor { border-left: 1px solid #505050; }

    .cm-s-base16-light span.cm-comment { color: #8f5536; }
    .cm-s-base16-light span.cm-atom { color: #aa759f; }
    .cm-s-base16-light span.cm-number { color: #aa759f; }

    .cm-s-base16-light span.cm-property, .cm-s-base16-light span.cm-attribute { color: #90a959; }
    .cm-s-base16-light span.cm-keyword { color: #ac4142; }
    .cm-s-base16-light span.cm-string { color: #f4bf75; }

    .cm-s-base16-light span.cm-variable { color: #90a959; }
    .cm-s-base16-light span.cm-variable-2 { color: #6a9fb5; }
    .cm-s-base16-light span.cm-def { color: #d28445; }
    .cm-s-base16-light span.cm-bracket { color: #202020; }
    .cm-s-base16-light span.cm-tag { color: #ac4142; }
    .cm-s-base16-light span.cm-link { color: #aa759f; }
    .cm-s-base16-light span.cm-error { background: #ac4142; color: #505050; }

    .cm-s-base16-light .CodeMirror-activeline-background { background: #DDDCDC; }
    .cm-s-base16-light .CodeMirror-matchingbracket { color: #f5f5f5 !important; background-color: #6A9FB5 !important}
  uploads-admin-Public-Admin-plugins-codemirror-theme-seti.css: |
    /*

        Name:       seti
        Author:     Michael Kaminsky (http://github.com/mkaminsky11)

        Original seti color scheme by Jesse Weed (https://github.com/jesseweed/seti-syntax)

    */


    .cm-s-seti.CodeMirror {
      background-color: #151718 !important;
      color: #CFD2D1 !important;
      border: none;
    }
    .cm-s-seti .CodeMirror-gutters {
      color: #404b53;
      background-color: #0E1112;
      border: none;
    }
    .cm-s-seti .CodeMirror-cursor { border-left: solid thin #f8f8f0; }
    .cm-s-seti .CodeMirror-linenumber { color: #6D8A88; }
    .cm-s-seti.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }
    .cm-s-seti .CodeMirror-line::selection, .cm-s-seti .CodeMirror-line > span::selection, .cm-s-seti .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }
    .cm-s-seti .CodeMirror-line::-moz-selection, .cm-s-seti .CodeMirror-line > span::-moz-selection, .cm-s-seti .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }
    .cm-s-seti span.cm-comment { color: #41535b; }
    .cm-s-seti span.cm-string, .cm-s-seti span.cm-string-2 { color: #55b5db; }
    .cm-s-seti span.cm-number { color: #cd3f45; }
    .cm-s-seti span.cm-variable { color: #55b5db; }
    .cm-s-seti span.cm-variable-2 { color: #a074c4; }
    .cm-s-seti span.cm-def { color: #55b5db; }
    .cm-s-seti span.cm-keyword { color: #ff79c6; }
    .cm-s-seti span.cm-operator { color: #9fca56; }
    .cm-s-seti span.cm-keyword { color: #e6cd69; }
    .cm-s-seti span.cm-atom { color: #cd3f45; }
    .cm-s-seti span.cm-meta { color: #55b5db; }
    .cm-s-seti span.cm-tag { color: #55b5db; }
    .cm-s-seti span.cm-attribute { color: #9fca56; }
    .cm-s-seti span.cm-qualifier { color: #9fca56; }
    .cm-s-seti span.cm-property { color: #a074c4; }
    .cm-s-seti span.cm-variable-3, .cm-s-seti span.cm-type { color: #9fca56; }
    .cm-s-seti span.cm-builtin { color: #9fca56; }
    .cm-s-seti .CodeMirror-activeline-background { background: #101213; }
    .cm-s-seti .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
  uploads-admin-Public-Admin-plugins-codemirror-theme-yonce.css: |
    /*

        Name:       yoncé
        Author:     Thomas MacLean (http://github.com/thomasmaclean)

        Original yoncé color scheme by Mina Markham (https://github.com/minamarkham)

    */

    .cm-s-yonce.CodeMirror { background: #1C1C1C; color: #d4d4d4; } /**/
    .cm-s-yonce div.CodeMirror-selected { background: rgba(252, 69, 133, 0.478); } /**/
    .cm-s-yonce .CodeMirror-selectedtext,
    .cm-s-yonce .CodeMirror-selected,
    .cm-s-yonce .CodeMirror-line::selection,
    .cm-s-yonce .CodeMirror-line > span::selection,
    .cm-s-yonce .CodeMirror-line > span > span::selection,
    .cm-s-yonce .CodeMirror-line::-moz-selection,
    .cm-s-yonce .CodeMirror-line > span::-moz-selection,
    .cm-s-yonce .CodeMirror-line > span > span::-moz-selection { background: rgba(252, 67, 132, 0.47); }

    .cm-s-yonce.CodeMirror pre { padding-left: 0px; }
    .cm-s-yonce .CodeMirror-gutters {background: #1C1C1C; border-right: 0px;}
    .cm-s-yonce .CodeMirror-linenumber {color: #777777;  padding-right: 10px; }
    .cm-s-yonce .CodeMirror-activeline .CodeMirror-linenumber.CodeMirror-gutter-elt { background: #1C1C1C; color: #fc4384; }
    .cm-s-yonce .CodeMirror-linenumber { color: #777; }
    .cm-s-yonce .CodeMirror-cursor { border-left: 2px solid #FC4384; }
    .cm-s-yonce .cm-searching { background: rgba(243, 155, 53, .3) !important; outline: 1px solid #F39B35; }
    .cm-s-yonce .cm-searching.CodeMirror-selectedtext { background: rgba(243, 155, 53, .7) !important; color: white; }

    .cm-s-yonce .cm-keyword { color: #00A7AA; } /**/
    .cm-s-yonce .cm-atom { color: #F39B35; }
    .cm-s-yonce .cm-number, .cm-s-yonce span.cm-type { color:  #A06FCA; } /**/
    .cm-s-yonce .cm-def { color: #98E342; }
    .cm-s-yonce .cm-property,
    .cm-s-yonce span.cm-variable { color: #D4D4D4; font-style: italic; }
    .cm-s-yonce span.cm-variable-2 { color: #da7dae; font-style: italic; }
    .cm-s-yonce span.cm-variable-3 { color: #A06FCA; }
    .cm-s-yonce .cm-type.cm-def { color: #FC4384; font-style: normal; text-decoration: underline; }
    .cm-s-yonce .cm-property.cm-def { color: #FC4384; font-style: normal; }
    .cm-s-yonce .cm-callee { color: #FC4384; font-style: normal; }
    .cm-s-yonce .cm-operator { color: #FC4384; } /**/
    .cm-s-yonce .cm-qualifier,
    .cm-s-yonce .cm-tag { color: #FC4384; }
    .cm-s-yonce .cm-tag.cm-bracket { color: #D4D4D4; }
    .cm-s-yonce .cm-attribute { color: #A06FCA; }
    .cm-s-yonce .cm-comment { color:#696d70; font-style:italic; font-weight:normal; } /**/
    .cm-s-yonce .cm-comment.cm-tag { color: #FC4384 }
    .cm-s-yonce .cm-comment.cm-attribute { color: #D4D4D4; }
    .cm-s-yonce .cm-string { color:#E6DB74; } /**/
    .cm-s-yonce .cm-string-2 { color:#F39B35; } /*?*/
    .cm-s-yonce .cm-meta { color: #D4D4D4; background: inherit; }
    .cm-s-yonce .cm-builtin { color: #FC4384; } /*?*/
    .cm-s-yonce .cm-header { color: #da7dae; }
    .cm-s-yonce .cm-hr { color: #98E342; }
    .cm-s-yonce .cm-link { color:#696d70; font-style:italic; text-decoration:none; } /**/
    .cm-s-yonce .cm-error { border-bottom: 1px solid #C42412; }

    .cm-s-yonce .CodeMirror-activeline-background { background: #272727; }
    .cm-s-yonce .CodeMirror-matchingbracket { outline:1px solid grey; color:#D4D4D4 !important; }
  uploads-admin-Public-Admin-plugins-codemirror-theme-zenburn.css: |
    /**
     * "
     *  Using Zenburn color palette from the Emacs Zenburn Theme
     *  https://github.com/bbatsov/zenburn-emacs/blob/master/zenburn-theme.el
     *
     *  Also using parts of https://github.com/xavi/coderay-lighttable-theme
     * "
     * From: https://github.com/wisenomad/zenburn-lighttable-theme/blob/master/zenburn.css
     */

    .cm-s-zenburn .CodeMirror-gutters { background: #3f3f3f !important; }
    .cm-s-zenburn .CodeMirror-foldgutter-open, .CodeMirror-foldgutter-folded { color: #999; }
    .cm-s-zenburn .CodeMirror-cursor { border-left: 1px solid white; }
    .cm-s-zenburn.CodeMirror { background-color: #3f3f3f; color: #dcdccc; }
    .cm-s-zenburn span.cm-builtin { color: #dcdccc; font-weight: bold; }
    .cm-s-zenburn span.cm-comment { color: #7f9f7f; }
    .cm-s-zenburn span.cm-keyword { color: #f0dfaf; font-weight: bold; }
    .cm-s-zenburn span.cm-atom { color: #bfebbf; }
    .cm-s-zenburn span.cm-def { color: #dcdccc; }
    .cm-s-zenburn span.cm-variable { color: #dfaf8f; }
    .cm-s-zenburn span.cm-variable-2 { color: #dcdccc; }
    .cm-s-zenburn span.cm-string { color: #cc9393; }
    .cm-s-zenburn span.cm-string-2 { color: #cc9393; }
    .cm-s-zenburn span.cm-number { color: #dcdccc; }
    .cm-s-zenburn span.cm-tag { color: #93e0e3; }
    .cm-s-zenburn span.cm-property { color: #dfaf8f; }
    .cm-s-zenburn span.cm-attribute { color: #dfaf8f; }
    .cm-s-zenburn span.cm-qualifier { color: #7cb8bb; }
    .cm-s-zenburn span.cm-meta { color: #f0dfaf; }
    .cm-s-zenburn span.cm-header { color: #f0efd0; }
    .cm-s-zenburn span.cm-operator { color: #f0efd0; }
    .cm-s-zenburn span.CodeMirror-matchingbracket { box-sizing: border-box; background: transparent; border-bottom: 1px solid; }
    .cm-s-zenburn span.CodeMirror-nonmatchingbracket { border-bottom: 1px solid; background: none; }
    .cm-s-zenburn .CodeMirror-activeline { background: #000000; }
    .cm-s-zenburn .CodeMirror-activeline-background { background: #000000; }
    .cm-s-zenburn div.CodeMirror-selected { background: #545454; }
    .cm-s-zenburn .CodeMirror-focused div.CodeMirror-selected { background: #4f4f4f; }
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: php-code-content-102
