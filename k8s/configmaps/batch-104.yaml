apiVersion: v1
data:
  uploads-admin-Public-Admin-plugins-codemirror-keymap-emacs.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var cmds = CodeMirror.commands;
      var Pos = CodeMirror.Pos;
      function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }

      // Kill 'ring'

      var killRing = [];
      function addToRing(str) {
        killRing.push(str);
        if (killRing.length > 50) killRing.shift();
      }
      function growRingTop(str) {
        if (!killRing.length) return addToRing(str);
        killRing[killRing.length - 1] += str;
      }
      function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || ""; }
      function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }

      var lastKill = null;

      // Internal generic kill function, used by several mapped kill "family" functions.
      function _kill(cm, from, to, ring, text) {
        if (text == null) text = cm.getRange(from, to);

        if (ring == "grow" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))
          growRingTop(text);
        else if (ring !== false)
          addToRing(text);
        cm.replaceRange("", from, to, "+delete");

        if (ring == "grow") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};
        else lastKill = null;
      }

      // Boundaries of various units

      function byChar(cm, pos, dir) {
        return cm.findPosH(pos, dir, "char", true);
      }

      function byWord(cm, pos, dir) {
        return cm.findPosH(pos, dir, "word", true);
      }

      function byLine(cm, pos, dir) {
        return cm.findPosV(pos, dir, "line", cm.doc.sel.goalColumn);
      }

      function byPage(cm, pos, dir) {
        return cm.findPosV(pos, dir, "page", cm.doc.sel.goalColumn);
      }

      function byParagraph(cm, pos, dir) {
        var no = pos.line, line = cm.getLine(no);
        var sawText = /\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));
        var fst = cm.firstLine(), lst = cm.lastLine();
        for (;;) {
          no += dir;
          if (no < fst || no > lst)
            return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));
          line = cm.getLine(no);
          var hasText = /\S/.test(line);
          if (hasText) sawText = true;
          else if (sawText) return Pos(no, 0);
        }
      }

      function bySentence(cm, pos, dir) {
        var line = pos.line, ch = pos.ch;
        var text = cm.getLine(pos.line), sawWord = false;
        for (;;) {
          var next = text.charAt(ch + (dir < 0 ? -1 : 0));
          if (!next) { // End/beginning of line reached
            if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);
            text = cm.getLine(line + dir);
            if (!/\S/.test(text)) return Pos(line, ch);
            line += dir;
            ch = dir < 0 ? text.length : 0;
            continue;
          }
          if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));
          if (!sawWord) sawWord = /\w/.test(next);
          ch += dir;
        }
      }

      function byExpr(cm, pos, dir) {
        var wrap;
        if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))
            && wrap.match && (wrap.forward ? 1 : -1) == dir)
          return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;

        for (var first = true;; first = false) {
          var token = cm.getTokenAt(pos);
          var after = Pos(pos.line, dir < 0 ? token.start : token.end);
          if (first && dir > 0 && token.end == pos.ch || !/\w/.test(token.string)) {
            var newPos = cm.findPosH(after, dir, "char");
            if (posEq(after, newPos)) return pos;
            else pos = newPos;
          } else {
            return after;
          }
        }
      }

      // Prefixes (only crudely supported)

      function getPrefix(cm, precise) {
        var digits = cm.state.emacsPrefix;
        if (!digits) return precise ? null : 1;
        clearPrefix(cm);
        return digits == "-" ? -1 : Number(digits);
      }

      function repeated(cmd) {
        var f = typeof cmd == "string" ? function(cm) { cm.execCommand(cmd); } : cmd;
        return function(cm) {
          var prefix = getPrefix(cm);
          f(cm);
          for (var i = 1; i < prefix; ++i) f(cm);
        };
      }

      function findEnd(cm, pos, by, dir) {
        var prefix = getPrefix(cm);
        if (prefix < 0) { dir = -dir; prefix = -prefix; }
        for (var i = 0; i < prefix; ++i) {
          var newPos = by(cm, pos, dir);
          if (posEq(newPos, pos)) break;
          pos = newPos;
        }
        return pos;
      }

      function move(by, dir) {
        var f = function(cm) {
          cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));
        };
        f.motion = true;
        return f;
      }

      function killTo(cm, by, dir, ring) {
        var selections = cm.listSelections(), cursor;
        var i = selections.length;
        while (i--) {
          cursor = selections[i].head;
          _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);
        }
      }

      function _killRegion(cm, ring) {
        if (cm.somethingSelected()) {
          var selections = cm.listSelections(), selection;
          var i = selections.length;
          while (i--) {
            selection = selections[i];
            _kill(cm, selection.anchor, selection.head, ring);
          }
          return true;
        }
      }

      function addPrefix(cm, digit) {
        if (cm.state.emacsPrefix) {
          if (digit != "-") cm.state.emacsPrefix += digit;
          return;
        }
        // Not active yet
        cm.state.emacsPrefix = digit;
        cm.on("keyHandled", maybeClearPrefix);
        cm.on("inputRead", maybeDuplicateInput);
      }

      var prefixPreservingKeys = {"Alt-G": true, "Ctrl-X": true, "Ctrl-Q": true, "Ctrl-U": true};

      function maybeClearPrefix(cm, arg) {
        if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))
          clearPrefix(cm);
      }

      function clearPrefix(cm) {
        cm.state.emacsPrefix = null;
        cm.off("keyHandled", maybeClearPrefix);
        cm.off("inputRead", maybeDuplicateInput);
      }

      function maybeDuplicateInput(cm, event) {
        var dup = getPrefix(cm);
        if (dup > 1 && event.origin == "+input") {
          var one = event.text.join("\n"), txt = "";
          for (var i = 1; i < dup; ++i) txt += one;
          cm.replaceSelection(txt);
        }
      }

      function maybeRemovePrefixMap(cm, arg) {
        if (typeof arg == "string" && (/^\d$/.test(arg) || arg == "Ctrl-U")) return;
        cm.removeKeyMap(prefixMap);
        cm.state.emacsPrefixMap = false;
        cm.off("keyHandled", maybeRemovePrefixMap);
        cm.off("inputRead", maybeRemovePrefixMap);
      }

      // Utilities

      cmds.setMark = function (cm) {
        cm.setCursor(cm.getCursor());
        cm.setExtending(!cm.getExtending());
        cm.on("change", function() { cm.setExtending(false); });
      }

      function clearMark(cm) {
        cm.setExtending(false);
        cm.setCursor(cm.getCursor());
      }

      function makePrompt(msg) {
        var fragment = document.createDocumentFragment();
        var input = document.createElement("input");
        input.setAttribute("type", "text");
        input.style.width = "10em";
        fragment.appendChild(document.createTextNode(msg + ": "));
        fragment.appendChild(input);
        return fragment;
      }

      function getInput(cm, msg, f) {
        if (cm.openDialog)
          cm.openDialog(makePrompt(msg), f, {bottom: true});
        else
          f(prompt(msg, ""));
      }

      function operateOnWord(cm, op) {
        var start = cm.getCursor(), end = cm.findPosH(start, 1, "word");
        cm.replaceRange(op(cm.getRange(start, end)), start, end);
        cm.setCursor(end);
      }

      function toEnclosingExpr(cm) {
        var pos = cm.getCursor(), line = pos.line, ch = pos.ch;
        var stack = [];
        while (line >= cm.firstLine()) {
          var text = cm.getLine(line);
          for (var i = ch == null ? text.length : ch; i > 0;) {
            var ch = text.charAt(--i);
            if (ch == ")")
              stack.push("(");
            else if (ch == "]")
              stack.push("[");
            else if (ch == "}")
              stack.push("{");
            else if (/[\(\{\[]/.test(ch) && (!stack.length || stack.pop() != ch))
              return cm.extendSelection(Pos(line, i));
          }
          --line; ch = null;
        }
      }

      // Commands. Names should match emacs function names (albeit in camelCase)
      // except where emacs function names collide with code mirror core commands.

      cmds.killRegion = function(cm) {
        _kill(cm, cm.getCursor("start"), cm.getCursor("end"), true);
      };

      // Maps to emacs kill-line
      cmds.killLineEmacs = repeated(function(cm) {
        var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));
        var text = cm.getRange(start, end);
        if (!/\S/.test(text)) {
          text += "\n";
          end = Pos(start.line + 1, 0);
        }
        _kill(cm, start, end, "grow", text);
      });

      cmds.killRingSave = function(cm) {
        addToRing(cm.getSelection());
        clearMark(cm);
      };

      cmds.yank = function(cm) {
        var start = cm.getCursor();
        cm.replaceRange(getFromRing(getPrefix(cm)), start, start, "paste");
        cm.setSelection(start, cm.getCursor());
      };

      cmds.yankPop = function(cm) {
        cm.replaceSelection(popFromRing(), "around", "paste");
      };

      cmds.forwardChar = move(byChar, 1);

      cmds.backwardChar = move(byChar, -1)

      cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };

      cmds.deleteForwardChar = function(cm) {
        _killRegion(cm, false) || killTo(cm, byChar, 1, false);
      };

      cmds.deleteBackwardChar = function(cm) {
        _killRegion(cm, false) || killTo(cm, byChar, -1, false);
      };

      cmds.forwardWord = move(byWord, 1);

      cmds.backwardWord = move(byWord, -1);

      cmds.killWord = function(cm) { killTo(cm, byWord, 1, "grow"); };

      cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, "grow"); };

      cmds.nextLine = move(byLine, 1);

      cmds.previousLine = move(byLine, -1);

      cmds.scrollDownCommand = move(byPage, -1);

      cmds.scrollUpCommand = move(byPage, 1);

      cmds.backwardParagraph = move(byParagraph, -1);

      cmds.forwardParagraph = move(byParagraph, 1);

      cmds.backwardSentence = move(bySentence, -1);

      cmds.forwardSentence = move(bySentence, 1);

      cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, "grow"); };

      cmds.backwardKillSentence = function(cm) {
        _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), "grow");
      };

      cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, "grow"); };

      cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, "grow"); };

      cmds.forwardSexp = move(byExpr, 1);

      cmds.backwardSexp = move(byExpr, -1);

      cmds.markSexp = function(cm) {
        var cursor = cm.getCursor();
        cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);
      };

      cmds.transposeSexps = function(cm) {
        var leftStart = byExpr(cm, cm.getCursor(), -1);
        var leftEnd = byExpr(cm, leftStart, 1);
        var rightEnd = byExpr(cm, leftEnd, 1);
        var rightStart = byExpr(cm, rightEnd, -1);
        cm.replaceRange(cm.getRange(rightStart, rightEnd) +
                        cm.getRange(leftEnd, rightStart) +
                        cm.getRange(leftStart, leftEnd), leftStart, rightEnd);
      };

      cmds.backwardUpList = repeated(toEnclosingExpr);

      cmds.justOneSpace = function(cm) {
        var pos = cm.getCursor(), from = pos.ch;
        var to = pos.ch, text = cm.getLine(pos.line);
        while (from && /\s/.test(text.charAt(from - 1))) --from;
        while (to < text.length && /\s/.test(text.charAt(to))) ++to;
        cm.replaceRange(" ", Pos(pos.line, from), Pos(pos.line, to));
      };

      cmds.openLine = repeated(function(cm) {
        cm.replaceSelection("\n", "start");
      });

      // maps to emacs 'transpose-chars'
      cmds.transposeCharsRepeatable = repeated(function(cm) {
        cm.execCommand("transposeChars");
      });

      cmds.capitalizeWord = repeated(function(cm) {
        operateOnWord(cm, function(w) {
          var letter = w.search(/\w/);
          if (letter == -1) return w;
          return w.slice(0, letter) + w.charAt(letter).toUpperCase() +
              w.slice(letter + 1).toLowerCase();
        });
      });

      cmds.upcaseWord = repeated(function(cm) {
        operateOnWord(cm, function(w) { return w.toUpperCase(); });
      });

      cmds.downcaseWord = repeated(function(cm) {
        operateOnWord(cm, function(w) { return w.toLowerCase(); });
      });

      // maps to emacs 'undo'
      cmds.undoRepeatable = repeated("undo");

      cmds.keyboardQuit = function(cm) {
        cm.execCommand("clearSearch");
        clearMark(cm);
      }

      cmds.newline = repeated(function(cm) { cm.replaceSelection("\n", "end"); });

      cmds.gotoLine = function(cm) {
        var prefix = getPrefix(cm, true);
        if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);

        getInput(cm, "Goto line", function(str) {
          var num;
          if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)
          cm.setCursor(num - 1);
        });
      };

      cmds.indentRigidly = function(cm) {
        cm.indentSelection(getPrefix(cm, true) || cm.getOption("indentUnit"));
      };

      cmds.exchangePointAndMark = function(cm) {
        cm.setSelection(cm.getCursor("head"), cm.getCursor("anchor"));
      };

      cmds.quotedInsertTab = repeated("insertTab");

      cmds.universalArgument = function addPrefixMap(cm) {
        cm.state.emacsPrefixMap = true;
        cm.addKeyMap(prefixMap);
        cm.on("keyHandled", maybeRemovePrefixMap);
        cm.on("inputRead", maybeRemovePrefixMap);
      };

      CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};

      // Actual keymap
      var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({
        "Ctrl-W": "killRegion",
        "Ctrl-K": "killLineEmacs",
        "Alt-W": "killRingSave",
        "Ctrl-Y": "yank",
        "Alt-Y": "yankPop",
        "Ctrl-Space": "setMark",
        "Ctrl-Shift-2": "setMark",
        "Ctrl-F": "forwardChar",
        "Ctrl-B": "backwardChar",
        "Right": "forwardChar",
        "Left": "backwardChar",
        "Ctrl-D": "deleteChar",
        "Delete": "deleteForwardChar",
        "Ctrl-H": "deleteBackwardChar",
        "Backspace": "deleteBackwardChar",
        "Alt-F": "forwardWord",
        "Alt-B": "backwardWord",
        "Alt-Right": "forwardWord",
        "Alt-Left": "backwardWord",
        "Alt-D": "killWord",
        "Alt-Backspace": "backwardKillWord",
        "Ctrl-N": "nextLine",
        "Ctrl-P": "previousLine",
        "Down": "nextLine",
        "Up": "previousLine",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "End": "goLineEnd",
        "Home": "goLineStart",
        "Alt-V": "scrollDownCommand",
        "Ctrl-V": "scrollUpCommand",
        "PageUp": "scrollDownCommand",
        "PageDown": "scrollUpCommand",
        "Ctrl-Up": "backwardParagraph",
        "Ctrl-Down": "forwardParagraph",
        "Alt-{": "backwardParagraph",
        "Alt-}": "forwardParagraph",
        "Alt-A": "backwardSentence",
        "Alt-E": "forwardSentence",
        "Alt-K": "killSentence",
        "Ctrl-X Delete": "backwardKillSentence",
        "Ctrl-Alt-K": "killSexp",
        "Ctrl-Alt-Backspace": "backwardKillSexp",
        "Ctrl-Alt-F": "forwardSexp",
        "Ctrl-Alt-B": "backwardSexp",
        "Shift-Ctrl-Alt-2": "markSexp",
        "Ctrl-Alt-T": "transposeSexps",
        "Ctrl-Alt-U": "backwardUpList",
        "Alt-Space": "justOneSpace",
        "Ctrl-O": "openLine",
        "Ctrl-T": "transposeCharsRepeatable",
        "Alt-C": "capitalizeWord",
        "Alt-U": "upcaseWord",
        "Alt-L": "downcaseWord",
        "Alt-;": "toggleComment",
        "Ctrl-/": "undoRepeatable",
        "Shift-Ctrl--": "undoRepeatable",
        "Ctrl-Z": "undoRepeatable",
        "Cmd-Z": "undoRepeatable",
        "Ctrl-X U": "undoRepeatable",
        "Shift-Ctrl-Z": "redo",
        "Shift-Alt-,": "goDocStart",
        "Shift-Alt-.": "goDocEnd",
        "Ctrl-S": "findPersistentNext",
        "Ctrl-R": "findPersistentPrev",
        "Ctrl-G": "keyboardQuit",
        "Shift-Alt-5": "replace",
        "Alt-/": "autocomplete",
        "Enter": "newlineAndIndent",
        "Ctrl-J": "newline",
        "Tab": "indentAuto",
        "Alt-G G": "gotoLine",
        "Ctrl-X Tab": "indentRigidly",
        "Ctrl-X Ctrl-X": "exchangePointAndMark",
        "Ctrl-X Ctrl-S": "save",
        "Ctrl-X Ctrl-W": "save",
        "Ctrl-X S": "saveAll",
        "Ctrl-X F": "open",
        "Ctrl-X K": "close",
        "Ctrl-X H": "selectAll",
        "Ctrl-Q Tab": "quotedInsertTab",
        "Ctrl-U": "universalArgument",
        "fallthrough": "default"
      });

      var prefixMap = {"Ctrl-G": clearPrefix};
      function regPrefix(d) {
        prefixMap[d] = function(cm) { addPrefix(cm, d); };
        keyMap["Ctrl-" + d] = function(cm) { addPrefix(cm, d); };
        prefixPreservingKeys["Ctrl-" + d] = true;
      }
      for (var i = 0; i < 10; ++i) regPrefix(String(i));
      regPrefix("-");
    });
  uploads-admin-Public-Admin-plugins-codemirror-keymap-sublime.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // A rough approximation of Sublime Text's keybindings
    // Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../lib/codemirror"), require("../addon/search/searchcursor"), require("../addon/edit/matchbrackets"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var cmds = CodeMirror.commands;
      var Pos = CodeMirror.Pos;

      // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.
      function findPosSubword(doc, start, dir) {
        if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));
        var line = doc.getLine(start.line);
        if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));
        var state = "start", type, startPos = start.ch;
        for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
          var next = line.charAt(dir < 0 ? pos - 1 : pos);
          var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";
          if (cat == "w" && next.toUpperCase() == next) cat = "W";
          if (state == "start") {
            if (cat != "o") { state = "in"; type = cat; }
            else startPos = pos + dir
          } else if (state == "in") {
            if (type != cat) {
              if (type == "w" && cat == "W" && dir < 0) pos--;
              if (type == "W" && cat == "w" && dir > 0) { // From uppercase to lowercase
                if (pos == startPos + 1) { type = "w"; continue; }
                else pos--;
              }
              break;
            }
          }
        }
        return Pos(start.line, pos);
      }

      function moveSubword(cm, dir) {
        cm.extendSelectionsBy(function(range) {
          if (cm.display.shift || cm.doc.extend || range.empty())
            return findPosSubword(cm.doc, range.head, dir);
          else
            return dir < 0 ? range.from() : range.to();
        });
      }

      cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };
      cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };

      cmds.scrollLineUp = function(cm) {
        var info = cm.getScrollInfo();
        if (!cm.somethingSelected()) {
          var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
          if (cm.getCursor().line >= visibleBottomLine)
            cm.execCommand("goLineUp");
        }
        cm.scrollTo(null, info.top - cm.defaultTextHeight());
      };
      cmds.scrollLineDown = function(cm) {
        var info = cm.getScrollInfo();
        if (!cm.somethingSelected()) {
          var visibleTopLine = cm.lineAtHeight(info.top, "local")+1;
          if (cm.getCursor().line <= visibleTopLine)
            cm.execCommand("goLineDown");
        }
        cm.scrollTo(null, info.top + cm.defaultTextHeight());
      };

      cmds.splitSelectionByLine = function(cm) {
        var ranges = cm.listSelections(), lineRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var from = ranges[i].from(), to = ranges[i].to();
          for (var line = from.line; line <= to.line; ++line)
            if (!(to.line > from.line && line == to.line && to.ch == 0))
              lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),
                               head: line == to.line ? to : Pos(line)});
        }
        cm.setSelections(lineRanges, 0);
      };

      cmds.singleSelectionTop = function(cm) {
        var range = cm.listSelections()[0];
        cm.setSelection(range.anchor, range.head, {scroll: false});
      };

      cmds.selectLine = function(cm) {
        var ranges = cm.listSelections(), extended = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          extended.push({anchor: Pos(range.from().line, 0),
                         head: Pos(range.to().line + 1, 0)});
        }
        cm.setSelections(extended);
      };

      function insertLine(cm, above) {
        if (cm.isReadOnly()) return CodeMirror.Pass
        cm.operation(function() {
          var len = cm.listSelections().length, newSelection = [], last = -1;
          for (var i = 0; i < len; i++) {
            var head = cm.listSelections()[i].head;
            if (head.line <= last) continue;
            var at = Pos(head.line + (above ? 0 : 1), 0);
            cm.replaceRange("\n", at, null, "+insertLine");
            cm.indentLine(at.line, null, true);
            newSelection.push({head: at, anchor: at});
            last = head.line + 1;
          }
          cm.setSelections(newSelection);
        });
        cm.execCommand("indentAuto");
      }

      cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };

      cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };

      function wordAt(cm, pos) {
        var start = pos.ch, end = start, line = cm.getLine(pos.line);
        while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;
        while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;
        return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};
      }

      cmds.selectNextOccurrence = function(cm) {
        var from = cm.getCursor("from"), to = cm.getCursor("to");
        var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
        if (CodeMirror.cmpPos(from, to) == 0) {
          var word = wordAt(cm, from);
          if (!word.word) return;
          cm.setSelection(word.from, word.to);
          fullWord = true;
        } else {
          var text = cm.getRange(from, to);
          var query = fullWord ? new RegExp("\\b" + text + "\\b") : text;
          var cur = cm.getSearchCursor(query, to);
          var found = cur.findNext();
          if (!found) {
            cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
            found = cur.findNext();
          }
          if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return
          cm.addSelection(cur.from(), cur.to());
        }
        if (fullWord)
          cm.state.sublimeFindFullWord = cm.doc.sel;
      };

      cmds.skipAndSelectNextOccurrence = function(cm) {
        var prevAnchor = cm.getCursor("anchor"), prevHead = cm.getCursor("head");
        cmds.selectNextOccurrence(cm);
        if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {
          cm.doc.setSelections(cm.doc.listSelections()
              .filter(function (sel) {
                return sel.anchor != prevAnchor || sel.head != prevHead;
              }));
        }
      }

      function addCursorToSelection(cm, dir) {
        var ranges = cm.listSelections(), newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          var newAnchor = cm.findPosV(
              range.anchor, dir, "line", range.anchor.goalColumn);
          var newHead = cm.findPosV(
              range.head, dir, "line", range.head.goalColumn);
          newAnchor.goalColumn = range.anchor.goalColumn != null ?
              range.anchor.goalColumn : cm.cursorCoords(range.anchor, "div").left;
          newHead.goalColumn = range.head.goalColumn != null ?
              range.head.goalColumn : cm.cursorCoords(range.head, "div").left;
          var newRange = {anchor: newAnchor, head: newHead};
          newRanges.push(range);
          newRanges.push(newRange);
        }
        cm.setSelections(newRanges);
      }
      cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };
      cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };

      function isSelectedRange(ranges, from, to) {
        for (var i = 0; i < ranges.length; i++)
          if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 &&
              CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true
        return false
      }

      var mirror = "(){}[]";
      function selectBetweenBrackets(cm) {
        var ranges = cm.listSelections(), newRanges = []
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);
          if (!opening) return false;
          for (;;) {
            var closing = cm.scanForBracket(pos, 1);
            if (!closing) return false;
            if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
              var startPos = Pos(opening.pos.line, opening.pos.ch + 1);
              if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&
                  CodeMirror.cmpPos(closing.pos, range.to()) == 0) {
                opening = cm.scanForBracket(opening.pos, -1);
                if (!opening) return false;
              } else {
                newRanges.push({anchor: startPos, head: closing.pos});
                break;
              }
            }
            pos = Pos(closing.pos.line, closing.pos.ch + 1);
          }
        }
        cm.setSelections(newRanges);
        return true;
      }

      cmds.selectScope = function(cm) {
        selectBetweenBrackets(cm) || cm.execCommand("selectAll");
      };
      cmds.selectBetweenBrackets = function(cm) {
        if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
      };

      function puncType(type) {
        return !type ? null : /\bpunctuation\b/.test(type) ? type : undefined
      }

      cmds.goToBracket = function(cm) {
        cm.extendSelectionsBy(function(range) {
          var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));
          if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
          var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));
          return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
        });
      };

      cmds.swapLineUp = function(cm) {
        if (cm.isReadOnly()) return CodeMirror.Pass
        var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], from = range.from().line - 1, to = range.to().line;
          newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),
                        head: Pos(range.head.line - 1, range.head.ch)});
          if (range.to().ch == 0 && !range.empty()) --to;
          if (from > at) linesToMove.push(from, to);
          else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
          at = to;
        }
        cm.operation(function() {
          for (var i = 0; i < linesToMove.length; i += 2) {
            var from = linesToMove[i], to = linesToMove[i + 1];
            var line = cm.getLine(from);
            cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
            if (to > cm.lastLine())
              cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");
            else
              cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
          }
          cm.setSelections(newSels);
          cm.scrollIntoView();
        });
      };

      cmds.swapLineDown = function(cm) {
        if (cm.isReadOnly()) return CodeMirror.Pass
        var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;
        for (var i = ranges.length - 1; i >= 0; i--) {
          var range = ranges[i], from = range.to().line + 1, to = range.from().line;
          if (range.to().ch == 0 && !range.empty()) from--;
          if (from < at) linesToMove.push(from, to);
          else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
          at = to;
        }
        cm.operation(function() {
          for (var i = linesToMove.length - 2; i >= 0; i -= 2) {
            var from = linesToMove[i], to = linesToMove[i + 1];
            var line = cm.getLine(from);
            if (from == cm.lastLine())
              cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");
            else
              cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
            cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
          }
          cm.scrollIntoView();
        });
      };

      cmds.toggleCommentIndented = function(cm) {
        cm.toggleComment({ indent: true });
      }

      cmds.joinLines = function(cm) {
        var ranges = cm.listSelections(), joined = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], from = range.from();
          var start = from.line, end = range.to().line;
          while (i < ranges.length - 1 && ranges[i + 1].from().line == end)
            end = ranges[++i].to().line;
          joined.push({start: start, end: end, anchor: !range.empty() && from});
        }
        cm.operation(function() {
          var offset = 0, ranges = [];
          for (var i = 0; i < joined.length; i++) {
            var obj = joined[i];
            var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;
            for (var line = obj.start; line <= obj.end; line++) {
              var actual = line - offset;
              if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);
              if (actual < cm.lastLine()) {
                cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
                ++offset;
              }
            }
            ranges.push({anchor: anchor || head, head: head});
          }
          cm.setSelections(ranges, 0);
        });
      };

      cmds.duplicateLine = function(cm) {
        cm.operation(function() {
          var rangeCount = cm.listSelections().length;
          for (var i = 0; i < rangeCount; i++) {
            var range = cm.listSelections()[i];
            if (range.empty())
              cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));
            else
              cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
          }
          cm.scrollIntoView();
        });
      };


      function sortLines(cm, caseSensitive, direction) {
        if (cm.isReadOnly()) return CodeMirror.Pass
        var ranges = cm.listSelections(), toSort = [], selected;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (range.empty()) continue;
          var from = range.from().line, to = range.to().line;
          while (i < ranges.length - 1 && ranges[i + 1].from().line == to)
            to = ranges[++i].to().line;
          if (!ranges[i].to().ch) to--;
          toSort.push(from, to);
        }
        if (toSort.length) selected = true;
        else toSort.push(cm.firstLine(), cm.lastLine());

        cm.operation(function() {
          var ranges = [];
          for (var i = 0; i < toSort.length; i += 2) {
            var from = toSort[i], to = toSort[i + 1];
            var start = Pos(from, 0), end = Pos(to);
            var lines = cm.getRange(start, end, false);
            if (caseSensitive)
              lines.sort(function(a, b) { return a < b ? -direction : a == b ? 0 : direction; });
            else
              lines.sort(function(a, b) {
                var au = a.toUpperCase(), bu = b.toUpperCase();
                if (au != bu) { a = au; b = bu; }
                return a < b ? -direction : a == b ? 0 : direction;
              });
            cm.replaceRange(lines, start, end);
            if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});
          }
          if (selected) cm.setSelections(ranges, 0);
        });
      }

      cmds.sortLines = function(cm) { sortLines(cm, true, 1); };
      cmds.reverseSortLines = function(cm) { sortLines(cm, true, -1); };
      cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false, 1); };
      cmds.reverseSortLinesInsensitive = function(cm) { sortLines(cm, false, -1); };

      cmds.nextBookmark = function(cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks) while (marks.length) {
          var current = marks.shift();
          var found = current.find();
          if (found) {
            marks.push(current);
            return cm.setSelection(found.from, found.to);
          }
        }
      };

      cmds.prevBookmark = function(cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks) while (marks.length) {
          marks.unshift(marks.pop());
          var found = marks[marks.length - 1].find();
          if (!found)
            marks.pop();
          else
            return cm.setSelection(found.from, found.to);
        }
      };

      cmds.toggleBookmark = function(cm) {
        var ranges = cm.listSelections();
        var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
        for (var i = 0; i < ranges.length; i++) {
          var from = ranges[i].from(), to = ranges[i].to();
          var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);
          for (var j = 0; j < found.length; j++) {
            if (found[j].sublimeBookmark) {
              found[j].clear();
              for (var k = 0; k < marks.length; k++)
                if (marks[k] == found[j])
                  marks.splice(k--, 1);
              break;
            }
          }
          if (j == found.length)
            marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));
        }
      };

      cmds.clearBookmarks = function(cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
        marks.length = 0;
      };

      cmds.selectBookmarks = function(cm) {
        var marks = cm.state.sublimeBookmarks, ranges = [];
        if (marks) for (var i = 0; i < marks.length; i++) {
          var found = marks[i].find();
          if (!found)
            marks.splice(i--, 0);
          else
            ranges.push({anchor: found.from, head: found.to});
        }
        if (ranges.length)
          cm.setSelections(ranges, 0);
      };

      function modifyWordOrSelection(cm, mod) {
        cm.operation(function() {
          var ranges = cm.listSelections(), indices = [], replacements = [];
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (range.empty()) { indices.push(i); replacements.push(""); }
            else replacements.push(mod(cm.getRange(range.from(), range.to())));
          }
          cm.replaceSelections(replacements, "around", "case");
          for (var i = indices.length - 1, at; i >= 0; i--) {
            var range = ranges[indices[i]];
            if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;
            var word = wordAt(cm, range.head);
            at = word.from;
            cm.replaceRange(mod(word.word), word.from, word.to);
          }
        });
      }

      cmds.smartBackspace = function(cm) {
        if (cm.somethingSelected()) return CodeMirror.Pass;

        cm.operation(function() {
          var cursors = cm.listSelections();
          var indentUnit = cm.getOption("indentUnit");

          for (var i = cursors.length - 1; i >= 0; i--) {
            var cursor = cursors[i].head;
            var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);
            var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption("tabSize"));

            // Delete by one character by default
            var deletePos = cm.findPosH(cursor, -1, "char", false);

            if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
              var prevIndent = new Pos(cursor.line,
                CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));

              // Smart delete only if we found a valid prevIndent location
              if (prevIndent.ch != cursor.ch) deletePos = prevIndent;
            }

            cm.replaceRange("", deletePos, cursor, "+delete");
          }
        });
      };

      cmds.delLineRight = function(cm) {
        cm.operation(function() {
          var ranges = cm.listSelections();
          for (var i = ranges.length - 1; i >= 0; i--)
            cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
          cm.scrollIntoView();
        });
      };

      cmds.upcaseAtCursor = function(cm) {
        modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });
      };
      cmds.downcaseAtCursor = function(cm) {
        modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });
      };

      cmds.setSublimeMark = function(cm) {
        if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
        cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      };
      cmds.selectToSublimeMark = function(cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found) cm.setSelection(cm.getCursor(), found);
      };
      cmds.deleteToSublimeMark = function(cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found) {
          var from = cm.getCursor(), to = found;
          if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }
          cm.state.sublimeKilled = cm.getRange(from, to);
          cm.replaceRange("", from, to);
        }
      };
      cmds.swapWithSublimeMark = function(cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found) {
          cm.state.sublimeMark.clear();
          cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
          cm.setCursor(found);
        }
      };
      cmds.sublimeYank = function(cm) {
        if (cm.state.sublimeKilled != null)
          cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
      };

      cmds.showInCenter = function(cm) {
        var pos = cm.cursorCoords(null, "local");
        cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
      };

      function getTarget(cm) {
        var from = cm.getCursor("from"), to = cm.getCursor("to");
        if (CodeMirror.cmpPos(from, to) == 0) {
          var word = wordAt(cm, from);
          if (!word.word) return;
          from = word.from;
          to = word.to;
        }
        return {from: from, to: to, query: cm.getRange(from, to), word: word};
      }

      function findAndGoTo(cm, forward) {
        var target = getTarget(cm);
        if (!target) return;
        var query = target.query;
        var cur = cm.getSearchCursor(query, forward ? target.to : target.from);

        if (forward ? cur.findNext() : cur.findPrevious()) {
          cm.setSelection(cur.from(), cur.to());
        } else {
          cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)
                                                  : cm.clipPos(Pos(cm.lastLine())));
          if (forward ? cur.findNext() : cur.findPrevious())
            cm.setSelection(cur.from(), cur.to());
          else if (target.word)
            cm.setSelection(target.from, target.to);
        }
      };
      cmds.findUnder = function(cm) { findAndGoTo(cm, true); };
      cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };
      cmds.findAllUnder = function(cm) {
        var target = getTarget(cm);
        if (!target) return;
        var cur = cm.getSearchCursor(target.query);
        var matches = [];
        var primaryIndex = -1;
        while (cur.findNext()) {
          matches.push({anchor: cur.from(), head: cur.to()});
          if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)
            primaryIndex++;
        }
        cm.setSelections(matches, primaryIndex);
      };


      var keyMap = CodeMirror.keyMap;
      keyMap.macSublime = {
        "Cmd-Left": "goLineStartSmart",
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-Left": "goSubwordLeft",
        "Ctrl-Right": "goSubwordRight",
        "Ctrl-Alt-Up": "scrollLineUp",
        "Ctrl-Alt-Down": "scrollLineDown",
        "Cmd-L": "selectLine",
        "Shift-Cmd-L": "splitSelectionByLine",
        "Esc": "singleSelectionTop",
        "Cmd-Enter": "insertLineAfter",
        "Shift-Cmd-Enter": "insertLineBefore",
        "Cmd-D": "selectNextOccurrence",
        "Shift-Cmd-Space": "selectScope",
        "Shift-Cmd-M": "selectBetweenBrackets",
        "Cmd-M": "goToBracket",
        "Cmd-Ctrl-Up": "swapLineUp",
        "Cmd-Ctrl-Down": "swapLineDown",
        "Cmd-/": "toggleCommentIndented",
        "Cmd-J": "joinLines",
        "Shift-Cmd-D": "duplicateLine",
        "F5": "sortLines",
        "Shift-F5": "reverseSortLines",
        "Cmd-F5": "sortLinesInsensitive",
        "Shift-Cmd-F5": "reverseSortLinesInsensitive",
        "F2": "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Cmd-F2": "toggleBookmark",
        "Shift-Cmd-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        "Backspace": "smartBackspace",
        "Cmd-K Cmd-D": "skipAndSelectNextOccurrence",
        "Cmd-K Cmd-K": "delLineRight",
        "Cmd-K Cmd-U": "upcaseAtCursor",
        "Cmd-K Cmd-L": "downcaseAtCursor",
        "Cmd-K Cmd-Space": "setSublimeMark",
        "Cmd-K Cmd-A": "selectToSublimeMark",
        "Cmd-K Cmd-W": "deleteToSublimeMark",
        "Cmd-K Cmd-X": "swapWithSublimeMark",
        "Cmd-K Cmd-Y": "sublimeYank",
        "Cmd-K Cmd-C": "showInCenter",
        "Cmd-K Cmd-G": "clearBookmarks",
        "Cmd-K Cmd-Backspace": "delLineLeft",
        "Cmd-K Cmd-1": "foldAll",
        "Cmd-K Cmd-0": "unfoldAll",
        "Cmd-K Cmd-J": "unfoldAll",
        "Ctrl-Shift-Up": "addCursorToPrevLine",
        "Ctrl-Shift-Down": "addCursorToNextLine",
        "Cmd-F3": "findUnder",
        "Shift-Cmd-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Cmd-[": "fold",
        "Shift-Cmd-]": "unfold",
        "Cmd-I": "findIncremental",
        "Shift-Cmd-I": "findIncrementalReverse",
        "Cmd-H": "replace",
        "F3": "findNext",
        "Shift-F3": "findPrev",
        "fallthrough": "macDefault"
      };
      CodeMirror.normalizeKeyMap(keyMap.macSublime);

      keyMap.pcSublime = {
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-T": "transposeChars",
        "Alt-Left": "goSubwordLeft",
        "Alt-Right": "goSubwordRight",
        "Ctrl-Up": "scrollLineUp",
        "Ctrl-Down": "scrollLineDown",
        "Ctrl-L": "selectLine",
        "Shift-Ctrl-L": "splitSelectionByLine",
        "Esc": "singleSelectionTop",
        "Ctrl-Enter": "insertLineAfter",
        "Shift-Ctrl-Enter": "insertLineBefore",
        "Ctrl-D": "selectNextOccurrence",
        "Shift-Ctrl-Space": "selectScope",
        "Shift-Ctrl-M": "selectBetweenBrackets",
        "Ctrl-M": "goToBracket",
        "Shift-Ctrl-Up": "swapLineUp",
        "Shift-Ctrl-Down": "swapLineDown",
        "Ctrl-/": "toggleCommentIndented",
        "Ctrl-J": "joinLines",
        "Shift-Ctrl-D": "duplicateLine",
        "F9": "sortLines",
        "Shift-F9": "reverseSortLines",
        "Ctrl-F9": "sortLinesInsensitive",
        "Shift-Ctrl-F9": "reverseSortLinesInsensitive",
        "F2": "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Ctrl-F2": "toggleBookmark",
        "Shift-Ctrl-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        "Backspace": "smartBackspace",
        "Ctrl-K Ctrl-D": "skipAndSelectNextOccurrence",
        "Ctrl-K Ctrl-K": "delLineRight",
        "Ctrl-K Ctrl-U": "upcaseAtCursor",
        "Ctrl-K Ctrl-L": "downcaseAtCursor",
        "Ctrl-K Ctrl-Space": "setSublimeMark",
        "Ctrl-K Ctrl-A": "selectToSublimeMark",
        "Ctrl-K Ctrl-W": "deleteToSublimeMark",
        "Ctrl-K Ctrl-X": "swapWithSublimeMark",
        "Ctrl-K Ctrl-Y": "sublimeYank",
        "Ctrl-K Ctrl-C": "showInCenter",
        "Ctrl-K Ctrl-G": "clearBookmarks",
        "Ctrl-K Ctrl-Backspace": "delLineLeft",
        "Ctrl-K Ctrl-1": "foldAll",
        "Ctrl-K Ctrl-0": "unfoldAll",
        "Ctrl-K Ctrl-J": "unfoldAll",
        "Ctrl-Alt-Up": "addCursorToPrevLine",
        "Ctrl-Alt-Down": "addCursorToNextLine",
        "Ctrl-F3": "findUnder",
        "Shift-Ctrl-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Ctrl-[": "fold",
        "Shift-Ctrl-]": "unfold",
        "Ctrl-I": "findIncremental",
        "Shift-Ctrl-I": "findIncrementalReverse",
        "Ctrl-H": "replace",
        "F3": "findNext",
        "Shift-F3": "findPrev",
        "fallthrough": "pcDefault"
      };
      CodeMirror.normalizeKeyMap(keyMap.pcSublime);

      var mac = keyMap.default == keyMap.macDefault;
      keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;
    });
  uploads-admin-Public-Admin-plugins-codemirror-keymap-vim.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Supported keybindings:
     *   Too many to list. Refer to defaultKeymap below.
     *
     * Supported Ex commands:
     *   Refer to defaultExCommandMap below.
     *
     * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9
     *   (Does not respect the special case for number registers when delete
     *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )
     *   TODO: Implement the remaining registers.
     *
     * Marks: a-z, A-Z, and 0-9
     *   TODO: Implement the remaining special marks. They have more complex
     *       behavior.
     *
     * Events:
     *  'vim-mode-change' - raised on the editor anytime the current mode changes,
     *                      Event object: {mode: "visual", subMode: "linewise"}
     *
     * Code structure:
     *  1. Default keymap
     *  2. Variable declarations and short basic helpers
     *  3. Instance (External API) implementation
     *  4. Internal state tracking objects (input state, counter) implementation
     *     and instantiation
     *  5. Key handler (the main command dispatcher) implementation
     *  6. Motion, operator, and action implementations
     *  7. Helper functions for the key handler, motions, operators, and actions
     *  8. Set up Vim to work as a keymap for CodeMirror.
     *  9. Ex command implementations.
     */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../lib/codemirror"), require("../addon/search/searchcursor"), require("../addon/dialog/dialog"), require("../addon/edit/matchbrackets.js"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/dialog/dialog", "../addon/edit/matchbrackets"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      'use strict';

      var defaultKeymap = [
        // Key to key mapping. This goes first to make it possible to override
        // existing mappings.
        { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },
        { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },
        { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },
        { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },
        { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },
        { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},
        { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},
        { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },
        { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },
        { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },
        { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },
        { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },
        { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },
        { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },
        { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },
        { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },
        { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },
        { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },
        { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},
        { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },
        { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },
        { keys: '<Home>', type: 'keyToKey', toKeys: '0' },
        { keys: '<End>', type: 'keyToKey', toKeys: '$' },
        { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },
        { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },
        { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },
        { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },
        // Motions
        { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},
        { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},
        { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},
        { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},
        { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},
        { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},
        { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},
        { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},
        { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},
        { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},
        { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},
        { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},
        { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},
        { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},
        { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},
        { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},
        { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},
        { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},
        { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},
        { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},
        { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},
        { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},
        { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},
        { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},
        { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},
        { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},
        { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},
        { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },
        { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },
        { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},
        { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},
        { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},
        { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},
        { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},
        { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},
        { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},
        { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},
        { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},
        { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},
        { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},
        { keys: '\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},
        { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},
        { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },
        { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },
        { keys: ']\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },
        { keys: '[\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },
        // the next two aren't motions but must come before more general motion declarations
        { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},
        { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},
        { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},
        { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},
        { keys: '|', type: 'motion', motion: 'moveToColumn'},
        { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},
        { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},
        // Operators
        { keys: 'd', type: 'operator', operator: 'delete' },
        { keys: 'y', type: 'operator', operator: 'yank' },
        { keys: 'c', type: 'operator', operator: 'change' },
        { keys: '=', type: 'operator', operator: 'indentAuto' },
        { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},
        { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},
        { keys: 'g~', type: 'operator', operator: 'changeCase' },
        { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },
        { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },
        { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},
        { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},
        { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},
        { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},
        // Operator-Motion dual commands
        { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},
        { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},
        { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},
        { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},
        { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},
        { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},
        { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},
        { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},
        { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},
        { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},
        { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },
        //ignore C-w in normal mode
        { keys: '<C-w>', type: 'idle', context: 'normal' },
        // Actions
        { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},
        { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},
        { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},
        { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},
        { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },
        { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },
        { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },
        { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },
        { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },
        { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },
        { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },
        { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },
        { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },
        { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },
        { keys: 'v', type: 'action', action: 'toggleVisualMode' },
        { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},
        { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},
        { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},
        { keys: 'gv', type: 'action', action: 'reselectLastSelection' },
        { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },
        { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },
        { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},
        { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},
        { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },
        { keys: '@<character>', type: 'action', action: 'replayMacro' },
        { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },
        // Handle Replace-mode as a special case of insert mode.
        { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},
        { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},
        { keys: 'u', type: 'action', action: 'undo', context: 'normal' },
        { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },
        { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },
        { keys: '<C-r>', type: 'action', action: 'redo' },
        { keys: 'm<character>', type: 'action', action: 'setMark' },
        { keys: '"<character>', type: 'action', action: 'setRegister' },
        { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},
        { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
        { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},
        { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
        { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},
        { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
        { keys: '.', type: 'action', action: 'repeatLastEdit' },
        { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},
        { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},
        { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },
        { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },
        // Text object motions
        { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },
        { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},
        // Search
        { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},
        { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},
        { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},
        { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},
        { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},
        { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},
        // Ex command
        { keys: ':', type: 'ex' }
      ];
      var defaultKeymapLength = defaultKeymap.length;

      /**
       * Ex commands
       * Care must be taken when adding to the default Ex command map. For any
       * pair of commands that have a shared prefix, at least one of their
       * shortNames must not match the prefix of the other command.
       */
      var defaultExCommandMap = [
        { name: 'colorscheme', shortName: 'colo' },
        { name: 'map' },
        { name: 'imap', shortName: 'im' },
        { name: 'nmap', shortName: 'nm' },
        { name: 'vmap', shortName: 'vm' },
        { name: 'unmap' },
        { name: 'write', shortName: 'w' },
        { name: 'undo', shortName: 'u' },
        { name: 'redo', shortName: 'red' },
        { name: 'set', shortName: 'se' },
        { name: 'setlocal', shortName: 'setl' },
        { name: 'setglobal', shortName: 'setg' },
        { name: 'sort', shortName: 'sor' },
        { name: 'substitute', shortName: 's', possiblyAsync: true },
        { name: 'nohlsearch', shortName: 'noh' },
        { name: 'yank', shortName: 'y' },
        { name: 'delmarks', shortName: 'delm' },
        { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },
        { name: 'vglobal', shortName: 'v' },
        { name: 'global', shortName: 'g' }
      ];

      var Pos = CodeMirror.Pos;

      var Vim = function() {
        function enterVimMode(cm) {
          cm.setOption('disableInput', true);
          cm.setOption('showCursorWhenSelecting', false);
          CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
          cm.on('cursorActivity', onCursorActivity);
          maybeInitVimState(cm);
          CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));
        }

        function leaveVimMode(cm) {
          cm.setOption('disableInput', false);
          cm.off('cursorActivity', onCursorActivity);
          CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));
          cm.state.vim = null;
        }

        function detachVimMap(cm, next) {
          if (this == CodeMirror.keyMap.vim) {
            CodeMirror.rmClass(cm.getWrapperElement(), "cm-fat-cursor");
            if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
              disableFatCursorMark(cm);
              cm.getInputField().style.caretColor = "";
            }
          }

          if (!next || next.attach != attachVimMap)
            leaveVimMode(cm);
        }
        function attachVimMap(cm, prev) {
          if (this == CodeMirror.keyMap.vim) {
            CodeMirror.addClass(cm.getWrapperElement(), "cm-fat-cursor");
            if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
              enableFatCursorMark(cm);
              cm.getInputField().style.caretColor = "transparent";
            }
          }

          if (!prev || prev.attach != attachVimMap)
            enterVimMode(cm);
        }

        function updateFatCursorMark(cm) {
          if (!cm.state.fatCursorMarks) return;
          clearFatCursorMark(cm);
          var ranges = cm.listSelections(), result = []
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (range.empty()) {
              var lineLength = cm.getLine(range.anchor.line).length;
              if (range.anchor.ch < lineLength) {
                result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),
                                        {className: "cm-fat-cursor-mark"}));
              } else {
                result.push(cm.markText(Pos(range.anchor.line, lineLength - 1),
                                        Pos(range.anchor.line, lineLength),
                                        {className: "cm-fat-cursor-mark"}));
              }
            }
          }
          cm.state.fatCursorMarks = result;
        }

        function clearFatCursorMark(cm) {
          var marks = cm.state.fatCursorMarks;
          if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
        }

        function enableFatCursorMark(cm) {
          cm.state.fatCursorMarks = [];
          updateFatCursorMark(cm)
          cm.on("cursorActivity", updateFatCursorMark)
        }

        function disableFatCursorMark(cm) {
          clearFatCursorMark(cm);
          cm.off("cursorActivity", updateFatCursorMark);
          // explicitly set fatCursorMarks to null because event listener above
          // can be invoke after removing it, if off is called from operation
          cm.state.fatCursorMarks = null;
        }

        // Deprecated, simply setting the keymap works again.
        CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {
          if (val && cm.getOption("keyMap") != "vim")
            cm.setOption("keyMap", "vim");
          else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption("keyMap")))
            cm.setOption("keyMap", "default");
        });

        function cmKey(key, cm) {
          if (!cm) { return undefined; }
          if (this[key]) { return this[key]; }
          var vimKey = cmKeyToVimKey(key);
          if (!vimKey) {
            return false;
          }
          var cmd = CodeMirror.Vim.findKey(cm, vimKey);
          if (typeof cmd == 'function') {
            CodeMirror.signal(cm, 'vim-keypress', vimKey);
          }
          return cmd;
        }

        var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};
        var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};
        function cmKeyToVimKey(key) {
          if (key.charAt(0) == '\'') {
            // Keypress character binding of format "'a'"
            return key.charAt(1);
          }
          var pieces = key.split(/-(?!$)/);
          var lastPiece = pieces[pieces.length - 1];
          if (pieces.length == 1 && pieces[0].length == 1) {
            // No-modifier bindings use literal character bindings above. Skip.
            return false;
          } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {
            // Ignore Shift+char bindings as they should be handled by literal character.
            return false;
          }
          var hasCharacter = false;
          for (var i = 0; i < pieces.length; i++) {
            var piece = pieces[i];
            if (piece in modifiers) { pieces[i] = modifiers[piece]; }
            else { hasCharacter = true; }
            if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }
          }
          if (!hasCharacter) {
            // Vim does not support modifier only keys.
            return false;
          }
          // TODO: Current bindings expect the character to be lower case, but
          // it looks like vim key notation uses upper case.
          if (isUpperCase(lastPiece)) {
            pieces[pieces.length - 1] = lastPiece.toLowerCase();
          }
          return '<' + pieces.join('-') + '>';
        }

        function getOnPasteFn(cm) {
          var vim = cm.state.vim;
          if (!vim.onPasteFn) {
            vim.onPasteFn = function() {
              if (!vim.insertMode) {
                cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
                actions.enterInsertMode(cm, {}, vim);
              }
            };
          }
          return vim.onPasteFn;
        }

        var numberRegex = /[\d]/;
        var wordCharTest = [CodeMirror.isWordChar, function(ch) {
          return ch && !CodeMirror.isWordChar(ch) && !/\s/.test(ch);
        }], bigWordCharTest = [function(ch) {
          return /\S/.test(ch);
        }];
        function makeKeyRange(start, size) {
          var keys = [];
          for (var i = start; i < start + size; i++) {
            keys.push(String.fromCharCode(i));
          }
          return keys;
        }
        var upperCaseAlphabet = makeKeyRange(65, 26);
        var lowerCaseAlphabet = makeKeyRange(97, 26);
        var numbers = makeKeyRange(48, 10);
        var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);
        var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '"', '.', ':', '_', '/']);
        var upperCaseChars;
        try { upperCaseChars = new RegExp("^[\\p{Lu}]$", "u"); }
        catch (_) { upperCaseChars = /^[A-Z]$/; }

        function isLine(cm, line) {
          return line >= cm.firstLine() && line <= cm.lastLine();
        }
        function isLowerCase(k) {
          return (/^[a-z]$/).test(k);
        }
        function isMatchableSymbol(k) {
          return '()[]{}'.indexOf(k) != -1;
        }
        function isNumber(k) {
          return numberRegex.test(k);
        }
        function isUpperCase(k) {
          return upperCaseChars.test(k);
        }
        function isWhiteSpaceString(k) {
          return (/^\s*$/).test(k);
        }
        function isEndOfSentenceSymbol(k) {
          return '.?!'.indexOf(k) != -1;
        }
        function inArray(val, arr) {
          for (var i = 0; i < arr.length; i++) {
            if (arr[i] == val) {
              return true;
            }
          }
          return false;
        }

        var options = {};
        function defineOption(name, defaultValue, type, aliases, callback) {
          if (defaultValue === undefined && !callback) {
            throw Error('defaultValue is required unless callback is provided');
          }
          if (!type) { type = 'string'; }
          options[name] = {
            type: type,
            defaultValue: defaultValue,
            callback: callback
          };
          if (aliases) {
            for (var i = 0; i < aliases.length; i++) {
              options[aliases[i]] = options[name];
            }
          }
          if (defaultValue) {
            setOption(name, defaultValue);
          }
        }

        function setOption(name, value, cm, cfg) {
          var option = options[name];
          cfg = cfg || {};
          var scope = cfg.scope;
          if (!option) {
            return new Error('Unknown option: ' + name);
          }
          if (option.type == 'boolean') {
            if (value && value !== true) {
              return new Error('Invalid argument: ' + name + '=' + value);
            } else if (value !== false) {
              // Boolean options are set to true if value is not defined.
              value = true;
            }
          }
          if (option.callback) {
            if (scope !== 'local') {
              option.callback(value, undefined);
            }
            if (scope !== 'global' && cm) {
              option.callback(value, cm);
            }
          } else {
            if (scope !== 'local') {
              option.value = option.type == 'boolean' ? !!value : value;
            }
            if (scope !== 'global' && cm) {
              cm.state.vim.options[name] = {value: value};
            }
          }
        }

        function getOption(name, cm, cfg) {
          var option = options[name];
          cfg = cfg || {};
          var scope = cfg.scope;
          if (!option) {
            return new Error('Unknown option: ' + name);
          }
          if (option.callback) {
            var local = cm && option.callback(undefined, cm);
            if (scope !== 'global' && local !== undefined) {
              return local;
            }
            if (scope !== 'local') {
              return option.callback();
            }
            return;
          } else {
            var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);
            return (local || (scope !== 'local') && option || {}).value;
          }
        }

        defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {
          // Option is local. Do nothing for global.
          if (cm === undefined) {
            return;
          }
          // The 'filetype' option proxies to the CodeMirror 'mode' option.
          if (name === undefined) {
            var mode = cm.getOption('mode');
            return mode == 'null' ? '' : mode;
          } else {
            var mode = name == '' ? 'null' : name;
            cm.setOption('mode', mode);
          }
        });

        var createCircularJumpList = function() {
          var size = 100;
          var pointer = -1;
          var head = 0;
          var tail = 0;
          var buffer = new Array(size);
          function add(cm, oldCur, newCur) {
            var current = pointer % size;
            var curMark = buffer[current];
            function useNextSlot(cursor) {
              var next = ++pointer % size;
              var trashMark = buffer[next];
              if (trashMark) {
                trashMark.clear();
              }
              buffer[next] = cm.setBookmark(cursor);
            }
            if (curMark) {
              var markPos = curMark.find();
              // avoid recording redundant cursor position
              if (markPos && !cursorEqual(markPos, oldCur)) {
                useNextSlot(oldCur);
              }
            } else {
              useNextSlot(oldCur);
            }
            useNextSlot(newCur);
            head = pointer;
            tail = pointer - size + 1;
            if (tail < 0) {
              tail = 0;
            }
          }
          function move(cm, offset) {
            pointer += offset;
            if (pointer > head) {
              pointer = head;
            } else if (pointer < tail) {
              pointer = tail;
            }
            var mark = buffer[(size + pointer) % size];
            // skip marks that are temporarily removed from text buffer
            if (mark && !mark.find()) {
              var inc = offset > 0 ? 1 : -1;
              var newCur;
              var oldCur = cm.getCursor();
              do {
                pointer += inc;
                mark = buffer[(size + pointer) % size];
                // skip marks that are the same as current position
                if (mark &&
                    (newCur = mark.find()) &&
                    !cursorEqual(oldCur, newCur)) {
                  break;
                }
              } while (pointer < head && pointer > tail);
            }
            return mark;
          }
          function find(cm, offset) {
            var oldPointer = pointer;
            var mark = move(cm, offset);
            pointer = oldPointer;
            return mark && mark.find();
          }
          return {
            cachedCursor: undefined, //used for # and * jumps
            add: add,
            find: find,
            move: move
          };
        };

        // Returns an object to track the changes associated insert mode.  It
        // clones the object that is passed in, or creates an empty object one if
        // none is provided.
        var createInsertModeChanges = function(c) {
          if (c) {
            // Copy construction
            return {
              changes: c.changes,
              expectCursorActivityForChange: c.expectCursorActivityForChange
            };
          }
          return {
            // Change list
            changes: [],
            // Set to true on change, false on cursorActivity.
            expectCursorActivityForChange: false
          };
        };

        function MacroModeState() {
          this.latestRegister = undefined;
          this.isPlaying = false;
          this.isRecording = false;
          this.replaySearchQueries = [];
          this.onRecordingDone = undefined;
          this.lastInsertModeChanges = createInsertModeChanges();
        }
        MacroModeState.prototype = {
          exitMacroRecordMode: function() {
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.onRecordingDone) {
              macroModeState.onRecordingDone(); // close dialog
            }
            macroModeState.onRecordingDone = undefined;
            macroModeState.isRecording = false;
          },
          enterMacroRecordMode: function(cm, registerName) {
            var register =
                vimGlobalState.registerController.getRegister(registerName);
            if (register) {
              register.clear();
              this.latestRegister = registerName;
              if (cm.openDialog) {
                this.onRecordingDone = cm.openDialog(
                    document.createTextNode('(recording)['+registerName+']'), null, {bottom:true});
              }
              this.isRecording = true;
            }
          }
        };

        function maybeInitVimState(cm) {
          if (!cm.state.vim) {
            // Store instance state in the CodeMirror object.
            cm.state.vim = {
              inputState: new InputState(),
              // Vim's input state that triggered the last edit, used to repeat
              // motions and operators with '.'.
              lastEditInputState: undefined,
              // Vim's action command before the last edit, used to repeat actions
              // with '.' and insert mode repeat.
              lastEditActionCommand: undefined,
              // When using jk for navigation, if you move from a longer line to a
              // shorter line, the cursor may clip to the end of the shorter line.
              // If j is pressed again and cursor goes to the next line, the
              // cursor should go back to its horizontal position on the longer
              // line if it can. This is to keep track of the horizontal position.
              lastHPos: -1,
              // Doing the same with screen-position for gj/gk
              lastHSPos: -1,
              // The last motion command run. Cleared if a non-motion command gets
              // executed in between.
              lastMotion: null,
              marks: {},
              // Mark for rendering fake cursor for visual mode.
              fakeCursor: null,
              insertMode: false,
              // Repeat count for changes made in insert mode, triggered by key
              // sequences like 3,i. Only exists when insertMode is true.
              insertModeRepeat: undefined,
              visualMode: false,
              // If we are in visual line mode. No effect if visualMode is false.
              visualLine: false,
              visualBlock: false,
              lastSelection: null,
              lastPastedText: null,
              sel: {},
              // Buffer-local/window-local values of vim options.
              options: {}
            };
          }
          return cm.state.vim;
        }
        var vimGlobalState;
        function resetVimGlobalState() {
          vimGlobalState = {
            // The current search query.
            searchQuery: null,
            // Whether we are searching backwards.
            searchIsReversed: false,
            // Replace part of the last substituted pattern
            lastSubstituteReplacePart: undefined,
            jumpList: createCircularJumpList(),
            macroModeState: new MacroModeState,
            // Recording latest f, t, F or T motion command.
            lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},
            registerController: new RegisterController({}),
            // search history buffer
            searchHistoryController: new HistoryController(),
            // ex Command history buffer
            exCommandHistoryController : new HistoryController()
          };
          for (var optionName in options) {
            var option = options[optionName];
            option.value = option.defaultValue;
          }
        }

        var lastInsertModeKeyTimer;
        var vimApi= {
          buildKeyMap: function() {
            // TODO: Convert keymap into dictionary format for fast lookup.
          },
          // Testing hook, though it might be useful to expose the register
          // controller anyway.
          getRegisterController: function() {
            return vimGlobalState.registerController;
          },
          // Testing hook.
          resetVimGlobalState_: resetVimGlobalState,

          // Testing hook.
          getVimGlobalState_: function() {
            return vimGlobalState;
          },

          // Testing hook.
          maybeInitVimState_: maybeInitVimState,

          suppressErrorLogging: false,

          InsertModeKey: InsertModeKey,
          map: function(lhs, rhs, ctx) {
            // Add user defined key bindings.
            exCommandDispatcher.map(lhs, rhs, ctx);
          },
          unmap: function(lhs, ctx) {
            exCommandDispatcher.unmap(lhs, ctx);
          },
          // Non-recursive map function.
          // NOTE: This will not create mappings to key maps that aren't present
          // in the default key map. See TODO at bottom of function.
          noremap: function(lhs, rhs, ctx) {
            function toCtxArray(ctx) {
              return ctx ? [ctx] : ['normal', 'insert', 'visual'];
            }
            var ctxsToMap = toCtxArray(ctx);
            // Look through all actual defaults to find a map candidate.
            var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
            for (var i = actualLength - origLength;
                 i < actualLength && ctxsToMap.length;
                 i++) {
              var mapping = defaultKeymap[i];
              // Omit mappings that operate in the wrong context(s) and those of invalid type.
              if (mapping.keys == rhs &&
                  (!ctx || !mapping.context || mapping.context === ctx) &&
                  mapping.type.substr(0, 2) !== 'ex' &&
                  mapping.type.substr(0, 3) !== 'key') {
                // Make a shallow copy of the original keymap entry.
                var newMapping = {};
                for (var key in mapping) {
                  newMapping[key] = mapping[key];
                }
                // Modify it point to the new mapping with the proper context.
                newMapping.keys = lhs;
                if (ctx && !newMapping.context) {
                  newMapping.context = ctx;
                }
                // Add it to the keymap with a higher priority than the original.
                this._mapCommand(newMapping);
                // Record the mapped contexts as complete.
                var mappedCtxs = toCtxArray(mapping.context);
                ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });
              }
            }
            // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.
          },
          // Remove all user-defined mappings for the provided context.
          mapclear: function(ctx) {
            // Partition the existing keymap into user-defined and true defaults.
            var actualLength = defaultKeymap.length,
                origLength = defaultKeymapLength;
            var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
            defaultKeymap = defaultKeymap.slice(actualLength - origLength);
            if (ctx) {
              // If a specific context is being cleared, we need to keep mappings
              // from all other contexts.
              for (var i = userKeymap.length - 1; i >= 0; i--) {
                var mapping = userKeymap[i];
                if (ctx !== mapping.context) {
                  if (mapping.context) {
                    this._mapCommand(mapping);
                  } else {
                    // `mapping` applies to all contexts so create keymap copies
                    // for each context except the one being cleared.
                    var contexts = ['normal', 'insert', 'visual'];
                    for (var j in contexts) {
                      if (contexts[j] !== ctx) {
                        var newMapping = {};
                        for (var key in mapping) {
                          newMapping[key] = mapping[key];
                        }
                        newMapping.context = contexts[j];
                        this._mapCommand(newMapping);
                      }
                    }
                  }
                }
              }
            }
          },
          // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
          // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
          setOption: setOption,
          getOption: getOption,
          defineOption: defineOption,
          defineEx: function(name, prefix, func){
            if (!prefix) {
              prefix = name;
            } else if (name.indexOf(prefix) !== 0) {
              throw new Error('(Vim.defineEx) "'+prefix+'" is not a prefix of "'+name+'", command not registered');
            }
            exCommands[name]=func;
            exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};
          },
          handleKey: function (cm, key, origin) {
            var command = this.findKey(cm, key, origin);
            if (typeof command === 'function') {
              return command();
            }
          },
          /**
           * This is the outermost function called by CodeMirror, after keys have
           * been mapped to their Vim equivalents.
           *
           * Finds a command based on the key (and cached keys if there is a
           * multi-key sequence). Returns `undefined` if no key is matched, a noop
           * function if a partial match is found (multi-key), and a function to
           * execute the bound command if a a key is matched. The function always
           * returns true.
           */
          findKey: function(cm, key, origin) {
            var vim = maybeInitVimState(cm);
            function handleMacroRecording() {
              var macroModeState = vimGlobalState.macroModeState;
              if (macroModeState.isRecording) {
                if (key == 'q') {
                  macroModeState.exitMacroRecordMode();
                  clearInputState(cm);
                  return true;
                }
                if (origin != 'mapping') {
                  logKey(macroModeState, key);
                }
              }
            }
            function handleEsc() {
              if (key == '<Esc>') {
                // Clear input state and get back to normal mode.
                clearInputState(cm);
                if (vim.visualMode) {
                  exitVisualMode(cm);
                } else if (vim.insertMode) {
                  exitInsertMode(cm);
                }
                return true;
              }
            }
            function doKeyToKey(keys) {
              // TODO: prevent infinite recursion.
              var match;
              while (keys) {
                // Pull off one command key, which is either a single character
                // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
                match = (/<\w+-.+?>|<\w+>|./).exec(keys);
                key = match[0];
                keys = keys.substring(match.index + key.length);
                CodeMirror.Vim.handleKey(cm, key, 'mapping');
              }
            }

            function handleKeyInsertMode() {
              if (handleEsc()) { return true; }
              var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
              var keysAreChars = key.length == 1;
              var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
              // Need to check all key substrings in insert mode.
              while (keys.length > 1 && match.type != 'full') {
                var keys = vim.inputState.keyBuffer = keys.slice(1);
                var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
                if (thisMatch.type != 'none') { match = thisMatch; }
              }
              if (match.type == 'none') { clearInputState(cm); return false; }
              else if (match.type == 'partial') {
                if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
                lastInsertModeKeyTimer = window.setTimeout(
                  function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },
                  getOption('insertModeEscKeysTimeout'));
                return !keysAreChars;
              }

              if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
              if (keysAreChars) {
                var selections = cm.listSelections();
                for (var i = 0; i < selections.length; i++) {
                  var here = selections[i].head;
                  cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');
                }
                vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
              }
              clearInputState(cm);
              return match.command;
            }

            function handleKeyNonInsertMode() {
              if (handleMacroRecording() || handleEsc()) { return true; }

              var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
              if (/^[1-9]\d*$/.test(keys)) { return true; }

              var keysMatcher = /^(\d*)(.*)$/.exec(keys);
              if (!keysMatcher) { clearInputState(cm); return false; }
              var context = vim.visualMode ? 'visual' :
                                             'normal';
              var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);
              if (match.type == 'none') { clearInputState(cm); return false; }
              else if (match.type == 'partial') { return true; }

              vim.inputState.keyBuffer = '';
              var keysMatcher = /^(\d*)(.*)$/.exec(keys);
              if (keysMatcher[1] && keysMatcher[1] != '0') {
                vim.inputState.pushRepeatDigit(keysMatcher[1]);
              }
              return match.command;
            }

            var command;
            if (vim.insertMode) { command = handleKeyInsertMode(); }
            else { command = handleKeyNonInsertMode(); }
            if (command === false) {
              return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;
            } else if (command === true) {
              // TODO: Look into using CodeMirror's multi-key handling.
              // Return no-op since we are caching the key. Counts as handled, but
              // don't want act on it just yet.
              return function() { return true; };
            } else {
              return function() {
                return cm.operation(function() {
                  cm.curOp.isVimOp = true;
                  try {
                    if (command.type == 'keyToKey') {
                      doKeyToKey(command.toKeys);
                    } else {
                      commandDispatcher.processCommand(cm, vim, command);
                    }
                  } catch (e) {
                    // clear VIM state in case it's in a bad state.
                    cm.state.vim = undefined;
                    maybeInitVimState(cm);
                    if (!CodeMirror.Vim.suppressErrorLogging) {
                      console['log'](e);
                    }
                    throw e;
                  }
                  return true;
                });
              };
            }
          },
          handleEx: function(cm, input) {
            exCommandDispatcher.processCommand(cm, input);
          },

          defineMotion: defineMotion,
          defineAction: defineAction,
          defineOperator: defineOperator,
          mapCommand: mapCommand,
          _mapCommand: _mapCommand,

          defineRegister: defineRegister,

          exitVisualMode: exitVisualMode,
          exitInsertMode: exitInsertMode
        };

        // Represents the current input state.
        function InputState() {
          this.prefixRepeat = [];
          this.motionRepeat = [];

          this.operator = null;
          this.operatorArgs = null;
          this.motion = null;
          this.motionArgs = null;
          this.keyBuffer = []; // For matching multi-key commands.
          this.registerName = null; // Defaults to the unnamed register.
        }
        InputState.prototype.pushRepeatDigit = function(n) {
          if (!this.operator) {
            this.prefixRepeat = this.prefixRepeat.concat(n);
          } else {
            this.motionRepeat = this.motionRepeat.concat(n);
          }
        };
        InputState.prototype.getRepeat = function() {
          var repeat = 0;
          if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
            repeat = 1;
            if (this.prefixRepeat.length > 0) {
              repeat *= parseInt(this.prefixRepeat.join(''), 10);
            }
            if (this.motionRepeat.length > 0) {
              repeat *= parseInt(this.motionRepeat.join(''), 10);
            }
          }
          return repeat;
        };

        function clearInputState(cm, reason) {
          cm.state.vim.inputState = new InputState();
          CodeMirror.signal(cm, 'vim-command-done', reason);
        }

        /*
         * Register stores information about copy and paste registers.  Besides
         * text, a register must store whether it is linewise (i.e., when it is
         * pasted, should it insert itself into a new line, or should the text be
         * inserted at the cursor position.)
         */
        function Register(text, linewise, blockwise) {
          this.clear();
          this.keyBuffer = [text || ''];
          this.insertModeChanges = [];
          this.searchQueries = [];
          this.linewise = !!linewise;
          this.blockwise = !!blockwise;
        }
        Register.prototype = {
          setText: function(text, linewise, blockwise) {
            this.keyBuffer = [text || ''];
            this.linewise = !!linewise;
            this.blockwise = !!blockwise;
          },
          pushText: function(text, linewise) {
            // if this register has ever been set to linewise, use linewise.
            if (linewise) {
              if (!this.linewise) {
                this.keyBuffer.push('\n');
              }
              this.linewise = true;
            }
            this.keyBuffer.push(text);
          },
          pushInsertModeChanges: function(changes) {
            this.insertModeChanges.push(createInsertModeChanges(changes));
          },
          pushSearchQuery: function(query) {
            this.searchQueries.push(query);
          },
          clear: function() {
            this.keyBuffer = [];
            this.insertModeChanges = [];
            this.searchQueries = [];
            this.linewise = false;
          },
          toString: function() {
            return this.keyBuffer.join('');
          }
        };

        /**
         * Defines an external register.
         *
         * The name should be a single character that will be used to reference the register.
         * The register should support setText, pushText, clear, and toString(). See Register
         * for a reference implementation.
         */
        function defineRegister(name, register) {
          var registers = vimGlobalState.registerController.registers;
          if (!name || name.length != 1) {
            throw Error('Register name must be 1 character');
          }
          if (registers[name]) {
            throw Error('Register already defined ' + name);
          }
          registers[name] = register;
          validRegisters.push(name);
        }

        /*
         * vim registers allow you to keep many independent copy and paste buffers.
         * See http://usevim.com/2012/04/13/registers/ for an introduction.
         *
         * RegisterController keeps the state of all the registers.  An initial
         * state may be passed in.  The unnamed register '"' will always be
         * overridden.
         */
        function RegisterController(registers) {
          this.registers = registers;
          this.unnamedRegister = registers['"'] = new Register();
          registers['.'] = new Register();
          registers[':'] = new Register();
          registers['/'] = new Register();
        }
        RegisterController.prototype = {
          pushText: function(registerName, operator, text, linewise, blockwise) {
            // The black hole register, "_, means delete/yank to nowhere.
            if (registerName === '_') return;
            if (linewise && text.charAt(text.length - 1) !== '\n'){
              text += '\n';
            }
            // Lowercase and uppercase registers refer to the same register.
            // Uppercase just means append.
            var register = this.isValidRegister(registerName) ?
                this.getRegister(registerName) : null;
            // if no register/an invalid register was specified, things go to the
            // default registers
            if (!register) {
              switch (operator) {
                case 'yank':
                  // The 0 register contains the text from the most recent yank.
                  this.registers['0'] = new Register(text, linewise, blockwise);
                  break;
                case 'delete':
                case 'change':
                  if (text.indexOf('\n') == -1) {
                    // Delete less than 1 line. Update the small delete register.
                    this.registers['-'] = new Register(text, linewise);
                  } else {
                    // Shift down the contents of the numbered registers and put the
                    // deleted text into register 1.
                    this.shiftNumericRegisters_();
                    this.registers['1'] = new Register(text, linewise);
                  }
                  break;
              }
              // Make sure the unnamed register is set to what just happened
              this.unnamedRegister.setText(text, linewise, blockwise);
              return;
            }

            // If we've gotten to this point, we've actually specified a register
            var append = isUpperCase(registerName);
            if (append) {
              register.pushText(text, linewise);
            } else {
              register.setText(text, linewise, blockwise);
            }
            // The unnamed register always has the same value as the last used
            // register.
            this.unnamedRegister.setText(register.toString(), linewise);
          },
          // Gets the register named @name.  If one of @name doesn't already exist,
          // create it.  If @name is invalid, return the unnamedRegister.
          getRegister: function(name) {
            if (!this.isValidRegister(name)) {
              return this.unnamedRegister;
            }
            name = name.toLowerCase();
            if (!this.registers[name]) {
              this.registers[name] = new Register();
            }
            return this.registers[name];
          },
          isValidRegister: function(name) {
            return name && inArray(name, validRegisters);
          },
          shiftNumericRegisters_: function() {
            for (var i = 9; i >= 2; i--) {
              this.registers[i] = this.getRegister('' + (i - 1));
            }
          }
        };
        function HistoryController() {
            this.historyBuffer = [];
            this.iterator = 0;
            this.initialPrefix = null;
        }
        HistoryController.prototype = {
          // the input argument here acts a user entered prefix for a small time
          // until we start autocompletion in which case it is the autocompleted.
          nextMatch: function (input, up) {
            var historyBuffer = this.historyBuffer;
            var dir = up ? -1 : 1;
            if (this.initialPrefix === null) this.initialPrefix = input;
            for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {
              var element = historyBuffer[i];
              for (var j = 0; j <= element.length; j++) {
                if (this.initialPrefix == element.substring(0, j)) {
                  this.iterator = i;
                  return element;
                }
              }
            }
            // should return the user input in case we reach the end of buffer.
            if (i >= historyBuffer.length) {
              this.iterator = historyBuffer.length;
              return this.initialPrefix;
            }
            // return the last autocompleted query or exCommand as it is.
            if (i < 0 ) return input;
          },
          pushInput: function(input) {
            var index = this.historyBuffer.indexOf(input);
            if (index > -1) this.historyBuffer.splice(index, 1);
            if (input.length) this.historyBuffer.push(input);
          },
          reset: function() {
            this.initialPrefix = null;
            this.iterator = this.historyBuffer.length;
          }
        };
        var commandDispatcher = {
          matchCommand: function(keys, keyMap, inputState, context) {
            var matches = commandMatches(keys, keyMap, context, inputState);
            if (!matches.full && !matches.partial) {
              return {type: 'none'};
            } else if (!matches.full && matches.partial) {
              return {type: 'partial'};
            }

            var bestMatch;
            for (var i = 0; i < matches.full.length; i++) {
              var match = matches.full[i];
              if (!bestMatch) {
                bestMatch = match;
              }
            }
            if (bestMatch.keys.slice(-11) == '<character>') {
              var character = lastChar(keys);
              if (!character) return {type: 'none'};
              inputState.selectedCharacter = character;
            }
            return {type: 'full', command: bestMatch};
          },
          processCommand: function(cm, vim, command) {
            vim.inputState.repeatOverride = command.repeatOverride;
            switch (command.type) {
              case 'motion':
                this.processMotion(cm, vim, command);
                break;
              case 'operator':
                this.processOperator(cm, vim, command);
                break;
              case 'operatorMotion':
                this.processOperatorMotion(cm, vim, command);
                break;
              case 'action':
                this.processAction(cm, vim, command);
                break;
              case 'search':
                this.processSearch(cm, vim, command);
                break;
              case 'ex':
              case 'keyToEx':
                this.processEx(cm, vim, command);
                break;
              default:
                break;
            }
          },
          processMotion: function(cm, vim, command) {
            vim.inputState.motion = command.motion;
            vim.inputState.motionArgs = copyArgs(command.motionArgs);
            this.evalInput(cm, vim);
          },
          processOperator: function(cm, vim, command) {
            var inputState = vim.inputState;
            if (inputState.operator) {
              if (inputState.operator == command.operator) {
                // Typing an operator twice like 'dd' makes the operator operate
                // linewise
                inputState.motion = 'expandToLine';
                inputState.motionArgs = { linewise: true };
                this.evalInput(cm, vim);
                return;
              } else {
                // 2 different operators in a row doesn't make sense.
                clearInputState(cm);
              }
            }
            inputState.operator = command.operator;
            inputState.operatorArgs = copyArgs(command.operatorArgs);
            if (command.exitVisualBlock) {
                vim.visualBlock = false;
                updateCmSelection(cm);
            }
            if (vim.visualMode) {
              // Operating on a selection in visual mode. We don't need a motion.
              this.evalInput(cm, vim);
            }
          },
          processOperatorMotion: function(cm, vim, command) {
            var visualMode = vim.visualMode;
            var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
            if (operatorMotionArgs) {
              // Operator motions may have special behavior in visual mode.
              if (visualMode && operatorMotionArgs.visualLine) {
                vim.visualLine = true;
              }
            }
            this.processOperator(cm, vim, command);
            if (!visualMode) {
              this.processMotion(cm, vim, command);
            }
          },
          processAction: function(cm, vim, command) {
            var inputState = vim.inputState;
            var repeat = inputState.getRepeat();
            var repeatIsExplicit = !!repeat;
            var actionArgs = copyArgs(command.actionArgs) || {};
            if (inputState.selectedCharacter) {
              actionArgs.selectedCharacter = inputState.selectedCharacter;
            }
            // Actions may or may not have motions and operators. Do these first.
            if (command.operator) {
              this.processOperator(cm, vim, command);
            }
            if (command.motion) {
              this.processMotion(cm, vim, command);
            }
            if (command.motion || command.operator) {
              this.evalInput(cm, vim);
            }
            actionArgs.repeat = repeat || 1;
            actionArgs.repeatIsExplicit = repeatIsExplicit;
            actionArgs.registerName = inputState.registerName;
            clearInputState(cm);
            vim.lastMotion = null;
            if (command.isEdit) {
              this.recordLastEdit(vim, inputState, command);
            }
            actions[command.action](cm, actionArgs, vim);
          },
          processSearch: function(cm, vim, command) {
            if (!cm.getSearchCursor) {
              // Search depends on SearchCursor.
              return;
            }
            var forward = command.searchArgs.forward;
            var wholeWordOnly = command.searchArgs.wholeWordOnly;
            getSearchState(cm).setReversed(!forward);
            var promptPrefix = (forward) ? '/' : '?';
            var originalQuery = getSearchState(cm).getQuery();
            var originalScrollPos = cm.getScrollInfo();
            function handleQuery(query, ignoreCase, smartCase) {
              vimGlobalState.searchHistoryController.pushInput(query);
              vimGlobalState.searchHistoryController.reset();
              try {
                updateSearchQuery(cm, query, ignoreCase, smartCase);
              } catch (e) {
                showConfirm(cm, 'Invalid regex: ' + query);
                clearInputState(cm);
                return;
              }
              commandDispatcher.processMotion(cm, vim, {
                type: 'motion',
                motion: 'findNext',
                motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
              });
            }
            function onPromptClose(query) {
              cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
              handleQuery(query, true /** ignoreCase */, true /** smartCase */);
              var macroModeState = vimGlobalState.macroModeState;
              if (macroModeState.isRecording) {
                logSearchQuery(macroModeState, query);
              }
            }
            function onPromptKeyUp(e, query, close) {
              var keyName = CodeMirror.keyName(e), up, offset;
              if (keyName == 'Up' || keyName == 'Down') {
                up = keyName == 'Up' ? true : false;
                offset = e.target ? e.target.selectionEnd : 0;
                query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';
                close(query);
                if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
              } else {
                if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')
                  vimGlobalState.searchHistoryController.reset();
              }
              var parsedQuery;
              try {
                parsedQuery = updateSearchQuery(cm, query,
                    true /** ignoreCase */, true /** smartCase */);
              } catch (e) {
                // Swallow bad regexes for incremental search.
              }
              if (parsedQuery) {
                cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
              } else {
                clearSearchHighlight(cm);
                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
              }
            }
            function onPromptKeyDown(e, query, close) {
              var keyName = CodeMirror.keyName(e);
              if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||
                  (keyName == 'Backspace' && query == '')) {
                vimGlobalState.searchHistoryController.pushInput(query);
                vimGlobalState.searchHistoryController.reset();
                updateSearchQuery(cm, originalQuery);
                clearSearchHighlight(cm);
                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
                CodeMirror.e_stop(e);
                clearInputState(cm);
                close();
                cm.focus();
              } else if (keyName == 'Up' || keyName == 'Down') {
                CodeMirror.e_stop(e);
              } else if (keyName == 'Ctrl-U') {
                // Ctrl-U clears input.
                CodeMirror.e_stop(e);
                close('');
              }
            }
            switch (command.searchArgs.querySrc) {
              case 'prompt':
                var macroModeState = vimGlobalState.macroModeState;
                if (macroModeState.isPlaying) {
                  var query = macroModeState.replaySearchQueries.shift();
                  handleQuery(query, true /** ignoreCase */, false /** smartCase */);
                } else {
                  showPrompt(cm, {
                      onClose: onPromptClose,
                      prefix: promptPrefix,
                      desc: '(JavaScript regexp)',
                      onKeyUp: onPromptKeyUp,
                      onKeyDown: onPromptKeyDown
                  });
                }
                break;
              case 'wordUnderCursor':
                var word = expandWordUnderCursor(cm, false /** inclusive */,
                    true /** forward */, false /** bigWord */,
                    true /** noSymbol */);
                var isKeyword = true;
                if (!word) {
                  word = expandWordUnderCursor(cm, false /** inclusive */,
                      true /** forward */, false /** bigWord */,
                      false /** noSymbol */);
                  isKeyword = false;
                }
                if (!word) {
                  return;
                }
                var query = cm.getLine(word.start.line).substring(word.start.ch,
                    word.end.ch);
                if (isKeyword && wholeWordOnly) {
                    query = '\\b' + query + '\\b';
                } else {
                  query = escapeRegex(query);
                }

                // cachedCursor is used to save the old position of the cursor
                // when * or # causes vim to seek for the nearest word and shift
                // the cursor before entering the motion.
                vimGlobalState.jumpList.cachedCursor = cm.getCursor();
                cm.setCursor(word.start);

                handleQuery(query, true /** ignoreCase */, false /** smartCase */);
                break;
            }
          },
          processEx: function(cm, vim, command) {
            function onPromptClose(input) {
              // Give the prompt some time to close so that if processCommand shows
              // an error, the elements don't overlap.
              vimGlobalState.exCommandHistoryController.pushInput(input);
              vimGlobalState.exCommandHistoryController.reset();
              exCommandDispatcher.processCommand(cm, input);
            }
            function onPromptKeyDown(e, input, close) {
              var keyName = CodeMirror.keyName(e), up, offset;
              if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||
                  (keyName == 'Backspace' && input == '')) {
                vimGlobalState.exCommandHistoryController.pushInput(input);
                vimGlobalState.exCommandHistoryController.reset();
                CodeMirror.e_stop(e);
                clearInputState(cm);
                close();
                cm.focus();
              }
              if (keyName == 'Up' || keyName == 'Down') {
                CodeMirror.e_stop(e);
                up = keyName == 'Up' ? true : false;
                offset = e.target ? e.target.selectionEnd : 0;
                input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';
                close(input);
                if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
              } else if (keyName == 'Ctrl-U') {
                // Ctrl-U clears input.
                CodeMirror.e_stop(e);
                close('');
              } else {
                if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')
                  vimGlobalState.exCommandHistoryController.reset();
              }
            }
            if (command.type == 'keyToEx') {
              // Handle user defined Ex to Ex mappings
              exCommandDispatcher.processCommand(cm, command.exArgs.input);
            } else {
              if (vim.visualMode) {
                showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\'<,\'>',
                    onKeyDown: onPromptKeyDown, selectValueOnOpen: false});
              } else {
                showPrompt(cm, { onClose: onPromptClose, prefix: ':',
                    onKeyDown: onPromptKeyDown});
              }
            }
          },
          evalInput: function(cm, vim) {
            // If the motion command is set, execute both the operator and motion.
            // Otherwise return.
            var inputState = vim.inputState;
            var motion = inputState.motion;
            var motionArgs = inputState.motionArgs || {};
            var operator = inputState.operator;
            var operatorArgs = inputState.operatorArgs || {};
            var registerName = inputState.registerName;
            var sel = vim.sel;
            // TODO: Make sure cm and vim selections are identical outside visual mode.
            var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));
            var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));
            var oldHead = copyCursor(origHead);
            var oldAnchor = copyCursor(origAnchor);
            var newHead, newAnchor;
            var repeat;
            if (operator) {
              this.recordLastEdit(vim, inputState);
            }
            if (inputState.repeatOverride !== undefined) {
              // If repeatOverride is specified, that takes precedence over the
              // input state's repeat. Used by Ex mode and can be user defined.
              repeat = inputState.repeatOverride;
            } else {
              repeat = inputState.getRepeat();
            }
            if (repeat > 0 && motionArgs.explicitRepeat) {
              motionArgs.repeatIsExplicit = true;
            } else if (motionArgs.noRepeat ||
                (!motionArgs.explicitRepeat && repeat === 0)) {
              repeat = 1;
              motionArgs.repeatIsExplicit = false;
            }
            if (inputState.selectedCharacter) {
              // If there is a character input, stick it in all of the arg arrays.
              motionArgs.selectedCharacter = operatorArgs.selectedCharacter =
                  inputState.selectedCharacter;
            }
            motionArgs.repeat = repeat;
            clearInputState(cm);
            if (motion) {
              var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
              vim.lastMotion = motions[motion];
              if (!motionResult) {
                return;
              }
              if (motionArgs.toJumplist) {
                var jumpList = vimGlobalState.jumpList;
                // if the current motion is # or *, use cachedCursor
                var cachedCursor = jumpList.cachedCursor;
                if (cachedCursor) {
                  recordJumpPosition(cm, cachedCursor, motionResult);
                  delete jumpList.cachedCursor;
                } else {
                  recordJumpPosition(cm, origHead, motionResult);
                }
              }
              if (motionResult instanceof Array) {
                newAnchor = motionResult[0];
                newHead = motionResult[1];
              } else {
                newHead = motionResult;
              }
              // TODO: Handle null returns from motion commands better.
              if (!newHead) {
                newHead = copyCursor(origHead);
              }
              if (vim.visualMode) {
                if (!(vim.visualBlock && newHead.ch === Infinity)) {
                  newHead = clipCursorToContent(cm, newHead);
                }
                if (newAnchor) {
                  newAnchor = clipCursorToContent(cm, newAnchor);
                }
                newAnchor = newAnchor || oldAnchor;
                sel.anchor = newAnchor;
                sel.head = newHead;
                updateCmSelection(cm);
                updateMark(cm, vim, '<',
                    cursorIsBefore(newAnchor, newHead) ? newAnchor
                        : newHead);
                updateMark(cm, vim, '>',
                    cursorIsBefore(newAnchor, newHead) ? newHead
                        : newAnchor);
              } else if (!operator) {
                newHead = clipCursorToContent(cm, newHead);
                cm.setCursor(newHead.line, newHead.ch);
              }
            }
            if (operator) {
              if (operatorArgs.lastSel) {
                // Replaying a visual mode operation
                newAnchor = oldAnchor;
                var lastSel = operatorArgs.lastSel;
                var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
                var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
                if (lastSel.visualLine) {
                  // Linewise Visual mode: The same number of lines.
                  newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
                } else if (lastSel.visualBlock) {
                  // Blockwise Visual mode: The same number of lines and columns.
                  newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
                } else if (lastSel.head.line == lastSel.anchor.line) {
                  // Normal Visual mode within one line: The same number of characters.
                  newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);
                } else {
                  // Normal Visual mode with several lines: The same number of lines, in the
                  // last line the same number of characters as in the last line the last time.
                  newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
                }
                vim.visualMode = true;
                vim.visualLine = lastSel.visualLine;
                vim.visualBlock = lastSel.visualBlock;
                sel = vim.sel = {
                  anchor: newAnchor,
                  head: newHead
                };
                updateCmSelection(cm);
              } else if (vim.visualMode) {
                operatorArgs.lastSel = {
                  anchor: copyCursor(sel.anchor),
                  head: copyCursor(sel.head),
                  visualBlock: vim.visualBlock,
                  visualLine: vim.visualLine
                };
              }
              var curStart, curEnd, linewise, mode;
              var cmSel;
              if (vim.visualMode) {
                // Init visual op
                curStart = cursorMin(sel.head, sel.anchor);
                curEnd = cursorMax(sel.head, sel.anchor);
                linewise = vim.visualLine || operatorArgs.linewise;
                mode = vim.visualBlock ? 'block' :
                       linewise ? 'line' :
                       'char';
                cmSel = makeCmSelection(cm, {
                  anchor: curStart,
                  head: curEnd
                }, mode);
                if (linewise) {
                  var ranges = cmSel.ranges;
                  if (mode == 'block') {
                    // Linewise operators in visual block mode extend to end of line
                    for (var i = 0; i < ranges.length; i++) {
                      ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                    }
                  } else if (mode == 'line') {
                    ranges[0].head = Pos(ranges[0].head.line + 1, 0);
                  }
                }
              } else {
                // Init motion op
                curStart = copyCursor(newAnchor || oldAnchor);
                curEnd = copyCursor(newHead || oldHead);
                if (cursorIsBefore(curEnd, curStart)) {
                  var tmp = curStart;
                  curStart = curEnd;
                  curEnd = tmp;
                }
                linewise = motionArgs.linewise || operatorArgs.linewise;
                if (linewise) {
                  // Expand selection to entire line.
                  expandSelectionToLine(cm, curStart, curEnd);
                } else if (motionArgs.forward) {
                  // Clip to trailing newlines only if the motion goes forward.
                  clipToLine(cm, curStart, curEnd);
                }
                mode = 'char';
                var exclusive = !motionArgs.inclusive || linewise;
                cmSel = makeCmSelection(cm, {
                  anchor: curStart,
                  head: curEnd
                }, mode, exclusive);
              }
              cm.setSelections(cmSel.ranges, cmSel.primary);
              vim.lastMotion = null;
              operatorArgs.repeat = repeat; // For indent in visual mode.
              operatorArgs.registerName = registerName;
              // Keep track of linewise as it affects how paste and change behave.
              operatorArgs.linewise = linewise;
              var operatorMoveTo = operators[operator](
                cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
              if (vim.visualMode) {
                exitVisualMode(cm, operatorMoveTo != null);
              }
              if (operatorMoveTo) {
                cm.setCursor(operatorMoveTo);
              }
            }
          },
          recordLastEdit: function(vim, inputState, actionCommand) {
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isPlaying) { return; }
            vim.lastEditInputState = inputState;
            vim.lastEditActionCommand = actionCommand;
            macroModeState.lastInsertModeChanges.changes = [];
            macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
            macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
          }
        };

        /**
         * typedef {Object{line:number,ch:number}} Cursor An object containing the
         *     position of the cursor.
         */
        // All of the functions below return Cursor objects.
        var motions = {
          moveToTopLine: function(cm, _head, motionArgs) {
            var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;
            return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
          },
          moveToMiddleLine: function(cm) {
            var range = getUserVisibleLines(cm);
            var line = Math.floor((range.top + range.bottom) * 0.5);
            return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
          },
          moveToBottomLine: function(cm, _head, motionArgs) {
            var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;
            return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
          },
          expandToLine: function(_cm, head, motionArgs) {
            // Expands forward to end of line, and then to next line if repeat is
            // >1. Does not handle backward motion!
            var cur = head;
            return Pos(cur.line + motionArgs.repeat - 1, Infinity);
          },
          findNext: function(cm, _head, motionArgs) {
            var state = getSearchState(cm);
            var query = state.getQuery();
            if (!query) {
              return;
            }
            var prev = !motionArgs.forward;
            // If search is initiated with ? instead of /, negate direction.
            prev = (state.isReversed()) ? !prev : prev;
            highlightSearchMatches(cm, query);
            return findNext(cm, prev/** prev */, query, motionArgs.repeat);
          },
          /**
           * Find and select the next occurrence of the search query. If the cursor is currently
           * within a match, then find and select the current match. Otherwise, find the next occurrence in the
           * appropriate direction.
           *
           * This differs from `findNext` in the following ways:
           *
           * 1. Instead of only returning the "from", this returns a "from", "to" range.
           * 2. If the cursor is currently inside a search match, this selects the current match
           *    instead of the next match.
           * 3. If there is no associated operator, this will turn on visual mode.
           */
          findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {
            var state = getSearchState(cm);
            var query = state.getQuery();

            if (!query) {
              return;
            }

            var prev = !motionArgs.forward;
            prev = (state.isReversed()) ? !prev : prev;

            // next: [from, to] | null
            var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);

            // No matches.
            if (!next) {
              return;
            }

            // If there's an operator that will be executed, return the selection.
            if (prevInputState.operator) {
              return next;
            }

            // At this point, we know that there is no accompanying operator -- let's
            // deal with visual mode in order to select an appropriate match.

            var from = next[0];
            // For whatever reason, when we use the "to" as returned by searchcursor.js directly,
            // the resulting selection is extended by 1 char. Let's shrink it so that only the
            // match is selected.
            var to = Pos(next[1].line, next[1].ch - 1);

            if (vim.visualMode) {
              // If we were in visualLine or visualBlock mode, get out of it.
              if (vim.visualLine || vim.visualBlock) {
                vim.visualLine = false;
                vim.visualBlock = false;
                CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: ""});
              }

              // If we're currently in visual mode, we should extend the selection to include
              // the search result.
              var anchor = vim.sel.anchor;
              if (anchor) {
                if (state.isReversed()) {
                  if (motionArgs.forward) {
                    return [anchor, from];
                  }

                  return [anchor, to];
                } else {
                  if (motionArgs.forward) {
                    return [anchor, to];
                  }

                  return [anchor, from];
                }
              }
            } else {
              // Let's turn visual mode on.
              vim.visualMode = true;
              vim.visualLine = false;
              vim.visualBlock = false;
              CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: ""});
            }

            return prev ? [to, from] : [from, to];
          },
          goToMark: function(cm, _head, motionArgs, vim) {
            var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
            if (pos) {
              return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
            }
            return null;
          },
          moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {
            if (vim.visualBlock && motionArgs.sameLine) {
              var sel = vim.sel;
              return [
                clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),
                clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))
              ];
            } else {
              return ([vim.sel.head, vim.sel.anchor]);
            }
          },
          jumpToMark: function(cm, head, motionArgs, vim) {
            var best = head;
            for (var i = 0; i < motionArgs.repeat; i++) {
              var cursor = best;
              for (var key in vim.marks) {
                if (!isLowerCase(key)) {
                  continue;
                }
                var mark = vim.marks[key].find();
                var isWrongDirection = (motionArgs.forward) ?
                  cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);

                if (isWrongDirection) {
                  continue;
                }
                if (motionArgs.linewise && (mark.line == cursor.line)) {
                  continue;
                }

                var equal = cursorEqual(cursor, best);
                var between = (motionArgs.forward) ?
                  cursorIsBetween(cursor, mark, best) :
                  cursorIsBetween(best, mark, cursor);

                if (equal || between) {
                  best = mark;
                }
              }
            }

            if (motionArgs.linewise) {
              // Vim places the cursor on the first non-whitespace character of
              // the line if there is one, else it places the cursor at the end
              // of the line, regardless of whether a mark was found.
              best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
            }
            return best;
          },
          moveByCharacters: function(_cm, head, motionArgs) {
            var cur = head;
            var repeat = motionArgs.repeat;
            var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
            return Pos(cur.line, ch);
          },
          moveByLines: function(cm, head, motionArgs, vim) {
            var cur = head;
            var endCh = cur.ch;
            // Depending what our last motion was, we may want to do different
            // things. If our last motion was moving vertically, we want to
            // preserve the HPos from our last horizontal move.  If our last motion
            // was going to the end of a line, moving vertically we should go to
            // the end of the line, etc.
            switch (vim.lastMotion) {
              case this.moveByLines:
              case this.moveByDisplayLines:
              case this.moveByScroll:
              case this.moveToColumn:
              case this.moveToEol:
                endCh = vim.lastHPos;
                break;
              default:
                vim.lastHPos = endCh;
            }
            var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);
            var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
            var first = cm.firstLine();
            var last = cm.lastLine();
            var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);
            var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;
            if (hasMarkedText) {
              line = posV.line;
              endCh = posV.ch;
            }
            // Vim go to line begin or line end when cursor at first/last line and
            // move to previous/next line is triggered.
            if (line < first && cur.line == first){
              return this.moveToStartOfLine(cm, head, motionArgs, vim);
            } else if (line > last && cur.line == last){
                return moveToEol(cm, head, motionArgs, vim, true);
            }
            if (motionArgs.toFirstChar){
              endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));
              vim.lastHPos = endCh;
            }
            vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;
            return Pos(line, endCh);
          },
          moveByDisplayLines: function(cm, head, motionArgs, vim) {
            var cur = head;
            switch (vim.lastMotion) {
              case this.moveByDisplayLines:
              case this.moveByScroll:
              case this.moveByLines:
              case this.moveToColumn:
              case this.moveToEol:
                break;
              default:
                vim.lastHSPos = cm.charCoords(cur,'div').left;
            }
            var repeat = motionArgs.repeat;
            var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);
            if (res.hitSide) {
              if (motionArgs.forward) {
                var lastCharCoords = cm.charCoords(res, 'div');
                var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
                var res = cm.coordsChar(goalCoords, 'div');
              } else {
                var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');
                resCoords.left = vim.lastHSPos;
                res = cm.coordsChar(resCoords, 'div');
              }
            }
            vim.lastHPos = res.ch;
            return res;
          },
          moveByPage: function(cm, head, motionArgs) {
            // CodeMirror only exposes functions that move the cursor page down, so
            // doing this bad hack to move the cursor and move it back. evalInput
            // will move the cursor to where it should be in the end.
            var curStart = head;
            var repeat = motionArgs.repeat;
            return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');
          },
          moveByParagraph: function(cm, head, motionArgs) {
            var dir = motionArgs.forward ? 1 : -1;
            return findParagraph(cm, head, motionArgs.repeat, dir);
          },
          moveBySentence: function(cm, head, motionArgs) {
            var dir = motionArgs.forward ? 1 : -1;
            return findSentence(cm, head, motionArgs.repeat, dir);
          },
          moveByScroll: function(cm, head, motionArgs, vim) {
            var scrollbox = cm.getScrollInfo();
            var curEnd = null;
            var repeat = motionArgs.repeat;
            if (!repeat) {
              repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
            }
            var orig = cm.charCoords(head, 'local');
            motionArgs.repeat = repeat;
            var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
            if (!curEnd) {
              return null;
            }
            var dest = cm.charCoords(curEnd, 'local');
            cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
            return curEnd;
          },
          moveByWords: function(cm, head, motionArgs) {
            return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,
                !!motionArgs.wordEnd, !!motionArgs.bigWord);
          },
          moveTillCharacter: function(cm, _head, motionArgs) {
            var repeat = motionArgs.repeat;
            var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,
                motionArgs.selectedCharacter);
            var increment = motionArgs.forward ? -1 : 1;
            recordLastCharacterSearch(increment, motionArgs);
            if (!curEnd) return null;
            curEnd.ch += increment;
            return curEnd;
          },
          moveToCharacter: function(cm, head, motionArgs) {
            var repeat = motionArgs.repeat;
            recordLastCharacterSearch(0, motionArgs);
            return moveToCharacter(cm, repeat, motionArgs.forward,
                motionArgs.selectedCharacter) || head;
          },
          moveToSymbol: function(cm, head, motionArgs) {
            var repeat = motionArgs.repeat;
            return findSymbol(cm, repeat, motionArgs.forward,
                motionArgs.selectedCharacter) || head;
          },
          moveToColumn: function(cm, head, motionArgs, vim) {
            var repeat = motionArgs.repeat;
            // repeat is equivalent to which column we want to move to!
            vim.lastHPos = repeat - 1;
            vim.lastHSPos = cm.charCoords(head,'div').left;
            return moveToColumn(cm, repeat);
          },
          moveToEol: function(cm, head, motionArgs, vim) {
            return moveToEol(cm, head, motionArgs, vim, false);
          },
          moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
            // Go to the start of the line where the text begins, or the end for
            // whitespace-only lines
            var cursor = head;
            return Pos(cursor.line,
                       findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
          },
          moveToMatchedSymbol: function(cm, head) {
            var cursor = head;
            var line = cursor.line;
            var ch = cursor.ch;
            var lineText = cm.getLine(line);
            var symbol;
            for (; ch < lineText.length; ch++) {
              symbol = lineText.charAt(ch);
              if (symbol && isMatchableSymbol(symbol)) {
                var style = cm.getTokenTypeAt(Pos(line, ch + 1));
                if (style !== "string" && style !== "comment") {
                  break;
                }
              }
            }
            if (ch < lineText.length) {
              // Only include angle brackets in analysis if they are being matched.
              var re = (ch === '<' || ch === '>') ? /[(){}[\]<>]/ : /[(){}[\]]/;
              var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});
              return matched.to;
            } else {
              return cursor;
            }
          },
          moveToStartOfLine: function(_cm, head) {
            return Pos(head.line, 0);
          },
          moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
            var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
            if (motionArgs.repeatIsExplicit) {
              lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');
            }
            return Pos(lineNum,
                       findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
          },
          textObjectManipulation: function(cm, head, motionArgs, vim) {
            // TODO: lots of possible exceptions that can be thrown here. Try da(
            //     outside of a () block.
            var mirroredPairs = {'(': ')', ')': '(',
                                 '{': '}', '}': '{',
                                 '[': ']', ']': '[',
                                 '<': '>', '>': '<'};
            var selfPaired = {'\'': true, '"': true, '`': true};

            var character = motionArgs.selectedCharacter;
            // 'b' refers to  '()' block.
            // 'B' refers to  '{}' block.
            if (character == 'b') {
              character = '(';
            } else if (character == 'B') {
              character = '{';
            }

            // Inclusive is the difference between a and i
            // TODO: Instead of using the additional text object map to perform text
            //     object operations, merge the map into the defaultKeyMap and use
            //     motionArgs to define behavior. Define separate entries for 'aw',
            //     'iw', 'a[', 'i[', etc.
            var inclusive = !motionArgs.textObjectInner;

            var tmp;
            if (mirroredPairs[character]) {
              tmp = selectCompanionObject(cm, head, character, inclusive);
            } else if (selfPaired[character]) {
              tmp = findBeginningAndEnd(cm, head, character, inclusive);
            } else if (character === 'W') {
              tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                         true /** bigWord */);
            } else if (character === 'w') {
              tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                         false /** bigWord */);
            } else if (character === 'p') {
              tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
              motionArgs.linewise = true;
              if (vim.visualMode) {
                if (!vim.visualLine) { vim.visualLine = true; }
              } else {
                var operatorArgs = vim.inputState.operatorArgs;
                if (operatorArgs) { operatorArgs.linewise = true; }
                tmp.end.line--;
              }
            } else if (character === 't') {
              tmp = expandTagUnderCursor(cm, head, inclusive);
            } else {
              // No text object defined for this, don't move.
              return null;
            }

            if (!cm.state.vim.visualMode) {
              return [tmp.start, tmp.end];
            } else {
              return expandSelection(cm, tmp.start, tmp.end);
            }
          },

          repeatLastCharacterSearch: function(cm, head, motionArgs) {
            var lastSearch = vimGlobalState.lastCharacterSearch;
            var repeat = motionArgs.repeat;
            var forward = motionArgs.forward === lastSearch.forward;
            var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
            cm.moveH(-increment, 'char');
            motionArgs.inclusive = forward ? true : false;
            var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
            if (!curEnd) {
              cm.moveH(increment, 'char');
              return head;
            }
            curEnd.ch += increment;
            return curEnd;
          }
        };

        function defineMotion(name, fn) {
          motions[name] = fn;
        }

        function fillArray(val, times) {
          var arr = [];
          for (var i = 0; i < times; i++) {
            arr.push(val);
          }
          return arr;
        }
        /**
         * An operator acts on a text selection. It receives the list of selections
         * as input. The corresponding CodeMirror selection is guaranteed to
        * match the input selection.
         */
        var operators = {
          change: function(cm, args, ranges) {
            var finalHead, text;
            var vim = cm.state.vim;
            var anchor = ranges[0].anchor,
                head = ranges[0].head;
            if (!vim.visualMode) {
              text = cm.getRange(anchor, head);
              var lastState = vim.lastEditInputState || {};
              if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
                // Exclude trailing whitespace if the range is not all whitespace.
                var match = (/\s+$/).exec(text);
                if (match && lastState.motionArgs && lastState.motionArgs.forward) {
                  head = offsetCursor(head, 0, - match[0].length);
                  text = text.slice(0, - match[0].length);
                }
              }
              var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
              var wasLastLine = cm.firstLine() == cm.lastLine();
              if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {
                cm.replaceRange('', prevLineEnd, head);
              } else {
                cm.replaceRange('', anchor, head);
              }
              if (args.linewise) {
                // Push the next line back down, if there is a next line.
                if (!wasLastLine) {
                  cm.setCursor(prevLineEnd);
                  CodeMirror.commands.newlineAndIndent(cm);
                }
                // make sure cursor ends up at the end of the line.
                anchor.ch = Number.MAX_VALUE;
              }
              finalHead = anchor;
            } else if (args.fullLine) {
                head.ch = Number.MAX_VALUE;
                head.line--;
                cm.setSelection(anchor, head)
                text = cm.getSelection();
                cm.replaceSelection("");
                finalHead = anchor;
            } else {
              text = cm.getSelection();
              var replacement = fillArray('', ranges.length);
              cm.replaceSelections(replacement);
              finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
            }
            vimGlobalState.registerController.pushText(
                args.registerName, 'change', text,
                args.linewise, ranges.length > 1);
            actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);
          },
          // delete is a javascript keyword.
          'delete': function(cm, args, ranges) {
            var finalHead, text;
            var vim = cm.state.vim;
            if (!vim.visualBlock) {
              var anchor = ranges[0].anchor,
                  head = ranges[0].head;
              if (args.linewise &&
                  head.line != cm.firstLine() &&
                  anchor.line == cm.lastLine() &&
                  anchor.line == head.line - 1) {
                // Special case for dd on last line (and first line).
                if (anchor.line == cm.firstLine()) {
                  anchor.ch = 0;
                } else {
                  anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
                }
              }
              text = cm.getRange(anchor, head);
              cm.replaceRange('', anchor, head);
              finalHead = anchor;
              if (args.linewise) {
                finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
              }
            } else {
              text = cm.getSelection();
              var replacement = fillArray('', ranges.length);
              cm.replaceSelections(replacement);
              finalHead = ranges[0].anchor;
            }
            vimGlobalState.registerController.pushText(
                args.registerName, 'delete', text,
                args.linewise, vim.visualBlock);
            return clipCursorToContent(cm, finalHead);
          },
          indent: function(cm, args, ranges) {
            var vim = cm.state.vim;
            var startLine = ranges[0].anchor.line;
            var endLine = vim.visualBlock ?
              ranges[ranges.length - 1].anchor.line :
              ranges[0].head.line;
            // In visual mode, n> shifts the selection right n times, instead of
            // shifting n lines right once.
            var repeat = (vim.visualMode) ? args.repeat : 1;
            if (args.linewise) {
              // The only way to delete a newline is to delete until the start of
              // the next line, so in linewise mode evalInput will include the next
              // line. We don't want this in indent, so we go back a line.
              endLine--;
            }
            for (var i = startLine; i <= endLine; i++) {
              for (var j = 0; j < repeat; j++) {
                cm.indentLine(i, args.indentRight);
              }
            }
            return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
          },
          indentAuto: function(cm, _args, ranges) {
            cm.execCommand("indentAuto");
            return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
          },
          changeCase: function(cm, args, ranges, oldAnchor, newHead) {
            var selections = cm.getSelections();
            var swapped = [];
            var toLower = args.toLower;
            for (var j = 0; j < selections.length; j++) {
              var toSwap = selections[j];
              var text = '';
              if (toLower === true) {
                text = toSwap.toLowerCase();
              } else if (toLower === false) {
                text = toSwap.toUpperCase();
              } else {
                for (var i = 0; i < toSwap.length; i++) {
                  var character = toSwap.charAt(i);
                  text += isUpperCase(character) ? character.toLowerCase() :
                      character.toUpperCase();
                }
              }
              swapped.push(text);
            }
            cm.replaceSelections(swapped);
            if (args.shouldMoveCursor){
              return newHead;
            } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
              return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
            } else if (args.linewise){
              return oldAnchor;
            } else {
              return cursorMin(ranges[0].anchor, ranges[0].head);
            }
          },
          yank: function(cm, args, ranges, oldAnchor) {
            var vim = cm.state.vim;
            var text = cm.getSelection();
            var endPos = vim.visualMode
              ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)
              : oldAnchor;
            vimGlobalState.registerController.pushText(
                args.registerName, 'yank',
                text, args.linewise, vim.visualBlock);
            return endPos;
          }
        };

        function defineOperator(name, fn) {
          operators[name] = fn;
        }

        var actions = {
          jumpListWalk: function(cm, actionArgs, vim) {
            if (vim.visualMode) {
              return;
            }
            var repeat = actionArgs.repeat;
            var forward = actionArgs.forward;
            var jumpList = vimGlobalState.jumpList;

            var mark = jumpList.move(cm, forward ? repeat : -repeat);
            var markPos = mark ? mark.find() : undefined;
            markPos = markPos ? markPos : cm.getCursor();
            cm.setCursor(markPos);
          },
          scroll: function(cm, actionArgs, vim) {
            if (vim.visualMode) {
              return;
            }
            var repeat = actionArgs.repeat || 1;
            var lineHeight = cm.defaultTextHeight();
            var top = cm.getScrollInfo().top;
            var delta = lineHeight * repeat;
            var newPos = actionArgs.forward ? top + delta : top - delta;
            var cursor = copyCursor(cm.getCursor());
            var cursorCoords = cm.charCoords(cursor, 'local');
            if (actionArgs.forward) {
              if (newPos > cursorCoords.top) {
                 cursor.line += (newPos - cursorCoords.top) / lineHeight;
                 cursor.line = Math.ceil(cursor.line);
                 cm.setCursor(cursor);
                 cursorCoords = cm.charCoords(cursor, 'local');
                 cm.scrollTo(null, cursorCoords.top);
              } else {
                 // Cursor stays within bounds.  Just reposition the scroll window.
                 cm.scrollTo(null, newPos);
              }
            } else {
              var newBottom = newPos + cm.getScrollInfo().clientHeight;
              if (newBottom < cursorCoords.bottom) {
                 cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
                 cursor.line = Math.floor(cursor.line);
                 cm.setCursor(cursor);
                 cursorCoords = cm.charCoords(cursor, 'local');
                 cm.scrollTo(
                     null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
              } else {
                 // Cursor stays within bounds.  Just reposition the scroll window.
                 cm.scrollTo(null, newPos);
              }
            }
          },
          scrollToCursor: function(cm, actionArgs) {
            var lineNum = cm.getCursor().line;
            var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');
            var height = cm.getScrollInfo().clientHeight;
            var y = charCoords.top;
            var lineHeight = charCoords.bottom - y;
            switch (actionArgs.position) {
              case 'center': y = y - (height / 2) + lineHeight;
                break;
              case 'bottom': y = y - height + lineHeight;
                break;
            }
            cm.scrollTo(null, y);
          },
          replayMacro: function(cm, actionArgs, vim) {
            var registerName = actionArgs.selectedCharacter;
            var repeat = actionArgs.repeat;
            var macroModeState = vimGlobalState.macroModeState;
            if (registerName == '@') {
              registerName = macroModeState.latestRegister;
            } else {
              macroModeState.latestRegister = registerName;
            }
            while(repeat--){
              executeMacroRegister(cm, vim, macroModeState, registerName);
            }
          },
          enterMacroRecordMode: function(cm, actionArgs) {
            var macroModeState = vimGlobalState.macroModeState;
            var registerName = actionArgs.selectedCharacter;
            if (vimGlobalState.registerController.isValidRegister(registerName)) {
              macroModeState.enterMacroRecordMode(cm, registerName);
            }
          },
          toggleOverwrite: function(cm) {
            if (!cm.state.overwrite) {
              cm.toggleOverwrite(true);
              cm.setOption('keyMap', 'vim-replace');
              CodeMirror.signal(cm, "vim-mode-change", {mode: "replace"});
            } else {
              cm.toggleOverwrite(false);
              cm.setOption('keyMap', 'vim-insert');
              CodeMirror.signal(cm, "vim-mode-change", {mode: "insert"});
            }
          },
          enterInsertMode: function(cm, actionArgs, vim) {
            if (cm.getOption('readOnly')) { return; }
            vim.insertMode = true;
            vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
            var insertAt = (actionArgs) ? actionArgs.insertAt : null;
            var sel = vim.sel;
            var head = actionArgs.head || cm.getCursor('head');
            var height = cm.listSelections().length;
            if (insertAt == 'eol') {
              head = Pos(head.line, lineLength(cm, head.line));
            } else if (insertAt == 'bol') {
              head = Pos(head.line, 0);
            } else if (insertAt == 'charAfter') {
              head = offsetCursor(head, 0, 1);
            } else if (insertAt == 'firstNonBlank') {
              head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
            } else if (insertAt == 'startOfSelectedArea') {
              if (!vim.visualMode)
                  return;
              if (!vim.visualBlock) {
                if (sel.head.line < sel.anchor.line) {
                  head = sel.head;
                } else {
                  head = Pos(sel.anchor.line, 0);
                }
              } else {
                head = Pos(
                    Math.min(sel.head.line, sel.anchor.line),
                    Math.min(sel.head.ch, sel.anchor.ch));
                height = Math.abs(sel.head.line - sel.anchor.line) + 1;
              }
            } else if (insertAt == 'endOfSelectedArea') {
                if (!vim.visualMode)
                  return;
              if (!vim.visualBlock) {
                if (sel.head.line >= sel.anchor.line) {
                  head = offsetCursor(sel.head, 0, 1);
                } else {
                  head = Pos(sel.anchor.line, 0);
                }
              } else {
                head = Pos(
                    Math.min(sel.head.line, sel.anchor.line),
                    Math.max(sel.head.ch + 1, sel.anchor.ch));
                height = Math.abs(sel.head.line - sel.anchor.line) + 1;
              }
            } else if (insertAt == 'inplace') {
              if (vim.visualMode){
                return;
              }
            } else if (insertAt == 'lastEdit') {
              head = getLastEditPos(cm) || head;
            }
            cm.setOption('disableInput', false);
            if (actionArgs && actionArgs.replace) {
              // Handle Replace-mode as a special case of insert mode.
              cm.toggleOverwrite(true);
              cm.setOption('keyMap', 'vim-replace');
              CodeMirror.signal(cm, "vim-mode-change", {mode: "replace"});
            } else {
              cm.toggleOverwrite(false);
              cm.setOption('keyMap', 'vim-insert');
              CodeMirror.signal(cm, "vim-mode-change", {mode: "insert"});
            }
            if (!vimGlobalState.macroModeState.isPlaying) {
              // Only record if not replaying.
              cm.on('change', onChange);
              CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
            }
            if (vim.visualMode) {
              exitVisualMode(cm);
            }
            selectForInsert(cm, head, height);
          },
          toggleVisualMode: function(cm, actionArgs, vim) {
            var repeat = actionArgs.repeat;
            var anchor = cm.getCursor();
            var head;
            // TODO: The repeat should actually select number of characters/lines
            //     equal to the repeat times the size of the previous visual
            //     operation.
            if (!vim.visualMode) {
              // Entering visual mode
              vim.visualMode = true;
              vim.visualLine = !!actionArgs.linewise;
              vim.visualBlock = !!actionArgs.blockwise;
              head = clipCursorToContent(
                  cm, Pos(anchor.line, anchor.ch + repeat - 1));
              vim.sel = {
                anchor: anchor,
                head: head
              };
              CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""});
              updateCmSelection(cm);
              updateMark(cm, vim, '<', cursorMin(anchor, head));
              updateMark(cm, vim, '>', cursorMax(anchor, head));
            } else if (vim.visualLine ^ actionArgs.linewise ||
                vim.visualBlock ^ actionArgs.blockwise) {
              // Toggling between modes
              vim.visualLine = !!actionArgs.linewise;
              vim.visualBlock = !!actionArgs.blockwise;
              CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""});
              updateCmSelection(cm);
            } else {
              exitVisualMode(cm);
            }
          },
          reselectLastSelection: function(cm, _actionArgs, vim) {
            var lastSelection = vim.lastSelection;
            if (vim.visualMode) {
              updateLastSelection(cm, vim);
            }
            if (lastSelection) {
              var anchor = lastSelection.anchorMark.find();
              var head = lastSelection.headMark.find();
              if (!anchor || !head) {
                // If the marks have been destroyed due to edits, do nothing.
                return;
              }
              vim.sel = {
                anchor: anchor,
                head: head
              };
              vim.visualMode = true;
              vim.visualLine = lastSelection.visualLine;
              vim.visualBlock = lastSelection.visualBlock;
              updateCmSelection(cm);
              updateMark(cm, vim, '<', cursorMin(anchor, head));
              updateMark(cm, vim, '>', cursorMax(anchor, head));
              CodeMirror.signal(cm, 'vim-mode-change', {
                mode: 'visual',
                subMode: vim.visualLine ? 'linewise' :
                         vim.visualBlock ? 'blockwise' : ''});
            }
          },
          joinLines: function(cm, actionArgs, vim) {
            var curStart, curEnd;
            if (vim.visualMode) {
              curStart = cm.getCursor('anchor');
              curEnd = cm.getCursor('head');
              if (cursorIsBefore(curEnd, curStart)) {
                var tmp = curEnd;
                curEnd = curStart;
                curStart = tmp;
              }
              curEnd.ch = lineLength(cm, curEnd.line) - 1;
            } else {
              // Repeat is the number of lines to join. Minimum 2 lines.
              var repeat = Math.max(actionArgs.repeat, 2);
              curStart = cm.getCursor();
              curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,
                                                   Infinity));
            }
            var finalCh = 0;
            for (var i = curStart.line; i < curEnd.line; i++) {
              finalCh = lineLength(cm, curStart.line);
              var tmp = Pos(curStart.line + 1,
                            lineLength(cm, curStart.line + 1));
              var text = cm.getRange(curStart, tmp);
              text = actionArgs.keepSpaces
                ? text.replace(/\n\r?/g, '')
                : text.replace(/\n\s*/g, ' ');
              cm.replaceRange(text, curStart, tmp);
            }
            var curFinalPos = Pos(curStart.line, finalCh);
            if (vim.visualMode) {
              exitVisualMode(cm, false);
            }
            cm.setCursor(curFinalPos);
          },
          newLineAndEnterInsertMode: function(cm, actionArgs, vim) {
            vim.insertMode = true;
            var insertAt = copyCursor(cm.getCursor());
            if (insertAt.line === cm.firstLine() && !actionArgs.after) {
              // Special case for inserting newline before start of document.
              cm.replaceRange('\n', Pos(cm.firstLine(), 0));
              cm.setCursor(cm.firstLine(), 0);
            } else {
              insertAt.line = (actionArgs.after) ? insertAt.line :
                  insertAt.line - 1;
              insertAt.ch = lineLength(cm, insertAt.line);
              cm.setCursor(insertAt);
              var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||
                  CodeMirror.commands.newlineAndIndent;
              newlineFn(cm);
            }
            this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
          },
          paste: function(cm, actionArgs, vim) {
            var cur = copyCursor(cm.getCursor());
            var register = vimGlobalState.registerController.getRegister(
                actionArgs.registerName);
            var text = register.toString();
            if (!text) {
              return;
            }
            if (actionArgs.matchIndent) {
              var tabSize = cm.getOption("tabSize");
              // length that considers tabs and tabSize
              var whitespaceLength = function(str) {
                var tabs = (str.split("\t").length - 1);
                var spaces = (str.split(" ").length - 1);
                return tabs * tabSize + spaces * 1;
              };
              var currentLine = cm.getLine(cm.getCursor().line);
              var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
              // chomp last newline b/c don't want it to match /^\s*/gm
              var chompedText = text.replace(/\n$/, '');
              var wasChomped = text !== chompedText;
              var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
              var text = chompedText.replace(/^\s*/gm, function(wspace) {
                var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
                if (newIndent < 0) {
                  return "";
                }
                else if (cm.getOption("indentWithTabs")) {
                  var quotient = Math.floor(newIndent / tabSize);
                  return Array(quotient + 1).join('\t');
                }
                else {
                  return Array(newIndent + 1).join(' ');
                }
              });
              text += wasChomped ? "\n" : "";
            }
            if (actionArgs.repeat > 1) {
              var text = Array(actionArgs.repeat + 1).join(text);
            }
            var linewise = register.linewise;
            var blockwise = register.blockwise;
            if (blockwise) {
              text = text.split('\n');
              if (linewise) {
                  text.pop();
              }
              for (var i = 0; i < text.length; i++) {
                text[i] = (text[i] == '') ? ' ' : text[i];
              }
              cur.ch += actionArgs.after ? 1 : 0;
              cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
            } else if (linewise) {
              if(vim.visualMode) {
                text = vim.visualLine ? text.slice(0, -1) : '\n' + text.slice(0, text.length - 1) + '\n';
              } else if (actionArgs.after) {
                // Move the newline at the end to the start instead, and paste just
                // before the newline character of the line we are on right now.
                text = '\n' + text.slice(0, text.length - 1);
                cur.ch = lineLength(cm, cur.line);
              } else {
                cur.ch = 0;
              }
            } else {
              cur.ch += actionArgs.after ? 1 : 0;
            }
            var curPosFinal;
            var idx;
            if (vim.visualMode) {
              //  save the pasted text for reselection if the need arises
              vim.lastPastedText = text;
              var lastSelectionCurEnd;
              var selectedArea = getSelectedAreaRange(cm, vim);
              var selectionStart = selectedArea[0];
              var selectionEnd = selectedArea[1];
              var selectedText = cm.getSelection();
              var selections = cm.listSelections();
              var emptyStrings = new Array(selections.length).join('1').split('1');
              // save the curEnd marker before it get cleared due to cm.replaceRange.
              if (vim.lastSelection) {
                lastSelectionCurEnd = vim.lastSelection.headMark.find();
              }
              // push the previously selected text to unnamed register
              vimGlobalState.registerController.unnamedRegister.setText(selectedText);
              if (blockwise) {
                // first delete the selected text
                cm.replaceSelections(emptyStrings);
                // Set new selections as per the block length of the yanked text
                selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);
                cm.setCursor(selectionStart);
                selectBlock(cm, selectionEnd);
                cm.replaceSelections(text);
                curPosFinal = selectionStart;
              } else if (vim.visualBlock) {
                cm.replaceSelections(emptyStrings);
                cm.setCursor(selectionStart);
                cm.replaceRange(text, selectionStart, selectionStart);
                curPosFinal = selectionStart;
              } else {
                cm.replaceRange(text, selectionStart, selectionEnd);
                curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
              }
              // restore the the curEnd marker
              if(lastSelectionCurEnd) {
                vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
              }
              if (linewise) {
                curPosFinal.ch=0;
              }
            } else {
              if (blockwise) {
                cm.setCursor(cur);
                for (var i = 0; i < text.length; i++) {
                  var line = cur.line+i;
                  if (line > cm.lastLine()) {
                    cm.replaceRange('\n',  Pos(line, 0));
                  }
                  var lastCh = lineLength(cm, line);
                  if (lastCh < cur.ch) {
                    extendLineToColumn(cm, line, cur.ch);
                  }
                }
                cm.setCursor(cur);
                selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));
                cm.replaceSelections(text);
                curPosFinal = cur;
              } else {
                cm.replaceRange(text, cur);
                // Now fine tune the cursor to where we want it.
                if (linewise && actionArgs.after) {
                  curPosFinal = Pos(
                  cur.line + 1,
                  findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
                } else if (linewise && !actionArgs.after) {
                  curPosFinal = Pos(
                    cur.line,
                    findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
                } else if (!linewise && actionArgs.after) {
                  idx = cm.indexFromPos(cur);
                  curPosFinal = cm.posFromIndex(idx + text.length - 1);
                } else {
                  idx = cm.indexFromPos(cur);
                  curPosFinal = cm.posFromIndex(idx + text.length);
                }
              }
            }
            if (vim.visualMode) {
              exitVisualMode(cm, false);
            }
            cm.setCursor(curPosFinal);
          },
          undo: function(cm, actionArgs) {
            cm.operation(function() {
              repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
              cm.setCursor(cm.getCursor('anchor'));
            });
          },
          redo: function(cm, actionArgs) {
            repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
          },
          setRegister: function(_cm, actionArgs, vim) {
            vim.inputState.registerName = actionArgs.selectedCharacter;
          },
          setMark: function(cm, actionArgs, vim) {
            var markName = actionArgs.selectedCharacter;
            updateMark(cm, vim, markName, cm.getCursor());
          },
          replace: function(cm, actionArgs, vim) {
            var replaceWith = actionArgs.selectedCharacter;
            var curStart = cm.getCursor();
            var replaceTo;
            var curEnd;
            var selections = cm.listSelections();
            if (vim.visualMode) {
              curStart = cm.getCursor('start');
              curEnd = cm.getCursor('end');
            } else {
              var line = cm.getLine(curStart.line);
              replaceTo = curStart.ch + actionArgs.repeat;
              if (replaceTo > line.length) {
                replaceTo=line.length;
              }
              curEnd = Pos(curStart.line, replaceTo);
            }
            if (replaceWith=='\n') {
              if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);
              // special case, where vim help says to replace by just one line-break
              (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
            } else {
              var replaceWithStr = cm.getRange(curStart, curEnd);
              //replace all characters in range by selected, but keep linebreaks
              replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
              if (vim.visualBlock) {
                // Tabs are split in visua block before replacing
                var spaces = new Array(cm.getOption("tabSize")+1).join(' ');
                replaceWithStr = cm.getSelection();
                replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split('\n');
                cm.replaceSelections(replaceWithStr);
              } else {
                cm.replaceRange(replaceWithStr, curStart, curEnd);
              }
              if (vim.visualMode) {
                curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?
                             selections[0].anchor : selections[0].head;
                cm.setCursor(curStart);
                exitVisualMode(cm, false);
              } else {
                cm.setCursor(offsetCursor(curEnd, 0, -1));
              }
            }
          },
          incrementNumberToken: function(cm, actionArgs) {
            var cur = cm.getCursor();
            var lineStr = cm.getLine(cur.line);
            var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
            var match;
            var start;
            var end;
            var numberStr;
            while ((match = re.exec(lineStr)) !== null) {
              start = match.index;
              end = start + match[0].length;
              if (cur.ch < end)break;
            }
            if (!actionArgs.backtrack && (end <= cur.ch))return;
            if (match) {
              var baseStr = match[2] || match[4]
              var digits = match[3] || match[5]
              var increment = actionArgs.increase ? 1 : -1;
              var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];
              var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);
              numberStr = number.toString(base);
              var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''
              if (numberStr.charAt(0) === '-') {
                numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);
              } else {
                numberStr = baseStr + zeroPadding + numberStr;
              }
              var from = Pos(cur.line, start);
              var to = Pos(cur.line, end);
              cm.replaceRange(numberStr, from, to);
            } else {
              return;
            }
            cm.setCursor(Pos(cur.line, start + numberStr.length - 1));
          },
          repeatLastEdit: function(cm, actionArgs, vim) {
            var lastEditInputState = vim.lastEditInputState;
            if (!lastEditInputState) { return; }
            var repeat = actionArgs.repeat;
            if (repeat && actionArgs.repeatIsExplicit) {
              vim.lastEditInputState.repeatOverride = repeat;
            } else {
              repeat = vim.lastEditInputState.repeatOverride || repeat;
            }
            repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);
          },
          indent: function(cm, actionArgs) {
            cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
          },
          exitInsertMode: exitInsertMode
        };

        function defineAction(name, fn) {
          actions[name] = fn;
        }

        /*
         * Below are miscellaneous utility functions used by vim.js
         */

        /**
         * Clips cursor to ensure that line is within the buffer's range
         * If includeLineBreak is true, then allow cur.ch == lineLength.
         */
        function clipCursorToContent(cm, cur) {
          var vim = cm.state.vim;
          var includeLineBreak = vim.insertMode || vim.visualMode;
          var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );
          var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;
          var ch = Math.min(Math.max(0, cur.ch), maxCh);
          return Pos(line, ch);
        }
        function copyArgs(args) {
          var ret = {};
          for (var prop in args) {
            if (args.hasOwnProperty(prop)) {
              ret[prop] = args[prop];
            }
          }
          return ret;
        }
        function offsetCursor(cur, offsetLine, offsetCh) {
          if (typeof offsetLine === 'object') {
            offsetCh = offsetLine.ch;
            offsetLine = offsetLine.line;
          }
          return Pos(cur.line + offsetLine, cur.ch + offsetCh);
        }
        function commandMatches(keys, keyMap, context, inputState) {
          // Partial matches are not applied. They inform the key handler
          // that the current key sequence is a subsequence of a valid key
          // sequence, so that the key buffer is not cleared.
          var match, partial = [], full = [];
          for (var i = 0; i < keyMap.length; i++) {
            var command = keyMap[i];
            if (context == 'insert' && command.context != 'insert' ||
                command.context && command.context != context ||
                inputState.operator && command.type == 'action' ||
                !(match = commandMatch(keys, command.keys))) { continue; }
            if (match == 'partial') { partial.push(command); }
            if (match == 'full') { full.push(command); }
          }
          return {
            partial: partial.length && partial,
            full: full.length && full
          };
        }
        function commandMatch(pressed, mapped) {
          if (mapped.slice(-11) == '<character>') {
            // Last character matches anything.
            var prefixLen = mapped.length - 11;
            var pressedPrefix = pressed.slice(0, prefixLen);
            var mappedPrefix = mapped.slice(0, prefixLen);
            return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :
                   mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;
          } else {
            return pressed == mapped ? 'full' :
                   mapped.indexOf(pressed) == 0 ? 'partial' : false;
          }
        }
        function lastChar(keys) {
          var match = /^.*(<[^>]+>)$/.exec(keys);
          var selectedCharacter = match ? match[1] : keys.slice(-1);
          if (selectedCharacter.length > 1){
            switch(selectedCharacter){
              case '<CR>':
                selectedCharacter='\n';
                break;
              case '<Space>':
                selectedCharacter=' ';
                break;
              default:
                selectedCharacter='';
                break;
            }
          }
          return selectedCharacter;
        }
        function repeatFn(cm, fn, repeat) {
          return function() {
            for (var i = 0; i < repeat; i++) {
              fn(cm);
            }
          };
        }
        function copyCursor(cur) {
          return Pos(cur.line, cur.ch);
        }
        function cursorEqual(cur1, cur2) {
          return cur1.ch == cur2.ch && cur1.line == cur2.line;
        }
        function cursorIsBefore(cur1, cur2) {
          if (cur1.line < cur2.line) {
            return true;
          }
          if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
            return true;
          }
          return false;
        }
        function cursorMin(cur1, cur2) {
          if (arguments.length > 2) {
            cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));
          }
          return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
        }
        function cursorMax(cur1, cur2) {
          if (arguments.length > 2) {
            cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));
          }
          return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
        }
        function cursorIsBetween(cur1, cur2, cur3) {
          // returns true if cur2 is between cur1 and cur3.
          var cur1before2 = cursorIsBefore(cur1, cur2);
          var cur2before3 = cursorIsBefore(cur2, cur3);
          return cur1before2 && cur2before3;
        }
        function lineLength(cm, lineNum) {
          return cm.getLine(lineNum).length;
        }
        function trim(s) {
          if (s.trim) {
            return s.trim();
          }
          return s.replace(/^\s+|\s+$/g, '');
        }
        function escapeRegex(s) {
          return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, '\\$1');
        }
        function extendLineToColumn(cm, lineNum, column) {
          var endCh = lineLength(cm, lineNum);
          var spaces = new Array(column-endCh+1).join(' ');
          cm.setCursor(Pos(lineNum, endCh));
          cm.replaceRange(spaces, cm.getCursor());
        }
        // This functions selects a rectangular block
        // of text with selectionEnd as any of its corner
        // Height of block:
        // Difference in selectionEnd.line and first/last selection.line
        // Width of the block:
        // Distance between selectionEnd.ch and any(first considered here) selection.ch
        function selectBlock(cm, selectionEnd) {
          var selections = [], ranges = cm.listSelections();
          var head = copyCursor(cm.clipPos(selectionEnd));
          var isClipped = !cursorEqual(selectionEnd, head);
          var curHead = cm.getCursor('head');
          var primIndex = getIndex(ranges, curHead);
          var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
          var max = ranges.length - 1;
          var index = max - primIndex > primIndex ? max : 0;
          var base = ranges[index].anchor;

          var firstLine = Math.min(base.line, head.line);
          var lastLine = Math.max(base.line, head.line);
          var baseCh = base.ch, headCh = head.ch;

          var dir = ranges[index].head.ch - baseCh;
          var newDir = headCh - baseCh;
          if (dir > 0 && newDir <= 0) {
            baseCh++;
            if (!isClipped) { headCh--; }
          } else if (dir < 0 && newDir >= 0) {
            baseCh--;
            if (!wasClipped) { headCh++; }
          } else if (dir < 0 && newDir == -1) {
            baseCh--;
            headCh++;
          }
          for (var line = firstLine; line <= lastLine; line++) {
            var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};
            selections.push(range);
          }
          cm.setSelections(selections);
          selectionEnd.ch = headCh;
          base.ch = baseCh;
          return base;
        }
        function selectForInsert(cm, head, height) {
          var sel = [];
          for (var i = 0; i < height; i++) {
            var lineHead = offsetCursor(head, i, 0);
            sel.push({anchor: lineHead, head: lineHead});
          }
          cm.setSelections(sel, 0);
        }
        // getIndex returns the index of the cursor in the selections.
        function getIndex(ranges, cursor, end) {
          for (var i = 0; i < ranges.length; i++) {
            var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);
            var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);
            if (atAnchor || atHead) {
              return i;
            }
          }
          return -1;
        }
        function getSelectedAreaRange(cm, vim) {
          var lastSelection = vim.lastSelection;
          var getCurrentSelectedAreaRange = function() {
            var selections = cm.listSelections();
            var start =  selections[0];
            var end = selections[selections.length-1];
            var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
            var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
            return [selectionStart, selectionEnd];
          };
          var getLastSelectedAreaRange = function() {
            var selectionStart = cm.getCursor();
            var selectionEnd = cm.getCursor();
            var block = lastSelection.visualBlock;
            if (block) {
              var width = block.width;
              var height = block.height;
              selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);
              var selections = [];
              // selectBlock creates a 'proper' rectangular block.
              // We do not want that in all cases, so we manually set selections.
              for (var i = selectionStart.line; i < selectionEnd.line; i++) {
                var anchor = Pos(i, selectionStart.ch);
                var head = Pos(i, selectionEnd.ch);
                var range = {anchor: anchor, head: head};
                selections.push(range);
              }
              cm.setSelections(selections);
            } else {
              var start = lastSelection.anchorMark.find();
              var end = lastSelection.headMark.find();
              var line = end.line - start.line;
              var ch = end.ch - start.ch;
              selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};
              if (lastSelection.visualLine) {
                selectionStart = Pos(selectionStart.line, 0);
                selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
              }
              cm.setSelection(selectionStart, selectionEnd);
            }
            return [selectionStart, selectionEnd];
          };
          if (!vim.visualMode) {
          // In case of replaying the action.
            return getLastSelectedAreaRange();
          } else {
            return getCurrentSelectedAreaRange();
          }
        }
        // Updates the previous selection with the current selection's values. This
        // should only be called in visual mode.
        function updateLastSelection(cm, vim) {
          var anchor = vim.sel.anchor;
          var head = vim.sel.head;
          // To accommodate the effect of lastPastedText in the last selection
          if (vim.lastPastedText) {
            head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
            vim.lastPastedText = null;
          }
          vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),
                               'headMark': cm.setBookmark(head),
                               'anchor': copyCursor(anchor),
                               'head': copyCursor(head),
                               'visualMode': vim.visualMode,
                               'visualLine': vim.visualLine,
                               'visualBlock': vim.visualBlock};
        }
        function expandSelection(cm, start, end) {
          var sel = cm.state.vim.sel;
          var head = sel.head;
          var anchor = sel.anchor;
          var tmp;
          if (cursorIsBefore(end, start)) {
            tmp = end;
            end = start;
            start = tmp;
          }
          if (cursorIsBefore(head, anchor)) {
            head = cursorMin(start, head);
            anchor = cursorMax(anchor, end);
          } else {
            anchor = cursorMin(start, anchor);
            head = cursorMax(head, end);
            head = offsetCursor(head, 0, -1);
            if (head.ch == -1 && head.line != cm.firstLine()) {
              head = Pos(head.line - 1, lineLength(cm, head.line - 1));
            }
          }
          return [anchor, head];
        }
        /**
         * Updates the CodeMirror selection to match the provided vim selection.
         * If no arguments are given, it uses the current vim selection state.
         */
        function updateCmSelection(cm, sel, mode) {
          var vim = cm.state.vim;
          sel = sel || vim.sel;
          var mode = mode ||
            vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';
          var cmSel = makeCmSelection(cm, sel, mode);
          cm.setSelections(cmSel.ranges, cmSel.primary);
          updateFakeCursor(cm);
        }
        function makeCmSelection(cm, sel, mode, exclusive) {
          var head = copyCursor(sel.head);
          var anchor = copyCursor(sel.anchor);
          if (mode == 'char') {
            var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
            var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
            head = offsetCursor(sel.head, 0, headOffset);
            anchor = offsetCursor(sel.anchor, 0, anchorOffset);
            return {
              ranges: [{anchor: anchor, head: head}],
              primary: 0
            };
          } else if (mode == 'line') {
            if (!cursorIsBefore(sel.head, sel.anchor)) {
              anchor.ch = 0;

              var lastLine = cm.lastLine();
              if (head.line > lastLine) {
                head.line = lastLine;
              }
              head.ch = lineLength(cm, head.line);
            } else {
              head.ch = 0;
              anchor.ch = lineLength(cm, anchor.line);
            }
            return {
              ranges: [{anchor: anchor, head: head}],
              primary: 0
            };
          } else if (mode == 'block') {
            var top = Math.min(anchor.line, head.line),
                left = Math.min(anchor.ch, head.ch),
                bottom = Math.max(anchor.line, head.line),
                right = Math.max(anchor.ch, head.ch) + 1;
            var height = bottom - top + 1;
            var primary = head.line == top ? 0 : height - 1;
            var ranges = [];
            for (var i = 0; i < height; i++) {
              ranges.push({
                anchor: Pos(top + i, left),
                head: Pos(top + i, right)
              });
            }
            return {
              ranges: ranges,
              primary: primary
            };
          }
        }
        function getHead(cm) {
          var cur = cm.getCursor('head');
          if (cm.getSelection().length == 1) {
            // Small corner case when only 1 character is selected. The "real"
            // head is the left of head and anchor.
            cur = cursorMin(cur, cm.getCursor('anchor'));
          }
          return cur;
        }

        /**
         * If moveHead is set to false, the CodeMirror selection will not be
         * touched. The caller assumes the responsibility of putting the cursor
        * in the right place.
         */
        function exitVisualMode(cm, moveHead) {
          var vim = cm.state.vim;
          if (moveHead !== false) {
            cm.setCursor(clipCursorToContent(cm, vim.sel.head));
          }
          updateLastSelection(cm, vim);
          vim.visualMode = false;
          vim.visualLine = false;
          vim.visualBlock = false;
          if (!vim.insertMode) CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
          clearFakeCursor(vim);
        }

        // Remove any trailing newlines from the selection. For
        // example, with the caret at the start of the last word on the line,
        // 'dw' should word, but not the newline, while 'w' should advance the
        // caret to the first character of the next line.
        function clipToLine(cm, curStart, curEnd) {
          var selection = cm.getRange(curStart, curEnd);
          // Only clip if the selection ends with trailing newline + whitespace
          if (/\n\s*$/.test(selection)) {
            var lines = selection.split('\n');
            // We know this is all whitespace.
            lines.pop();

            // Cases:
            // 1. Last word is an empty line - do not clip the trailing '\n'
            // 2. Last word is not an empty line - clip the trailing '\n'
            var line;
            // Find the line containing the last word, and clip all whitespace up
            // to it.
            for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
              curEnd.line--;
              curEnd.ch = 0;
            }
            // If the last word is not an empty line, clip an additional newline
            if (line) {
              curEnd.line--;
              curEnd.ch = lineLength(cm, curEnd.line);
            } else {
              curEnd.ch = 0;
            }
          }
        }

        // Expand the selection to line ends.
        function expandSelectionToLine(_cm, curStart, curEnd) {
          curStart.ch = 0;
          curEnd.ch = 0;
          curEnd.line++;
        }

        function findFirstNonWhiteSpaceCharacter(text) {
          if (!text) {
            return 0;
          }
          var firstNonWS = text.search(/\S/);
          return firstNonWS == -1 ? text.length : firstNonWS;
        }

        function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
          var cur = getHead(cm);
          var line = cm.getLine(cur.line);
          var idx = cur.ch;

          // Seek to first word or non-whitespace character, depending on if
          // noSymbol is true.
          var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];
          while (!test(line.charAt(idx))) {
            idx++;
            if (idx >= line.length) { return null; }
          }

          if (bigWord) {
            test = bigWordCharTest[0];
          } else {
            test = wordCharTest[0];
            if (!test(line.charAt(idx))) {
              test = wordCharTest[1];
            }
          }

          var end = idx, start = idx;
          while (test(line.charAt(end)) && end < line.length) { end++; }
          while (test(line.charAt(start)) && start >= 0) { start--; }
          start++;

          if (inclusive) {
            // If present, include all whitespace after word.
            // Otherwise, include all whitespace before word, except indentation.
            var wordEnd = end;
            while (/\s/.test(line.charAt(end)) && end < line.length) { end++; }
            if (wordEnd == end) {
              var wordStart = start;
              while (/\s/.test(line.charAt(start - 1)) && start > 0) { start--; }
              if (!start) { start = wordStart; }
            }
          }
          return { start: Pos(cur.line, start), end: Pos(cur.line, end) };
        }

        /**
         * Depends on the following:
         *
         * - editor mode should be htmlmixedmode / xml
         * - mode/xml/xml.js should be loaded
         * - addon/fold/xml-fold.js should be loaded
         *
         * If any of the above requirements are not true, this function noops.
         *
         * This is _NOT_ a 100% accurate implementation of vim tag text objects.
         * The following caveats apply (based off cursory testing, I'm sure there
         * are other discrepancies):
         *
         * - Does not work inside comments:
         *   ```
         *   <!-- <div>broken</div> -->
         *   ```
         * - Does not work when tags have different cases:
         *   ```
         *   <div>broken</DIV>
         *   ```
         * - Does not work when cursor is inside a broken tag:
         *   ```
         *   <div><brok><en></div>
         *   ```
         */
        function expandTagUnderCursor(cm, head, inclusive) {
          var cur = head;
          if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {
            return { start: cur, end: cur };
          }

          var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);
          if (!tags || !tags.open || !tags.close) {
            return { start: cur, end: cur };
          }

          if (inclusive) {
            return { start: tags.open.from, end: tags.close.to };
          }
          return { start: tags.open.to, end: tags.close.from };
        }

        function recordJumpPosition(cm, oldCur, newCur) {
          if (!cursorEqual(oldCur, newCur)) {
            vimGlobalState.jumpList.add(cm, oldCur, newCur);
          }
        }

        function recordLastCharacterSearch(increment, args) {
            vimGlobalState.lastCharacterSearch.increment = increment;
            vimGlobalState.lastCharacterSearch.forward = args.forward;
            vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
        }

        var symbolToMode = {
            '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',
            '[': 'section', ']': 'section',
            '*': 'comment', '/': 'comment',
            'm': 'method', 'M': 'method',
            '#': 'preprocess'
        };
        var findSymbolModes = {
          bracket: {
            isComplete: function(state) {
              if (state.nextCh === state.symb) {
                state.depth++;
                if (state.depth >= 1)return true;
              } else if (state.nextCh === state.reverseSymb) {
                state.depth--;
              }
              return false;
            }
          },
          section: {
            init: function(state) {
              state.curMoveThrough = true;
              state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';
            },
            isComplete: function(state) {
              return state.index === 0 && state.nextCh === state.symb;
            }
          },
          comment: {
            isComplete: function(state) {
              var found = state.lastCh === '*' && state.nextCh === '/';
              state.lastCh = state.nextCh;
              return found;
            }
          },
          // TODO: The original Vim implementation only operates on level 1 and 2.
          // The current implementation doesn't check for code block level and
          // therefore it operates on any levels.
          method: {
            init: function(state) {
              state.symb = (state.symb === 'm' ? '{' : '}');
              state.reverseSymb = state.symb === '{' ? '}' : '{';
            },
            isComplete: function(state) {
              if (state.nextCh === state.symb)return true;
              return false;
            }
          },
          preprocess: {
            init: function(state) {
              state.index = 0;
            },
            isComplete: function(state) {
              if (state.nextCh === '#') {
                var token = state.lineText.match(/^#(\w+)/)[1];
                if (token === 'endif') {
                  if (state.forward && state.depth === 0) {
                    return true;
                  }
                  state.depth++;
                } else if (token === 'if') {
                  if (!state.forward && state.depth === 0) {
                    return true;
                  }
                  state.depth--;
                }
                if (token === 'else' && state.depth === 0)return true;
              }
              return false;
            }
          }
        };
        function findSymbol(cm, repeat, forward, symb) {
          var cur = copyCursor(cm.getCursor());
          var increment = forward ? 1 : -1;
          var endLine = forward ? cm.lineCount() : -1;
          var curCh = cur.ch;
          var line = cur.line;
          var lineText = cm.getLine(line);
          var state = {
            lineText: lineText,
            nextCh: lineText.charAt(curCh),
            lastCh: null,
            index: curCh,
            symb: symb,
            reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],
            forward: forward,
            depth: 0,
            curMoveThrough: false
          };
          var mode = symbolToMode[symb];
          if (!mode)return cur;
          var init = findSymbolModes[mode].init;
          var isComplete = findSymbolModes[mode].isComplete;
          if (init) { init(state); }
          while (line !== endLine && repeat) {
            state.index += increment;
            state.nextCh = state.lineText.charAt(state.index);
            if (!state.nextCh) {
              line += increment;
              state.lineText = cm.getLine(line) || '';
              if (increment > 0) {
                state.index = 0;
              } else {
                var lineLen = state.lineText.length;
                state.index = (lineLen > 0) ? (lineLen-1) : 0;
              }
              state.nextCh = state.lineText.charAt(state.index);
            }
            if (isComplete(state)) {
              cur.line = line;
              cur.ch = state.index;
              repeat--;
            }
          }
          if (state.nextCh || state.curMoveThrough) {
            return Pos(line, state.index);
          }
          return cur;
        }

        /*
         * Returns the boundaries of the next word. If the cursor in the middle of
         * the word, then returns the boundaries of the current word, starting at
         * the cursor. If the cursor is at the start/end of a word, and we are going
         * forward/backward, respectively, find the boundaries of the next word.
         *
         * @param {CodeMirror} cm CodeMirror object.
         * @param {Cursor} cur The cursor position.
         * @param {boolean} forward True to search forward. False to search
         *     backward.
         * @param {boolean} bigWord True if punctuation count as part of the word.
         *     False if only [a-zA-Z0-9] characters count as part of the word.
         * @param {boolean} emptyLineIsWord True if empty lines should be treated
         *     as words.
         * @return {Object{from:number, to:number, line: number}} The boundaries of
         *     the word, or null if there are no more words.
         */
        function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
          var lineNum = cur.line;
          var pos = cur.ch;
          var line = cm.getLine(lineNum);
          var dir = forward ? 1 : -1;
          var charTests = bigWord ? bigWordCharTest: wordCharTest;

          if (emptyLineIsWord && line == '') {
            lineNum += dir;
            line = cm.getLine(lineNum);
            if (!isLine(cm, lineNum)) {
              return null;
            }
            pos = (forward) ? 0 : line.length;
          }

          while (true) {
            if (emptyLineIsWord && line == '') {
              return { from: 0, to: 0, line: lineNum };
            }
            var stop = (dir > 0) ? line.length : -1;
            var wordStart = stop, wordEnd = stop;
            // Find bounds of next word.
            while (pos != stop) {
              var foundWord = false;
              for (var i = 0; i < charTests.length && !foundWord; ++i) {
                if (charTests[i](line.charAt(pos))) {
                  wordStart = pos;
                  // Advance to end of word.
                  while (pos != stop && charTests[i](line.charAt(pos))) {
                    pos += dir;
                  }
                  wordEnd = pos;
                  foundWord = wordStart != wordEnd;
                  if (wordStart == cur.ch && lineNum == cur.line &&
                      wordEnd == wordStart + dir) {
                    // We started at the end of a word. Find the next one.
                    continue;
                  } else {
                    return {
                      from: Math.min(wordStart, wordEnd + 1),
                      to: Math.max(wordStart, wordEnd),
                      line: lineNum };
                  }
                }
              }
              if (!foundWord) {
                pos += dir;
              }
            }
            // Advance to next/prev line.
            lineNum += dir;
            if (!isLine(cm, lineNum)) {
              return null;
            }
            line = cm.getLine(lineNum);
            pos = (dir > 0) ? 0 : line.length;
          }
        }

        /**
         * @param {CodeMirror} cm CodeMirror object.
         * @param {Pos} cur The position to start from.
         * @param {int} repeat Number of words to move past.
         * @param {boolean} forward True to search forward. False to search
         *     backward.
         * @param {boolean} wordEnd True to move to end of word. False to move to
         *     beginning of word.
         * @param {boolean} bigWord True if punctuation count as part of the word.
         *     False if only alphabet characters count as part of the word.
         * @return {Cursor} The position the cursor should move to.
         */
        function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
          var curStart = copyCursor(cur);
          var words = [];
          if (forward && !wordEnd || !forward && wordEnd) {
            repeat++;
          }
          // For 'e', empty lines are not considered words, go figure.
          var emptyLineIsWord = !(forward && wordEnd);
          for (var i = 0; i < repeat; i++) {
            var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
            if (!word) {
              var eodCh = lineLength(cm, cm.lastLine());
              words.push(forward
                  ? {line: cm.lastLine(), from: eodCh, to: eodCh}
                  : {line: 0, from: 0, to: 0});
              break;
            }
            words.push(word);
            cur = Pos(word.line, forward ? (word.to - 1) : word.from);
          }
          var shortCircuit = words.length != repeat;
          var firstWord = words[0];
          var lastWord = words.pop();
          if (forward && !wordEnd) {
            // w
            if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
              // We did not start in the middle of a word. Discard the extra word at the end.
              lastWord = words.pop();
            }
            return Pos(lastWord.line, lastWord.from);
          } else if (forward && wordEnd) {
            return Pos(lastWord.line, lastWord.to - 1);
          } else if (!forward && wordEnd) {
            // ge
            if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
              // We did not start in the middle of a word. Discard the extra word at the end.
              lastWord = words.pop();
            }
            return Pos(lastWord.line, lastWord.to);
          } else {
            // b
            return Pos(lastWord.line, lastWord.from);
          }
        }

        function moveToEol(cm, head, motionArgs, vim, keepHPos) {
          var cur = head;
          var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);
          var end=cm.clipPos(retval);
          end.ch--;
          if (!keepHPos) {
            vim.lastHPos = Infinity;
            vim.lastHSPos = cm.charCoords(end,'div').left;
          }
          return retval;
        }

        function moveToCharacter(cm, repeat, forward, character) {
          var cur = cm.getCursor();
          var start = cur.ch;
          var idx;
          for (var i = 0; i < repeat; i ++) {
            var line = cm.getLine(cur.line);
            idx = charIdxInLine(start, line, character, forward, true);
            if (idx == -1) {
              return null;
            }
            start = idx;
          }
          return Pos(cm.getCursor().line, idx);
        }

        function moveToColumn(cm, repeat) {
          // repeat is always >= 1, so repeat - 1 always corresponds
          // to the column we want to go to.
          var line = cm.getCursor().line;
          return clipCursorToContent(cm, Pos(line, repeat - 1));
        }

        function updateMark(cm, vim, markName, pos) {
          if (!inArray(markName, validMarks)) {
            return;
          }
          if (vim.marks[markName]) {
            vim.marks[markName].clear();
          }
          vim.marks[markName] = cm.setBookmark(pos);
        }

        function charIdxInLine(start, line, character, forward, includeChar) {
          // Search for char in line.
          // motion_options: {forward, includeChar}
          // If includeChar = true, include it too.
          // If forward = true, search forward, else search backwards.
          // If char is not found on this line, do nothing
          var idx;
          if (forward) {
            idx = line.indexOf(character, start + 1);
            if (idx != -1 && !includeChar) {
              idx -= 1;
            }
          } else {
            idx = line.lastIndexOf(character, start - 1);
            if (idx != -1 && !includeChar) {
              idx += 1;
            }
          }
          return idx;
        }

        function findParagraph(cm, head, repeat, dir, inclusive) {
          var line = head.line;
          var min = cm.firstLine();
          var max = cm.lastLine();
          var start, end, i = line;
          function isEmpty(i) { return !cm.getLine(i); }
          function isBoundary(i, dir, any) {
            if (any) { return isEmpty(i) != isEmpty(i + dir); }
            return !isEmpty(i) && isEmpty(i + dir);
          }
          if (dir) {
            while (min <= i && i <= max && repeat > 0) {
              if (isBoundary(i, dir)) { repeat--; }
              i += dir;
            }
            return new Pos(i, 0);
          }

          var vim = cm.state.vim;
          if (vim.visualLine && isBoundary(line, 1, true)) {
            var anchor = vim.sel.anchor;
            if (isBoundary(anchor.line, -1, true)) {
              if (!inclusive || anchor.line != line) {
                line += 1;
              }
            }
          }
          var startState = isEmpty(line);
          for (i = line; i <= max && repeat; i++) {
            if (isBoundary(i, 1, true)) {
              if (!inclusive || isEmpty(i) != startState) {
                repeat--;
              }
            }
          }
          end = new Pos(i, 0);
          // select boundary before paragraph for the last one
          if (i > max && !startState) { startState = true; }
          else { inclusive = false; }
          for (i = line; i > min; i--) {
            if (!inclusive || isEmpty(i) == startState || i == line) {
              if (isBoundary(i, -1, true)) { break; }
            }
          }
          start = new Pos(i, 0);
          return { start: start, end: end };
        }

        function findSentence(cm, cur, repeat, dir) {

          /*
            Takes an index object
            {
              line: the line string,
              ln: line number,
              pos: index in line,
              dir: direction of traversal (-1 or 1)
            }
            and modifies the line, ln, and pos members to represent the
            next valid position or sets them to null if there are
            no more valid positions.
           */
          function nextChar(cm, idx) {
            if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
              idx.ln += idx.dir;
              if (!isLine(cm, idx.ln)) {
                idx.line = null;
                idx.ln = null;
                idx.pos = null;
                return;
              }
              idx.line = cm.getLine(idx.ln);
              idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;
            }
            else {
              idx.pos += idx.dir;
            }
          }

          /*
            Performs one iteration of traversal in forward direction
            Returns an index object of the new location
           */
          function forward(cm, ln, pos, dir) {
            var line = cm.getLine(ln);
            var stop = (line === "");

            var curr = {
              line: line,
              ln: ln,
              pos: pos,
              dir: dir,
            }

            var last_valid = {
              ln: curr.ln,
              pos: curr.pos,
            }

            var skip_empty_lines = (curr.line === "");

            // Move one step to skip character we start on
            nextChar(cm, curr);

            while (curr.line !== null) {
              last_valid.ln = curr.ln;
              last_valid.pos = curr.pos;

              if (curr.line === "" && !skip_empty_lines) {
                return { ln: curr.ln, pos: curr.pos, };
              }
              else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
                return { ln: curr.ln, pos: curr.pos, };
              }
              else if (isEndOfSentenceSymbol(curr.line[curr.pos])
                && !stop
                && (curr.pos === curr.line.length - 1
                  || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
                stop = true;
              }

              nextChar(cm, curr);
            }

            /*
              Set the position to the last non whitespace character on the last
              valid line in the case that we reach the end of the document.
            */
            var line = cm.getLine(last_valid.ln);
            last_valid.pos = 0;
            for(var i = line.length - 1; i >= 0; --i) {
              if (!isWhiteSpaceString(line[i])) {
                last_valid.pos = i;
                break;
              }
            }

            return last_valid;

          }

          /*
            Performs one iteration of traversal in reverse direction
            Returns an index object of the new location
           */
          function reverse(cm, ln, pos, dir) {
            var line = cm.getLine(ln);

            var curr = {
              line: line,
              ln: ln,
              pos: pos,
              dir: dir,
            }

            var last_valid = {
              ln: curr.ln,
              pos: null,
            };

            var skip_empty_lines = (curr.line === "");

            // Move one step to skip character we start on
            nextChar(cm, curr);

            while (curr.line !== null) {

              if (curr.line === "" && !skip_empty_lines) {
                if (last_valid.pos !== null) {
                  return last_valid;
                }
                else {
                  return { ln: curr.ln, pos: curr.pos };
                }
              }
              else if (isEndOfSentenceSymbol(curr.line[curr.pos])
                  && last_valid.pos !== null
                  && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
                return last_valid;
              }
              else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
                skip_empty_lines = false;
                last_valid = { ln: curr.ln, pos: curr.pos }
              }

              nextChar(cm, curr);
            }

            /*
              Set the position to the first non whitespace character on the last
              valid line in the case that we reach the beginning of the document.
            */
            var line = cm.getLine(last_valid.ln);
            last_valid.pos = 0;
            for(var i = 0; i < line.length; ++i) {
              if (!isWhiteSpaceString(line[i])) {
                last_valid.pos = i;
                break;
              }
            }
            return last_valid;
          }

          var curr_index = {
            ln: cur.line,
            pos: cur.ch,
          };

          while (repeat > 0) {
            if (dir < 0) {
              curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
            }
            else {
              curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
            }
            repeat--;
          }

          return Pos(curr_index.ln, curr_index.pos);
        }

        // TODO: perhaps this finagling of start and end positions belongs
        // in codemirror/replaceRange?
        function selectCompanionObject(cm, head, symb, inclusive) {
          var cur = head, start, end;

          var bracketRegexp = ({
            '(': /[()]/, ')': /[()]/,
            '[': /[[\]]/, ']': /[[\]]/,
            '{': /[{}]/, '}': /[{}]/,
            '<': /[<>]/, '>': /[<>]/})[symb];
          var openSym = ({
            '(': '(', ')': '(',
            '[': '[', ']': '[',
            '{': '{', '}': '{',
            '<': '<', '>': '<'})[symb];
          var curChar = cm.getLine(cur.line).charAt(cur.ch);
          // Due to the behavior of scanForBracket, we need to add an offset if the
          // cursor is on a matching open bracket.
          var offset = curChar === openSym ? 1 : 0;

          start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});
          end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});

          if (!start || !end) {
            return { start: cur, end: cur };
          }

          start = start.pos;
          end = end.pos;

          if ((start.line == end.line && start.ch > end.ch)
              || (start.line > end.line)) {
            var tmp = start;
            start = end;
            end = tmp;
          }

          if (inclusive) {
            end.ch += 1;
          } else {
            start.ch += 1;
          }

          return { start: start, end: end };
        }

        // Takes in a symbol and a cursor and tries to simulate text objects that
        // have identical opening and closing symbols
        // TODO support across multiple lines
        function findBeginningAndEnd(cm, head, symb, inclusive) {
          var cur = copyCursor(head);
          var line = cm.getLine(cur.line);
          var chars = line.split('');
          var start, end, i, len;
          var firstIndex = chars.indexOf(symb);

          // the decision tree is to always look backwards for the beginning first,
          // but if the cursor is in front of the first instance of the symb,
          // then move the cursor forward
          if (cur.ch < firstIndex) {
            cur.ch = firstIndex;
            // Why is this line even here???
            // cm.setCursor(cur.line, firstIndex+1);
          }
          // otherwise if the cursor is currently on the closing symbol
          else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
            end = cur.ch; // assign end to the current cursor
            --cur.ch; // make sure to look backwards
          }

          // if we're currently on the symbol, we've got a start
          if (chars[cur.ch] == symb && !end) {
            start = cur.ch + 1; // assign start to ahead of the cursor
          } else {
            // go backwards to find the start
            for (i = cur.ch; i > -1 && !start; i--) {
              if (chars[i] == symb) {
                start = i + 1;
              }
            }
          }

          // look forwards for the end symbol
          if (start && !end) {
            for (i = start, len = chars.length; i < len && !end; i++) {
              if (chars[i] == symb) {
                end = i;
              }
            }
          }

          // nothing found
          if (!start || !end) {
            return { start: cur, end: cur };
          }

          // include the symbols
          if (inclusive) {
            --start; ++end;
          }

          return {
            start: Pos(cur.line, start),
            end: Pos(cur.line, end)
          };
        }

        // Search functions
        defineOption('pcre', true, 'boolean');
        function SearchState() {}
        SearchState.prototype = {
          getQuery: function() {
            return vimGlobalState.query;
          },
          setQuery: function(query) {
            vimGlobalState.query = query;
          },
          getOverlay: function() {
            return this.searchOverlay;
          },
          setOverlay: function(overlay) {
            this.searchOverlay = overlay;
          },
          isReversed: function() {
            return vimGlobalState.isReversed;
          },
          setReversed: function(reversed) {
            vimGlobalState.isReversed = reversed;
          },
          getScrollbarAnnotate: function() {
            return this.annotate;
          },
          setScrollbarAnnotate: function(annotate) {
            this.annotate = annotate;
          }
        };
        function getSearchState(cm) {
          var vim = cm.state.vim;
          return vim.searchState_ || (vim.searchState_ = new SearchState());
        }
        function splitBySlash(argString) {
          return splitBySeparator(argString, '/');
        }

        function findUnescapedSlashes(argString) {
          return findUnescapedSeparators(argString, '/');
        }

        function splitBySeparator(argString, separator) {
          var slashes = findUnescapedSeparators(argString, separator) || [];
          if (!slashes.length) return [];
          var tokens = [];
          // in case of strings like foo/bar
          if (slashes[0] !== 0) return;
          for (var i = 0; i < slashes.length; i++) {
            if (typeof slashes[i] == 'number')
              tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));
          }
          return tokens;
        }

        function findUnescapedSeparators(str, separator) {
          if (!separator)
            separator = '/';

          var escapeNextChar = false;
          var slashes = [];
          for (var i = 0; i < str.length; i++) {
            var c = str.charAt(i);
            if (!escapeNextChar && c == separator) {
              slashes.push(i);
            }
            escapeNextChar = !escapeNextChar && (c == '\\');
          }
          return slashes;
        }

        // Translates a search string from ex (vim) syntax into javascript form.
        function translateRegex(str) {
          // When these match, add a '\' if unescaped or remove one if escaped.
          var specials = '|(){';
          // Remove, but never add, a '\' for these.
          var unescape = '}';
          var escapeNextChar = false;
          var out = [];
          for (var i = -1; i < str.length; i++) {
            var c = str.charAt(i) || '';
            var n = str.charAt(i+1) || '';
            var specialComesNext = (n && specials.indexOf(n) != -1);
            if (escapeNextChar) {
              if (c !== '\\' || !specialComesNext) {
                out.push(c);
              }
              escapeNextChar = false;
            } else {
              if (c === '\\') {
                escapeNextChar = true;
                // Treat the unescape list as special for removing, but not adding '\'.
                if (n && unescape.indexOf(n) != -1) {
                  specialComesNext = true;
                }
                // Not passing this test means removing a '\'.
                if (!specialComesNext || n === '\\') {
                  out.push(c);
                }
              } else {
                out.push(c);
                if (specialComesNext && n !== '\\') {
                  out.push('\\');
                }
              }
            }
          }
          return out.join('');
        }

        // Translates the replace part of a search and replace from ex (vim) syntax into
        // javascript form.  Similar to translateRegex, but additionally fixes back references
        // (translates '\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.
        var charUnescapes = {'\\n': '\n', '\\r': '\r', '\\t': '\t'};
        function translateRegexReplace(str) {
          var escapeNextChar = false;
          var out = [];
          for (var i = -1; i < str.length; i++) {
            var c = str.charAt(i) || '';
            var n = str.charAt(i+1) || '';
            if (charUnescapes[c + n]) {
              out.push(charUnescapes[c+n]);
              i++;
            } else if (escapeNextChar) {
              // At any point in the loop, escapeNextChar is true if the previous
              // character was a '\' and was not escaped.
              out.push(c);
              escapeNextChar = false;
            } else {
              if (c === '\\') {
                escapeNextChar = true;
                if ((isNumber(n) || n === '$')) {
                  out.push('$');
                } else if (n !== '/' && n !== '\\') {
                  out.push('\\');
                }
              } else {
                if (c === '$') {
                  out.push('$');
                }
                out.push(c);
                if (n === '/') {
                  out.push('\\');
                }
              }
            }
          }
          return out.join('');
        }

        // Unescape \ and / in the replace part, for PCRE mode.
        var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r': '\r', '\\t': '\t', '\\&':'&'};
        function unescapeRegexReplace(str) {
          var stream = new CodeMirror.StringStream(str);
          var output = [];
          while (!stream.eol()) {
            // Search for \.
            while (stream.peek() && stream.peek() != '\\') {
              output.push(stream.next());
            }
            var matched = false;
            for (var matcher in unescapes) {
              if (stream.match(matcher, true)) {
                matched = true;
                output.push(unescapes[matcher]);
                break;
              }
            }
            if (!matched) {
              // Don't change anything
              output.push(stream.next());
            }
          }
          return output.join('');
        }

        /**
         * Extract the regular expression from the query and return a Regexp object.
         * Returns null if the query is blank.
         * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.
         * If smartCase is passed in, and the query contains upper case letters,
         *   then ignoreCase is overridden, and the 'i' flag will not be set.
         * If the query contains the /i in the flag part of the regular expression,
         *   then both ignoreCase and smartCase are ignored, and 'i' will be passed
         *   through to the Regex object.
         */
        function parseQuery(query, ignoreCase, smartCase) {
          // First update the last search register
          var lastSearchRegister = vimGlobalState.registerController.getRegister('/');
          lastSearchRegister.setText(query);
          // Check if the query is already a regex.
          if (query instanceof RegExp) { return query; }
          // First try to extract regex + flags from the input. If no flags found,
          // extract just the regex. IE does not accept flags directly defined in
          // the regex string in the form /regex/flags
          var slashes = findUnescapedSlashes(query);
          var regexPart;
          var forceIgnoreCase;
          if (!slashes.length) {
            // Query looks like 'regexp'
            regexPart = query;
          } else {
            // Query looks like 'regexp/...'
            regexPart = query.substring(0, slashes[0]);
            var flagsPart = query.substring(slashes[0]);
            forceIgnoreCase = (flagsPart.indexOf('i') != -1);
          }
          if (!regexPart) {
            return null;
          }
          if (!getOption('pcre')) {
            regexPart = translateRegex(regexPart);
          }
          if (smartCase) {
            ignoreCase = (/^[^A-Z]*$/).test(regexPart);
          }
          var regexp = new RegExp(regexPart,
              (ignoreCase || forceIgnoreCase) ? 'i' : undefined);
          return regexp;
        }

        /**
         * dom - Document Object Manipulator
         * Usage:
         *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])
         * Examples:
         *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))
         *   dom(document.head, dom('script', 'alert("hello!")'))
         * Not supported:
         *   dom('p', ['arrays are objects'], Error('objects specify attributes'))
         */
        function dom(n) {
          if (typeof n === 'string') n = document.createElement(n);
          for (var a, i = 1; i < arguments.length; i++) {
            if (!(a = arguments[i])) continue;
            if (typeof a !== 'object') a = document.createTextNode(a);
            if (a.nodeType) n.appendChild(a);
            else for (var key in a) {
              if (!Object.prototype.hasOwnProperty.call(a, key)) continue;
              if (key[0] === '$') n.style[key.slice(1)] = a[key];
              else n.setAttribute(key, a[key]);
            }
          }
          return n;
        }

        function showConfirm(cm, template) {
          var pre = dom('pre', {$color: 'red'}, template);
          if (cm.openNotification) {
            cm.openNotification(pre, {bottom: true, duration: 5000});
          } else {
            alert(pre.innerText);
          }
        }

        function makePrompt(prefix, desc) {
          return dom(document.createDocumentFragment(),
                   dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},
                     prefix,
                     dom('input', {type: 'text', autocorrect: 'off',
                                   autocapitalize: 'off', spellcheck: 'false'})),
                   desc && dom('span', {$color: '#888'}, desc));
        }

        function showPrompt(cm, options) {
          var shortText = (options.prefix || '') + ' ' + (options.desc || '');
          var template = makePrompt(options.prefix, options.desc);
          if (cm.openDialog) {
            cm.openDialog(template, options.onClose, {
              onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,
              bottom: true, selectValueOnOpen: false, value: options.value
            });
          }
          else {
            options.onClose(prompt(shortText, ''));
          }
        }

        function regexEqual(r1, r2) {
          if (r1 instanceof RegExp && r2 instanceof RegExp) {
              var props = ['global', 'multiline', 'ignoreCase', 'source'];
              for (var i = 0; i < props.length; i++) {
                  var prop = props[i];
                  if (r1[prop] !== r2[prop]) {
                      return false;
                  }
              }
              return true;
          }
          return false;
        }
        // Returns true if the query is valid.
        function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
          if (!rawQuery) {
            return;
          }
          var state = getSearchState(cm);
          var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
          if (!query) {
            return;
          }
          highlightSearchMatches(cm, query);
          if (regexEqual(query, state.getQuery())) {
            return query;
          }
          state.setQuery(query);
          return query;
        }
        function searchOverlay(query) {
          if (query.source.charAt(0) == '^') {
            var matchSol = true;
          }
          return {
            token: function(stream) {
              if (matchSol && !stream.sol()) {
                stream.skipToEnd();
                return;
              }
              var match = stream.match(query, false);
              if (match) {
                if (match[0].length == 0) {
                  // Matched empty string, skip to next.
                  stream.next();
                  return 'searching';
                }
                if (!stream.sol()) {
                  // Backtrack 1 to match \b
                  stream.backUp(1);
                  if (!query.exec(stream.next() + match[0])) {
                    stream.next();
                    return null;
                  }
                }
                stream.match(query);
                return 'searching';
              }
              while (!stream.eol()) {
                stream.next();
                if (stream.match(query, false)) break;
              }
            },
            query: query
          };
        }
        var highlightTimeout = 0;
        function highlightSearchMatches(cm, query) {
          clearTimeout(highlightTimeout);
          highlightTimeout = setTimeout(function() {
            var searchState = getSearchState(cm);
            var overlay = searchState.getOverlay();
            if (!overlay || query != overlay.query) {
              if (overlay) {
                cm.removeOverlay(overlay);
              }
              overlay = searchOverlay(query);
              cm.addOverlay(overlay);
              if (cm.showMatchesOnScrollbar) {
                if (searchState.getScrollbarAnnotate()) {
                  searchState.getScrollbarAnnotate().clear();
                }
                searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
              }
              searchState.setOverlay(overlay);
            }
          }, 50);
        }
        function findNext(cm, prev, query, repeat) {
          if (repeat === undefined) { repeat = 1; }
          return cm.operation(function() {
            var pos = cm.getCursor();
            var cursor = cm.getSearchCursor(query, pos);
            for (var i = 0; i < repeat; i++) {
              var found = cursor.find(prev);
              if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }
              if (!found) {
                // SearchCursor may have returned null because it hit EOF, wrap
                // around and try again.
                cursor = cm.getSearchCursor(query,
                    (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
                if (!cursor.find(prev)) {
                  return;
                }
              }
            }
            return cursor.from();
          });
        }
        /**
         * Pretty much the same as `findNext`, except for the following differences:
         *
         * 1. Before starting the search, move to the previous search. This way if our cursor is
         * already inside a match, we should return the current match.
         * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.
         */
        function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
          if (repeat === undefined) { repeat = 1; }
          return cm.operation(function() {
            var pos = cm.getCursor();
            var cursor = cm.getSearchCursor(query, pos);

            // Go back one result to ensure that if the cursor is currently a match, we keep it.
            var found = cursor.find(!prev);

            // If we haven't moved, go back one more (similar to if i==0 logic in findNext).
            if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {
              cursor.find(!prev);
            }

            for (var i = 0; i < repeat; i++) {
              found = cursor.find(prev);
              if (!found) {
                // SearchCursor may have returned null because it hit EOF, wrap
                // around and try again.
                cursor = cm.getSearchCursor(query,
                    (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
                if (!cursor.find(prev)) {
                  return;
                }
              }
            }
            return [cursor.from(), cursor.to()];
          });
        }
        function clearSearchHighlight(cm) {
          var state = getSearchState(cm);
          cm.removeOverlay(getSearchState(cm).getOverlay());
          state.setOverlay(null);
          if (state.getScrollbarAnnotate()) {
            state.getScrollbarAnnotate().clear();
            state.setScrollbarAnnotate(null);
          }
        }
        /**
         * Check if pos is in the specified range, INCLUSIVE.
         * Range can be specified with 1 or 2 arguments.
         * If the first range argument is an array, treat it as an array of line
         * numbers. Match pos against any of the lines.
         * If the first range argument is a number,
         *   if there is only 1 range argument, check if pos has the same line
         *       number
         *   if there are 2 range arguments, then check if pos is in between the two
         *       range arguments.
         */
        function isInRange(pos, start, end) {
          if (typeof pos != 'number') {
            // Assume it is a cursor position. Get the line number.
            pos = pos.line;
          }
          if (start instanceof Array) {
            return inArray(pos, start);
          } else {
            if (typeof end == 'number') {
              return (pos >= start && pos <= end);
            } else {
              return pos == start;
            }
          }
        }
        function getUserVisibleLines(cm) {
          var scrollInfo = cm.getScrollInfo();
          var occludeToleranceTop = 6;
          var occludeToleranceBottom = 10;
          var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');
          var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
          var to = cm.coordsChar({left:0, top: bottomY}, 'local');
          return {top: from.line, bottom: to.line};
        }

        function getMarkPos(cm, vim, markName) {
          if (markName == '\'' || markName == '`') {
            return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);
          } else if (markName == '.') {
            return getLastEditPos(cm);
          }

          var mark = vim.marks[markName];
          return mark && mark.find();
        }

        function getLastEditPos(cm) {
          var done = cm.doc.history.done;
          for (var i = done.length; i--;) {
            if (done[i].changes) {
              return copyCursor(done[i].changes[0].to);
            }
          }
        }

        var ExCommandDispatcher = function() {
          this.buildCommandMap_();
        };
        ExCommandDispatcher.prototype = {
          processCommand: function(cm, input, opt_params) {
            var that = this;
            cm.operation(function () {
              cm.curOp.isVimOp = true;
              that._processCommand(cm, input, opt_params);
            });
          },
          _processCommand: function(cm, input, opt_params) {
            var vim = cm.state.vim;
            var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');
            var previousCommand = commandHistoryRegister.toString();
            if (vim.visualMode) {
              exitVisualMode(cm);
            }
            var inputStream = new CodeMirror.StringStream(input);
            // update ": with the latest command whether valid or invalid
            commandHistoryRegister.setText(input);
            var params = opt_params || {};
            params.input = input;
            try {
              this.parseInput_(cm, inputStream, params);
            } catch(e) {
              showConfirm(cm, e.toString());
              throw e;
            }
            var command;
            var commandName;
            if (!params.commandName) {
              // If only a line range is defined, move to the line.
              if (params.line !== undefined) {
                commandName = 'move';
              }
            } else {
              command = this.matchCommand_(params.commandName);
              if (command) {
                commandName = command.name;
                if (command.excludeFromCommandHistory) {
                  commandHistoryRegister.setText(previousCommand);
                }
                this.parseCommandArgs_(inputStream, params, command);
                if (command.type == 'exToKey') {
                  // Handle Ex to Key mapping.
                  for (var i = 0; i < command.toKeys.length; i++) {
                    CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');
                  }
                  return;
                } else if (command.type == 'exToEx') {
                  // Handle Ex to Ex mapping.
                  this.processCommand(cm, command.toInput);
                  return;
                }
              }
            }
            if (!commandName) {
              showConfirm(cm, 'Not an editor command ":' + input + '"');
              return;
            }
            try {
              exCommands[commandName](cm, params);
              // Possibly asynchronous commands (e.g. substitute, which might have a
              // user confirmation), are responsible for calling the callback when
              // done. All others have it taken care of for them here.
              if ((!command || !command.possiblyAsync) && params.callback) {
                params.callback();
              }
            } catch(e) {
              showConfirm(cm, e.toString());
              throw e;
            }
          },
          parseInput_: function(cm, inputStream, result) {
            inputStream.eatWhile(':');
            // Parse range.
            if (inputStream.eat('%')) {
              result.line = cm.firstLine();
              result.lineEnd = cm.lastLine();
            } else {
              result.line = this.parseLineSpec_(cm, inputStream);
              if (result.line !== undefined && inputStream.eat(',')) {
                result.lineEnd = this.parseLineSpec_(cm, inputStream);
              }
            }

            // Parse command name.
            var commandMatch = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
            if (commandMatch) {
              result.commandName = commandMatch[1];
            } else {
              result.commandName = inputStream.match(/.*/)[0];
            }

            return result;
          },
          parseLineSpec_: function(cm, inputStream) {
            var numberMatch = inputStream.match(/^(\d+)/);
            if (numberMatch) {
              // Absolute line number plus offset (N+M or N-M) is probably a typo,
              // not something the user actually wanted. (NB: vim does allow this.)
              return parseInt(numberMatch[1], 10) - 1;
            }
            switch (inputStream.next()) {
              case '.':
                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
              case '$':
                return this.parseLineSpecOffset_(inputStream, cm.lastLine());
              case '\'':
                var markName = inputStream.next();
                var markPos = getMarkPos(cm, cm.state.vim, markName);
                if (!markPos) throw new Error('Mark not set');
                return this.parseLineSpecOffset_(inputStream, markPos.line);
              case '-':
              case '+':
                inputStream.backUp(1);
                // Offset is relative to current line if not otherwise specified.
                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
              default:
                inputStream.backUp(1);
                return undefined;
            }
          },
          parseLineSpecOffset_: function(inputStream, line) {
            var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
            if (offsetMatch) {
              var offset = parseInt(offsetMatch[2], 10);
              if (offsetMatch[1] == "-") {
                line -= offset;
              } else {
                line += offset;
              }
            }
            return line;
          },
          parseCommandArgs_: function(inputStream, params, command) {
            if (inputStream.eol()) {
              return;
            }
            params.argString = inputStream.match(/.*/)[0];
            // Parse command-line arguments
            var delim = command.argDelimiter || /\s+/;
            var args = trim(params.argString).split(delim);
            if (args.length && args[0]) {
              params.args = args;
            }
          },
          matchCommand_: function(commandName) {
            // Return the command in the command map that matches the shortest
            // prefix of the passed in command name. The match is guaranteed to be
            // unambiguous if the defaultExCommandMap's shortNames are set up
            // correctly. (see @code{defaultExCommandMap}).
            for (var i = commandName.length; i > 0; i--) {
              var prefix = commandName.substring(0, i);
              if (this.commandMap_[prefix]) {
                var command = this.commandMap_[prefix];
                if (command.name.indexOf(commandName) === 0) {
                  return command;
                }
              }
            }
            return null;
          },
          buildCommandMap_: function() {
            this.commandMap_ = {};
            for (var i = 0; i < defaultExCommandMap.length; i++) {
              var command = defaultExCommandMap[i];
              var key = command.shortName || command.name;
              this.commandMap_[key] = command;
            }
          },
          map: function(lhs, rhs, ctx) {
            if (lhs != ':' && lhs.charAt(0) == ':') {
              if (ctx) { throw Error('Mode not supported for ex mappings'); }
              var commandName = lhs.substring(1);
              if (rhs != ':' && rhs.charAt(0) == ':') {
                // Ex to Ex mapping
                this.commandMap_[commandName] = {
                  name: commandName,
                  type: 'exToEx',
                  toInput: rhs.substring(1),
                  user: true
                };
              } else {
                // Ex to key mapping
                this.commandMap_[commandName] = {
                  name: commandName,
                  type: 'exToKey',
                  toKeys: rhs,
                  user: true
                };
              }
            } else {
              if (rhs != ':' && rhs.charAt(0) == ':') {
                // Key to Ex mapping.
                var mapping = {
                  keys: lhs,
                  type: 'keyToEx',
                  exArgs: { input: rhs.substring(1) }
                };
                if (ctx) { mapping.context = ctx; }
                defaultKeymap.unshift(mapping);
              } else {
                // Key to key mapping
                var mapping = {
                  keys: lhs,
                  type: 'keyToKey',
                  toKeys: rhs
                };
                if (ctx) { mapping.context = ctx; }
                defaultKeymap.unshift(mapping);
              }
            }
          },
          unmap: function(lhs, ctx) {
            if (lhs != ':' && lhs.charAt(0) == ':') {
              // Ex to Ex or Ex to key mapping
              if (ctx) { throw Error('Mode not supported for ex mappings'); }
              var commandName = lhs.substring(1);
              if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
                delete this.commandMap_[commandName];
                return;
              }
            } else {
              // Key to Ex or key to key mapping
              var keys = lhs;
              for (var i = 0; i < defaultKeymap.length; i++) {
                if (keys == defaultKeymap[i].keys
                    && defaultKeymap[i].context === ctx) {
                  defaultKeymap.splice(i, 1);
                  return;
                }
              }
            }
            throw Error('No such mapping.');
          }
        };

        var exCommands = {
          colorscheme: function(cm, params) {
            if (!params.args || params.args.length < 1) {
              showConfirm(cm, cm.getOption('theme'));
              return;
            }
            cm.setOption('theme', params.args[0]);
          },
          map: function(cm, params, ctx) {
            var mapArgs = params.args;
            if (!mapArgs || mapArgs.length < 2) {
              if (cm) {
                showConfirm(cm, 'Invalid mapping: ' + params.input);
              }
              return;
            }
            exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
          },
          imap: function(cm, params) { this.map(cm, params, 'insert'); },
          nmap: function(cm, params) { this.map(cm, params, 'normal'); },
          vmap: function(cm, params) { this.map(cm, params, 'visual'); },
          unmap: function(cm, params, ctx) {
            var mapArgs = params.args;
            if (!mapArgs || mapArgs.length < 1) {
              if (cm) {
                showConfirm(cm, 'No such mapping: ' + params.input);
              }
              return;
            }
            exCommandDispatcher.unmap(mapArgs[0], ctx);
          },
          move: function(cm, params) {
            commandDispatcher.processCommand(cm, cm.state.vim, {
                type: 'motion',
                motion: 'moveToLineOrEdgeOfDocument',
                motionArgs: { forward: false, explicitRepeat: true,
                  linewise: true },
                repeatOverride: params.line+1});
          },
          set: function(cm, params) {
            var setArgs = params.args;
            // Options passed through to the setOption/getOption calls. May be passed in by the
            // local/global versions of the set command
            var setCfg = params.setCfg || {};
            if (!setArgs || setArgs.length < 1) {
              if (cm) {
                showConfirm(cm, 'Invalid mapping: ' + params.input);
              }
              return;
            }
            var expr = setArgs[0].split('=');
            var optionName = expr[0];
            var value = expr[1];
            var forceGet = false;

            if (optionName.charAt(optionName.length - 1) == '?') {
              // If post-fixed with ?, then the set is actually a get.
              if (value) { throw Error('Trailing characters: ' + params.argString); }
              optionName = optionName.substring(0, optionName.length - 1);
              forceGet = true;
            }
            if (value === undefined && optionName.substring(0, 2) == 'no') {
              // To set boolean options to false, the option name is prefixed with
              // 'no'.
              optionName = optionName.substring(2);
              value = false;
            }

            var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';
            if (optionIsBoolean && value == undefined) {
              // Calling set with a boolean option sets it to true.
              value = true;
            }
            // If no value is provided, then we assume this is a get.
            if (!optionIsBoolean && value === undefined || forceGet) {
              var oldValue = getOption(optionName, cm, setCfg);
              if (oldValue instanceof Error) {
                showConfirm(cm, oldValue.message);
              } else if (oldValue === true || oldValue === false) {
                showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);
              } else {
                showConfirm(cm, '  ' + optionName + '=' + oldValue);
              }
            } else {
              var setOptionReturn = setOption(optionName, value, cm, setCfg);
              if (setOptionReturn instanceof Error) {
                showConfirm(cm, setOptionReturn.message);
              }
            }
          },
          setlocal: function (cm, params) {
            // setCfg is passed through to setOption
            params.setCfg = {scope: 'local'};
            this.set(cm, params);
          },
          setglobal: function (cm, params) {
            // setCfg is passed through to setOption
            params.setCfg = {scope: 'global'};
            this.set(cm, params);
          },
          registers: function(cm, params) {
            var regArgs = params.args;
            var registers = vimGlobalState.registerController.registers;
            var regInfo = '----------Registers----------\n\n';
            if (!regArgs) {
              for (var registerName in registers) {
                var text = registers[registerName].toString();
                if (text.length) {
                  regInfo += '"' + registerName + '    ' + text + '\n'
                }
              }
            } else {
              var registerName;
              regArgs = regArgs.join('');
              for (var i = 0; i < regArgs.length; i++) {
                registerName = regArgs.charAt(i);
                if (!vimGlobalState.registerController.isValidRegister(registerName)) {
                  continue;
                }
                var register = registers[registerName] || new Register();
                regInfo += '"' + registerName + '    ' + register.toString() + '\n'
              }
            }
            showConfirm(cm, regInfo);
          },
          sort: function(cm, params) {
            var reverse, ignoreCase, unique, number, pattern;
            function parseArgs() {
              if (params.argString) {
                var args = new CodeMirror.StringStream(params.argString);
                if (args.eat('!')) { reverse = true; }
                if (args.eol()) { return; }
                if (!args.eatSpace()) { return 'Invalid arguments'; }
                var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
                if (!opts && !args.eol()) { return 'Invalid arguments'; }
                if (opts[1]) {
                  ignoreCase = opts[1].indexOf('i') != -1;
                  unique = opts[1].indexOf('u') != -1;
                  var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;
                  var hex = opts[1].indexOf('x') != -1 && 1;
                  var octal = opts[1].indexOf('o') != -1 && 1;
                  if (decimal + hex + octal > 1) { return 'Invalid arguments'; }
                  number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';
                }
                if (opts[2]) {
                  pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');
                }
              }
            }
            var err = parseArgs();
            if (err) {
              showConfirm(cm, err + ': ' + params.argString);
              return;
            }
            var lineStart = params.line || cm.firstLine();
            var lineEnd = params.lineEnd || params.line || cm.lastLine();
            if (lineStart == lineEnd) { return; }
            var curStart = Pos(lineStart, 0);
            var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));
            var text = cm.getRange(curStart, curEnd).split('\n');
            var numberRegex = pattern ? pattern :
               (number == 'decimal') ? /(-?)([\d]+)/ :
               (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :
               (number == 'octal') ? /([0-7]+)/ : null;
            var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;
            var numPart = [], textPart = [];
            if (number || pattern) {
              for (var i = 0; i < text.length; i++) {
                var matchPart = pattern ? text[i].match(pattern) : null;
                if (matchPart && matchPart[0] != '') {
                  numPart.push(matchPart);
                } else if (!pattern && numberRegex.exec(text[i])) {
                  numPart.push(text[i]);
                } else {
                  textPart.push(text[i]);
                }
              }
            } else {
              textPart = text;
            }
            function compareFn(a, b) {
              if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
              if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }
              var anum = number && numberRegex.exec(a);
              var bnum = number && numberRegex.exec(b);
              if (!anum) { return a < b ? -1 : 1; }
              anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
              bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
              return anum - bnum;
            }
            function comparePatternFn(a, b) {
              if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
              if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }
              return (a[0] < b[0]) ? -1 : 1;
            }
            numPart.sort(pattern ? comparePatternFn : compareFn);
            if (pattern) {
              for (var i = 0; i < numPart.length; i++) {
                numPart[i] = numPart[i].input;
              }
            } else if (!number) { textPart.sort(compareFn); }
            text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);
            if (unique) { // Remove duplicate lines
              var textOld = text;
              var lastLine;
              text = [];
              for (var i = 0; i < textOld.length; i++) {
                if (textOld[i] != lastLine) {
                  text.push(textOld[i]);
                }
                lastLine = textOld[i];
              }
            }
            cm.replaceRange(text.join('\n'), curStart, curEnd);
          },
          vglobal: function(cm, params) {
            // global inspects params.commandName
            this.global(cm, params);
          },
          global: function(cm, params) {
            // a global command is of the form
            // :[range]g/pattern/[cmd]
            // argString holds the string /pattern/[cmd]
            var argString = params.argString;
            if (!argString) {
              showConfirm(cm, 'Regular Expression missing from global');
              return;
            }
            var inverted = params.commandName[0] === 'v';
            // range is specified here
            var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();
            var lineEnd = params.lineEnd || params.line || cm.lastLine();
            // get the tokens from argString
            var tokens = splitBySlash(argString);
            var regexPart = argString, cmd;
            if (tokens.length) {
              regexPart = tokens[0];
              cmd = tokens.slice(1, tokens.length).join('/');
            }
            if (regexPart) {
              // If regex part is empty, then use the previous query. Otherwise
              // use the regex part as the new query.
              try {
               updateSearchQuery(cm, regexPart, true /** ignoreCase */,
                 true /** smartCase */);
              } catch (e) {
               showConfirm(cm, 'Invalid regex: ' + regexPart);
               return;
              }
            }
            // now that we have the regexPart, search for regex matches in the
            // specified range of lines
            var query = getSearchState(cm).getQuery();
            var matchedLines = [];
            for (var i = lineStart; i <= lineEnd; i++) {
              var line = cm.getLineHandle(i);
              var matched = query.test(line.text);
              if (matched !== inverted) {
                matchedLines.push(cmd ? line : line.text);
              }
            }
            // if there is no [cmd], just display the list of matched lines
            if (!cmd) {
              showConfirm(cm, matchedLines.join('\n'));
              return;
            }
            var index = 0;
            var nextCommand = function() {
              if (index < matchedLines.length) {
                var line = matchedLines[index++];
                var lineNum = cm.getLineNumber(line);
                if (lineNum == null) {
                  nextCommand();
                  return;
                }
                var command = (lineNum + 1) + cmd;
                exCommandDispatcher.processCommand(cm, command, {
                  callback: nextCommand
                });
              }
            };
            nextCommand();
          },
          substitute: function(cm, params) {
            if (!cm.getSearchCursor) {
              throw new Error('Search feature not available. Requires searchcursor.js or ' +
                  'any other getSearchCursor implementation.');
            }
            var argString = params.argString;
            var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
            var regexPart, replacePart = '', trailing, flagsPart, count;
            var confirm = false; // Whether to confirm each replace.
            var global = false; // True to replace all instances on a line, false to replace only 1.
            if (tokens.length) {
              regexPart = tokens[0];
              if (getOption('pcre') && regexPart !== '') {
                  regexPart = new RegExp(regexPart).source; //normalize not escaped characters
              }
              replacePart = tokens[1];
              // If the pattern ends with $ (line boundary assertion), change $ to \n.
              // Caveat: this workaround cannot match on the last line of the document.
              if (/(^|[^\\])(\\\\)*\$$/.test(regexPart)) {
                regexPart = regexPart.slice(0, -1) + '\\n';
                replacePart = (replacePart || '') + '\n';
              }
              if (replacePart !== undefined) {
                if (getOption('pcre')) {
                  replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g,"$1$$&"));
                } else {
                  replacePart = translateRegexReplace(replacePart);
                }
                vimGlobalState.lastSubstituteReplacePart = replacePart;
              }
              trailing = tokens[2] ? tokens[2].split(' ') : [];
            } else {
              // either the argString is empty or its of the form ' hello/world'
              // actually splitBySlash returns a list of tokens
              // only if the string starts with a '/'
              if (argString && argString.length) {
                showConfirm(cm, 'Substitutions should be of the form ' +
                    ':s/pattern/replace/');
                return;
              }
            }
            // After the 3rd slash, we can have flags followed by a space followed
            // by count.
            if (trailing) {
              flagsPart = trailing[0];
              count = parseInt(trailing[1]);
              if (flagsPart) {
                if (flagsPart.indexOf('c') != -1) {
                  confirm = true;
                }
                if (flagsPart.indexOf('g') != -1) {
                  global = true;
                }
                if (getOption('pcre')) {
                   regexPart = regexPart + '/' + flagsPart;
                } else {
                   regexPart = regexPart.replace(/\//g, "\\/") + '/' + flagsPart;
                }
              }
            }
            if (regexPart) {
              // If regex part is empty, then use the previous query. Otherwise use
              // the regex part as the new query.
              try {
                updateSearchQuery(cm, regexPart, true /** ignoreCase */,
                  true /** smartCase */);
              } catch (e) {
                showConfirm(cm, 'Invalid regex: ' + regexPart);
                return;
              }
            }
            replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
            if (replacePart === undefined) {
              showConfirm(cm, 'No previous substitute regular expression');
              return;
            }
            var state = getSearchState(cm);
            var query = state.getQuery();
            var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;
            var lineEnd = params.lineEnd || lineStart;
            if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
              lineEnd = Infinity;
            }
            if (count) {
              lineStart = lineEnd;
              lineEnd = lineStart + count - 1;
            }
            var startPos = clipCursorToContent(cm, Pos(lineStart, 0));
            var cursor = cm.getSearchCursor(query, startPos);
            doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
          },
          redo: CodeMirror.commands.redo,
          undo: CodeMirror.commands.undo,
          write: function(cm) {
            if (CodeMirror.commands.save) {
              // If a save command is defined, call it.
              CodeMirror.commands.save(cm);
            } else if (cm.save) {
              // Saves to text area if no save command is defined and cm.save() is available.
              cm.save();
            }
          },
          nohlsearch: function(cm) {
            clearSearchHighlight(cm);
          },
          yank: function (cm) {
            var cur = copyCursor(cm.getCursor());
            var line = cur.line;
            var lineText = cm.getLine(line);
            vimGlobalState.registerController.pushText(
              '0', 'yank', lineText, true, true);
          },
          delmarks: function(cm, params) {
            if (!params.argString || !trim(params.argString)) {
              showConfirm(cm, 'Argument required');
              return;
            }

            var state = cm.state.vim;
            var stream = new CodeMirror.StringStream(trim(params.argString));
            while (!stream.eol()) {
              stream.eatSpace();

              // Record the streams position at the beginning of the loop for use
              // in error messages.
              var count = stream.pos;

              if (!stream.match(/[a-zA-Z]/, false)) {
                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
                return;
              }

              var sym = stream.next();
              // Check if this symbol is part of a range
              if (stream.match('-', true)) {
                // This symbol is part of a range.

                // The range must terminate at an alphabetic character.
                if (!stream.match(/[a-zA-Z]/, false)) {
                  showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
                  return;
                }

                var startMark = sym;
                var finishMark = stream.next();
                // The range must terminate at an alphabetic character which
                // shares the same case as the start of the range.
                if (isLowerCase(startMark) && isLowerCase(finishMark) ||
                    isUpperCase(startMark) && isUpperCase(finishMark)) {
                  var start = startMark.charCodeAt(0);
                  var finish = finishMark.charCodeAt(0);
                  if (start >= finish) {
                    showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
                    return;
                  }

                  // Because marks are always ASCII values, and we have
                  // determined that they are the same case, we can use
                  // their char codes to iterate through the defined range.
                  for (var j = 0; j <= finish - start; j++) {
                    var mark = String.fromCharCode(start + j);
                    delete state.marks[mark];
                  }
                } else {
                  showConfirm(cm, 'Invalid argument: ' + startMark + '-');
                  return;
                }
              } else {
                // This symbol is a valid mark, and is not part of a range.
                delete state.marks[sym];
              }
            }
          }
        };

        var exCommandDispatcher = new ExCommandDispatcher();

        /**
        * @param {CodeMirror} cm CodeMirror instance we are in.
        * @param {boolean} confirm Whether to confirm each replace.
        * @param {Cursor} lineStart Line to start replacing from.
        * @param {Cursor} lineEnd Line to stop replacing at.
        * @param {RegExp} query Query for performing matches with.
        * @param {string} replaceWith Text to replace matches with. May contain $1,
        *     $2, etc for replacing captured groups using JavaScript replace.
        * @param {function()} callback A callback for when the replace is done.
        */
        function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,
            replaceWith, callback) {
          // Set up all the functions.
          cm.state.vim.exMode = true;
          var done = false;
          var lastPos, modifiedLineNumber, joined;
          function replaceAll() {
            cm.operation(function() {
              while (!done) {
                replace();
                next();
              }
              stop();
            });
          }
          function replace() {
            var text = cm.getRange(searchCursor.from(), searchCursor.to());
            var newText = text.replace(query, replaceWith);
            var unmodifiedLineNumber = searchCursor.to().line;
            searchCursor.replace(newText);
            modifiedLineNumber = searchCursor.to().line;
            lineEnd += modifiedLineNumber - unmodifiedLineNumber;
            joined = modifiedLineNumber < unmodifiedLineNumber;
          }
          function next() {
            // The below only loops to skip over multiple occurrences on the same
            // line when 'global' is not true.
            while(searchCursor.findNext() &&
                  isInRange(searchCursor.from(), lineStart, lineEnd)) {
              if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {
                continue;
              }
              cm.scrollIntoView(searchCursor.from(), 30);
              cm.setSelection(searchCursor.from(), searchCursor.to());
              lastPos = searchCursor.from();
              done = false;
              return;
            }
            done = true;
          }
          function stop(close) {
            if (close) { close(); }
            cm.focus();
            if (lastPos) {
              cm.setCursor(lastPos);
              var vim = cm.state.vim;
              vim.exMode = false;
              vim.lastHPos = vim.lastHSPos = lastPos.ch;
            }
            if (callback) { callback(); }
          }
          function onPromptKeyDown(e, _value, close) {
            // Swallow all keys.
            CodeMirror.e_stop(e);
            var keyName = CodeMirror.keyName(e);
            switch (keyName) {
              case 'Y':
                replace(); next(); break;
              case 'N':
                next(); break;
              case 'A':
                // replaceAll contains a call to close of its own. We don't want it
                // to fire too early or multiple times.
                var savedCallback = callback;
                callback = undefined;
                cm.operation(replaceAll);
                callback = savedCallback;
                break;
              case 'L':
                replace();
                // fall through and exit.
              case 'Q':
              case 'Esc':
              case 'Ctrl-C':
              case 'Ctrl-[':
                stop(close);
                break;
            }
            if (done) { stop(close); }
            return true;
          }

          // Actually do replace.
          next();
          if (done) {
            showConfirm(cm, 'No matches for ' + query.source);
            return;
          }
          if (!confirm) {
            replaceAll();
            if (callback) { callback(); }
            return;
          }
          showPrompt(cm, {
            prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),
            onKeyDown: onPromptKeyDown
          });
        }

        CodeMirror.keyMap.vim = {
          attach: attachVimMap,
          detach: detachVimMap,
          call: cmKey
        };

        function exitInsertMode(cm) {
          var vim = cm.state.vim;
          var macroModeState = vimGlobalState.macroModeState;
          var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');
          var isPlaying = macroModeState.isPlaying;
          var lastChange = macroModeState.lastInsertModeChanges;
          if (!isPlaying) {
            cm.off('change', onChange);
            CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
          }
          if (!isPlaying && vim.insertModeRepeat > 1) {
            // Perform insert mode repeat for commands like 3,a and 3,o.
            repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,
                true /** repeatForInsert */);
            vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
          }
          delete vim.insertModeRepeat;
          vim.insertMode = false;
          cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);
          cm.setOption('keyMap', 'vim');
          cm.setOption('disableInput', true);
          cm.toggleOverwrite(false); // exit replace mode if we were in it.
          // update the ". register before exiting insert mode
          insertModeChangeRegister.setText(lastChange.changes.join(''));
          CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
          if (macroModeState.isRecording) {
            logInsertModeChange(macroModeState);
          }
        }

        function _mapCommand(command) {
          defaultKeymap.unshift(command);
        }

        function mapCommand(keys, type, name, args, extra) {
          var command = {keys: keys, type: type};
          command[type] = name;
          command[type + "Args"] = args;
          for (var key in extra)
            command[key] = extra[key];
          _mapCommand(command);
        }

        // The timeout in milliseconds for the two-character ESC keymap should be
        // adjusted according to your typing speed to prevent false positives.
        defineOption('insertModeEscKeysTimeout', 200, 'number');

        CodeMirror.keyMap['vim-insert'] = {
          // TODO: override navigation keys so that Esc will cancel automatic
          // indentation from o, O, i_<CR>
          fallthrough: ['default'],
          attach: attachVimMap,
          detach: detachVimMap,
          call: cmKey
        };

        CodeMirror.keyMap['vim-replace'] = {
          'Backspace': 'goCharLeft',
          fallthrough: ['vim-insert'],
          attach: attachVimMap,
          detach: detachVimMap,
          call: cmKey
        };

        function executeMacroRegister(cm, vim, macroModeState, registerName) {
          var register = vimGlobalState.registerController.getRegister(registerName);
          if (registerName == ':') {
            // Read-only register containing last Ex command.
            if (register.keyBuffer[0]) {
              exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
            }
            macroModeState.isPlaying = false;
            return;
          }
          var keyBuffer = register.keyBuffer;
          var imc = 0;
          macroModeState.isPlaying = true;
          macroModeState.replaySearchQueries = register.searchQueries.slice(0);
          for (var i = 0; i < keyBuffer.length; i++) {
            var text = keyBuffer[i];
            var match, key;
            while (text) {
              // Pull off one command key, which is either a single character
              // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
              match = (/<\w+-.+?>|<\w+>|./).exec(text);
              key = match[0];
              text = text.substring(match.index + key.length);
              CodeMirror.Vim.handleKey(cm, key, 'macro');
              if (vim.insertMode) {
                var changes = register.insertModeChanges[imc++].changes;
                vimGlobalState.macroModeState.lastInsertModeChanges.changes =
                    changes;
                repeatInsertModeChanges(cm, changes, 1);
                exitInsertMode(cm);
              }
            }
          }
          macroModeState.isPlaying = false;
        }

        function logKey(macroModeState, key) {
          if (macroModeState.isPlaying) { return; }
          var registerName = macroModeState.latestRegister;
          var register = vimGlobalState.registerController.getRegister(registerName);
          if (register) {
            register.pushText(key);
          }
        }

        function logInsertModeChange(macroModeState) {
          if (macroModeState.isPlaying) { return; }
          var registerName = macroModeState.latestRegister;
          var register = vimGlobalState.registerController.getRegister(registerName);
          if (register && register.pushInsertModeChanges) {
            register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
          }
        }

        function logSearchQuery(macroModeState, query) {
          if (macroModeState.isPlaying) { return; }
          var registerName = macroModeState.latestRegister;
          var register = vimGlobalState.registerController.getRegister(registerName);
          if (register && register.pushSearchQuery) {
            register.pushSearchQuery(query);
          }
        }

        /**
         * Listens for changes made in insert mode.
         * Should only be active in insert mode.
         */
        function onChange(cm, changeObj) {
          var macroModeState = vimGlobalState.macroModeState;
          var lastChange = macroModeState.lastInsertModeChanges;
          if (!macroModeState.isPlaying) {
            while(changeObj) {
              lastChange.expectCursorActivityForChange = true;
              if (lastChange.ignoreCount > 1) {
                lastChange.ignoreCount--;
              } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'
                  || changeObj.origin === undefined /* only in testing */) {
                var selectionCount = cm.listSelections().length;
                if (selectionCount > 1)
                  lastChange.ignoreCount = selectionCount;
                var text = changeObj.text.join('\n');
                if (lastChange.maybeReset) {
                  lastChange.changes = [];
                  lastChange.maybeReset = false;
                }
                if (text) {
                  if (cm.state.overwrite && !/\n/.test(text)) {
                    lastChange.changes.push([text]);
                  } else {
                    lastChange.changes.push(text);
                  }
                }
              }
              // Change objects may be chained with next.
              changeObj = changeObj.next;
            }
          }
        }

        /**
        * Listens for any kind of cursor activity on CodeMirror.
        */
        function onCursorActivity(cm) {
          var vim = cm.state.vim;
          if (vim.insertMode) {
            // Tracking cursor activity in insert mode (for macro support).
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isPlaying) { return; }
            var lastChange = macroModeState.lastInsertModeChanges;
            if (lastChange.expectCursorActivityForChange) {
              lastChange.expectCursorActivityForChange = false;
            } else {
              // Cursor moved outside the context of an edit. Reset the change.
              lastChange.maybeReset = true;
            }
          } else if (!cm.curOp.isVimOp) {
            handleExternalSelection(cm, vim);
          }
          if (vim.visualMode) {
            updateFakeCursor(cm);
          }
        }
        /**
         * Keeps track of a fake cursor to support visual mode cursor behavior.
         */
        function updateFakeCursor(cm) {
          var className = 'cm-animate-fat-cursor';
          var vim = cm.state.vim;
          var from = clipCursorToContent(cm, copyCursor(vim.sel.head));
          var to = offsetCursor(from, 0, 1);
          clearFakeCursor(vim);
          // In visual mode, the cursor may be positioned over EOL.
          if (from.ch == cm.getLine(from.line).length) {
            var widget = dom('span', { 'class': className }, '\u00a0');
            vim.fakeCursorBookmark = cm.setBookmark(from, {widget: widget});
          } else {
            vim.fakeCursor = cm.markText(from, to, {className: className});
          }
        }
        function clearFakeCursor(vim) {
          if (vim.fakeCursor) {
            vim.fakeCursor.clear();
            vim.fakeCursor = null;
          }
          if (vim.fakeCursorBookmark) {
            vim.fakeCursorBookmark.clear();
            vim.fakeCursorBookmark = null;
          }
        }
        function handleExternalSelection(cm, vim) {
          var anchor = cm.getCursor('anchor');
          var head = cm.getCursor('head');
          // Enter or exit visual mode to match mouse selection.
          if (vim.visualMode && !cm.somethingSelected()) {
            exitVisualMode(cm, false);
          } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
            vim.visualMode = true;
            vim.visualLine = false;
            CodeMirror.signal(cm, "vim-mode-change", {mode: "visual"});
          }
          if (vim.visualMode) {
            // Bind CodeMirror selection model to vim selection model.
            // Mouse selections are considered visual characterwise.
            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
            head = offsetCursor(head, 0, headOffset);
            anchor = offsetCursor(anchor, 0, anchorOffset);
            vim.sel = {
              anchor: anchor,
              head: head
            };
            updateMark(cm, vim, '<', cursorMin(head, anchor));
            updateMark(cm, vim, '>', cursorMax(head, anchor));
          } else if (!vim.insertMode) {
            // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.
            vim.lastHPos = cm.getCursor().ch;
          }
        }

        /** Wrapper for special keys pressed in insert mode */
        function InsertModeKey(keyName) {
          this.keyName = keyName;
        }

        /**
        * Handles raw key down events from the text area.
        * - Should only be active in insert mode.
        * - For recording deletes in insert mode.
        */
        function onKeyEventTargetKeyDown(e) {
          var macroModeState = vimGlobalState.macroModeState;
          var lastChange = macroModeState.lastInsertModeChanges;
          var keyName = CodeMirror.keyName(e);
          if (!keyName) { return; }
          function onKeyFound() {
            if (lastChange.maybeReset) {
              lastChange.changes = [];
              lastChange.maybeReset = false;
            }
            lastChange.changes.push(new InsertModeKey(keyName));
            return true;
          }
          if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {
            CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);
          }
        }

        /**
         * Repeats the last edit, which includes exactly 1 command and at most 1
         * insert. Operator and motion commands are read from lastEditInputState,
         * while action commands are read from lastEditActionCommand.
         *
         * If repeatForInsert is true, then the function was called by
         * exitInsertMode to repeat the insert mode changes the user just made. The
         * corresponding enterInsertMode call was made with a count.
         */
        function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
          var macroModeState = vimGlobalState.macroModeState;
          macroModeState.isPlaying = true;
          var isAction = !!vim.lastEditActionCommand;
          var cachedInputState = vim.inputState;
          function repeatCommand() {
            if (isAction) {
              commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
            } else {
              commandDispatcher.evalInput(cm, vim);
            }
          }
          function repeatInsert(repeat) {
            if (macroModeState.lastInsertModeChanges.changes.length > 0) {
              // For some reason, repeat cw in desktop VIM does not repeat
              // insert mode changes. Will conform to that behavior.
              repeat = !vim.lastEditActionCommand ? 1 : repeat;
              var changeObject = macroModeState.lastInsertModeChanges;
              repeatInsertModeChanges(cm, changeObject.changes, repeat);
            }
          }
          vim.inputState = vim.lastEditInputState;
          if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {
            // o and O repeat have to be interlaced with insert repeats so that the
            // insertions appear on separate lines instead of the last line.
            for (var i = 0; i < repeat; i++) {
              repeatCommand();
              repeatInsert(1);
            }
          } else {
            if (!repeatForInsert) {
              // Hack to get the cursor to end up at the right place. If I is
              // repeated in insert mode repeat, cursor will be 1 insert
              // change set left of where it should be.
              repeatCommand();
            }
            repeatInsert(repeat);
          }
          vim.inputState = cachedInputState;
          if (vim.insertMode && !repeatForInsert) {
            // Don't exit insert mode twice. If repeatForInsert is set, then we
            // were called by an exitInsertMode call lower on the stack.
            exitInsertMode(cm);
          }
          macroModeState.isPlaying = false;
        }

        function repeatInsertModeChanges(cm, changes, repeat) {
          function keyHandler(binding) {
            if (typeof binding == 'string') {
              CodeMirror.commands[binding](cm);
            } else {
              binding(cm);
            }
            return true;
          }
          var head = cm.getCursor('head');
          var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
          if (visualBlock) {
            // Set up block selection again for repeating the changes.
            selectForInsert(cm, head, visualBlock + 1);
            repeat = cm.listSelections().length;
            cm.setCursor(head);
          }
          for (var i = 0; i < repeat; i++) {
            if (visualBlock) {
              cm.setCursor(offsetCursor(head, i, 0));
            }
            for (var j = 0; j < changes.length; j++) {
              var change = changes[j];
              if (change instanceof InsertModeKey) {
                CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);
              } else if (typeof change == "string") {
                var cur = cm.getCursor();
                cm.replaceRange(change, cur, cur);
              } else {
                var start = cm.getCursor();
                var end = offsetCursor(start, 0, change[0].length);
                cm.replaceRange(change[0], start, end);
              }
            }
          }
          if (visualBlock) {
            cm.setCursor(offsetCursor(head, 0, 1));
          }
        }

        resetVimGlobalState();
        return vimApi;
      };
      // Initialize Vim and make it available as an API.
      CodeMirror.Vim = Vim();
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-asciiarmor-asciiarmor.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      function errorIfNotEmpty(stream) {
        var nonWS = stream.match(/^\s*\S/);
        stream.skipToEnd();
        return nonWS ? "error" : null;
      }

      CodeMirror.defineMode("asciiarmor", function() {
        return {
          token: function(stream, state) {
            var m;
            if (state.state == "top") {
              if (stream.sol() && (m = stream.match(/^-----BEGIN (.*)?-----\s*$/))) {
                state.state = "headers";
                state.type = m[1];
                return "tag";
              }
              return errorIfNotEmpty(stream);
            } else if (state.state == "headers") {
              if (stream.sol() && stream.match(/^\w+:/)) {
                state.state = "header";
                return "atom";
              } else {
                var result = errorIfNotEmpty(stream);
                if (result) state.state = "body";
                return result;
              }
            } else if (state.state == "header") {
              stream.skipToEnd();
              state.state = "headers";
              return "string";
            } else if (state.state == "body") {
              if (stream.sol() && (m = stream.match(/^-----END (.*)?-----\s*$/))) {
                if (m[1] != state.type) return "error";
                state.state = "end";
                return "tag";
              } else {
                if (stream.eatWhile(/[A-Za-z0-9+\/=]/)) {
                  return null;
                } else {
                  stream.next();
                  return "error";
                }
              }
            } else if (state.state == "end") {
              return errorIfNotEmpty(stream);
            }
          },
          blankLine: function(state) {
            if (state.state == "headers") state.state = "body";
          },
          startState: function() {
            return {state: "top", type: null};
          }
        };
      });

      CodeMirror.defineMIME("application/pgp", "asciiarmor");
      CodeMirror.defineMIME("application/pgp-encrypted", "asciiarmor");
      CodeMirror.defineMIME("application/pgp-keys", "asciiarmor");
      CodeMirror.defineMIME("application/pgp-signature", "asciiarmor");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-brainfuck-brainfuck.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Brainfuck mode created by Michael Kaminsky https://github.com/mkaminsky11

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require("../../lib/codemirror"))
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod)
      else
        mod(CodeMirror)
    })(function(CodeMirror) {
      "use strict"
      var reserve = "><+-.,[]".split("");
      /*
      comments can be either:
      placed behind lines

            +++    this is a comment

      where reserved characters cannot be used
      or in a loop
      [
        this is ok to use [ ] and stuff
      ]
      or preceded by #
      */
      CodeMirror.defineMode("brainfuck", function() {
        return {
          startState: function() {
            return {
              commentLine: false,
              left: 0,
              right: 0,
              commentLoop: false
            }
          },
          token: function(stream, state) {
            if (stream.eatSpace()) return null
            if(stream.sol()){
              state.commentLine = false;
            }
            var ch = stream.next().toString();
            if(reserve.indexOf(ch) !== -1){
              if(state.commentLine === true){
                if(stream.eol()){
                  state.commentLine = false;
                }
                return "comment";
              }
              if(ch === "]" || ch === "["){
                if(ch === "["){
                  state.left++;
                }
                else{
                  state.right++;
                }
                return "bracket";
              }
              else if(ch === "+" || ch === "-"){
                return "keyword";
              }
              else if(ch === "<" || ch === ">"){
                return "atom";
              }
              else if(ch === "." || ch === ","){
                return "def";
              }
            }
            else{
              state.commentLine = true;
              if(stream.eol()){
                state.commentLine = false;
              }
              return "comment";
            }
            if(stream.eol()){
              state.commentLine = false;
            }
          }
        };
      });
    CodeMirror.defineMIME("text/x-brainfuck","brainfuck")
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-coffeescript-coffeescript.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Link to the project's GitHub page:
     * https://github.com/pickhardt/coffeescript-codemirror-mode
     */
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("coffeescript", function(conf, parserConf) {
      var ERRORCLASS = "error";

      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
      var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
      var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
      var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

      var wordOperators = wordRegexp(["and", "or", "not",
                                      "is", "isnt", "in",
                                      "instanceof", "typeof"]);
      var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                            "switch", "try", "catch", "finally", "class"];
      var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                            "do", "in", "of", "new", "return", "then",
                            "this", "@", "throw", "when", "until", "extends"];

      var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

      indentKeywords = wordRegexp(indentKeywords);


      var stringPrefixes = /^('{3}|\"{3}|['\"])/;
      var regexPrefixes = /^(\/{3}|\/)/;
      var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
      var constants = wordRegexp(commonConstants);

      // Tokenizers
      function tokenBase(stream, state) {
        // Handle scope changes
        if (stream.sol()) {
          if (state.scope.align === null) state.scope.align = false;
          var scopeOffset = state.scope.offset;
          if (stream.eatSpace()) {
            var lineOffset = stream.indentation();
            if (lineOffset > scopeOffset && state.scope.type == "coffee") {
              return "indent";
            } else if (lineOffset < scopeOffset) {
              return "dedent";
            }
            return null;
          } else {
            if (scopeOffset > 0) {
              dedent(stream, state);
            }
          }
        }
        if (stream.eatSpace()) {
          return null;
        }

        var ch = stream.peek();

        // Handle docco title comment (single line)
        if (stream.match("####")) {
          stream.skipToEnd();
          return "comment";
        }

        // Handle multi line comments
        if (stream.match("###")) {
          state.tokenize = longComment;
          return state.tokenize(stream, state);
        }

        // Single line comment
        if (ch === "#") {
          stream.skipToEnd();
          return "comment";
        }

        // Handle number literals
        if (stream.match(/^-?[0-9\.]/, false)) {
          var floatLiteral = false;
          // Floats
          if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
            floatLiteral = true;
          }
          if (stream.match(/^-?\d+\.\d*/)) {
            floatLiteral = true;
          }
          if (stream.match(/^-?\.\d+/)) {
            floatLiteral = true;
          }

          if (floatLiteral) {
            // prevent from getting extra . on 1..
            if (stream.peek() == "."){
              stream.backUp(1);
            }
            return "number";
          }
          // Integers
          var intLiteral = false;
          // Hex
          if (stream.match(/^-?0x[0-9a-f]+/i)) {
            intLiteral = true;
          }
          // Decimal
          if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
            intLiteral = true;
          }
          // Zero by itself with no other piece of number.
          if (stream.match(/^-?0(?![\dx])/i)) {
            intLiteral = true;
          }
          if (intLiteral) {
            return "number";
          }
        }

        // Handle strings
        if (stream.match(stringPrefixes)) {
          state.tokenize = tokenFactory(stream.current(), false, "string");
          return state.tokenize(stream, state);
        }
        // Handle regex literals
        if (stream.match(regexPrefixes)) {
          if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
            state.tokenize = tokenFactory(stream.current(), true, "string-2");
            return state.tokenize(stream, state);
          } else {
            stream.backUp(1);
          }
        }



        // Handle operators and delimiters
        if (stream.match(operators) || stream.match(wordOperators)) {
          return "operator";
        }
        if (stream.match(delimiters)) {
          return "punctuation";
        }

        if (stream.match(constants)) {
          return "atom";
        }

        if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
          return "property";
        }

        if (stream.match(keywords)) {
          return "keyword";
        }

        if (stream.match(identifiers)) {
          return "variable";
        }

        // Handle non-detected items
        stream.next();
        return ERRORCLASS;
      }

      function tokenFactory(delimiter, singleline, outclass) {
        return function(stream, state) {
          while (!stream.eol()) {
            stream.eatWhile(/[^'"\/\\]/);
            if (stream.eat("\\")) {
              stream.next();
              if (singleline && stream.eol()) {
                return outclass;
              }
            } else if (stream.match(delimiter)) {
              state.tokenize = tokenBase;
              return outclass;
            } else {
              stream.eat(/['"\/]/);
            }
          }
          if (singleline) {
            if (parserConf.singleLineStringErrors) {
              outclass = ERRORCLASS;
            } else {
              state.tokenize = tokenBase;
            }
          }
          return outclass;
        };
      }

      function longComment(stream, state) {
        while (!stream.eol()) {
          stream.eatWhile(/[^#]/);
          if (stream.match("###")) {
            state.tokenize = tokenBase;
            break;
          }
          stream.eatWhile("#");
        }
        return "comment";
      }

      function indent(stream, state, type) {
        type = type || "coffee";
        var offset = 0, align = false, alignOffset = null;
        for (var scope = state.scope; scope; scope = scope.prev) {
          if (scope.type === "coffee" || scope.type == "}") {
            offset = scope.offset + conf.indentUnit;
            break;
          }
        }
        if (type !== "coffee") {
          align = null;
          alignOffset = stream.column() + stream.current().length;
        } else if (state.scope.align) {
          state.scope.align = false;
        }
        state.scope = {
          offset: offset,
          type: type,
          prev: state.scope,
          align: align,
          alignOffset: alignOffset
        };
      }

      function dedent(stream, state) {
        if (!state.scope.prev) return;
        if (state.scope.type === "coffee") {
          var _indent = stream.indentation();
          var matched = false;
          for (var scope = state.scope; scope; scope = scope.prev) {
            if (_indent === scope.offset) {
              matched = true;
              break;
            }
          }
          if (!matched) {
            return true;
          }
          while (state.scope.prev && state.scope.offset !== _indent) {
            state.scope = state.scope.prev;
          }
          return false;
        } else {
          state.scope = state.scope.prev;
          return false;
        }
      }

      function tokenLexer(stream, state) {
        var style = state.tokenize(stream, state);
        var current = stream.current();

        // Handle scope changes.
        if (current === "return") {
          state.dedent = true;
        }
        if (((current === "->" || current === "=>") && stream.eol())
            || style === "indent") {
          indent(stream, state);
        }
        var delimiter_index = "[({".indexOf(current);
        if (delimiter_index !== -1) {
          indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
        }
        if (indentKeywords.exec(current)){
          indent(stream, state);
        }
        if (current == "then"){
          dedent(stream, state);
        }


        if (style === "dedent") {
          if (dedent(stream, state)) {
            return ERRORCLASS;
          }
        }
        delimiter_index = "])}".indexOf(current);
        if (delimiter_index !== -1) {
          while (state.scope.type == "coffee" && state.scope.prev)
            state.scope = state.scope.prev;
          if (state.scope.type == current)
            state.scope = state.scope.prev;
        }
        if (state.dedent && stream.eol()) {
          if (state.scope.type == "coffee" && state.scope.prev)
            state.scope = state.scope.prev;
          state.dedent = false;
        }

        return style;
      }

      var external = {
        startState: function(basecolumn) {
          return {
            tokenize: tokenBase,
            scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},
            prop: false,
            dedent: 0
          };
        },

        token: function(stream, state) {
          var fillAlign = state.scope.align === null && state.scope;
          if (fillAlign && stream.sol()) fillAlign.align = false;

          var style = tokenLexer(stream, state);
          if (style && style != "comment") {
            if (fillAlign) fillAlign.align = true;
            state.prop = style == "punctuation" && stream.current() == "."
          }

          return style;
        },

        indent: function(state, text) {
          if (state.tokenize != tokenBase) return 0;
          var scope = state.scope;
          var closer = text && "])}".indexOf(text.charAt(0)) > -1;
          if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
          var closes = closer && scope.type === text.charAt(0);
          if (scope.align)
            return scope.alignOffset - (closes ? 1 : 0);
          else
            return (closes ? scope.prev : scope).offset;
        },

        lineComment: "#",
        fold: "indent"
      };
      return external;
    });

    // IANA registered media type
    // https://www.iana.org/assignments/media-types/
    CodeMirror.defineMIME("application/vnd.coffeescript", "coffeescript");

    CodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
    CodeMirror.defineMIME("text/coffeescript", "coffeescript");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-crystal-crystal.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("crystal", function(config) {
        function wordRegExp(words, end) {
          return new RegExp((end ? "" : "^") + "(?:" + words.join("|") + ")" + (end ? "$" : "\\b"));
        }

        function chain(tokenize, stream, state) {
          state.tokenize.push(tokenize);
          return tokenize(stream, state);
        }

        var operators = /^(?:[-+/%|&^]|\*\*?|[<>]{2})/;
        var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;
        var indexingOperators = /^(?:\[\][?=]?)/;
        var anotherOperators = /^(?:\.(?:\.{2})?|->|[?:])/;
        var idents = /^[a-z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
        var types = /^[A-Z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
        var keywords = wordRegExp([
          "abstract", "alias", "as", "asm", "begin", "break", "case", "class", "def", "do",
          "else", "elsif", "end", "ensure", "enum", "extend", "for", "fun", "if",
          "include", "instance_sizeof", "lib", "macro", "module", "next", "of", "out", "pointerof",
          "private", "protected", "rescue", "return", "require", "select", "sizeof", "struct",
          "super", "then", "type", "typeof", "uninitialized", "union", "unless", "until", "when", "while", "with",
          "yield", "__DIR__", "__END_LINE__", "__FILE__", "__LINE__"
        ]);
        var atomWords = wordRegExp(["true", "false", "nil", "self"]);
        var indentKeywordsArray = [
          "def", "fun", "macro",
          "class", "module", "struct", "lib", "enum", "union",
          "do", "for"
        ];
        var indentKeywords = wordRegExp(indentKeywordsArray);
        var indentExpressionKeywordsArray = ["if", "unless", "case", "while", "until", "begin", "then"];
        var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);
        var dedentKeywordsArray = ["end", "else", "elsif", "rescue", "ensure"];
        var dedentKeywords = wordRegExp(dedentKeywordsArray);
        var dedentPunctualsArray = ["\\)", "\\}", "\\]"];
        var dedentPunctuals = new RegExp("^(?:" + dedentPunctualsArray.join("|") + ")$");
        var nextTokenizer = {
          "def": tokenFollowIdent, "fun": tokenFollowIdent, "macro": tokenMacroDef,
          "class": tokenFollowType, "module": tokenFollowType, "struct": tokenFollowType,
          "lib": tokenFollowType, "enum": tokenFollowType, "union": tokenFollowType
        };
        var matching = {"[": "]", "{": "}", "(": ")", "<": ">"};

        function tokenBase(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          // Macros
          if (state.lastToken != "\\" && stream.match("{%", false)) {
            return chain(tokenMacro("%", "%"), stream, state);
          }

          if (state.lastToken != "\\" && stream.match("{{", false)) {
            return chain(tokenMacro("{", "}"), stream, state);
          }

          // Comments
          if (stream.peek() == "#") {
            stream.skipToEnd();
            return "comment";
          }

          // Variables and keywords
          var matched;
          if (stream.match(idents)) {
            stream.eat(/[?!]/);

            matched = stream.current();
            if (stream.eat(":")) {
              return "atom";
            } else if (state.lastToken == ".") {
              return "property";
            } else if (keywords.test(matched)) {
              if (indentKeywords.test(matched)) {
                if (!(matched == "fun" && state.blocks.indexOf("lib") >= 0) && !(matched == "def" && state.lastToken == "abstract")) {
                  state.blocks.push(matched);
                  state.currentIndent += 1;
                }
              } else if ((state.lastStyle == "operator" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {
                state.blocks.push(matched);
                state.currentIndent += 1;
              } else if (matched == "end") {
                state.blocks.pop();
                state.currentIndent -= 1;
              }

              if (nextTokenizer.hasOwnProperty(matched)) {
                state.tokenize.push(nextTokenizer[matched]);
              }

              return "keyword";
            } else if (atomWords.test(matched)) {
              return "atom";
            }

            return "variable";
          }

          // Class variables and instance variables
          // or attributes
          if (stream.eat("@")) {
            if (stream.peek() == "[") {
              return chain(tokenNest("[", "]", "meta"), stream, state);
            }

            stream.eat("@");
            stream.match(idents) || stream.match(types);
            return "variable-2";
          }

          // Constants and types
          if (stream.match(types)) {
            return "tag";
          }

          // Symbols or ':' operator
          if (stream.eat(":")) {
            if (stream.eat("\"")) {
              return chain(tokenQuote("\"", "atom", false), stream, state);
            } else if (stream.match(idents) || stream.match(types) ||
                       stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {
              return "atom";
            }
            stream.eat(":");
            return "operator";
          }

          // Strings
          if (stream.eat("\"")) {
            return chain(tokenQuote("\"", "string", true), stream, state);
          }

          // Strings or regexps or macro variables or '%' operator
          if (stream.peek() == "%") {
            var style = "string";
            var embed = true;
            var delim;

            if (stream.match("%r")) {
              // Regexps
              style = "string-2";
              delim = stream.next();
            } else if (stream.match("%w")) {
              embed = false;
              delim = stream.next();
            } else if (stream.match("%q")) {
              embed = false;
              delim = stream.next();
            } else {
              if(delim = stream.match(/^%([^\w\s=])/)) {
                delim = delim[1];
              } else if (stream.match(/^%[a-zA-Z_\u009F-\uFFFF][\w\u009F-\uFFFF]*/)) {
                // Macro variables
                return "meta";
              } else if (stream.eat('%')) {
                // '%' operator
                return "operator";
              }
            }

            if (matching.hasOwnProperty(delim)) {
              delim = matching[delim];
            }
            return chain(tokenQuote(delim, style, embed), stream, state);
          }

          // Here Docs
          if (matched = stream.match(/^<<-('?)([A-Z]\w*)\1/)) {
            return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)
          }

          // Characters
          if (stream.eat("'")) {
            stream.match(/^(?:[^']|\\(?:[befnrtv0'"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]{1,6}\})))/);
            stream.eat("'");
            return "atom";
          }

          // Numbers
          if (stream.eat("0")) {
            if (stream.eat("x")) {
              stream.match(/^[0-9a-fA-F_]+/);
            } else if (stream.eat("o")) {
              stream.match(/^[0-7_]+/);
            } else if (stream.eat("b")) {
              stream.match(/^[01_]+/);
            }
            return "number";
          }

          if (stream.eat(/^\d/)) {
            stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+-]?\d+)?/);
            return "number";
          }

          // Operators
          if (stream.match(operators)) {
            stream.eat("="); // Operators can follow assign symbol.
            return "operator";
          }

          if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {
            return "operator";
          }

          // Parens and braces
          if (matched = stream.match(/[({[]/, false)) {
            matched = matched[0];
            return chain(tokenNest(matched, matching[matched], null), stream, state);
          }

          // Escapes
          if (stream.eat("\\")) {
            stream.next();
            return "meta";
          }

          stream.next();
          return null;
        }

        function tokenNest(begin, end, style, started) {
          return function (stream, state) {
            if (!started && stream.match(begin)) {
              state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);
              state.currentIndent += 1;
              return style;
            }

            var nextStyle = tokenBase(stream, state);
            if (stream.current() === end) {
              state.tokenize.pop();
              state.currentIndent -= 1;
              nextStyle = style;
            }

            return nextStyle;
          };
        }

        function tokenMacro(begin, end, started) {
          return function (stream, state) {
            if (!started && stream.match("{" + begin)) {
              state.currentIndent += 1;
              state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);
              return "meta";
            }

            if (stream.match(end + "}")) {
              state.currentIndent -= 1;
              state.tokenize.pop();
              return "meta";
            }

            return tokenBase(stream, state);
          };
        }

        function tokenMacroDef(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          var matched;
          if (matched = stream.match(idents)) {
            if (matched == "def") {
              return "keyword";
            }
            stream.eat(/[?!]/);
          }

          state.tokenize.pop();
          return "def";
        }

        function tokenFollowIdent(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          if (stream.match(idents)) {
            stream.eat(/[!?]/);
          } else {
            stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);
          }
          state.tokenize.pop();
          return "def";
        }

        function tokenFollowType(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          stream.match(types);
          state.tokenize.pop();
          return "def";
        }

        function tokenQuote(end, style, embed) {
          return function (stream, state) {
            var escaped = false;

            while (stream.peek()) {
              if (!escaped) {
                if (stream.match("{%", false)) {
                  state.tokenize.push(tokenMacro("%", "%"));
                  return style;
                }

                if (stream.match("{{", false)) {
                  state.tokenize.push(tokenMacro("{", "}"));
                  return style;
                }

                if (embed && stream.match("#{", false)) {
                  state.tokenize.push(tokenNest("#{", "}", "meta"));
                  return style;
                }

                var ch = stream.next();

                if (ch == end) {
                  state.tokenize.pop();
                  return style;
                }

                escaped = embed && ch == "\\";
              } else {
                stream.next();
                escaped = false;
              }
            }

            return style;
          };
        }

        function tokenHereDoc(phrase, embed) {
          return function (stream, state) {
            if (stream.sol()) {
              stream.eatSpace()
              if (stream.match(phrase)) {
                state.tokenize.pop();
                return "string";
              }
            }

            var escaped = false;
            while (stream.peek()) {
              if (!escaped) {
                if (stream.match("{%", false)) {
                  state.tokenize.push(tokenMacro("%", "%"));
                  return "string";
                }

                if (stream.match("{{", false)) {
                  state.tokenize.push(tokenMacro("{", "}"));
                  return "string";
                }

                if (embed && stream.match("#{", false)) {
                  state.tokenize.push(tokenNest("#{", "}", "meta"));
                  return "string";
                }

                escaped = embed && stream.next() == "\\";
              } else {
                stream.next();
                escaped = false;
              }
            }

            return "string";
          }
        }

        return {
          startState: function () {
            return {
              tokenize: [tokenBase],
              currentIndent: 0,
              lastToken: null,
              lastStyle: null,
              blocks: []
            };
          },

          token: function (stream, state) {
            var style = state.tokenize[state.tokenize.length - 1](stream, state);
            var token = stream.current();

            if (style && style != "comment") {
              state.lastToken = token;
              state.lastStyle = style;
            }

            return style;
          },

          indent: function (state, textAfter) {
            textAfter = textAfter.replace(/^\s*(?:\{%)?\s*|\s*(?:%\})?\s*$/g, "");

            if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {
              return config.indentUnit * (state.currentIndent - 1);
            }

            return config.indentUnit * state.currentIndent;
          },

          fold: "indent",
          electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),
          lineComment: '#'
        };
      });

      CodeMirror.defineMIME("text/x-crystal", "crystal");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-cypher-cypher.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // By the Neo4j Team and contributors.
    // https://github.com/neo4j-contrib/CodeMirror

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";
      var wordRegexp = function(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      };

      CodeMirror.defineMode("cypher", function(config) {
        var tokenBase = function(stream/*, state*/) {
          var ch = stream.next();
          if (ch ==='"') {
            stream.match(/^[^"]*"/);
            return "string";
          }
          if (ch === "'") {
            stream.match(/^[^']*'/);
            return "string";
          }
          if (/[{}\(\),\.;\[\]]/.test(ch)) {
            curPunc = ch;
            return "node";
          } else if (ch === "/" && stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          } else if (operatorChars.test(ch)) {
            stream.eatWhile(operatorChars);
            return null;
          } else {
            stream.eatWhile(/[_\w\d]/);
            if (stream.eat(":")) {
              stream.eatWhile(/[\w\d_\-]/);
              return "atom";
            }
            var word = stream.current();
            if (funcs.test(word)) return "builtin";
            if (preds.test(word)) return "def";
            if (keywords.test(word) || systemKeywords.test(word)) return "keyword";
            return "variable";
          }
        };
        var pushContext = function(state, type, col) {
          return state.context = {
            prev: state.context,
            indent: state.indent,
            col: col,
            type: type
          };
        };
        var popContext = function(state) {
          state.indent = state.context.indent;
          return state.context = state.context.prev;
        };
        var indentUnit = config.indentUnit;
        var curPunc;
        var funcs = wordRegexp(["abs", "acos", "allShortestPaths", "asin", "atan", "atan2", "avg", "ceil", "coalesce", "collect", "cos", "cot", "count", "degrees", "e", "endnode", "exp", "extract", "filter", "floor", "haversin", "head", "id", "keys", "labels", "last", "left", "length", "log", "log10", "lower", "ltrim", "max", "min", "node", "nodes", "percentileCont", "percentileDisc", "pi", "radians", "rand", "range", "reduce", "rel", "relationship", "relationships", "replace", "reverse", "right", "round", "rtrim", "shortestPath", "sign", "sin", "size", "split", "sqrt", "startnode", "stdev", "stdevp", "str", "substring", "sum", "tail", "tan", "timestamp", "toFloat", "toInt", "toString", "trim", "type", "upper"]);
        var preds = wordRegexp(["all", "and", "any", "contains", "exists", "has", "in", "none", "not", "or", "single", "xor"]);
        var keywords = wordRegexp(["as", "asc", "ascending", "assert", "by", "case", "commit", "constraint", "create", "csv", "cypher", "delete", "desc", "descending", "detach", "distinct", "drop", "else", "end", "ends", "explain", "false", "fieldterminator", "foreach", "from", "headers", "in", "index", "is", "join", "limit", "load", "match", "merge", "null", "on", "optional", "order", "periodic", "profile", "remove", "return", "scan", "set", "skip", "start", "starts", "then", "true", "union", "unique", "unwind", "using", "when", "where", "with", "call", "yield"]);
        var systemKeywords = wordRegexp(["access", "active", "assign", "all", "alter", "as", "catalog", "change", "copy", "create", "constraint", "constraints", "current", "database", "databases", "dbms", "default", "deny", "drop", "element", "elements", "exists", "from", "grant", "graph", "graphs", "if", "index", "indexes", "label", "labels", "management", "match", "name", "names", "new", "node", "nodes", "not", "of", "on", "or", "password", "populated", "privileges", "property", "read", "relationship", "relationships", "remove", "replace", "required", "revoke", "role", "roles", "set", "show", "start", "status", "stop", "suspended", "to", "traverse", "type", "types", "user", "users", "with", "write"]);
        var operatorChars = /[*+\-<>=&|~%^]/;

        return {
          startState: function(/*base*/) {
            return {
              tokenize: tokenBase,
              context: null,
              indent: 0,
              col: 0
            };
          },
          token: function(stream, state) {
            if (stream.sol()) {
              if (state.context && (state.context.align == null)) {
                state.context.align = false;
              }
              state.indent = stream.indentation();
            }
            if (stream.eatSpace()) {
              return null;
            }
            var style = state.tokenize(stream, state);
            if (style !== "comment" && state.context && (state.context.align == null) && state.context.type !== "pattern") {
              state.context.align = true;
            }
            if (curPunc === "(") {
              pushContext(state, ")", stream.column());
            } else if (curPunc === "[") {
              pushContext(state, "]", stream.column());
            } else if (curPunc === "{") {
              pushContext(state, "}", stream.column());
            } else if (/[\]\}\)]/.test(curPunc)) {
              while (state.context && state.context.type === "pattern") {
                popContext(state);
              }
              if (state.context && curPunc === state.context.type) {
                popContext(state);
              }
            } else if (curPunc === "." && state.context && state.context.type === "pattern") {
              popContext(state);
            } else if (/atom|string|variable/.test(style) && state.context) {
              if (/[\}\]]/.test(state.context.type)) {
                pushContext(state, "pattern", stream.column());
              } else if (state.context.type === "pattern" && !state.context.align) {
                state.context.align = true;
                state.context.col = stream.column();
              }
            }
            return style;
          },
          indent: function(state, textAfter) {
            var firstChar = textAfter && textAfter.charAt(0);
            var context = state.context;
            if (/[\]\}]/.test(firstChar)) {
              while (context && context.type === "pattern") {
                context = context.prev;
              }
            }
            var closing = context && firstChar === context.type;
            if (!context) return 0;
            if (context.type === "keywords") return CodeMirror.commands.newlineAndIndent;
            if (context.align) return context.col + (closing ? 0 : 1);
            return context.indent + (closing ? 0 : indentUnit);
          }
        };
      });

      CodeMirror.modeExtensions["cypher"] = {
        autoFormatLineBreaks: function(text) {
          var i, lines, reProcessedPortion;
          var lines = text.split("\n");
          var reProcessedPortion = /\s+\b(return|where|order by|match|with|skip|limit|create|delete|set)\b\s/g;
          for (var i = 0; i < lines.length; i++)
            lines[i] = lines[i].replace(reProcessedPortion, " \n$1 ").trim();
          return lines.join("\n");
        }
      };

      CodeMirror.defineMIME("application/x-cypher-query", "cypher");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-diff-diff.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("diff", function() {

      var TOKEN_NAMES = {
        '+': 'positive',
        '-': 'negative',
        '@': 'meta'
      };

      return {
        token: function(stream) {
          var tw_pos = stream.string.search(/[\t ]+?$/);

          if (!stream.sol() || tw_pos === 0) {
            stream.skipToEnd();
            return ("error " + (
              TOKEN_NAMES[stream.string.charAt(0)] || '')).replace(/ $/, '');
          }

          var token_name = TOKEN_NAMES[stream.peek()] || stream.skipToEnd();

          if (tw_pos === -1) {
            stream.skipToEnd();
          } else {
            stream.pos = tw_pos;
          }

          return token_name;
        }
      };
    });

    CodeMirror.defineMIME("text/x-diff", "diff");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-dockerfile-dockerfile.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../addon/mode/simple"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var from = "from";
      var fromRegex = new RegExp("^(\\s*)\\b(" + from + ")\\b", "i");

      var shells = ["run", "cmd", "entrypoint", "shell"];
      var shellsAsArrayRegex = new RegExp("^(\\s*)(" + shells.join('|') + ")(\\s+\\[)", "i");

      var expose = "expose";
      var exposeRegex = new RegExp("^(\\s*)(" + expose + ")(\\s+)", "i");

      var others = [
        "arg", "from", "maintainer", "label", "env",
        "add", "copy", "volume", "user",
        "workdir", "onbuild", "stopsignal", "healthcheck", "shell"
      ];

      // Collect all Dockerfile directives
      var instructions = [from, expose].concat(shells).concat(others),
          instructionRegex = "(" + instructions.join('|') + ")",
          instructionOnlyLine = new RegExp("^(\\s*)" + instructionRegex + "(\\s*)(#.*)?$", "i"),
          instructionWithArguments = new RegExp("^(\\s*)" + instructionRegex + "(\\s+)", "i");

      CodeMirror.defineSimpleMode("dockerfile", {
        start: [
          // Block comment: This is a line starting with a comment
          {
            regex: /^\s*#.*$/,
            sol: true,
            token: "comment"
          },
          {
            regex: fromRegex,
            token: [null, "keyword"],
            sol: true,
            next: "from"
          },
          // Highlight an instruction without any arguments (for convenience)
          {
            regex: instructionOnlyLine,
            token: [null, "keyword", null, "error"],
            sol: true
          },
          {
            regex: shellsAsArrayRegex,
            token: [null, "keyword", null],
            sol: true,
            next: "array"
          },
          {
            regex: exposeRegex,
            token: [null, "keyword", null],
            sol: true,
            next: "expose"
          },
          // Highlight an instruction followed by arguments
          {
            regex: instructionWithArguments,
            token: [null, "keyword", null],
            sol: true,
            next: "arguments"
          },
          {
            regex: /./,
            token: null
          }
        ],
        from: [
          {
            regex: /\s*$/,
            token: null,
            next: "start"
          },
          {
            // Line comment without instruction arguments is an error
            regex: /(\s*)(#.*)$/,
            token: [null, "error"],
            next: "start"
          },
          {
            regex: /(\s*\S+\s+)(as)/i,
            token: [null, "keyword"],
            next: "start"
          },
          // Fail safe return to start
          {
            token: null,
            next: "start"
          }
        ],
        single: [
          {
            regex: /(?:[^\\']|\\.)/,
            token: "string"
          },
          {
            regex: /'/,
            token: "string",
            pop: true
          }
        ],
        double: [
          {
            regex: /(?:[^\\"]|\\.)/,
            token: "string"
          },
          {
            regex: /"/,
            token: "string",
            pop: true
          }
        ],
        array: [
          {
            regex: /\]/,
            token: null,
            next: "start"
          },
          {
            regex: /"(?:[^\\"]|\\.)*"?/,
            token: "string"
          }
        ],
        expose: [
          {
            regex: /\d+$/,
            token: "number",
            next: "start"
          },
          {
            regex: /[^\d]+$/,
            token: null,
            next: "start"
          },
          {
            regex: /\d+/,
            token: "number"
          },
          {
            regex: /[^\d]+/,
            token: null
          },
          // Fail safe return to start
          {
            token: null,
            next: "start"
          }
        ],
        arguments: [
          {
            regex: /^\s*#.*$/,
            sol: true,
            token: "comment"
          },
          {
            regex: /"(?:[^\\"]|\\.)*"?$/,
            token: "string",
            next: "start"
          },
          {
            regex: /"/,
            token: "string",
            push: "double"
          },
          {
            regex: /'(?:[^\\']|\\.)*'?$/,
            token: "string",
            next: "start"
          },
          {
            regex: /'/,
            token: "string",
            push: "single"
          },
          {
            regex: /[^#"']+[\\`]$/,
            token: null
          },
          {
            regex: /[^#"']+$/,
            token: null,
            next: "start"
          },
          {
            regex: /[^#"']+/,
            token: null
          },
          // Fail safe return to start
          {
            token: null,
            next: "start"
          }
        ],
        meta: {
          lineComment: "#"
        }
      });

      CodeMirror.defineMIME("text/x-dockerfile", "dockerfile");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-elm-elm.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: http://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("elm", function() {

        function switchState(source, setState, f)
        {
          setState(f);
          return f(source, setState);
        }

        var lowerRE = /[a-z]/;
        var upperRE = /[A-Z]/;
        var innerRE = /[a-zA-Z0-9_]/;

        var digitRE = /[0-9]/;
        var hexRE = /[0-9A-Fa-f]/;
        var symbolRE = /[-&*+.\\/<>=?^|:]/;
        var specialRE = /[(),[\]{}]/;
        var spacesRE = /[ \v\f]/; // newlines are handled in tokenizer

        function normal()
        {
          return function(source, setState)
          {
            if (source.eatWhile(spacesRE))
            {
              return null;
            }

            var char = source.next();

            if (specialRE.test(char))
            {
              return (char === '{' && source.eat('-'))
                ? switchState(source, setState, chompMultiComment(1))
                : (char === '[' && source.match('glsl|'))
                    ? switchState(source, setState, chompGlsl)
                    : 'builtin';
            }

            if (char === '\'')
            {
              return switchState(source, setState, chompChar);
            }

            if (char === '"')
            {
              return source.eat('"')
                ? source.eat('"')
                    ? switchState(source, setState, chompMultiString)
                    : 'string'
                : switchState(source, setState, chompSingleString);
            }

            if (upperRE.test(char))
            {
              source.eatWhile(innerRE);
              return 'variable-2';
            }

            if (lowerRE.test(char))
            {
              var isDef = source.pos === 1;
              source.eatWhile(innerRE);
              return isDef ? "def" : "variable";
            }

            if (digitRE.test(char))
            {
              if (char === '0')
              {
                if (source.eat(/[xX]/))
                {
                  source.eatWhile(hexRE); // should require at least 1
                  return "number";
                }
              }
              else
              {
                source.eatWhile(digitRE);
              }
              if (source.eat('.'))
              {
                source.eatWhile(digitRE); // should require at least 1
              }
              if (source.eat(/[eE]/))
              {
                source.eat(/[-+]/);
                source.eatWhile(digitRE); // should require at least 1
              }
              return "number";
            }

            if (symbolRE.test(char))
            {
              if (char === '-' && source.eat('-'))
              {
                source.skipToEnd();
                return "comment";
              }
              source.eatWhile(symbolRE);
              return "keyword";
            }

            if (char === '_')
            {
              return "keyword";
            }

            return "error";
          }
        }

        function chompMultiComment(nest)
        {
          if (nest == 0)
          {
            return normal();
          }
          return function(source, setState)
          {
            while (!source.eol())
            {
              var char = source.next();
              if (char == '{' && source.eat('-'))
              {
                ++nest;
              }
              else if (char == '-' && source.eat('}'))
              {
                --nest;
                if (nest === 0)
                {
                  setState(normal());
                  return 'comment';
                }
              }
            }
            setState(chompMultiComment(nest));
            return 'comment';
          }
        }

        function chompMultiString(source, setState)
        {
          while (!source.eol())
          {
            var char = source.next();
            if (char === '"' && source.eat('"') && source.eat('"'))
            {
              setState(normal());
              return 'string';
            }
          }
          return 'string';
        }

        function chompSingleString(source, setState)
        {
          while (source.skipTo('\\"')) { source.next(); source.next(); }
          if (source.skipTo('"'))
          {
            source.next();
            setState(normal());
            return 'string';
          }
          source.skipToEnd();
          setState(normal());
          return 'error';
        }

        function chompChar(source, setState)
        {
          while (source.skipTo("\\'")) { source.next(); source.next(); }
          if (source.skipTo("'"))
          {
            source.next();
            setState(normal());
            return 'string';
          }
          source.skipToEnd();
          setState(normal());
          return 'error';
        }

        function chompGlsl(source, setState)
        {
          while (!source.eol())
          {
            var char = source.next();
            if (char === '|' && source.eat(']'))
            {
              setState(normal());
              return 'string';
            }
          }
          return 'string';
        }

        var wellKnownWords = {
          case: 1,
          of: 1,
          as: 1,
          if: 1,
          then: 1,
          else: 1,
          let: 1,
          in: 1,
          type: 1,
          alias: 1,
          module: 1,
          where: 1,
          import: 1,
          exposing: 1,
          port: 1
        };

        return {
          startState: function ()  { return { f: normal() }; },
          copyState:  function (s) { return { f: s.f }; },

          token: function(stream, state) {
            var type = state.f(stream, function(s) { state.f = s; });
            var word = stream.current();
            return (wellKnownWords.hasOwnProperty(word)) ? 'keyword' : type;
          }
        };

      });

      CodeMirror.defineMIME("text/x-elm", "elm");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-gas-gas.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("gas", function(_config, parserConfig) {
      'use strict';

      // If an architecture is specified, its initialization function may
      // populate this array with custom parsing functions which will be
      // tried in the event that the standard functions do not find a match.
      var custom = [];

      // The symbol used to start a line comment changes based on the target
      // architecture.
      // If no architecture is pased in "parserConfig" then only multiline
      // comments will have syntax support.
      var lineCommentStartSymbol = "";

      // These directives are architecture independent.
      // Machine specific directives should go in their respective
      // architecture initialization function.
      // Reference:
      // http://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops
      var directives = {
        ".abort" : "builtin",
        ".align" : "builtin",
        ".altmacro" : "builtin",
        ".ascii" : "builtin",
        ".asciz" : "builtin",
        ".balign" : "builtin",
        ".balignw" : "builtin",
        ".balignl" : "builtin",
        ".bundle_align_mode" : "builtin",
        ".bundle_lock" : "builtin",
        ".bundle_unlock" : "builtin",
        ".byte" : "builtin",
        ".cfi_startproc" : "builtin",
        ".comm" : "builtin",
        ".data" : "builtin",
        ".def" : "builtin",
        ".desc" : "builtin",
        ".dim" : "builtin",
        ".double" : "builtin",
        ".eject" : "builtin",
        ".else" : "builtin",
        ".elseif" : "builtin",
        ".end" : "builtin",
        ".endef" : "builtin",
        ".endfunc" : "builtin",
        ".endif" : "builtin",
        ".equ" : "builtin",
        ".equiv" : "builtin",
        ".eqv" : "builtin",
        ".err" : "builtin",
        ".error" : "builtin",
        ".exitm" : "builtin",
        ".extern" : "builtin",
        ".fail" : "builtin",
        ".file" : "builtin",
        ".fill" : "builtin",
        ".float" : "builtin",
        ".func" : "builtin",
        ".global" : "builtin",
        ".gnu_attribute" : "builtin",
        ".hidden" : "builtin",
        ".hword" : "builtin",
        ".ident" : "builtin",
        ".if" : "builtin",
        ".incbin" : "builtin",
        ".include" : "builtin",
        ".int" : "builtin",
        ".internal" : "builtin",
        ".irp" : "builtin",
        ".irpc" : "builtin",
        ".lcomm" : "builtin",
        ".lflags" : "builtin",
        ".line" : "builtin",
        ".linkonce" : "builtin",
        ".list" : "builtin",
        ".ln" : "builtin",
        ".loc" : "builtin",
        ".loc_mark_labels" : "builtin",
        ".local" : "builtin",
        ".long" : "builtin",
        ".macro" : "builtin",
        ".mri" : "builtin",
        ".noaltmacro" : "builtin",
        ".nolist" : "builtin",
        ".octa" : "builtin",
        ".offset" : "builtin",
        ".org" : "builtin",
        ".p2align" : "builtin",
        ".popsection" : "builtin",
        ".previous" : "builtin",
        ".print" : "builtin",
        ".protected" : "builtin",
        ".psize" : "builtin",
        ".purgem" : "builtin",
        ".pushsection" : "builtin",
        ".quad" : "builtin",
        ".reloc" : "builtin",
        ".rept" : "builtin",
        ".sbttl" : "builtin",
        ".scl" : "builtin",
        ".section" : "builtin",
        ".set" : "builtin",
        ".short" : "builtin",
        ".single" : "builtin",
        ".size" : "builtin",
        ".skip" : "builtin",
        ".sleb128" : "builtin",
        ".space" : "builtin",
        ".stab" : "builtin",
        ".string" : "builtin",
        ".struct" : "builtin",
        ".subsection" : "builtin",
        ".symver" : "builtin",
        ".tag" : "builtin",
        ".text" : "builtin",
        ".title" : "builtin",
        ".type" : "builtin",
        ".uleb128" : "builtin",
        ".val" : "builtin",
        ".version" : "builtin",
        ".vtable_entry" : "builtin",
        ".vtable_inherit" : "builtin",
        ".warning" : "builtin",
        ".weak" : "builtin",
        ".weakref" : "builtin",
        ".word" : "builtin"
      };

      var registers = {};

      function x86(_parserConfig) {
        lineCommentStartSymbol = "#";

        registers.ax  = "variable";
        registers.eax = "variable-2";
        registers.rax = "variable-3";

        registers.bx  = "variable";
        registers.ebx = "variable-2";
        registers.rbx = "variable-3";

        registers.cx  = "variable";
        registers.ecx = "variable-2";
        registers.rcx = "variable-3";

        registers.dx  = "variable";
        registers.edx = "variable-2";
        registers.rdx = "variable-3";

        registers.si  = "variable";
        registers.esi = "variable-2";
        registers.rsi = "variable-3";

        registers.di  = "variable";
        registers.edi = "variable-2";
        registers.rdi = "variable-3";

        registers.sp  = "variable";
        registers.esp = "variable-2";
        registers.rsp = "variable-3";

        registers.bp  = "variable";
        registers.ebp = "variable-2";
        registers.rbp = "variable-3";

        registers.ip  = "variable";
        registers.eip = "variable-2";
        registers.rip = "variable-3";

        registers.cs  = "keyword";
        registers.ds  = "keyword";
        registers.ss  = "keyword";
        registers.es  = "keyword";
        registers.fs  = "keyword";
        registers.gs  = "keyword";
      }

      function armv6(_parserConfig) {
        // Reference:
        // http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf
        // http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/DDI0301H_arm1176jzfs_r0p7_trm.pdf
        lineCommentStartSymbol = "@";
        directives.syntax = "builtin";

        registers.r0  = "variable";
        registers.r1  = "variable";
        registers.r2  = "variable";
        registers.r3  = "variable";
        registers.r4  = "variable";
        registers.r5  = "variable";
        registers.r6  = "variable";
        registers.r7  = "variable";
        registers.r8  = "variable";
        registers.r9  = "variable";
        registers.r10 = "variable";
        registers.r11 = "variable";
        registers.r12 = "variable";

        registers.sp  = "variable-2";
        registers.lr  = "variable-2";
        registers.pc  = "variable-2";
        registers.r13 = registers.sp;
        registers.r14 = registers.lr;
        registers.r15 = registers.pc;

        custom.push(function(ch, stream) {
          if (ch === '#') {
            stream.eatWhile(/\w/);
            return "number";
          }
        });
      }

      var arch = (parserConfig.architecture || "x86").toLowerCase();
      if (arch === "x86") {
        x86(parserConfig);
      } else if (arch === "arm" || arch === "armv6") {
        armv6(parserConfig);
      }

      function nextUntilUnescaped(stream, end) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (next === end && !escaped) {
            return false;
          }
          escaped = !escaped && next === "\\";
        }
        return escaped;
      }

      function clikeComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (ch === "/" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch === "*");
        }
        return "comment";
      }

      return {
        startState: function() {
          return {
            tokenize: null
          };
        },

        token: function(stream, state) {
          if (state.tokenize) {
            return state.tokenize(stream, state);
          }

          if (stream.eatSpace()) {
            return null;
          }

          var style, cur, ch = stream.next();

          if (ch === "/") {
            if (stream.eat("*")) {
              state.tokenize = clikeComment;
              return clikeComment(stream, state);
            }
          }

          if (ch === lineCommentStartSymbol) {
            stream.skipToEnd();
            return "comment";
          }

          if (ch === '"') {
            nextUntilUnescaped(stream, '"');
            return "string";
          }

          if (ch === '.') {
            stream.eatWhile(/\w/);
            cur = stream.current().toLowerCase();
            style = directives[cur];
            return style || null;
          }

          if (ch === '=') {
            stream.eatWhile(/\w/);
            return "tag";
          }

          if (ch === '{') {
            return "bracket";
          }

          if (ch === '}') {
            return "bracket";
          }

          if (/\d/.test(ch)) {
            if (ch === "0" && stream.eat("x")) {
              stream.eatWhile(/[0-9a-fA-F]/);
              return "number";
            }
            stream.eatWhile(/\d/);
            return "number";
          }

          if (/\w/.test(ch)) {
            stream.eatWhile(/\w/);
            if (stream.eat(":")) {
              return 'tag';
            }
            cur = stream.current().toLowerCase();
            style = registers[cur];
            return style || null;
          }

          for (var i = 0; i < custom.length; i++) {
            style = custom[i](ch, stream, state);
            if (style) {
              return style;
            }
          }
        },

        lineComment: lineCommentStartSymbol,
        blockCommentStart: "/*",
        blockCommentEnd: "*/"
      };
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-gherkin-gherkin.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
    Gherkin mode - http://www.cukes.info/
    Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues
    */

    // Following Objs from Brackets implementation: https://github.com/tregusti/brackets-gherkin/blob/master/main.js
    //var Quotes = {
    //  SINGLE: 1,
    //  DOUBLE: 2
    //};

    //var regex = {
    //  keywords: /(Feature| {2}(Scenario|In order to|As|I)| {4}(Given|When|Then|And))/
    //};

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("gherkin", function () {
      return {
        startState: function () {
          return {
            lineNumber: 0,
            tableHeaderLine: false,
            allowFeature: true,
            allowBackground: false,
            allowScenario: false,
            allowSteps: false,
            allowPlaceholders: false,
            allowMultilineArgument: false,
            inMultilineString: false,
            inMultilineTable: false,
            inKeywordLine: false
          };
        },
        token: function (stream, state) {
          if (stream.sol()) {
            state.lineNumber++;
            state.inKeywordLine = false;
            if (state.inMultilineTable) {
                state.tableHeaderLine = false;
                if (!stream.match(/\s*\|/, false)) {
                  state.allowMultilineArgument = false;
                  state.inMultilineTable = false;
                }
            }
          }

          stream.eatSpace();

          if (state.allowMultilineArgument) {

            // STRING
            if (state.inMultilineString) {
              if (stream.match('"""')) {
                state.inMultilineString = false;
                state.allowMultilineArgument = false;
              } else {
                stream.match(/.*/);
              }
              return "string";
            }

            // TABLE
            if (state.inMultilineTable) {
              if (stream.match(/\|\s*/)) {
                return "bracket";
              } else {
                stream.match(/[^\|]*/);
                return state.tableHeaderLine ? "header" : "string";
              }
            }

            // DETECT START
            if (stream.match('"""')) {
              // String
              state.inMultilineString = true;
              return "string";
            } else if (stream.match("|")) {
              // Table
              state.inMultilineTable = true;
              state.tableHeaderLine = true;
              return "bracket";
            }

          }

          // LINE COMMENT
          if (stream.match(/#.*/)) {
            return "comment";

          // TAG
          } else if (!state.inKeywordLine && stream.match(/@\S+/)) {
            return "tag";

          // FEATURE
          } else if (!state.inKeywordLine && state.allowFeature && stream.match(/(機能|功能|フィーチャ|기능|โครงหลัก|ความสามารถ|ความต้องการทางธุรกิจ|ಹೆಚ್ಚಳ|గుణము|ਮੁਹਾਂਦਰਾ|ਨਕਸ਼ ਨੁਹਾਰ|ਖਾਸੀਅਤ|रूप लेख|وِیژگی|خاصية|תכונה|Функціонал|Функция|Функционалност|Функционал|Үзенчәлеклелек|Свойство|Особина|Мөмкинлек|Могућност|Λειτουργία|Δυνατότητα|Właściwość|Vlastnosť|Trajto|Tính năng|Savybė|Pretty much|Požiadavka|Požadavek|Potrzeba biznesowa|Özellik|Osobina|Ominaisuus|Omadus|OH HAI|Mogućnost|Mogucnost|Jellemző|Hwæt|Hwaet|Funzionalità|Funktionalitéit|Funktionalität|Funkcja|Funkcionalnost|Funkcionalitāte|Funkcia|Fungsi|Functionaliteit|Funcționalitate|Funcţionalitate|Functionalitate|Funcionalitat|Funcionalidade|Fonctionnalité|Fitur|Fīča|Feature|Eiginleiki|Egenskap|Egenskab|Característica|Caracteristica|Business Need|Aspekt|Arwedd|Ahoy matey!|Ability):/)) {
            state.allowScenario = true;
            state.allowBackground = true;
            state.allowPlaceholders = false;
            state.allowSteps = false;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // BACKGROUND
          } else if (!state.inKeywordLine && state.allowBackground && stream.match(/(背景|배경|แนวคิด|ಹಿನ್ನೆಲೆ|నేపథ్యం|ਪਿਛੋਕੜ|पृष्ठभूमि|زمینه|الخلفية|רקע|Тарих|Предыстория|Предистория|Позадина|Передумова|Основа|Контекст|Кереш|Υπόβαθρο|Założenia|Yo\-ho\-ho|Tausta|Taust|Situācija|Rerefons|Pozadina|Pozadie|Pozadí|Osnova|Latar Belakang|Kontext|Konteksts|Kontekstas|Kontekst|Háttér|Hannergrond|Grundlage|Geçmiş|Fundo|Fono|First off|Dis is what went down|Dasar|Contexto|Contexte|Context|Contesto|Cenário de Fundo|Cenario de Fundo|Cefndir|Bối cảnh|Bakgrunnur|Bakgrunn|Bakgrund|Baggrund|Background|B4|Antecedents|Antecedentes|Ær|Aer|Achtergrond):/)) {
            state.allowPlaceholders = false;
            state.allowSteps = true;
            state.allowBackground = false;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // SCENARIO OUTLINE
          } else if (!state.inKeywordLine && state.allowScenario && stream.match(/(場景大綱|场景大纲|劇本大綱|剧本大纲|テンプレ|シナリオテンプレート|シナリオテンプレ|シナリオアウトライン|시나리오 개요|สรุปเหตุการณ์|โครงสร้างของเหตุการณ์|ವಿವರಣೆ|కథనం|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਟਕਥਾ ਢਾਂਚਾ|परिदृश्य रूपरेखा|سيناريو مخطط|الگوی سناریو|תבנית תרחיש|Сценарийның төзелеше|Сценарий структураси|Структура сценарію|Структура сценария|Структура сценарија|Скица|Рамка на сценарий|Концепт|Περιγραφή Σεναρίου|Wharrimean is|Template Situai|Template Senario|Template Keadaan|Tapausaihio|Szenariogrundriss|Szablon scenariusza|Swa hwær swa|Swa hwaer swa|Struktura scenarija|Structură scenariu|Structura scenariu|Skica|Skenario konsep|Shiver me timbers|Senaryo taslağı|Schema dello scenario|Scenariomall|Scenariomal|Scenario Template|Scenario Outline|Scenario Amlinellol|Scenārijs pēc parauga|Scenarijaus šablonas|Reckon it's like|Raamstsenaarium|Plang vum Szenario|Plan du Scénario|Plan du scénario|Osnova scénáře|Osnova Scenára|Náčrt Scenáru|Náčrt Scénáře|Náčrt Scenára|MISHUN SRSLY|Menggariskan Senario|Lýsing Dæma|Lýsing Atburðarásar|Konturo de la scenaro|Koncept|Khung tình huống|Khung kịch bản|Forgatókönyv vázlat|Esquema do Cenário|Esquema do Cenario|Esquema del escenario|Esquema de l'escenari|Esbozo do escenario|Delineação do Cenário|Delineacao do Cenario|All y'all|Abstrakt Scenario|Abstract Scenario):/)) {
            state.allowPlaceholders = true;
            state.allowSteps = true;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // EXAMPLES
          } else if (state.allowScenario && stream.match(/(例子|例|サンプル|예|ชุดของเหตุการณ์|ชุดของตัวอย่าง|ಉದಾಹರಣೆಗಳು|ఉదాహరణలు|ਉਦਾਹਰਨਾਂ|उदाहरण|نمونه ها|امثلة|דוגמאות|Үрнәкләр|Сценарији|Примеры|Примери|Приклади|Мисоллар|Мисаллар|Σενάρια|Παραδείγματα|You'll wanna|Voorbeelden|Variantai|Tapaukset|Se þe|Se the|Se ðe|Scenarios|Scenariji|Scenarijai|Przykłady|Primjeri|Primeri|Příklady|Príklady|Piemēri|Példák|Pavyzdžiai|Paraugs|Örnekler|Juhtumid|Exemplos|Exemples|Exemple|Exempel|EXAMPLZ|Examples|Esempi|Enghreifftiau|Ekzemploj|Eksempler|Ejemplos|Dữ liệu|Dead men tell no tales|Dæmi|Contoh|Cenários|Cenarios|Beispiller|Beispiele|Atburðarásir):/)) {
            state.allowPlaceholders = false;
            state.allowSteps = true;
            state.allowBackground = false;
            state.allowMultilineArgument = true;
            return "keyword";

          // SCENARIO
          } else if (!state.inKeywordLine && state.allowScenario && stream.match(/(場景|场景|劇本|剧本|シナリオ|시나리오|เหตุการณ์|ಕಥಾಸಾರಾಂಶ|సన్నివేశం|ਪਟਕਥਾ|परिदृश्य|سيناريو|سناریو|תרחיש|Сценарій|Сценарио|Сценарий|Пример|Σενάριο|Tình huống|The thing of it is|Tapaus|Szenario|Swa|Stsenaarium|Skenario|Situai|Senaryo|Senario|Scenaro|Scenariusz|Scenariu|Scénario|Scenario|Scenarijus|Scenārijs|Scenarij|Scenarie|Scénář|Scenár|Primer|MISHUN|Kịch bản|Keadaan|Heave to|Forgatókönyv|Escenario|Escenari|Cenário|Cenario|Awww, look mate|Atburðarás):/)) {
            state.allowPlaceholders = false;
            state.allowSteps = true;
            state.allowBackground = false;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // STEPS
          } else if (!state.inKeywordLine && state.allowSteps && stream.match(/(那麼|那么|而且|當|当|并且|同時|同时|前提|假设|假設|假定|假如|但是|但し|並且|もし|ならば|ただし|しかし|かつ|하지만|조건|먼저|만일|만약|단|그리고|그러면|และ |เมื่อ |แต่ |ดังนั้น |กำหนดให้ |ಸ್ಥಿತಿಯನ್ನು |ಮತ್ತು |ನೀಡಿದ |ನಂತರ |ಆದರೆ |మరియు |చెప్పబడినది |కాని |ఈ పరిస్థితిలో |అప్పుడు |ਪਰ |ਤਦ |ਜੇਕਰ |ਜਿਵੇਂ ਕਿ |ਜਦੋਂ |ਅਤੇ |यदि |परन्तु |पर |तब |तदा |तथा |जब |चूंकि |किन्तु |कदा |और |अगर |و |هنگامی |متى |لكن |عندما |ثم |بفرض |با فرض |اما |اذاً |آنگاه |כאשר |וגם |בהינתן |אזי |אז |אבל |Якщо |Һәм |Унда |Тоді |Тогда |То |Также |Та |Пусть |Припустимо, що |Припустимо |Онда |Но |Нехай |Нәтиҗәдә |Лекин |Ләкин |Коли |Когда |Когато |Када |Кад |К тому же |І |И |Задато |Задати |Задате |Если |Допустим |Дано |Дадено |Вә |Ва |Бирок |Әмма |Әйтик |Әгәр |Аммо |Али |Але |Агар |А також |А |Τότε |Όταν |Και |Δεδομένου |Αλλά |Þurh |Þegar |Þa þe |Þá |Þa |Zatati |Zakładając |Zadato |Zadate |Zadano |Zadani |Zadan |Za předpokladu |Za predpokladu |Youse know when youse got |Youse know like when |Yna |Yeah nah |Y'know |Y |Wun |Wtedy |When y'all |When |Wenn |WEN |wann |Ve |Và |Und |Un |ugeholl |Too right |Thurh |Thì |Then y'all |Then |Tha the |Tha |Tetapi |Tapi |Tak |Tada |Tad |Stel |Soit |Siis |Și |Şi |Si |Sed |Se |Så |Quando |Quand |Quan |Pryd |Potom |Pokud |Pokiaľ |Però |Pero |Pak |Oraz |Onda |Ond |Oletetaan |Og |Och |O zaman |Niin |Nhưng |När |Når |Mutta |Men |Mas |Maka |Majd |Mając |Mais |Maar |mä |Ma |Lorsque |Lorsqu'|Logo |Let go and haul |Kun |Kuid |Kui |Kiedy |Khi |Ketika |Kemudian |Keď |Když |Kaj |Kai |Kada |Kad |Jeżeli |Jeśli |Ja |It's just unbelievable |Ir |I CAN HAZ |I |Ha |Givun |Givet |Given y'all |Given |Gitt |Gegeven |Gegeben seien |Gegeben sei |Gdy |Gangway! |Fakat |Étant donnés |Etant donnés |Étant données |Etant données |Étant donnée |Etant donnée |Étant donné |Etant donné |Et |És |Entonces |Entón |Então |Entao |En |Eğer ki |Ef |Eeldades |E |Ðurh |Duota |Dun |Donitaĵo |Donat |Donada |Do |Diyelim ki |Diberi |Dengan |Den youse gotta |DEN |De |Dato |Dați fiind |Daţi fiind |Dati fiind |Dati |Date fiind |Date |Data |Dat fiind |Dar |Dann |dann |Dan |Dados |Dado |Dadas |Dada |Ða ðe |Ða |Cuando |Cho |Cando |Când |Cand |Cal |But y'all |But at the end of the day I reckon |BUT |But |Buh |Blimey! |Biết |Bet |Bagi |Aye |awer |Avast! |Atunci |Atesa |Atès |Apabila |Anrhegedig a |Angenommen |And y'all |And |AN |An |an |Amikor |Amennyiben |Ama |Als |Alors |Allora |Ali |Aleshores |Ale |Akkor |Ak |Adott |Ac |Aber |A zároveň |A tiež |A taktiež |A také |A |a |7 |\* )/)) {
            state.inStep = true;
            state.allowPlaceholders = true;
            state.allowMultilineArgument = true;
            state.inKeywordLine = true;
            return "keyword";

          // INLINE STRING
          } else if (stream.match(/"[^"]*"?/)) {
            return "string";

          // PLACEHOLDER
          } else if (state.allowPlaceholders && stream.match(/<[^>]*>?/)) {
            return "variable";

          // Fall through
          } else {
            stream.next();
            stream.eatWhile(/[^@"<#]/);
            return null;
          }
        }
      };
    });

    CodeMirror.defineMIME("text/x-feature", "gherkin");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-go-go.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("go", function(config) {
      var indentUnit = config.indentUnit;

      var keywords = {
        "break":true, "case":true, "chan":true, "const":true, "continue":true,
        "default":true, "defer":true, "else":true, "fallthrough":true, "for":true,
        "func":true, "go":true, "goto":true, "if":true, "import":true,
        "interface":true, "map":true, "package":true, "range":true, "return":true,
        "select":true, "struct":true, "switch":true, "type":true, "var":true,
        "bool":true, "byte":true, "complex64":true, "complex128":true,
        "float32":true, "float64":true, "int8":true, "int16":true, "int32":true,
        "int64":true, "string":true, "uint8":true, "uint16":true, "uint32":true,
        "uint64":true, "int":true, "uint":true, "uintptr":true, "error": true,
        "rune":true
      };

      var atoms = {
        "true":true, "false":true, "iota":true, "nil":true, "append":true,
        "cap":true, "close":true, "complex":true, "copy":true, "delete":true, "imag":true,
        "len":true, "make":true, "new":true, "panic":true, "print":true,
        "println":true, "real":true, "recover":true
      };

      var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'" || ch == "`") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\d\.]/.test(ch)) {
          if (ch == ".") {
            stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
          } else if (ch == "0") {
            stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
          } else {
            stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
          }
          return "number";
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) {
          if (cur == "case" || cur == "default") curPunc = "case";
          return "keyword";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && quote != "`" && next == "\\";
          }
          if (end || !(escaped || quote == "`"))
            state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        if (!state.context.prev) return;
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
            if (ctx.type == "case") ctx.type = "}";
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment") return style;
          if (ctx.align == null) ctx.align = true;

          if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "case") ctx.type = "case";
          else if (curPunc == "}" && ctx.type == "}") popContext(state);
          else if (curPunc == ctx.type) popContext(state);
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          if (ctx.type == "case" && /^(?:case|default)\b/.test(textAfter)) {
            state.context.type = "}";
            return ctx.indented;
          }
          var closing = firstChar == ctx.type;
          if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}):",
        closeBrackets: "()[]{}''\"\"``",
        fold: "brace",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME("text/x-go", "go");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-handlebars-handlebars.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../addon/mode/simple"), require("../../addon/mode/multiplex"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../addon/mode/simple", "../../addon/mode/multiplex"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineSimpleMode("handlebars-tags", {
        start: [
          { regex: /\{\{\{/, push: "handlebars_raw", token: "tag" },
          { regex: /\{\{!--/, push: "dash_comment", token: "comment" },
          { regex: /\{\{!/,   push: "comment", token: "comment" },
          { regex: /\{\{/,    push: "handlebars", token: "tag" }
        ],
        handlebars_raw: [
          { regex: /\}\}\}/, pop: true, token: "tag" },
        ],
        handlebars: [
          { regex: /\}\}/, pop: true, token: "tag" },

          // Double and single quotes
          { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
          { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },

          // Handlebars keywords
          { regex: />|[#\/]([A-Za-z_]\w*)/, token: "keyword" },
          { regex: /(?:else|this)\b/, token: "keyword" },

          // Numeral
          { regex: /\d+/i, token: "number" },

          // Atoms like = and .
          { regex: /=|~|@|true|false/, token: "atom" },

          // Paths
          { regex: /(?:\.\.\/)*(?:[A-Za-z_][\w\.]*)+/, token: "variable-2" }
        ],
        dash_comment: [
          { regex: /--\}\}/, pop: true, token: "comment" },

          // Commented code
          { regex: /./, token: "comment"}
        ],
        comment: [
          { regex: /\}\}/, pop: true, token: "comment" },
          { regex: /./, token: "comment" }
        ],
        meta: {
          blockCommentStart: "{{--",
          blockCommentEnd: "--}}"
        }
      });

      CodeMirror.defineMode("handlebars", function(config, parserConfig) {
        var handlebars = CodeMirror.getMode(config, "handlebars-tags");
        if (!parserConfig || !parserConfig.base) return handlebars;
        return CodeMirror.multiplexingMode(
          CodeMirror.getMode(config, parserConfig.base),
          {open: "{{", close: /\}\}\}?/, mode: handlebars, parseDelimiters: true}
        );
      });

      CodeMirror.defineMIME("text/x-handlebars-template", "handlebars");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-htmlembedded-htmlembedded.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"),
            require("../../addon/mode/multiplex"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../htmlmixed/htmlmixed",
                "../../addon/mode/multiplex"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("htmlembedded", function(config, parserConfig) {
        var closeComment = parserConfig.closeComment || "--%>"
        return CodeMirror.multiplexingMode(CodeMirror.getMode(config, "htmlmixed"), {
          open: parserConfig.openComment || "<%--",
          close: closeComment,
          delimStyle: "comment",
          mode: {token: function(stream) {
            stream.skipTo(closeComment) || stream.skipToEnd()
            return "comment"
          }}
        }, {
          open: parserConfig.open || parserConfig.scriptStartRegex || "<%",
          close: parserConfig.close || parserConfig.scriptEndRegex || "%>",
          mode: CodeMirror.getMode(config, parserConfig.scriptingModeSpec)
        });
      }, "htmlmixed");

      CodeMirror.defineMIME("application/x-ejs", {name: "htmlembedded", scriptingModeSpec:"javascript"});
      CodeMirror.defineMIME("application/x-aspx", {name: "htmlembedded", scriptingModeSpec:"text/x-csharp"});
      CodeMirror.defineMIME("application/x-jsp", {name: "htmlembedded", scriptingModeSpec:"text/x-java"});
      CodeMirror.defineMIME("application/x-erb", {name: "htmlembedded", scriptingModeSpec:"ruby"});
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-htmlmixed-htmlmixed.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      var defaultTags = {
        script: [
          ["lang", /(javascript|babel)/i, "javascript"],
          ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
          ["type", /./, "text/plain"],
          [null, null, "javascript"]
        ],
        style:  [
          ["lang", /^css$/i, "css"],
          ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
          ["type", /./, "text/plain"],
          [null, null, "css"]
        ]
      };

      function maybeBackup(stream, pat, style) {
        var cur = stream.current(), close = cur.search(pat);
        if (close > -1) {
          stream.backUp(cur.length - close);
        } else if (cur.match(/<\/?$/)) {
          stream.backUp(cur.length);
          if (!stream.match(pat, false)) stream.match(cur);
        }
        return style;
      }

      var attrRegexpCache = {};
      function getAttrRegexp(attr) {
        var regexp = attrRegexpCache[attr];
        if (regexp) return regexp;
        return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
      }

      function getAttrValue(text, attr) {
        var match = text.match(getAttrRegexp(attr))
        return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
      }

      function getTagRegexp(tagName, anchored) {
        return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
      }

      function addTags(from, to) {
        for (var tag in from) {
          var dest = to[tag] || (to[tag] = []);
          var source = from[tag];
          for (var i = source.length - 1; i >= 0; i--)
            dest.unshift(source[i])
        }
      }

      function findMatchingMode(tagInfo, tagText) {
        for (var i = 0; i < tagInfo.length; i++) {
          var spec = tagInfo[i];
          if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
        }
      }

      CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
        var htmlMode = CodeMirror.getMode(config, {
          name: "xml",
          htmlMode: true,
          multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
          multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
          allowMissingTagName: parserConfig.allowMissingTagName,
        });

        var tags = {};
        var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
        addTags(defaultTags, tags);
        if (configTags) addTags(configTags, tags);
        if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
          tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

        function html(stream, state) {
          var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
          if (tag && !/[<>\s\/]/.test(stream.current()) &&
              (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
              tags.hasOwnProperty(tagName)) {
            state.inTag = tagName + " "
          } else if (state.inTag && tag && />$/.test(stream.current())) {
            var inTag = /^([\S]+) (.*)/.exec(state.inTag)
            state.inTag = null
            var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
            var mode = CodeMirror.getMode(config, modeSpec)
            var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
            state.token = function (stream, state) {
              if (stream.match(endTagA, false)) {
                state.token = html;
                state.localState = state.localMode = null;
                return null;
              }
              return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
            };
            state.localMode = mode;
            state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
          } else if (state.inTag) {
            state.inTag += stream.current()
            if (stream.eol()) state.inTag += " "
          }
          return style;
        };

        return {
          startState: function () {
            var state = CodeMirror.startState(htmlMode);
            return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
          },

          copyState: function (state) {
            var local;
            if (state.localState) {
              local = CodeMirror.copyState(state.localMode, state.localState);
            }
            return {token: state.token, inTag: state.inTag,
                    localMode: state.localMode, localState: local,
                    htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
          },

          token: function (stream, state) {
            return state.token(stream, state);
          },

          indent: function (state, textAfter, line) {
            if (!state.localMode || /^\s*<\//.test(textAfter))
              return htmlMode.indent(state.htmlState, textAfter, line);
            else if (state.localMode.indent)
              return state.localMode.indent(state.localState, textAfter, line);
            else
              return CodeMirror.Pass;
          },

          innerMode: function (state) {
            return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
          }
        };
      }, "xml", "javascript", "css");

      CodeMirror.defineMIME("text/html", "htmlmixed");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-http-http.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("http", function() {
      function failFirstLine(stream, state) {
        stream.skipToEnd();
        state.cur = header;
        return "error";
      }

      function start(stream, state) {
        if (stream.match(/^HTTP\/\d\.\d/)) {
          state.cur = responseStatusCode;
          return "keyword";
        } else if (stream.match(/^[A-Z]+/) && /[ \t]/.test(stream.peek())) {
          state.cur = requestPath;
          return "keyword";
        } else {
          return failFirstLine(stream, state);
        }
      }

      function responseStatusCode(stream, state) {
        var code = stream.match(/^\d+/);
        if (!code) return failFirstLine(stream, state);

        state.cur = responseStatusText;
        var status = Number(code[0]);
        if (status >= 100 && status < 200) {
          return "positive informational";
        } else if (status >= 200 && status < 300) {
          return "positive success";
        } else if (status >= 300 && status < 400) {
          return "positive redirect";
        } else if (status >= 400 && status < 500) {
          return "negative client-error";
        } else if (status >= 500 && status < 600) {
          return "negative server-error";
        } else {
          return "error";
        }
      }

      function responseStatusText(stream, state) {
        stream.skipToEnd();
        state.cur = header;
        return null;
      }

      function requestPath(stream, state) {
        stream.eatWhile(/\S/);
        state.cur = requestProtocol;
        return "string-2";
      }

      function requestProtocol(stream, state) {
        if (stream.match(/^HTTP\/\d\.\d$/)) {
          state.cur = header;
          return "keyword";
        } else {
          return failFirstLine(stream, state);
        }
      }

      function header(stream) {
        if (stream.sol() && !stream.eat(/[ \t]/)) {
          if (stream.match(/^.*?:/)) {
            return "atom";
          } else {
            stream.skipToEnd();
            return "error";
          }
        } else {
          stream.skipToEnd();
          return "string";
        }
      }

      function body(stream) {
        stream.skipToEnd();
        return null;
      }

      return {
        token: function(stream, state) {
          var cur = state.cur;
          if (cur != header && cur != body && stream.eatSpace()) return null;
          return cur(stream, state);
        },

        blankLine: function(state) {
          state.cur = body;
        },

        startState: function() {
          return {cur: start};
        }
      };
    });

    CodeMirror.defineMIME("message/http", "http");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-javascript-javascript.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("javascript", function(config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonldMode = parserConfig.jsonld;
      var jsonMode = parserConfig.json || jsonldMode;
      var trackScope = parserConfig.trackScope !== false
      var isTS = parserConfig.typescript;
      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

      // Tokenizer

      var keywords = function(){
        function kw(type) {return {type: type, style: "keyword"};}
        var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
        var operator = kw("operator"), atom = {type: "atom", style: "atom"};

        return {
          "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
          "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
          "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
          "function": kw("function"), "catch": kw("catch"),
          "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
          "in": operator, "typeof": operator, "instanceof": operator,
          "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
          "this": kw("this"), "class": kw("class"), "super": kw("atom"),
          "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
          "await": C
        };
      }();

      var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

      function readRegexp(stream) {
        var escaped = false, next, inSet = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if (next == "/" && !inSet) return;
            if (next == "[") inSet = true;
            else if (inSet && next == "]") inSet = false;
          }
          escaped = !escaped && next == "\\";
        }
      }

      // Used as scratch variables to communicate multiple values without
      // consing up tons of objects.
      var type, content;
      function ret(tp, style, cont) {
        type = tp; content = cont;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>", "operator");
        } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (expressionAllowed(stream, state, 1)) {
            readRegexp(stream);
            stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
            return ret("regexp", "string-2");
          } else {
            stream.eat("=");
            return ret("operator", "operator", stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#" && stream.peek() == "!") {
          stream.skipToEnd();
          return ret("meta", "meta");
        } else if (ch == "#" && stream.eatWhile(wordRE)) {
          return ret("variable", "property")
        } else if (ch == "<" && stream.match("!--") ||
                   (ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start)))) {
          stream.skipToEnd()
          return ret("comment", "comment")
        } else if (isOperatorChar.test(ch)) {
          if (ch != ">" || !state.lexical || state.lexical.type != ">") {
            if (stream.eat("=")) {
              if (ch == "!" || ch == "=") stream.eat("=")
            } else if (/[<>*+\-|&?]/.test(ch)) {
              stream.eat(ch)
              if (ch == ">") stream.eat(ch)
            }
          }
          if (ch == "?" && stream.eat(".")) return ret(".")
          return ret("operator", "operator", stream.current());
        } else if (wordRE.test(ch)) {
          stream.eatWhile(wordRE);
          var word = stream.current()
          if (state.lastType != ".") {
            if (keywords.propertyIsEnumerable(word)) {
              var kw = keywords[word]
              return ret(kw.type, kw.style, word)
            }
            if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
              return ret("async", "keyword", word)
          }
          return ret("variable", "variable", word)
        }
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next;
          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
            state.tokenize = tokenBase;
            return ret("jsonld-keyword", "meta");
          }
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) break;
            escaped = !escaped && next == "\\";
          }
          if (!escaped) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
      }

      function tokenQuasi(stream, state) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }

      var brackets = "([{}])";
      // This is a crude lookahead trick to try and notice that we're
      // parsing the argument patterns for a fat-arrow function before we
      // actually hit the arrow token. It only works if the arrow is on
      // the same line as the arguments and there's no strange noise
      // (comments) in between. Fallback is to only notice when we hit the
      // arrow, and not declare the arguments as locals for the arrow
      // body.
      function findFatArrow(stream, state) {
        if (state.fatArrowAt) state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0) return;

        if (isTS) { // Try to skip TypeScript return type declarations after the arguments
          var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
          if (m) arrow = m.index
        }

        var depth = 0, sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) { ++pos; break; }
            if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (wordRE.test(ch)) {
            sawSomething = true;
          } else if (/["'\/`]/.test(ch)) {
            for (;; --pos) {
              if (pos == 0) return
              var next = stream.string.charAt(pos - 1)
              if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
            }
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth) state.fatArrowAt = pos;
      }

      // Parser

      var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true,
                         "regexp": true, "this": true, "import": true, "jsonld-keyword": true};

      function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
      }

      function inScope(state, varname) {
        if (!trackScope) return false
        for (var v = state.localVars; v; v = v.next)
          if (v.name == varname) return true;
        for (var cx = state.context; cx; cx = cx.prev) {
          for (var v = cx.vars; v; v = v.next)
            if (v.name == varname) return true;
        }
      }

      function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        // Communicate our context to the combinators.
        // (Less wasteful than consing up a hundred closures on every call.)
        cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = true;

        while(true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type, content)) {
            while(cc.length && cc[cc.length - 1].lex)
              cc.pop()();
            if (cx.marked) return cx.marked;
            if (type == "variable" && inScope(state, content)) return "variable-2";
            return style;
          }
        }
      }

      // Combinator utils

      var cx = {state: null, column: null, marked: null, cc: null};
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function inList(name, list) {
        for (var v = list; v; v = v.next) if (v.name == name) return true
        return false;
      }
      function register(varname) {
        var state = cx.state;
        cx.marked = "def";
        if (!trackScope) return
        if (state.context) {
          if (state.lexical.info == "var" && state.context && state.context.block) {
            // FIXME function decls are also not block scoped
            var newContext = registerVarScoped(varname, state.context)
            if (newContext != null) {
              state.context = newContext
              return
            }
          } else if (!inList(varname, state.localVars)) {
            state.localVars = new Var(varname, state.localVars)
            return
          }
        }
        // Fall through means this is global
        if (parserConfig.globalVars && !inList(varname, state.globalVars))
          state.globalVars = new Var(varname, state.globalVars)
      }
      function registerVarScoped(varname, context) {
        if (!context) {
          return null
        } else if (context.block) {
          var inner = registerVarScoped(varname, context.prev)
          if (!inner) return null
          if (inner == context.prev) return context
          return new Context(inner, context.vars, true)
        } else if (inList(varname, context.vars)) {
          return context
        } else {
          return new Context(context.prev, new Var(varname, context.vars), false)
        }
      }

      function isModifier(name) {
        return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
      }

      // Combinators

      function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }
      function Var(name, next) { this.name = name; this.next = next }

      var defaultVars = new Var("this", new Var("arguments", null))
      function pushcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, false)
        cx.state.localVars = defaultVars
      }
      function pushblockcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, true)
        cx.state.localVars = null
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars
        cx.state.context = cx.state.context.prev
      }
      popcontext.lex = true
      function pushlex(type, info) {
        var result = function() {
          var state = cx.state, indent = state.indented;
          if (state.lexical.type == "stat") indent = state.lexical.indented;
          else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
            indent = outer.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")")
            state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;

      function expect(wanted) {
        function exp(type) {
          if (type == wanted) return cont();
          else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
          else return cont(exp);
        };
        return exp;
      }

      function statement(type, value) {
        if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
        if (type == "debugger") return cont(expect(";"));
        if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
        if (type == ";") return cont();
        if (type == "if") {
          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
            cx.state.cc.pop()();
          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
        }
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
        if (type == "class" || (isTS && value == "interface")) {
          cx.marked = "keyword"
          return cont(pushlex("form", type == "class" ? type : value), className, poplex)
        }
        if (type == "variable") {
          if (isTS && value == "declare") {
            cx.marked = "keyword"
            return cont(statement)
          } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
            cx.marked = "keyword"
            if (value == "enum") return cont(enumdef);
            else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
            else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
          } else if (isTS && value == "namespace") {
            cx.marked = "keyword"
            return cont(pushlex("form"), expression, statement, poplex)
          } else if (isTS && value == "abstract") {
            cx.marked = "keyword"
            return cont(statement)
          } else {
            return cont(pushlex("stat"), maybelabel);
          }
        }
        if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                          block, poplex, poplex, popcontext);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
        if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
        if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
        if (type == "async") return cont(statement)
        if (value == "@") return cont(expression, statement)
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function maybeCatchBinding(type) {
        if (type == "(") return cont(funarg, expect(")"))
      }
      function expression(type, value) {
        return expressionInner(type, value, false);
      }
      function expressionNoComma(type, value) {
        return expressionInner(type, value, true);
      }
      function parenExpr(type) {
        if (type != "(") return pass()
        return cont(pushlex(")"), maybeexpression, expect(")"), poplex)
      }
      function expressionInner(type, value, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
          else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }

        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
        if (type == "function") return cont(functiondef, maybeop);
        if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
        if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
        if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
        if (type == "{") return contCommasep(objprop, "}", null, maybeop);
        if (type == "quasi") return pass(quasi, maybeop);
        if (type == "new") return cont(maybeTarget(noComma));
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
      }

      function maybeoperatorComma(type, value) {
        if (type == ",") return cont(maybeexpression);
        return maybeoperatorNoComma(type, value, false);
      }
      function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
          if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
          if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
          if (value == "?") return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type == "quasi") { return pass(quasi, me); }
        if (type == ";") return;
        if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
        if (type == ".") return cont(property, me);
        if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
        if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
        if (type == "regexp") {
          cx.state.lastType = cx.marked = "operator"
          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
          return cont(expr)
        }
      }
      function quasi(type, value) {
        if (type != "quasi") return pass();
        if (value.slice(value.length - 2) != "${") return cont(quasi);
        return cont(maybeexpression, continueQuasi);
      }
      function continueQuasi(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasi);
        }
      }
      function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expression);
      }
      function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expressionNoComma);
      }
      function maybeTarget(noComma) {
        return function(type) {
          if (type == ".") return cont(noComma ? targetNoComma : target);
          else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
          else return pass(noComma ? expressionNoComma : expression);
        };
      }
      function target(_, value) {
        if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
      }
      function targetNoComma(_, value) {
        if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
      }
      function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {cx.marked = "property"; return cont();}
      }
      function objprop(type, value) {
        if (type == "async") {
          cx.marked = "property";
          return cont(objprop);
        } else if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          if (value == "get" || value == "set") return cont(getterSetter);
          var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
            cx.state.fatArrowAt = cx.stream.pos + m[0].length
          return cont(afterprop);
        } else if (type == "number" || type == "string") {
          cx.marked = jsonldMode ? "property" : (cx.style + " property");
          return cont(afterprop);
        } else if (type == "jsonld-keyword") {
          return cont(afterprop);
        } else if (isTS && isModifier(value)) {
          cx.marked = "keyword"
          return cont(objprop)
        } else if (type == "[") {
          return cont(expression, maybetype, expect("]"), afterprop);
        } else if (type == "spread") {
          return cont(expressionNoComma, afterprop);
        } else if (value == "*") {
          cx.marked = "keyword";
          return cont(objprop);
        } else if (type == ":") {
          return pass(afterprop)
        }
      }
      function getterSetter(type) {
        if (type != "variable") return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type) {
        if (type == ":") return cont(expressionNoComma);
        if (type == "(") return pass(functiondef);
      }
      function commasep(what, end, sep) {
        function proceed(type, value) {
          if (sep ? sep.indexOf(type) > -1 : type == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
            return cont(function(type, value) {
              if (type == end || value == end) return pass()
              return pass(what)
            }, proceed);
          }
          if (type == end || value == end) return cont();
          if (sep && sep.indexOf(";") > -1) return pass(what)
          return cont(expect(end));
        }
        return function(type, value) {
          if (type == end || value == end) return cont();
          return pass(what, proceed);
        };
      }
      function contCommasep(what, end, info) {
        for (var i = 3; i < arguments.length; i++)
          cx.cc.push(arguments[i]);
        return cont(pushlex(end, info), commasep(what, end), poplex);
      }
      function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
      }
      function maybetype(type, value) {
        if (isTS) {
          if (type == ":") return cont(typeexpr);
          if (value == "?") return cont(maybetype);
        }
      }
      function maybetypeOrIn(type, value) {
        if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
      }
      function mayberettype(type) {
        if (isTS && type == ":") {
          if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
          else return cont(typeexpr)
        }
      }
      function isKW(_, value) {
        if (value == "is") {
          cx.marked = "keyword"
          return cont()
        }
      }
      function typeexpr(type, value) {
        if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
          cx.marked = "keyword"
          return cont(value == "typeof" ? expressionNoComma : typeexpr)
        }
        if (type == "variable" || value == "void") {
          cx.marked = "type"
          return cont(afterType)
        }
        if (value == "|" || value == "&") return cont(typeexpr)
        if (type == "string" || type == "number" || type == "atom") return cont(afterType);
        if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
        if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType)
        if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
        if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
        if (type == "quasi") { return pass(quasiType, afterType); }
      }
      function maybeReturnType(type) {
        if (type == "=>") return cont(typeexpr)
      }
      function typeprops(type) {
        if (type.match(/[\}\)\]]/)) return cont()
        if (type == "," || type == ";") return cont(typeprops)
        return pass(typeprop, typeprops)
      }
      function typeprop(type, value) {
        if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property"
          return cont(typeprop)
        } else if (value == "?" || type == "number" || type == "string") {
          return cont(typeprop)
        } else if (type == ":") {
          return cont(typeexpr)
        } else if (type == "[") {
          return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
        } else if (type == "(") {
          return pass(functiondecl, typeprop)
        } else if (!type.match(/[;\}\)\],]/)) {
          return cont()
        }
      }
      function quasiType(type, value) {
        if (type != "quasi") return pass();
        if (value.slice(value.length - 2) != "${") return cont(quasiType);
        return cont(typeexpr, continueQuasiType);
      }
      function continueQuasiType(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasiType);
        }
      }
      function typearg(type, value) {
        if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
        if (type == ":") return cont(typeexpr)
        if (type == "spread") return cont(typearg)
        return pass(typeexpr)
      }
      function afterType(type, value) {
        if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
        if (value == "|" || type == "." || value == "&") return cont(typeexpr)
        if (type == "[") return cont(typeexpr, expect("]"), afterType)
        if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
        if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
      }
      function maybeTypeArgs(_, value) {
        if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
      }
      function typeparam() {
        return pass(typeexpr, maybeTypeDefault)
      }
      function maybeTypeDefault(_, value) {
        if (value == "=") return cont(typeexpr)
      }
      function vardef(_, value) {
        if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type, value) {
        if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
        if (type == "variable") { register(value); return cont(); }
        if (type == "spread") return cont(pattern);
        if (type == "[") return contCommasep(eltpattern, "]");
        if (type == "{") return contCommasep(proppattern, "}");
      }
      function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type == "variable") cx.marked = "property";
        if (type == "spread") return cont(pattern);
        if (type == "}") return pass();
        if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
        return cont(expect(":"), pattern, maybeAssign);
      }
      function eltpattern() {
        return pass(pattern, maybeAssign)
      }
      function maybeAssign(_type, value) {
        if (value == "=") return cont(expressionNoComma);
      }
      function vardefCont(type) {
        if (type == ",") return cont(vardef);
      }
      function maybeelse(type, value) {
        if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
      }
      function forspec(type, value) {
        if (value == "await") return cont(forspec);
        if (type == "(") return cont(pushlex(")"), forspec1, poplex);
      }
      function forspec1(type) {
        if (type == "var") return cont(vardef, forspec2);
        if (type == "variable") return cont(forspec2);
        return pass(forspec2)
      }
      function forspec2(type, value) {
        if (type == ")") return cont()
        if (type == ";") return cont(forspec2)
        if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
        return pass(expression, forspec2)
      }
      function functiondef(type, value) {
        if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
        if (type == "variable") {register(value); return cont(functiondef);}
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
        if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
      }
      function functiondecl(type, value) {
        if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
        if (type == "variable") {register(value); return cont(functiondecl);}
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
        if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
      }
      function typename(type, value) {
        if (type == "keyword" || type == "variable") {
          cx.marked = "type"
          return cont(typename)
        } else if (value == "<") {
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
        }
      }
      function funarg(type, value) {
        if (value == "@") cont(expression, funarg)
        if (type == "spread") return cont(funarg);
        if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
        if (isTS && type == "this") return cont(maybetype, maybeAssign)
        return pass(pattern, maybetype, maybeAssign);
      }
      function classExpression(type, value) {
        // Class expressions may have an optional name.
        if (type == "variable") return className(type, value);
        return classNameAfter(type, value);
      }
      function className(type, value) {
        if (type == "variable") {register(value); return cont(classNameAfter);}
      }
      function classNameAfter(type, value) {
        if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
        if (value == "extends" || value == "implements" || (isTS && type == ",")) {
          if (value == "implements") cx.marked = "keyword";
          return cont(isTS ? typeexpr : expression, classNameAfter);
        }
        if (type == "{") return cont(pushlex("}"), classBody, poplex);
      }
      function classBody(type, value) {
        if (type == "async" ||
            (type == "variable" &&
             (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
             cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(classfield, classBody);
        }
        if (type == "number" || type == "string") return cont(classfield, classBody);
        if (type == "[")
          return cont(expression, maybetype, expect("]"), classfield, classBody)
        if (value == "*") {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (isTS && type == "(") return pass(functiondecl, classBody)
        if (type == ";" || type == ",") return cont(classBody);
        if (type == "}") return cont();
        if (value == "@") return cont(expression, classBody)
      }
      function classfield(type, value) {
        if (value == "!") return cont(classfield)
        if (value == "?") return cont(classfield)
        if (type == ":") return cont(typeexpr, maybeAssign)
        if (value == "=") return cont(expressionNoComma)
        var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"
        return pass(isInterface ? functiondecl : functiondef)
      }
      function afterExport(type, value) {
        if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
        if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
        if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
        return pass(statement);
      }
      function exportField(type, value) {
        if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
        if (type == "variable") return pass(expressionNoComma, exportField);
      }
      function afterImport(type) {
        if (type == "string") return cont();
        if (type == "(") return pass(expression);
        if (type == ".") return pass(maybeoperatorComma);
        return pass(importSpec, maybeMoreImports, maybeFrom);
      }
      function importSpec(type, value) {
        if (type == "{") return contCommasep(importSpec, "}");
        if (type == "variable") register(value);
        if (value == "*") cx.marked = "keyword";
        return cont(maybeAs);
      }
      function maybeMoreImports(type) {
        if (type == ",") return cont(importSpec, maybeMoreImports)
      }
      function maybeAs(_type, value) {
        if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
      }
      function maybeFrom(_type, value) {
        if (value == "from") { cx.marked = "keyword"; return cont(expression); }
      }
      function arrayLiteral(type) {
        if (type == "]") return cont();
        return pass(commasep(expressionNoComma, "]"));
      }
      function enumdef() {
        return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
      }
      function enummember() {
        return pass(pattern, maybeAssign);
      }

      function isContinuedStatement(state, textAfter) {
        return state.lastType == "operator" || state.lastType == "," ||
          isOperatorChar.test(textAfter.charAt(0)) ||
          /[,.]/.test(textAfter.charAt(0));
      }

      function expressionAllowed(stream, state, backUp) {
        return state.tokenize == tokenBase &&
          /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
          (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
      }

      // Interface

      return {
        startState: function(basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && new Context(null, null, false),
            indented: basecolumn || 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
            state.globalVars = parserConfig.globalVars;
          return state;
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (type == "comment") return style;
          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
          return parseJS(state, style, type, content, stream);
        },

        indent: function(state, textAfter) {
          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
          // Kludge to prevent 'maybelse' from blocking lexical scope pops
          if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
            var c = state.cc[i];
            if (c == poplex) lexical = lexical.prev;
            else if (c != maybeelse && c != popcontext) break;
          }
          while ((lexical.type == "stat" || lexical.type == "form") &&
                 (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                       (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                       !/^[,\.=+\-*:?[\(]/.test(textAfter))))
            lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
            lexical = lexical.prev;
          var type = lexical.type, closing = firstChar == type;

          if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
          else if (type == "form" && firstChar == "{") return lexical.indented;
          else if (type == "form") return lexical.indented + indentUnit;
          else if (type == "stat")
            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
          else if (lexical.align) return lexical.column + (closing ? 0 : 1);
          else return lexical.indented + (closing ? 0 : indentUnit);
        },

        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        blockCommentContinue: jsonMode ? null : " * ",
        lineComment: jsonMode ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",

        helperType: jsonMode ? "json" : "javascript",
        jsonldMode: jsonldMode,
        jsonMode: jsonMode,

        expressionAllowed: expressionAllowed,

        skipExpression: function(state) {
          parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", 2, null))
        }
      };
    });

    CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

    CodeMirror.defineMIME("text/javascript", "javascript");
    CodeMirror.defineMIME("text/ecmascript", "javascript");
    CodeMirror.defineMIME("application/javascript", "javascript");
    CodeMirror.defineMIME("application/x-javascript", "javascript");
    CodeMirror.defineMIME("application/ecmascript", "javascript");
    CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
    CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
    CodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true })
    CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
    CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
    CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-lua-lua.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // LUA mode. Ported to CodeMirror 2 from Franciszek Wawrzak's
    // CodeMirror 1 mode.
    // highlights keywords, strings, comments (no leveling supported! ("[==[")), tokens, basic indenting

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("lua", function(config, parserConfig) {
      var indentUnit = config.indentUnit;

      function prefixRE(words) {
        return new RegExp("^(?:" + words.join("|") + ")", "i");
      }
      function wordRE(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      }
      var specials = wordRE(parserConfig.specials || []);

      // long list of standard functions from lua manual
      var builtins = wordRE([
        "_G","_VERSION","assert","collectgarbage","dofile","error","getfenv","getmetatable","ipairs","load",
        "loadfile","loadstring","module","next","pairs","pcall","print","rawequal","rawget","rawset","require",
        "select","setfenv","setmetatable","tonumber","tostring","type","unpack","xpcall",

        "coroutine.create","coroutine.resume","coroutine.running","coroutine.status","coroutine.wrap","coroutine.yield",

        "debug.debug","debug.getfenv","debug.gethook","debug.getinfo","debug.getlocal","debug.getmetatable",
        "debug.getregistry","debug.getupvalue","debug.setfenv","debug.sethook","debug.setlocal","debug.setmetatable",
        "debug.setupvalue","debug.traceback",

        "close","flush","lines","read","seek","setvbuf","write",

        "io.close","io.flush","io.input","io.lines","io.open","io.output","io.popen","io.read","io.stderr","io.stdin",
        "io.stdout","io.tmpfile","io.type","io.write",

        "math.abs","math.acos","math.asin","math.atan","math.atan2","math.ceil","math.cos","math.cosh","math.deg",
        "math.exp","math.floor","math.fmod","math.frexp","math.huge","math.ldexp","math.log","math.log10","math.max",
        "math.min","math.modf","math.pi","math.pow","math.rad","math.random","math.randomseed","math.sin","math.sinh",
        "math.sqrt","math.tan","math.tanh",

        "os.clock","os.date","os.difftime","os.execute","os.exit","os.getenv","os.remove","os.rename","os.setlocale",
        "os.time","os.tmpname",

        "package.cpath","package.loaded","package.loaders","package.loadlib","package.path","package.preload",
        "package.seeall",

        "string.byte","string.char","string.dump","string.find","string.format","string.gmatch","string.gsub",
        "string.len","string.lower","string.match","string.rep","string.reverse","string.sub","string.upper",

        "table.concat","table.insert","table.maxn","table.remove","table.sort"
      ]);
      var keywords = wordRE(["and","break","elseif","false","nil","not","or","return",
                             "true","function", "end", "if", "then", "else", "do",
                             "while", "repeat", "until", "for", "in", "local" ]);

      var indentTokens = wordRE(["function", "if","repeat","do", "\\(", "{"]);
      var dedentTokens = wordRE(["end", "until", "\\)", "}"]);
      var dedentPartial = prefixRE(["end", "until", "\\)", "}", "else", "elseif"]);

      function readBracket(stream) {
        var level = 0;
        while (stream.eat("=")) ++level;
        stream.eat("[");
        return level;
      }

      function normal(stream, state) {
        var ch = stream.next();
        if (ch == "-" && stream.eat("-")) {
          if (stream.eat("[") && stream.eat("["))
            return (state.cur = bracketed(readBracket(stream), "comment"))(stream, state);
          stream.skipToEnd();
          return "comment";
        }
        if (ch == "\"" || ch == "'")
          return (state.cur = string(ch))(stream, state);
        if (ch == "[" && /[\[=]/.test(stream.peek()))
          return (state.cur = bracketed(readBracket(stream), "string"))(stream, state);
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w.%]/);
          return "number";
        }
        if (/[\w_]/.test(ch)) {
          stream.eatWhile(/[\w\\\-_.]/);
          return "variable";
        }
        return null;
      }

      function bracketed(level, style) {
        return function(stream, state) {
          var curlev = null, ch;
          while ((ch = stream.next()) != null) {
            if (curlev == null) {if (ch == "]") curlev = 0;}
            else if (ch == "=") ++curlev;
            else if (ch == "]" && curlev == level) { state.cur = normal; break; }
            else curlev = null;
          }
          return style;
        };
      }

      function string(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) state.cur = normal;
          return "string";
        };
      }

      return {
        startState: function(basecol) {
          return {basecol: basecol || 0, indentDepth: 0, cur: normal};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.cur(stream, state);
          var word = stream.current();
          if (style == "variable") {
            if (keywords.test(word)) style = "keyword";
            else if (builtins.test(word)) style = "builtin";
            else if (specials.test(word)) style = "variable-2";
          }
          if ((style != "comment") && (style != "string")){
            if (indentTokens.test(word)) ++state.indentDepth;
            else if (dedentTokens.test(word)) --state.indentDepth;
          }
          return style;
        },

        indent: function(state, textAfter) {
          var closing = dedentPartial.test(textAfter);
          return state.basecol + indentUnit * (state.indentDepth - (closing ? 1 : 0));
        },

        electricInput: /^\s*(?:end|until|else|\)|\})$/,
        lineComment: "--",
        blockCommentStart: "--[[",
        blockCommentEnd: "]]"
      };
    });

    CodeMirror.defineMIME("text/x-lua", "lua");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-mathematica-mathematica.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Mathematica mode copyright (c) 2015 by Calin Barbat
    // Based on code by Patrick Scheibe (halirutan)
    // See: https://github.com/halirutan/Mathematica-Source-Highlighting/tree/master/src/lang-mma.js

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode('mathematica', function(_config, _parserConfig) {

      // used pattern building blocks
      var Identifier = '[a-zA-Z\\$][a-zA-Z0-9\\$]*';
      var pBase      = "(?:\\d+)";
      var pFloat     = "(?:\\.\\d+|\\d+\\.\\d*|\\d+)";
      var pFloatBase = "(?:\\.\\w+|\\w+\\.\\w*|\\w+)";
      var pPrecision = "(?:`(?:`?"+pFloat+")?)";

      // regular expressions
      var reBaseForm        = new RegExp('(?:'+pBase+'(?:\\^\\^'+pFloatBase+pPrecision+'?(?:\\*\\^[+-]?\\d+)?))');
      var reFloatForm       = new RegExp('(?:' + pFloat + pPrecision + '?(?:\\*\\^[+-]?\\d+)?)');
      var reIdInContext     = new RegExp('(?:`?)(?:' + Identifier + ')(?:`(?:' + Identifier + '))*(?:`?)');

      function tokenBase(stream, state) {
        var ch;

        // get next character
        ch = stream.next();

        // string
        if (ch === '"') {
          state.tokenize = tokenString;
          return state.tokenize(stream, state);
        }

        // comment
        if (ch === '(') {
          if (stream.eat('*')) {
            state.commentLevel++;
            state.tokenize = tokenComment;
            return state.tokenize(stream, state);
          }
        }

        // go back one character
        stream.backUp(1);

        // look for numbers
        // Numbers in a baseform
        if (stream.match(reBaseForm, true, false)) {
          return 'number';
        }

        // Mathematica numbers. Floats (1.2, .2, 1.) can have optionally a precision (`float) or an accuracy definition
        // (``float). Note: while 1.2` is possible 1.2`` is not. At the end an exponent (float*^+12) can follow.
        if (stream.match(reFloatForm, true, false)) {
          return 'number';
        }

        /* In[23] and Out[34] */
        if (stream.match(/(?:In|Out)\[[0-9]*\]/, true, false)) {
          return 'atom';
        }

        // usage
        if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*(?:`[a-zA-Z0-9\$]+)*::usage)/, true, false)) {
          return 'meta';
        }

        // message
        if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*(?:`[a-zA-Z0-9\$]+)*::[a-zA-Z\$][a-zA-Z0-9\$]*):?/, true, false)) {
          return 'string-2';
        }

        // this makes a look-ahead match for something like variable:{_Integer}
        // the match is then forwarded to the mma-patterns tokenizer.
        if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*\s*:)(?:(?:[a-zA-Z\$][a-zA-Z0-9\$]*)|(?:[^:=>~@\^\&\*\)\[\]'\?,\|])).*/, true, false)) {
          return 'variable-2';
        }

        // catch variables which are used together with Blank (_), BlankSequence (__) or BlankNullSequence (___)
        // Cannot start with a number, but can have numbers at any other position. Examples
        // blub__Integer, a1_, b34_Integer32
        if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
          return 'variable-2';
        }
        if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+/, true, false)) {
          return 'variable-2';
        }
        if (stream.match(/_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
          return 'variable-2';
        }

        // Named characters in Mathematica, like \[Gamma].
        if (stream.match(/\\\[[a-zA-Z\$][a-zA-Z0-9\$]*\]/, true, false)) {
          return 'variable-3';
        }

        // Match all braces separately
        if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
          return 'bracket';
        }

        // Catch Slots (#, ##, #3, ##9 and the V10 named slots #name). I have never seen someone using more than one digit after #, so we match
        // only one.
        if (stream.match(/(?:#[a-zA-Z\$][a-zA-Z0-9\$]*|#+[0-9]?)/, true, false)) {
          return 'variable-2';
        }

        // Literals like variables, keywords, functions
        if (stream.match(reIdInContext, true, false)) {
          return 'keyword';
        }

        // operators. Note that operators like @@ or /; are matched separately for each symbol.
        if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%)/, true, false)) {
          return 'operator';
        }

        // everything else is an error
        stream.next(); // advance the stream.
        return 'error';
      }

      function tokenString(stream, state) {
        var next, end = false, escaped = false;
        while ((next = stream.next()) != null) {
          if (next === '"' && !escaped) {
            end = true;
            break;
          }
          escaped = !escaped && next === '\\';
        }
        if (end && !escaped) {
          state.tokenize = tokenBase;
        }
        return 'string';
      };

      function tokenComment(stream, state) {
        var prev, next;
        while(state.commentLevel > 0 && (next = stream.next()) != null) {
          if (prev === '(' && next === '*') state.commentLevel++;
          if (prev === '*' && next === ')') state.commentLevel--;
          prev = next;
        }
        if (state.commentLevel <= 0) {
          state.tokenize = tokenBase;
        }
        return 'comment';
      }

      return {
        startState: function() {return {tokenize: tokenBase, commentLevel: 0};},
        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        },
        blockCommentStart: "(*",
        blockCommentEnd: "*)"
      };
    });

    CodeMirror.defineMIME('text/x-mathematica', {
      name: 'mathematica'
    });

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-modelica-modelica.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Modelica support for CodeMirror, copyright (c) by Lennart Ochel

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })

    (function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("modelica", function(config, parserConfig) {

        var indentUnit = config.indentUnit;
        var keywords = parserConfig.keywords || {};
        var builtin = parserConfig.builtin || {};
        var atoms = parserConfig.atoms || {};

        var isSingleOperatorChar = /[;=\(:\),{}.*<>+\-\/^\[\]]/;
        var isDoubleOperatorChar = /(:=|<=|>=|==|<>|\.\+|\.\-|\.\*|\.\/|\.\^)/;
        var isDigit = /[0-9]/;
        var isNonDigit = /[_a-zA-Z]/;

        function tokenLineComment(stream, state) {
          stream.skipToEnd();
          state.tokenize = null;
          return "comment";
        }

        function tokenBlockComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (maybeEnd && ch == "/") {
              state.tokenize = null;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return "comment";
        }

        function tokenString(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == '"' && !escaped) {
              state.tokenize = null;
              state.sol = false;
              break;
            }
            escaped = !escaped && ch == "\\";
          }

          return "string";
        }

        function tokenIdent(stream, state) {
          stream.eatWhile(isDigit);
          while (stream.eat(isDigit) || stream.eat(isNonDigit)) { }


          var cur = stream.current();

          if(state.sol && (cur == "package" || cur == "model" || cur == "when" || cur == "connector")) state.level++;
          else if(state.sol && cur == "end" && state.level > 0) state.level--;

          state.tokenize = null;
          state.sol = false;

          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          else if (builtin.propertyIsEnumerable(cur)) return "builtin";
          else if (atoms.propertyIsEnumerable(cur)) return "atom";
          else return "variable";
        }

        function tokenQIdent(stream, state) {
          while (stream.eat(/[^']/)) { }

          state.tokenize = null;
          state.sol = false;

          if(stream.eat("'"))
            return "variable";
          else
            return "error";
        }

        function tokenUnsignedNumber(stream, state) {
          stream.eatWhile(isDigit);
          if (stream.eat('.')) {
            stream.eatWhile(isDigit);
          }
          if (stream.eat('e') || stream.eat('E')) {
            if (!stream.eat('-'))
              stream.eat('+');
            stream.eatWhile(isDigit);
          }

          state.tokenize = null;
          state.sol = false;
          return "number";
        }

        // Interface
        return {
          startState: function() {
            return {
              tokenize: null,
              level: 0,
              sol: true
            };
          },

          token: function(stream, state) {
            if(state.tokenize != null) {
              return state.tokenize(stream, state);
            }

            if(stream.sol()) {
              state.sol = true;
            }

            // WHITESPACE
            if(stream.eatSpace()) {
              state.tokenize = null;
              return null;
            }

            var ch = stream.next();

            // LINECOMMENT
            if(ch == '/' && stream.eat('/')) {
              state.tokenize = tokenLineComment;
            }
            // BLOCKCOMMENT
            else if(ch == '/' && stream.eat('*')) {
              state.tokenize = tokenBlockComment;
            }
            // TWO SYMBOL TOKENS
            else if(isDoubleOperatorChar.test(ch+stream.peek())) {
              stream.next();
              state.tokenize = null;
              return "operator";
            }
            // SINGLE SYMBOL TOKENS
            else if(isSingleOperatorChar.test(ch)) {
              state.tokenize = null;
              return "operator";
            }
            // IDENT
            else if(isNonDigit.test(ch)) {
              state.tokenize = tokenIdent;
            }
            // Q-IDENT
            else if(ch == "'" && stream.peek() && stream.peek() != "'") {
              state.tokenize = tokenQIdent;
            }
            // STRING
            else if(ch == '"') {
              state.tokenize = tokenString;
            }
            // UNSIGNED_NUMBER
            else if(isDigit.test(ch)) {
              state.tokenize = tokenUnsignedNumber;
            }
            // ERROR
            else {
              state.tokenize = null;
              return "error";
            }

            return state.tokenize(stream, state);
          },

          indent: function(state, textAfter) {
            if (state.tokenize != null) return CodeMirror.Pass;

            var level = state.level;
            if(/(algorithm)/.test(textAfter)) level--;
            if(/(equation)/.test(textAfter)) level--;
            if(/(initial algorithm)/.test(textAfter)) level--;
            if(/(initial equation)/.test(textAfter)) level--;
            if(/(end)/.test(textAfter)) level--;

            if(level > 0)
              return indentUnit*level;
            else
              return 0;
          },

          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i=0; i<words.length; ++i)
          obj[words[i]] = true;
        return obj;
      }

      var modelicaKeywords = "algorithm and annotation assert block break class connect connector constant constrainedby der discrete each else elseif elsewhen encapsulated end enumeration equation expandable extends external false final flow for function if import impure in initial inner input loop model not operator or outer output package parameter partial protected public pure record redeclare replaceable return stream then true type when while within";
      var modelicaBuiltin = "abs acos actualStream asin atan atan2 cardinality ceil cos cosh delay div edge exp floor getInstanceName homotopy inStream integer log log10 mod pre reinit rem semiLinear sign sin sinh spatialDistribution sqrt tan tanh";
      var modelicaAtoms = "Real Boolean Integer String";

      function def(mimes, mode) {
        if (typeof mimes == "string")
          mimes = [mimes];

        var words = [];

        function add(obj) {
          if (obj)
            for (var prop in obj)
              if (obj.hasOwnProperty(prop))
                words.push(prop);
        }

        add(mode.keywords);
        add(mode.builtin);
        add(mode.atoms);

        if (words.length) {
          mode.helperType = mimes[0];
          CodeMirror.registerHelper("hintWords", mimes[0], words);
        }

        for (var i=0; i<mimes.length; ++i)
          CodeMirror.defineMIME(mimes[i], mode);
      }

      def(["text/x-modelica"], {
        name: "modelica",
        keywords: words(modelicaKeywords),
        builtin: words(modelicaBuiltin),
        atoms: words(modelicaAtoms)
      });
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-mumps-mumps.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
      This MUMPS Language script was constructed using vbscript.js as a template.
    */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("mumps", function() {
        function wordRegexp(words) {
          return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
        }

        var singleOperators = new RegExp("^[\\+\\-\\*/&#!_?\\\\<>=\\'\\[\\]]");
        var doubleOperators = new RegExp("^(('=)|(<=)|(>=)|('>)|('<)|([[)|(]])|(^$))");
        var singleDelimiters = new RegExp("^[\\.,:]");
        var brackets = new RegExp("[()]");
        var identifiers = new RegExp("^[%A-Za-z][A-Za-z0-9]*");
        var commandKeywords = ["break","close","do","else","for","goto", "halt", "hang", "if", "job","kill","lock","merge","new","open", "quit", "read", "set", "tcommit", "trollback", "tstart", "use", "view", "write", "xecute", "b","c","d","e","f","g", "h", "i", "j","k","l","m","n","o", "q", "r", "s", "tc", "tro", "ts", "u", "v", "w", "x"];
        // The following list includes intrinsic functions _and_ special variables
        var intrinsicFuncsWords = ["\\$ascii", "\\$char", "\\$data", "\\$ecode", "\\$estack", "\\$etrap", "\\$extract", "\\$find", "\\$fnumber", "\\$get", "\\$horolog", "\\$io", "\\$increment", "\\$job", "\\$justify", "\\$length", "\\$name", "\\$next", "\\$order", "\\$piece", "\\$qlength", "\\$qsubscript", "\\$query", "\\$quit", "\\$random", "\\$reverse", "\\$select", "\\$stack", "\\$test", "\\$text", "\\$translate", "\\$view", "\\$x", "\\$y", "\\$a", "\\$c", "\\$d", "\\$e", "\\$ec", "\\$es", "\\$et", "\\$f", "\\$fn", "\\$g", "\\$h", "\\$i", "\\$j", "\\$l", "\\$n", "\\$na", "\\$o", "\\$p", "\\$q", "\\$ql", "\\$qs", "\\$r", "\\$re", "\\$s", "\\$st", "\\$t", "\\$tr", "\\$v", "\\$z"];
        var intrinsicFuncs = wordRegexp(intrinsicFuncsWords);
        var command = wordRegexp(commandKeywords);

        function tokenBase(stream, state) {
          if (stream.sol()) {
            state.label = true;
            state.commandMode = 0;
          }

          // The <space> character has meaning in MUMPS. Ignoring consecutive
          // spaces would interfere with interpreting whether the next non-space
          // character belongs to the command or argument context.

          // Examine each character and update a mode variable whose interpretation is:
          //   >0 => command    0 => argument    <0 => command post-conditional
          var ch = stream.peek();

          if (ch == " " || ch == "\t") { // Pre-process <space>
            state.label = false;
            if (state.commandMode == 0)
              state.commandMode = 1;
            else if ((state.commandMode < 0) || (state.commandMode == 2))
              state.commandMode = 0;
          } else if ((ch != ".") && (state.commandMode > 0)) {
            if (ch == ":")
              state.commandMode = -1;   // SIS - Command post-conditional
            else
              state.commandMode = 2;
          }

          // Do not color parameter list as line tag
          if ((ch === "(") || (ch === "\u0009"))
            state.label = false;

          // MUMPS comment starts with ";"
          if (ch === ";") {
            stream.skipToEnd();
            return "comment";
          }

          // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator
          if (stream.match(/^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?/))
            return "number";

          // Handle Strings
          if (ch == '"') {
            if (stream.skipTo('"')) {
              stream.next();
              return "string";
            } else {
              stream.skipToEnd();
              return "error";
            }
          }

          // Handle operators and Delimiters
          if (stream.match(doubleOperators) || stream.match(singleOperators))
            return "operator";

          // Prevents leading "." in DO block from falling through to error
          if (stream.match(singleDelimiters))
            return null;

          if (brackets.test(ch)) {
            stream.next();
            return "bracket";
          }

          if (state.commandMode > 0 && stream.match(command))
            return "variable-2";

          if (stream.match(intrinsicFuncs))
            return "builtin";

          if (stream.match(identifiers))
            return "variable";

          // Detect dollar-sign when not a documented intrinsic function
          // "^" may introduce a GVN or SSVN - Color same as function
          if (ch === "$" || ch === "^") {
            stream.next();
            return "builtin";
          }

          // MUMPS Indirection
          if (ch === "@") {
            stream.next();
            return "string-2";
          }

          if (/[\w%]/.test(ch)) {
            stream.eatWhile(/[\w%]/);
            return "variable";
          }

          // Handle non-detected items
          stream.next();
          return "error";
        }

        return {
          startState: function() {
            return {
              label: false,
              commandMode: 0
            };
          },

          token: function(stream, state) {
            var style = tokenBase(stream, state);
            if (state.label) return "tag";
            return style;
          }
        };
      });

      CodeMirror.defineMIME("text/x-mumps", "mumps");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-octave-octave.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("octave", function() {
      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      var singleOperators = new RegExp("^[\\+\\-\\*/&|\\^~<>!@'\\\\]");
      var singleDelimiters = new RegExp('^[\\(\\[\\{\\},:=;\\.]');
      var doubleOperators = new RegExp("^((==)|(~=)|(<=)|(>=)|(<<)|(>>)|(\\.[\\+\\-\\*/\\^\\\\]))");
      var doubleDelimiters = new RegExp("^((!=)|(\\+=)|(\\-=)|(\\*=)|(/=)|(&=)|(\\|=)|(\\^=))");
      var tripleDelimiters = new RegExp("^((>>=)|(<<=))");
      var expressionEnd = new RegExp("^[\\]\\)]");
      var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

      var builtins = wordRegexp([
        'error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos',
        'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh',
        'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones',
        'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov',
        'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot',
        'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str',
        'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember'
      ]);

      var keywords = wordRegexp([
        'return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction',
        'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events',
        'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until',
        'continue', 'pkg'
      ]);


      // tokenizers
      function tokenTranspose(stream, state) {
        if (!stream.sol() && stream.peek() === '\'') {
          stream.next();
          state.tokenize = tokenBase;
          return 'operator';
        }
        state.tokenize = tokenBase;
        return tokenBase(stream, state);
      }


      function tokenComment(stream, state) {
        if (stream.match(/^.*%}/)) {
          state.tokenize = tokenBase;
          return 'comment';
        };
        stream.skipToEnd();
        return 'comment';
      }

      function tokenBase(stream, state) {
        // whitespaces
        if (stream.eatSpace()) return null;

        // Handle one line Comments
        if (stream.match('%{')){
          state.tokenize = tokenComment;
          stream.skipToEnd();
          return 'comment';
        }

        if (stream.match(/^[%#]/)){
          stream.skipToEnd();
          return 'comment';
        }

        // Handle Number Literals
        if (stream.match(/^[0-9\.+-]/, false)) {
          if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {
            stream.tokenize = tokenBase;
            return 'number'; };
          if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; };
          if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; };
        }
        if (stream.match(wordRegexp(['nan','NaN','inf','Inf']))) { return 'number'; };

        // Handle Strings
        var m = stream.match(/^"(?:[^"]|"")*("|$)/) || stream.match(/^'(?:[^']|'')*('|$)/)
        if (m) { return m[1] ? 'string' : "string error"; }

        // Handle words
        if (stream.match(keywords)) { return 'keyword'; } ;
        if (stream.match(builtins)) { return 'builtin'; } ;
        if (stream.match(identifiers)) { return 'variable'; } ;

        if (stream.match(singleOperators) || stream.match(doubleOperators)) { return 'operator'; };
        if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) { return null; };

        if (stream.match(expressionEnd)) {
          state.tokenize = tokenTranspose;
          return null;
        };


        // Handle non-detected items
        stream.next();
        return 'error';
      };


      return {
        startState: function() {
          return {
            tokenize: tokenBase
          };
        },

        token: function(stream, state) {
          var style = state.tokenize(stream, state);
          if (style === 'number' || style === 'variable'){
            state.tokenize = tokenTranspose;
          }
          return style;
        },

        lineComment: '%',

        fold: 'indent'
      };
    });

    CodeMirror.defineMIME("text/x-octave", "octave");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-pascal-pascal.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("pascal", function() {
      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var keywords = words(
        "absolute and array asm begin case const constructor destructor div do " +
        "downto else end file for function goto if implementation in inherited " +
        "inline interface label mod nil not object of operator or packed procedure " +
        "program record reintroduce repeat self set shl shr string then to type " +
        "unit until uses var while with xor as class dispinterface except exports " +
        "finalization finally initialization inline is library on out packed " +
        "property raise resourcestring threadvar try absolute abstract alias " +
        "assembler bitpacked break cdecl continue cppdecl cvar default deprecated " +
        "dynamic enumerator experimental export external far far16 forward generic " +
        "helper implements index interrupt iocheck local message name near " +
        "nodefault noreturn nostackframe oldfpccall otherwise overload override " +
        "pascal platform private protected public published read register " +
        "reintroduce result safecall saveregisters softfloat specialize static " +
        "stdcall stored strict unaligned unimplemented varargs virtual write");
      var atoms = {"null": true};

      var isOperatorChar = /[+\-*&%=<>!?|\/]/;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == "#" && state.startOfLine) {
          stream.skipToEnd();
          return "meta";
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (ch == "(" && stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (ch == "{") {
          state.tokenize = tokenCommentBraces;
          return tokenCommentBraces(stream, state);
        }
        if (/[\[\]\(\),;\:\.]/.test(ch)) {
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) return "keyword";
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped) state.tokenize = null;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == ")" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function tokenCommentBraces(stream, state) {
        var ch;
        while (ch = stream.next()) {
          if (ch == "}") {
            state.tokenize = null;
            break;
          }
        }
        return "comment";
      }

      // Interface

      return {
        startState: function() {
          return {tokenize: null};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          return style;
        },

        electricChars: "{}"
      };
    });

    CodeMirror.defineMIME("text/x-pascal", "pascal");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-pig-pig.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
     *      Pig Latin Mode for CodeMirror 2
     *      @author Prasanth Jayachandran
     *      @link   https://github.com/prasanthj/pig-codemirror-2
     *  This implementation is adapted from PL/SQL mode in CodeMirror 2.
     */
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("pig", function(_config, parserConfig) {
      var keywords = parserConfig.keywords,
      builtins = parserConfig.builtins,
      types = parserConfig.types,
      multiLineStrings = parserConfig.multiLineStrings;

      var isOperatorChar = /[*+\-%<>=&?:\/!|]/;

      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      function tokenComment(stream, state) {
        var isEnd = false;
        var ch;
        while(ch = stream.next()) {
          if(ch == "/" && isEnd) {
            state.tokenize = tokenBase;
            break;
          }
          isEnd = (ch == "*");
        }
        return "comment";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true; break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "error";
        };
      }


      function tokenBase(stream, state) {
        var ch = stream.next();

        // is a start of string?
        if (ch == '"' || ch == "'")
          return chain(stream, state, tokenString(ch));
        // is it one of the special chars
        else if(/[\[\]{}\(\),;\.]/.test(ch))
          return null;
        // is it a number?
        else if(/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        // multi line comment or operator
        else if (ch == "/") {
          if (stream.eat("*")) {
            return chain(stream, state, tokenComment);
          }
          else {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
        }
        // single line comment or operator
        else if (ch=="-") {
          if(stream.eat("-")){
            stream.skipToEnd();
            return "comment";
          }
          else {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
        }
        // is it an operator
        else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        else {
          // get the while word
          stream.eatWhile(/[\w\$_]/);
          // is it one of the listed keywords?
          if (keywords && keywords.propertyIsEnumerable(stream.current().toUpperCase())) {
            //keywords can be used as variables like flatten(group), group.$0 etc..
            if (!stream.eat(")") && !stream.eat("."))
              return "keyword";
          }
          // is it one of the builtin functions?
          if (builtins && builtins.propertyIsEnumerable(stream.current().toUpperCase()))
            return "variable-2";
          // is it one of the listed types?
          if (types && types.propertyIsEnumerable(stream.current().toUpperCase()))
            return "variable-3";
          // default is a 'variable'
          return "variable";
        }
      }

      // Interface
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          if(stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          return style;
        }
      };
    });

    (function() {
      function keywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      // builtin funcs taken from trunk revision 1303237
      var pBuiltins = "ABS ACOS ARITY ASIN ATAN AVG BAGSIZE BINSTORAGE BLOOM BUILDBLOOM CBRT CEIL "
        + "CONCAT COR COS COSH COUNT COUNT_STAR COV CONSTANTSIZE CUBEDIMENSIONS DIFF DISTINCT DOUBLEABS "
        + "DOUBLEAVG DOUBLEBASE DOUBLEMAX DOUBLEMIN DOUBLEROUND DOUBLESUM EXP FLOOR FLOATABS FLOATAVG "
        + "FLOATMAX FLOATMIN FLOATROUND FLOATSUM GENERICINVOKER INDEXOF INTABS INTAVG INTMAX INTMIN "
        + "INTSUM INVOKEFORDOUBLE INVOKEFORFLOAT INVOKEFORINT INVOKEFORLONG INVOKEFORSTRING INVOKER "
        + "ISEMPTY JSONLOADER JSONMETADATA JSONSTORAGE LAST_INDEX_OF LCFIRST LOG LOG10 LOWER LONGABS "
        + "LONGAVG LONGMAX LONGMIN LONGSUM MAX MIN MAPSIZE MONITOREDUDF NONDETERMINISTIC OUTPUTSCHEMA  "
        + "PIGSTORAGE PIGSTREAMING RANDOM REGEX_EXTRACT REGEX_EXTRACT_ALL REPLACE ROUND SIN SINH SIZE "
        + "SQRT STRSPLIT SUBSTRING SUM STRINGCONCAT STRINGMAX STRINGMIN STRINGSIZE TAN TANH TOBAG "
        + "TOKENIZE TOMAP TOP TOTUPLE TRIM TEXTLOADER TUPLESIZE UCFIRST UPPER UTF8STORAGECONVERTER ";

      // taken from QueryLexer.g
      var pKeywords = "VOID IMPORT RETURNS DEFINE LOAD FILTER FOREACH ORDER CUBE DISTINCT COGROUP "
        + "JOIN CROSS UNION SPLIT INTO IF OTHERWISE ALL AS BY USING INNER OUTER ONSCHEMA PARALLEL "
        + "PARTITION GROUP AND OR NOT GENERATE FLATTEN ASC DESC IS STREAM THROUGH STORE MAPREDUCE "
        + "SHIP CACHE INPUT OUTPUT STDERROR STDIN STDOUT LIMIT SAMPLE LEFT RIGHT FULL EQ GT LT GTE LTE "
        + "NEQ MATCHES TRUE FALSE DUMP";

      // data types
      var pTypes = "BOOLEAN INT LONG FLOAT DOUBLE CHARARRAY BYTEARRAY BAG TUPLE MAP ";

      CodeMirror.defineMIME("text/x-pig", {
        name: "pig",
        builtins: keywords(pBuiltins),
        keywords: keywords(pKeywords),
        types: keywords(pTypes)
      });

      CodeMirror.registerHelper("hintWords", "pig", (pBuiltins + pTypes + pKeywords).split(" "));
    }());

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-q-q.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("q",function(config){
      var indentUnit=config.indentUnit,
          curPunc,
          keywords=buildRE(["abs","acos","aj","aj0","all","and","any","asc","asin","asof","atan","attr","avg","avgs","bin","by","ceiling","cols","cor","cos","count","cov","cross","csv","cut","delete","deltas","desc","dev","differ","distinct","div","do","each","ej","enlist","eval","except","exec","exit","exp","fby","fills","first","fkeys","flip","floor","from","get","getenv","group","gtime","hclose","hcount","hdel","hopen","hsym","iasc","idesc","if","ij","in","insert","inter","inv","key","keys","last","like","list","lj","load","log","lower","lsq","ltime","ltrim","mavg","max","maxs","mcount","md5","mdev","med","meta","min","mins","mmax","mmin","mmu","mod","msum","neg","next","not","null","or","over","parse","peach","pj","plist","prd","prds","prev","prior","rand","rank","ratios","raze","read0","read1","reciprocal","reverse","rload","rotate","rsave","rtrim","save","scan","select","set","setenv","show","signum","sin","sqrt","ss","ssr","string","sublist","sum","sums","sv","system","tables","tan","til","trim","txf","type","uj","ungroup","union","update","upper","upsert","value","var","view","views","vs","wavg","where","where","while","within","wj","wj1","wsum","xasc","xbar","xcol","xcols","xdesc","xexp","xgroup","xkey","xlog","xprev","xrank"]),
          E=/[|/&^!+:\\\-*%$=~#;@><,?_\'\"\[\(\]\)\s{}]/;
      function buildRE(w){return new RegExp("^("+w.join("|")+")$");}
      function tokenBase(stream,state){
        var sol=stream.sol(),c=stream.next();
        curPunc=null;
        if(sol)
          if(c=="/")
            return(state.tokenize=tokenLineComment)(stream,state);
          else if(c=="\\"){
            if(stream.eol()||/\s/.test(stream.peek()))
              return stream.skipToEnd(),/^\\\s*$/.test(stream.current())?(state.tokenize=tokenCommentToEOF)(stream):state.tokenize=tokenBase,"comment";
            else
              return state.tokenize=tokenBase,"builtin";
          }
        if(/\s/.test(c))
          return stream.peek()=="/"?(stream.skipToEnd(),"comment"):"whitespace";
        if(c=='"')
          return(state.tokenize=tokenString)(stream,state);
        if(c=='`')
          return stream.eatWhile(/[A-Za-z\d_:\/.]/),"symbol";
        if(("."==c&&/\d/.test(stream.peek()))||/\d/.test(c)){
          var t=null;
          stream.backUp(1);
          if(stream.match(/^\d{4}\.\d{2}(m|\.\d{2}([DT](\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)?)?)/)
          || stream.match(/^\d+D(\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)/)
          || stream.match(/^\d{2}:\d{2}(:\d{2}(\.\d{1,9})?)?/)
          || stream.match(/^\d+[ptuv]{1}/))
            t="temporal";
          else if(stream.match(/^0[NwW]{1}/)
          || stream.match(/^0x[\da-fA-F]*/)
          || stream.match(/^[01]+[b]{1}/)
          || stream.match(/^\d+[chijn]{1}/)
          || stream.match(/-?\d*(\.\d*)?(e[+\-]?\d+)?(e|f)?/))
            t="number";
          return(t&&(!(c=stream.peek())||E.test(c)))?t:(stream.next(),"error");
        }
        if(/[A-Za-z]|\./.test(c))
          return stream.eatWhile(/[A-Za-z._\d]/),keywords.test(stream.current())?"keyword":"variable";
        if(/[|/&^!+:\\\-*%$=~#;@><\.,?_\']/.test(c))
          return null;
        if(/[{}\(\[\]\)]/.test(c))
          return null;
        return"error";
      }
      function tokenLineComment(stream,state){
        return stream.skipToEnd(),/\/\s*$/.test(stream.current())?(state.tokenize=tokenBlockComment)(stream,state):(state.tokenize=tokenBase),"comment";
      }
      function tokenBlockComment(stream,state){
        var f=stream.sol()&&stream.peek()=="\\";
        stream.skipToEnd();
        if(f&&/^\\\s*$/.test(stream.current()))
          state.tokenize=tokenBase;
        return"comment";
      }
      function tokenCommentToEOF(stream){return stream.skipToEnd(),"comment";}
      function tokenString(stream,state){
        var escaped=false,next,end=false;
        while((next=stream.next())){
          if(next=="\""&&!escaped){end=true;break;}
          escaped=!escaped&&next=="\\";
        }
        if(end)state.tokenize=tokenBase;
        return"string";
      }
      function pushContext(state,type,col){state.context={prev:state.context,indent:state.indent,col:col,type:type};}
      function popContext(state){state.indent=state.context.indent;state.context=state.context.prev;}
      return{
        startState:function(){
          return{tokenize:tokenBase,
                 context:null,
                 indent:0,
                 col:0};
        },
        token:function(stream,state){
          if(stream.sol()){
            if(state.context&&state.context.align==null)
              state.context.align=false;
            state.indent=stream.indentation();
          }
          //if (stream.eatSpace()) return null;
          var style=state.tokenize(stream,state);
          if(style!="comment"&&state.context&&state.context.align==null&&state.context.type!="pattern"){
            state.context.align=true;
          }
          if(curPunc=="(")pushContext(state,")",stream.column());
          else if(curPunc=="[")pushContext(state,"]",stream.column());
          else if(curPunc=="{")pushContext(state,"}",stream.column());
          else if(/[\]\}\)]/.test(curPunc)){
            while(state.context&&state.context.type=="pattern")popContext(state);
            if(state.context&&curPunc==state.context.type)popContext(state);
          }
          else if(curPunc=="."&&state.context&&state.context.type=="pattern")popContext(state);
          else if(/atom|string|variable/.test(style)&&state.context){
            if(/[\}\]]/.test(state.context.type))
              pushContext(state,"pattern",stream.column());
            else if(state.context.type=="pattern"&&!state.context.align){
              state.context.align=true;
              state.context.col=stream.column();
            }
          }
          return style;
        },
        indent:function(state,textAfter){
          var firstChar=textAfter&&textAfter.charAt(0);
          var context=state.context;
          if(/[\]\}]/.test(firstChar))
            while (context&&context.type=="pattern")context=context.prev;
          var closing=context&&firstChar==context.type;
          if(!context)
            return 0;
          else if(context.type=="pattern")
            return context.col;
          else if(context.align)
            return context.col+(closing?0:1);
          else
            return context.indent+(closing?0:indentUnit);
        }
      };
    });
    CodeMirror.defineMIME("text/x-q","q");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-rst-rst.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../python/python"), require("../stex/stex"), require("../../addon/mode/overlay"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../python/python", "../stex/stex", "../../addon/mode/overlay"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode('rst', function (config, options) {

      var rx_strong = /^\*\*[^\*\s](?:[^\*]*[^\*\s])?\*\*/;
      var rx_emphasis = /^\*[^\*\s](?:[^\*]*[^\*\s])?\*/;
      var rx_literal = /^``[^`\s](?:[^`]*[^`\s])``/;

      var rx_number = /^(?:[\d]+(?:[\.,]\d+)*)/;
      var rx_positive = /^(?:\s\+[\d]+(?:[\.,]\d+)*)/;
      var rx_negative = /^(?:\s\-[\d]+(?:[\.,]\d+)*)/;

      var rx_uri_protocol = "[Hh][Tt][Tt][Pp][Ss]?://";
      var rx_uri_domain = "(?:[\\d\\w.-]+)\\.(?:\\w{2,6})";
      var rx_uri_path = "(?:/[\\d\\w\\#\\%\\&\\-\\.\\,\\/\\:\\=\\?\\~]+)*";
      var rx_uri = new RegExp("^" + rx_uri_protocol + rx_uri_domain + rx_uri_path);

      var overlay = {
        token: function (stream) {

          if (stream.match(rx_strong) && stream.match (/\W+|$/, false))
            return 'strong';
          if (stream.match(rx_emphasis) && stream.match (/\W+|$/, false))
            return 'em';
          if (stream.match(rx_literal) && stream.match (/\W+|$/, false))
            return 'string-2';
          if (stream.match(rx_number))
            return 'number';
          if (stream.match(rx_positive))
            return 'positive';
          if (stream.match(rx_negative))
            return 'negative';
          if (stream.match(rx_uri))
            return 'link';

          while (stream.next() != null) {
            if (stream.match(rx_strong, false)) break;
            if (stream.match(rx_emphasis, false)) break;
            if (stream.match(rx_literal, false)) break;
            if (stream.match(rx_number, false)) break;
            if (stream.match(rx_positive, false)) break;
            if (stream.match(rx_negative, false)) break;
            if (stream.match(rx_uri, false)) break;
          }

          return null;
        }
      };

      var mode = CodeMirror.getMode(
        config, options.backdrop || 'rst-base'
      );

      return CodeMirror.overlayMode(mode, overlay, true); // combine
    }, 'python', 'stex');

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    CodeMirror.defineMode('rst-base', function (config) {

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function format(string) {
        var args = Array.prototype.slice.call(arguments, 1);
        return string.replace(/{(\d+)}/g, function (match, n) {
          return typeof args[n] != 'undefined' ? args[n] : match;
        });
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      var mode_python = CodeMirror.getMode(config, 'python');
      var mode_stex = CodeMirror.getMode(config, 'stex');

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      var SEPA = "\\s+";
      var TAIL = "(?:\\s*|\\W|$)",
      rx_TAIL = new RegExp(format('^{0}', TAIL));

      var NAME =
        "(?:[^\\W\\d_](?:[\\w!\"#$%&'()\\*\\+,\\-\\.\/:;<=>\\?]*[^\\W_])?)",
      rx_NAME = new RegExp(format('^{0}', NAME));
      var NAME_WWS =
        "(?:[^\\W\\d_](?:[\\w\\s!\"#$%&'()\\*\\+,\\-\\.\/:;<=>\\?]*[^\\W_])?)";
      var REF_NAME = format('(?:{0}|`{1}`)', NAME, NAME_WWS);

      var TEXT1 = "(?:[^\\s\\|](?:[^\\|]*[^\\s\\|])?)";
      var TEXT2 = "(?:[^\\`]+)",
      rx_TEXT2 = new RegExp(format('^{0}', TEXT2));

      var rx_section = new RegExp(
        "^([!'#$%&\"()*+,-./:;<=>?@\\[\\\\\\]^_`{|}~])\\1{3,}\\s*$");
      var rx_explicit = new RegExp(
        format('^\\.\\.{0}', SEPA));
      var rx_link = new RegExp(
        format('^_{0}:{1}|^__:{1}', REF_NAME, TAIL));
      var rx_directive = new RegExp(
        format('^{0}::{1}', REF_NAME, TAIL));
      var rx_substitution = new RegExp(
        format('^\\|{0}\\|{1}{2}::{3}', TEXT1, SEPA, REF_NAME, TAIL));
      var rx_footnote = new RegExp(
        format('^\\[(?:\\d+|#{0}?|\\*)]{1}', REF_NAME, TAIL));
      var rx_citation = new RegExp(
        format('^\\[{0}\\]{1}', REF_NAME, TAIL));

      var rx_substitution_ref = new RegExp(
        format('^\\|{0}\\|', TEXT1));
      var rx_footnote_ref = new RegExp(
        format('^\\[(?:\\d+|#{0}?|\\*)]_', REF_NAME));
      var rx_citation_ref = new RegExp(
        format('^\\[{0}\\]_', REF_NAME));
      var rx_link_ref1 = new RegExp(
        format('^{0}__?', REF_NAME));
      var rx_link_ref2 = new RegExp(
        format('^`{0}`_', TEXT2));

      var rx_role_pre = new RegExp(
        format('^:{0}:`{1}`{2}', NAME, TEXT2, TAIL));
      var rx_role_suf = new RegExp(
        format('^`{1}`:{0}:{2}', NAME, TEXT2, TAIL));
      var rx_role = new RegExp(
        format('^:{0}:{1}', NAME, TAIL));

      var rx_directive_name = new RegExp(format('^{0}', REF_NAME));
      var rx_directive_tail = new RegExp(format('^::{0}', TAIL));
      var rx_substitution_text = new RegExp(format('^\\|{0}\\|', TEXT1));
      var rx_substitution_sepa = new RegExp(format('^{0}', SEPA));
      var rx_substitution_name = new RegExp(format('^{0}', REF_NAME));
      var rx_substitution_tail = new RegExp(format('^::{0}', TAIL));
      var rx_link_head = new RegExp("^_");
      var rx_link_name = new RegExp(format('^{0}|_', REF_NAME));
      var rx_link_tail = new RegExp(format('^:{0}', TAIL));

      var rx_verbatim = new RegExp('^::\\s*$');
      var rx_examples = new RegExp('^\\s+(?:>>>|In \\[\\d+\\]:)\\s');

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_normal(stream, state) {
        var token = null;

        if (stream.sol() && stream.match(rx_examples, false)) {
          change(state, to_mode, {
            mode: mode_python, local: CodeMirror.startState(mode_python)
          });
        } else if (stream.sol() && stream.match(rx_explicit)) {
          change(state, to_explicit);
          token = 'meta';
        } else if (stream.sol() && stream.match(rx_section)) {
          change(state, to_normal);
          token = 'header';
        } else if (phase(state) == rx_role_pre ||
                   stream.match(rx_role_pre, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_role_pre, 1));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 1:
            change(state, to_normal, context(rx_role_pre, 2));
            stream.match(rx_NAME);
            token = 'keyword';

            if (stream.current().match(/^(?:math|latex)/)) {
              state.tmp_stex = true;
            }
            break;
          case 2:
            change(state, to_normal, context(rx_role_pre, 3));
            stream.match(/^:`/);
            token = 'meta';
            break;
          case 3:
            if (state.tmp_stex) {
              state.tmp_stex = undefined; state.tmp = {
                mode: mode_stex, local: CodeMirror.startState(mode_stex)
              };
            }

            if (state.tmp) {
              if (stream.peek() == '`') {
                change(state, to_normal, context(rx_role_pre, 4));
                state.tmp = undefined;
                break;
              }

              token = state.tmp.mode.token(stream, state.tmp.local);
              break;
            }

            change(state, to_normal, context(rx_role_pre, 4));
            stream.match(rx_TEXT2);
            token = 'string';
            break;
          case 4:
            change(state, to_normal, context(rx_role_pre, 5));
            stream.match(/^`/);
            token = 'meta';
            break;
          case 5:
            change(state, to_normal, context(rx_role_pre, 6));
            stream.match(rx_TAIL);
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_role_suf ||
                   stream.match(rx_role_suf, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_role_suf, 1));
            stream.match(/^`/);
            token = 'meta';
            break;
          case 1:
            change(state, to_normal, context(rx_role_suf, 2));
            stream.match(rx_TEXT2);
            token = 'string';
            break;
          case 2:
            change(state, to_normal, context(rx_role_suf, 3));
            stream.match(/^`:/);
            token = 'meta';
            break;
          case 3:
            change(state, to_normal, context(rx_role_suf, 4));
            stream.match(rx_NAME);
            token = 'keyword';
            break;
          case 4:
            change(state, to_normal, context(rx_role_suf, 5));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 5:
            change(state, to_normal, context(rx_role_suf, 6));
            stream.match(rx_TAIL);
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_role || stream.match(rx_role, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_role, 1));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 1:
            change(state, to_normal, context(rx_role, 2));
            stream.match(rx_NAME);
            token = 'keyword';
            break;
          case 2:
            change(state, to_normal, context(rx_role, 3));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 3:
            change(state, to_normal, context(rx_role, 4));
            stream.match(rx_TAIL);
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_substitution_ref ||
                   stream.match(rx_substitution_ref, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_substitution_ref, 1));
            stream.match(rx_substitution_text);
            token = 'variable-2';
            break;
          case 1:
            change(state, to_normal, context(rx_substitution_ref, 2));
            if (stream.match(/^_?_?/)) token = 'link';
            break;
          default:
            change(state, to_normal);
          }
        } else if (stream.match(rx_footnote_ref)) {
          change(state, to_normal);
          token = 'quote';
        } else if (stream.match(rx_citation_ref)) {
          change(state, to_normal);
          token = 'quote';
        } else if (stream.match(rx_link_ref1)) {
          change(state, to_normal);
          if (!stream.peek() || stream.peek().match(/^\W$/)) {
            token = 'link';
          }
        } else if (phase(state) == rx_link_ref2 ||
                   stream.match(rx_link_ref2, false)) {

          switch (stage(state)) {
          case 0:
            if (!stream.peek() || stream.peek().match(/^\W$/)) {
              change(state, to_normal, context(rx_link_ref2, 1));
            } else {
              stream.match(rx_link_ref2);
            }
            break;
          case 1:
            change(state, to_normal, context(rx_link_ref2, 2));
            stream.match(/^`/);
            token = 'link';
            break;
          case 2:
            change(state, to_normal, context(rx_link_ref2, 3));
            stream.match(rx_TEXT2);
            break;
          case 3:
            change(state, to_normal, context(rx_link_ref2, 4));
            stream.match(/^`_/);
            token = 'link';
            break;
          default:
            change(state, to_normal);
          }
        } else if (stream.match(rx_verbatim)) {
          change(state, to_verbatim);
        }

        else {
          if (stream.next()) change(state, to_normal);
        }

        return token;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_explicit(stream, state) {
        var token = null;

        if (phase(state) == rx_substitution ||
            stream.match(rx_substitution, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_explicit, context(rx_substitution, 1));
            stream.match(rx_substitution_text);
            token = 'variable-2';
            break;
          case 1:
            change(state, to_explicit, context(rx_substitution, 2));
            stream.match(rx_substitution_sepa);
            break;
          case 2:
            change(state, to_explicit, context(rx_substitution, 3));
            stream.match(rx_substitution_name);
            token = 'keyword';
            break;
          case 3:
            change(state, to_explicit, context(rx_substitution, 4));
            stream.match(rx_substitution_tail);
            token = 'meta';
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_directive ||
                   stream.match(rx_directive, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_explicit, context(rx_directive, 1));
            stream.match(rx_directive_name);
            token = 'keyword';

            if (stream.current().match(/^(?:math|latex)/))
              state.tmp_stex = true;
            else if (stream.current().match(/^python/))
              state.tmp_py = true;
            break;
          case 1:
            change(state, to_explicit, context(rx_directive, 2));
            stream.match(rx_directive_tail);
            token = 'meta';

            if (stream.match(/^latex\s*$/) || state.tmp_stex) {
              state.tmp_stex = undefined; change(state, to_mode, {
                mode: mode_stex, local: CodeMirror.startState(mode_stex)
              });
            }
            break;
          case 2:
            change(state, to_explicit, context(rx_directive, 3));
            if (stream.match(/^python\s*$/) || state.tmp_py) {
              state.tmp_py = undefined; change(state, to_mode, {
                mode: mode_python, local: CodeMirror.startState(mode_python)
              });
            }
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_link || stream.match(rx_link, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_explicit, context(rx_link, 1));
            stream.match(rx_link_head);
            stream.match(rx_link_name);
            token = 'link';
            break;
          case 1:
            change(state, to_explicit, context(rx_link, 2));
            stream.match(rx_link_tail);
            token = 'meta';
            break;
          default:
            change(state, to_normal);
          }
        } else if (stream.match(rx_footnote)) {
          change(state, to_normal);
          token = 'quote';
        } else if (stream.match(rx_citation)) {
          change(state, to_normal);
          token = 'quote';
        }

        else {
          stream.eatSpace();
          if (stream.eol()) {
            change(state, to_normal);
          } else {
            stream.skipToEnd();
            change(state, to_comment);
            token = 'comment';
          }
        }

        return token;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_comment(stream, state) {
        return as_block(stream, state, 'comment');
      }

      function to_verbatim(stream, state) {
        return as_block(stream, state, 'meta');
      }

      function as_block(stream, state, token) {
        if (stream.eol() || stream.eatSpace()) {
          stream.skipToEnd();
          return token;
        } else {
          change(state, to_normal);
          return null;
        }
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_mode(stream, state) {

        if (state.ctx.mode && state.ctx.local) {

          if (stream.sol()) {
            if (!stream.eatSpace()) change(state, to_normal);
            return null;
          }

          return state.ctx.mode.token(stream, state.ctx.local);
        }

        change(state, to_normal);
        return null;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function context(phase, stage, mode, local) {
        return {phase: phase, stage: stage, mode: mode, local: local};
      }

      function change(state, tok, ctx) {
        state.tok = tok;
        state.ctx = ctx || {};
      }

      function stage(state) {
        return state.ctx.stage || 0;
      }

      function phase(state) {
        return state.ctx.phase;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      return {
        startState: function () {
          return {tok: to_normal, ctx: context(undefined, 0)};
        },

        copyState: function (state) {
          var ctx = state.ctx, tmp = state.tmp;
          if (ctx.local)
            ctx = {mode: ctx.mode, local: CodeMirror.copyState(ctx.mode, ctx.local)};
          if (tmp)
            tmp = {mode: tmp.mode, local: CodeMirror.copyState(tmp.mode, tmp.local)};
          return {tok: state.tok, ctx: ctx, tmp: tmp};
        },

        innerMode: function (state) {
          return state.tmp      ? {state: state.tmp.local, mode: state.tmp.mode}
          : state.ctx.mode ? {state: state.ctx.local, mode: state.ctx.mode}
          : null;
        },

        token: function (stream, state) {
          return state.tok(stream, state);
        }
      };
    }, 'python', 'stex');

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    CodeMirror.defineMIME('text/x-rst', 'rst');

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-rust-rust.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../addon/mode/simple"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineSimpleMode("rust",{
      start: [
        // string and byte string
        {regex: /b?"/, token: "string", next: "string"},
        // raw string and raw byte string
        {regex: /b?r"/, token: "string", next: "string_raw"},
        {regex: /b?r#+"/, token: "string", next: "string_raw_hash"},
        // character
        {regex: /'(?:[^'\\]|\\(?:[nrt0'"]|x[\da-fA-F]{2}|u\{[\da-fA-F]{6}\}))'/, token: "string-2"},
        // byte
        {regex: /b'(?:[^']|\\(?:['\\nrt0]|x[\da-fA-F]{2}))'/, token: "string-2"},

        {regex: /(?:(?:[0-9][0-9_]*)(?:(?:[Ee][+-]?[0-9_]+)|\.[0-9_]+(?:[Ee][+-]?[0-9_]+)?)(?:f32|f64)?)|(?:0(?:b[01_]+|(?:o[0-7_]+)|(?:x[0-9a-fA-F_]+))|(?:[0-9][0-9_]*))(?:u8|u16|u32|u64|i8|i16|i32|i64|isize|usize)?/,
         token: "number"},
        {regex: /(let(?:\s+mut)?|fn|enum|mod|struct|type|union)(\s+)([a-zA-Z_][a-zA-Z0-9_]*)/, token: ["keyword", null, "def"]},
        {regex: /(?:abstract|alignof|as|async|await|box|break|continue|const|crate|do|dyn|else|enum|extern|fn|for|final|if|impl|in|loop|macro|match|mod|move|offsetof|override|priv|proc|pub|pure|ref|return|self|sizeof|static|struct|super|trait|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, token: "keyword"},
        {regex: /\b(?:Self|isize|usize|char|bool|u8|u16|u32|u64|f16|f32|f64|i8|i16|i32|i64|str|Option)\b/, token: "atom"},
        {regex: /\b(?:true|false|Some|None|Ok|Err)\b/, token: "builtin"},
        {regex: /\b(fn)(\s+)([a-zA-Z_][a-zA-Z0-9_]*)/,
         token: ["keyword", null ,"def"]},
        {regex: /#!?\[.*\]/, token: "meta"},
        {regex: /\/\/.*/, token: "comment"},
        {regex: /\/\*/, token: "comment", next: "comment"},
        {regex: /[-+\/*=<>!]+/, token: "operator"},
        {regex: /[a-zA-Z_]\w*!/,token: "variable-3"},
        {regex: /[a-zA-Z_]\w*/, token: "variable"},
        {regex: /[\{\[\(]/, indent: true},
        {regex: /[\}\]\)]/, dedent: true}
      ],
      string: [
        {regex: /"/, token: "string", next: "start"},
        {regex: /(?:[^\\"]|\\(?:.|$))*/, token: "string"}
      ],
      string_raw: [
        {regex: /"/, token: "string", next: "start"},
        {regex: /[^"]*/, token: "string"}
      ],
      string_raw_hash: [
        {regex: /"#+/, token: "string", next: "start"},
        {regex: /(?:[^"]|"(?!#))*/, token: "string"}
      ],
      comment: [
        {regex: /.*?\*\//, token: "comment", next: "start"},
        {regex: /.*/, token: "comment"}
      ],
      meta: {
        dontIndentStates: ["comment"],
        electricInput: /^\s*\}$/,
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//",
        fold: "brace"
      }
    });


    CodeMirror.defineMIME("text/x-rustsrc", "rust");
    CodeMirror.defineMIME("text/rust", "rust");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-sas-sas.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE


    // SAS mode copyright (c) 2016 Jared Dean, SAS Institute
    // Created by Jared Dean

    // TODO
    // indent and de-indent
    // identify macro variables


    //Definitions
    //  comment -- text within * ; or /* */
    //  keyword -- SAS language variable
    //  variable -- macro variables starts with '&' or variable formats
    //  variable-2 -- DATA Step, proc, or macro names
    //  string -- text within ' ' or " "
    //  operator -- numeric operator + / - * ** le eq ge ... and so on
    //  builtin -- proc %macro data run mend
    //  atom
    //  def

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("sas", function () {
        var words = {};
        var isDoubleOperatorSym = {
          eq: 'operator',
          lt: 'operator',
          le: 'operator',
          gt: 'operator',
          ge: 'operator',
          "in": 'operator',
          ne: 'operator',
          or: 'operator'
        };
        var isDoubleOperatorChar = /(<=|>=|!=|<>)/;
        var isSingleOperatorChar = /[=\(:\),{}.*<>+\-\/^\[\]]/;

        // Takes a string of words separated by spaces and adds them as
        // keys with the value of the first argument 'style'
        function define(style, string, context) {
          if (context) {
            var split = string.split(' ');
            for (var i = 0; i < split.length; i++) {
              words[split[i]] = {style: style, state: context};
            }
          }
        }
        //datastep
        define('def', 'stack pgm view source debug nesting nolist', ['inDataStep']);
        define('def', 'if while until for do do; end end; then else cancel', ['inDataStep']);
        define('def', 'label format _n_ _error_', ['inDataStep']);
        define('def', 'ALTER BUFNO BUFSIZE CNTLLEV COMPRESS DLDMGACTION ENCRYPT ENCRYPTKEY EXTENDOBSCOUNTER GENMAX GENNUM INDEX LABEL OBSBUF OUTREP PW PWREQ READ REPEMPTY REPLACE REUSE ROLE SORTEDBY SPILL TOBSNO TYPE WRITE FILECLOSE FIRSTOBS IN OBS POINTOBS WHERE WHEREUP IDXNAME IDXWHERE DROP KEEP RENAME', ['inDataStep']);
        define('def', 'filevar finfo finv fipname fipnamel fipstate first firstobs floor', ['inDataStep']);
        define('def', 'varfmt varinfmt varlabel varlen varname varnum varray varrayx vartype verify vformat vformatd vformatdx vformatn vformatnx vformatw vformatwx vformatx vinarray vinarrayx vinformat vinformatd vinformatdx vinformatn vinformatnx vinformatw vinformatwx vinformatx vlabel vlabelx vlength vlengthx vname vnamex vnferr vtype vtypex weekday', ['inDataStep']);
        define('def', 'zipfips zipname zipnamel zipstate', ['inDataStep']);
        define('def', 'put putc putn', ['inDataStep']);
        define('builtin', 'data run', ['inDataStep']);


        //proc
        define('def', 'data', ['inProc']);

        // flow control for macros
        define('def', '%if %end %end; %else %else; %do %do; %then', ['inMacro']);

        //everywhere
        define('builtin', 'proc run; quit; libname filename %macro %mend option options', ['ALL']);

        define('def', 'footnote title libname ods', ['ALL']);
        define('def', '%let %put %global %sysfunc %eval ', ['ALL']);
        // automatic macro variables http://support.sas.com/documentation/cdl/en/mcrolref/61885/HTML/default/viewer.htm#a003167023.htm
        define('variable', '&sysbuffr &syscc &syscharwidth &syscmd &sysdate &sysdate9 &sysday &sysdevic &sysdmg &sysdsn &sysencoding &sysenv &syserr &syserrortext &sysfilrc &syshostname &sysindex &sysinfo &sysjobid &syslast &syslckrc &syslibrc &syslogapplname &sysmacroname &sysmenv &sysmsg &sysncpu &sysodspath &sysparm &syspbuff &sysprocessid &sysprocessname &sysprocname &sysrc &sysscp &sysscpl &sysscpl &syssite &sysstartid &sysstartname &systcpiphostname &systime &sysuserid &sysver &sysvlong &sysvlong4 &syswarningtext', ['ALL']);

        //footnote[1-9]? title[1-9]?

        //options statement
        define('def', 'source2 nosource2 page pageno pagesize', ['ALL']);

        //proc and datastep
        define('def', '_all_ _character_ _cmd_ _freq_ _i_ _infile_ _last_ _msg_ _null_ _numeric_ _temporary_ _type_ abort abs addr adjrsq airy alpha alter altlog altprint and arcos array arsin as atan attrc attrib attrn authserver autoexec awscontrol awsdef awsmenu awsmenumerge awstitle backward band base betainv between blocksize blshift bnot bor brshift bufno bufsize bxor by byerr byline byte calculated call cards cards4 catcache cbufno cdf ceil center cexist change chisq cinv class cleanup close cnonct cntllev coalesce codegen col collate collin column comamid comaux1 comaux2 comdef compbl compound compress config continue convert cos cosh cpuid create cross crosstab css curobs cv daccdb daccdbsl daccsl daccsyd dacctab dairy datalines datalines4 datejul datepart datetime day dbcslang dbcstype dclose ddfm ddm delete delimiter depdb depdbsl depsl depsyd deptab dequote descending descript design= device dflang dhms dif digamma dim dinfo display distinct dkricond dkrocond dlm dnum do dopen doptname doptnum dread drop dropnote dsname dsnferr echo else emaildlg emailid emailpw emailserver emailsys encrypt end endsas engine eof eov erf erfc error errorcheck errors exist exp fappend fclose fcol fdelete feedback fetch fetchobs fexist fget file fileclose fileexist filefmt filename fileref  fmterr fmtsearch fnonct fnote font fontalias  fopen foptname foptnum force formatted formchar formdelim formdlim forward fpoint fpos fput fread frewind frlen from fsep fuzz fwrite gaminv gamma getoption getvarc getvarn go goto group gwindow hbar hbound helpenv helploc hms honorappearance hosthelp hostprint hour hpct html hvar ibessel ibr id if index indexc indexw initcmd initstmt inner input inputc inputn inr insert int intck intnx into intrr invaliddata irr is jbessel join juldate keep kentb kurtosis label lag last lbound leave left length levels lgamma lib  library libref line linesize link list log log10 log2 logpdf logpmf logsdf lostcard lowcase lrecl ls macro macrogen maps mautosource max maxdec maxr mdy mean measures median memtype merge merror min minute missing missover mlogic mod mode model modify month mopen mort mprint mrecall msglevel msymtabmax mvarsize myy n nest netpv new news nmiss no nobatch nobs nocaps nocardimage nocenter nocharcode nocmdmac nocol nocum nodate nodbcs nodetails nodmr nodms nodmsbatch nodup nodupkey noduplicates noechoauto noequals noerrorabend noexitwindows nofullstimer noicon noimplmac noint nolist noloadlist nomiss nomlogic nomprint nomrecall nomsgcase nomstored nomultenvappl nonotes nonumber noobs noovp nopad nopercent noprint noprintinit normal norow norsasuser nosetinit  nosplash nosymbolgen note notes notitle notitles notsorted noverbose noxsync noxwait npv null number numkeys nummousekeys nway obs  on open     order ordinal otherwise out outer outp= output over ovp p(1 5 10 25 50 75 90 95 99) pad pad2  paired parm parmcards path pathdll pathname pdf peek peekc pfkey pmf point poisson poke position printer probbeta probbnml probchi probf probgam probhypr probit probnegb probnorm probsig probt procleave prt ps  pw pwreq qtr quote r ranbin rancau random ranexp rangam range ranks rannor ranpoi rantbl rantri ranuni rcorr read recfm register regr remote remove rename repeat repeated replace resolve retain return reuse reverse rewind right round rsquare rtf rtrace rtraceloc s s2 samploc sasautos sascontrol sasfrscr sasmsg sasmstore sasscript sasuser saving scan sdf second select selection separated seq serror set setcomm setot sign simple sin sinh siteinfo skewness skip sle sls sortedby sortpgm sortseq sortsize soundex  spedis splashlocation split spool sqrt start std stderr stdin stfips stimer stname stnamel stop stopover sub subgroup subpopn substr sum sumwgt symbol symbolgen symget symput sysget sysin sysleave sysmsg sysparm sysprint sysprintfont sysprod sysrc system t table tables tan tanh tapeclose tbufsize terminal test then timepart tinv  tnonct to today tol tooldef totper transformout translate trantab tranwrd trigamma trim trimn trunc truncover type unformatted uniform union until upcase update user usericon uss validate value var  weight when where while wincharset window work workinit workterm write wsum xsync xwait yearcutoff yes yyq  min max', ['inDataStep', 'inProc']);
        define('operator', 'and not ', ['inDataStep', 'inProc']);

        // Main function
        function tokenize(stream, state) {
          // Finally advance the stream
          var ch = stream.next();

          // BLOCKCOMMENT
          if (ch === '/' && stream.eat('*')) {
            state.continueComment = true;
            return "comment";
          } else if (state.continueComment === true) { // in comment block
            //comment ends at the beginning of the line
            if (ch === '*' && stream.peek() === '/') {
              stream.next();
              state.continueComment = false;
            } else if (stream.skipTo('*')) { //comment is potentially later in line
              stream.skipTo('*');
              stream.next();
              if (stream.eat('/'))
                state.continueComment = false;
            } else {
              stream.skipToEnd();
            }
            return "comment";
          }

          if (ch == "*" && stream.column() == stream.indentation()) {
            stream.skipToEnd()
            return "comment"
          }

          // DoubleOperator match
          var doubleOperator = ch + stream.peek();

          if ((ch === '"' || ch === "'") && !state.continueString) {
            state.continueString = ch
            return "string"
          } else if (state.continueString) {
            if (state.continueString == ch) {
              state.continueString = null;
            } else if (stream.skipTo(state.continueString)) {
              // quote found on this line
              stream.next();
              state.continueString = null;
            } else {
              stream.skipToEnd();
            }
            return "string";
          } else if (state.continueString !== null && stream.eol()) {
            stream.skipTo(state.continueString) || stream.skipToEnd();
            return "string";
          } else if (/[\d\.]/.test(ch)) { //find numbers
            if (ch === ".")
              stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
            else if (ch === "0")
              stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
            else
              stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
            return "number";
          } else if (isDoubleOperatorChar.test(ch + stream.peek())) { // TWO SYMBOL TOKENS
            stream.next();
            return "operator";
          } else if (isDoubleOperatorSym.hasOwnProperty(doubleOperator)) {
            stream.next();
            if (stream.peek() === ' ')
              return isDoubleOperatorSym[doubleOperator.toLowerCase()];
          } else if (isSingleOperatorChar.test(ch)) { // SINGLE SYMBOL TOKENS
            return "operator";
          }

          // Matches one whole word -- even if the word is a character
          var word;
          if (stream.match(/[%&;\w]+/, false) != null) {
            word = ch + stream.match(/[%&;\w]+/, true);
            if (/&/.test(word)) return 'variable'
          } else {
            word = ch;
          }
          // the word after DATA PROC or MACRO
          if (state.nextword) {
            stream.match(/[\w]+/);
            // match memname.libname
            if (stream.peek() === '.') stream.skipTo(' ');
            state.nextword = false;
            return 'variable-2';
          }

          word = word.toLowerCase()
          // Are we in a DATA Step?
          if (state.inDataStep) {
            if (word === 'run;' || stream.match(/run\s;/)) {
              state.inDataStep = false;
              return 'builtin';
            }
            // variable formats
            if ((word) && stream.next() === '.') {
              //either a format or libname.memname
              if (/\w/.test(stream.peek())) return 'variable-2';
              else return 'variable';
            }
            // do we have a DATA Step keyword
            if (word && words.hasOwnProperty(word) &&
                (words[word].state.indexOf("inDataStep") !== -1 ||
                 words[word].state.indexOf("ALL") !== -1)) {
              //backup to the start of the word
              if (stream.start < stream.pos)
                stream.backUp(stream.pos - stream.start);
              //advance the length of the word and return
              for (var i = 0; i < word.length; ++i) stream.next();
              return words[word].style;
            }
          }
          // Are we in an Proc statement?
          if (state.inProc) {
            if (word === 'run;' || word === 'quit;') {
              state.inProc = false;
              return 'builtin';
            }
            // do we have a proc keyword
            if (word && words.hasOwnProperty(word) &&
                (words[word].state.indexOf("inProc") !== -1 ||
                 words[word].state.indexOf("ALL") !== -1)) {
              stream.match(/[\w]+/);
              return words[word].style;
            }
          }
          // Are we in a Macro statement?
          if (state.inMacro) {
            if (word === '%mend') {
              if (stream.peek() === ';') stream.next();
              state.inMacro = false;
              return 'builtin';
            }
            if (word && words.hasOwnProperty(word) &&
                (words[word].state.indexOf("inMacro") !== -1 ||
                 words[word].state.indexOf("ALL") !== -1)) {
              stream.match(/[\w]+/);
              return words[word].style;
            }

            return 'atom';
          }
          // Do we have Keywords specific words?
          if (word && words.hasOwnProperty(word)) {
            // Negates the initial next()
            stream.backUp(1);
            // Actually move the stream
            stream.match(/[\w]+/);
            if (word === 'data' && /=/.test(stream.peek()) === false) {
              state.inDataStep = true;
              state.nextword = true;
              return 'builtin';
            }
            if (word === 'proc') {
              state.inProc = true;
              state.nextword = true;
              return 'builtin';
            }
            if (word === '%macro') {
              state.inMacro = true;
              state.nextword = true;
              return 'builtin';
            }
            if (/title[1-9]/.test(word)) return 'def';

            if (word === 'footnote') {
              stream.eat(/[1-9]/);
              return 'def';
            }

            // Returns their value as state in the prior define methods
            if (state.inDataStep === true && words[word].state.indexOf("inDataStep") !== -1)
              return words[word].style;
            if (state.inProc === true && words[word].state.indexOf("inProc") !== -1)
              return words[word].style;
            if (state.inMacro === true && words[word].state.indexOf("inMacro") !== -1)
              return words[word].style;
            if (words[word].state.indexOf("ALL") !== -1)
              return words[word].style;
            return null;
          }
          // Unrecognized syntax
          return null;
        }

        return {
          startState: function () {
            return {
              inDataStep: false,
              inProc: false,
              inMacro: false,
              nextword: false,
              continueString: null,
              continueComment: false
            };
          },
          token: function (stream, state) {
            // Strip the spaces, but regex will account for them either way
            if (stream.eatSpace()) return null;
            // Go through the main process
            return tokenize(stream, state);
          },

          blockCommentStart: "/*",
          blockCommentEnd: "*/"
        };

      });

      CodeMirror.defineMIME("text/x-sas", "sas");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-scheme-scheme.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Author: Koh Zi Han, based on implementation by Koh Zi Chun
     */

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("scheme", function () {
        var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
            ATOM = "atom", NUMBER = "number", BRACKET = "bracket";
        var INDENT_WORD_SKIP = 2;

        function makeKeywords(str) {
            var obj = {}, words = str.split(" ");
            for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
            return obj;
        }

        var keywords = makeKeywords("λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?");
        var indentKeys = makeKeywords("define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless");

        function stateStack(indent, type, prev) { // represents a state stack object
            this.indent = indent;
            this.type = type;
            this.prev = prev;
        }

        function pushStack(state, indent, type) {
            state.indentStack = new stateStack(indent, type, state.indentStack);
        }

        function popStack(state) {
            state.indentStack = state.indentStack.prev;
        }

        var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\/[01]+#*)?i|[-+]?[01]+#*(?:\/[01]+#*)?@[-+]?[01]+#*(?:\/[01]+#*)?|[-+]?[01]+#*(?:\/[01]+#*)?[-+](?:[01]+#*(?:\/[01]+#*)?)?i|[-+]?[01]+#*(?:\/[01]+#*)?)(?=[()\s;"]|$)/i);
        var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?)(?=[()\s;"]|$)/i);
        var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\da-f]+#*(?:\/[\da-f]+#*)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?@[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?[-+](?:[\da-f]+#*(?:\/[\da-f]+#*)?)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?)(?=[()\s;"]|$)/i);
        var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)i|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)@[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)?i|(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*))(?=[()\s;"]|$)/i);

        function isBinaryNumber (stream) {
            return stream.match(binaryMatcher);
        }

        function isOctalNumber (stream) {
            return stream.match(octalMatcher);
        }

        function isDecimalNumber (stream, backup) {
            if (backup === true) {
                stream.backUp(1);
            }
            return stream.match(decimalMatcher);
        }

        function isHexNumber (stream) {
            return stream.match(hexMatcher);
        }

        return {
            startState: function () {
                return {
                    indentStack: null,
                    indentation: 0,
                    mode: false,
                    sExprComment: false,
                    sExprQuote: false
                };
            },

            token: function (stream, state) {
                if (state.indentStack == null && stream.sol()) {
                    // update indentation, but only if indentStack is empty
                    state.indentation = stream.indentation();
                }

                // skip spaces
                if (stream.eatSpace()) {
                    return null;
                }
                var returnType = null;

                switch(state.mode){
                    case "string": // multi-line string parsing mode
                        var next, escaped = false;
                        while ((next = stream.next()) != null) {
                            if (next == "\"" && !escaped) {

                                state.mode = false;
                                break;
                            }
                            escaped = !escaped && next == "\\";
                        }
                        returnType = STRING; // continue on in scheme-string mode
                        break;
                    case "comment": // comment parsing mode
                        var next, maybeEnd = false;
                        while ((next = stream.next()) != null) {
                            if (next == "#" && maybeEnd) {

                                state.mode = false;
                                break;
                            }
                            maybeEnd = (next == "|");
                        }
                        returnType = COMMENT;
                        break;
                    case "s-expr-comment": // s-expr commenting mode
                        state.mode = false;
                        if(stream.peek() == "(" || stream.peek() == "["){
                            // actually start scheme s-expr commenting mode
                            state.sExprComment = 0;
                        }else{
                            // if not we just comment the entire of the next token
                            stream.eatWhile(/[^\s\(\)\[\]]/); // eat symbol atom
                            returnType = COMMENT;
                            break;
                        }
                    default: // default parsing mode
                        var ch = stream.next();

                        if (ch == "\"") {
                            state.mode = "string";
                            returnType = STRING;

                        } else if (ch == "'") {
                            if (stream.peek() == "(" || stream.peek() == "["){
                                if (typeof state.sExprQuote != "number") {
                                    state.sExprQuote = 0;
                                } // else already in a quoted expression
                                returnType = ATOM;
                            } else {
                                stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);
                                returnType = ATOM;
                            }
                        } else if (ch == '#') {
                            if (stream.eat("|")) {                    // Multi-line comment
                                state.mode = "comment"; // toggle to comment mode
                                returnType = COMMENT;
                            } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)
                                returnType = ATOM;
                            } else if (stream.eat(';')) {                // S-Expr comment
                                state.mode = "s-expr-comment";
                                returnType = COMMENT;
                            } else {
                                var numTest = null, hasExactness = false, hasRadix = true;
                                if (stream.eat(/[ei]/i)) {
                                    hasExactness = true;
                                } else {
                                    stream.backUp(1);       // must be radix specifier
                                }
                                if (stream.match(/^#b/i)) {
                                    numTest = isBinaryNumber;
                                } else if (stream.match(/^#o/i)) {
                                    numTest = isOctalNumber;
                                } else if (stream.match(/^#x/i)) {
                                    numTest = isHexNumber;
                                } else if (stream.match(/^#d/i)) {
                                    numTest = isDecimalNumber;
                                } else if (stream.match(/^[-+0-9.]/, false)) {
                                    hasRadix = false;
                                    numTest = isDecimalNumber;
                                // re-consume the initial # if all matches failed
                                } else if (!hasExactness) {
                                    stream.eat('#');
                                }
                                if (numTest != null) {
                                    if (hasRadix && !hasExactness) {
                                        // consume optional exactness after radix
                                        stream.match(/^#[ei]/i);
                                    }
                                    if (numTest(stream))
                                        returnType = NUMBER;
                                }
                            }
                        } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal
                            returnType = NUMBER;
                        } else if (ch == ";") { // comment
                            stream.skipToEnd(); // rest of the line is a comment
                            returnType = COMMENT;
                        } else if (ch == "(" || ch == "[") {
                          var keyWord = ''; var indentTemp = stream.column(), letter;
                            /**
                            Either
                            (indent-word ..
                            (non-indent-word ..
                            (;something else, bracket, etc.
                            */

                            while ((letter = stream.eat(/[^\s\(\[\;\)\]]/)) != null) {
                                keyWord += letter;
                            }

                            if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word

                                pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);
                            } else { // non-indent word
                                // we continue eating the spaces
                                stream.eatSpace();
                                if (stream.eol() || stream.peek() == ";") {
                                    // nothing significant after
                                    // we restart indentation 1 space after
                                    pushStack(state, indentTemp + 1, ch);
                                } else {
                                    pushStack(state, indentTemp + stream.current().length, ch); // else we match
                                }
                            }
                            stream.backUp(stream.current().length - 1); // undo all the eating

                            if(typeof state.sExprComment == "number") state.sExprComment++;
                            if(typeof state.sExprQuote == "number") state.sExprQuote++;

                            returnType = BRACKET;
                        } else if (ch == ")" || ch == "]") {
                            returnType = BRACKET;
                            if (state.indentStack != null && state.indentStack.type == (ch == ")" ? "(" : "[")) {
                                popStack(state);

                                if(typeof state.sExprComment == "number"){
                                    if(--state.sExprComment == 0){
                                        returnType = COMMENT; // final closing bracket
                                        state.sExprComment = false; // turn off s-expr commenting mode
                                    }
                                }
                                if(typeof state.sExprQuote == "number"){
                                    if(--state.sExprQuote == 0){
                                        returnType = ATOM; // final closing bracket
                                        state.sExprQuote = false; // turn off s-expr quote mode
                                    }
                                }
                            }
                        } else {
                            stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);

                            if (keywords && keywords.propertyIsEnumerable(stream.current())) {
                                returnType = BUILTIN;
                            } else returnType = "variable";
                        }
                }
                return (typeof state.sExprComment == "number") ? COMMENT : ((typeof state.sExprQuote == "number") ? ATOM : returnType);
            },

            indent: function (state) {
                if (state.indentStack == null) return state.indentation;
                return state.indentStack.indent;
            },

            closeBrackets: {pairs: "()[]{}\"\""},
            lineComment: ";;"
        };
    });

    CodeMirror.defineMIME("text/x-scheme", "scheme");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-slim-slim.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"), require("../ruby/ruby"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../ruby/ruby"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

      CodeMirror.defineMode("slim", function(config) {
        var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
        var rubyMode = CodeMirror.getMode(config, "ruby");
        var modes = { html: htmlMode, ruby: rubyMode };
        var embedded = {
          ruby: "ruby",
          javascript: "javascript",
          css: "text/css",
          sass: "text/x-sass",
          scss: "text/x-scss",
          less: "text/x-less",
          styl: "text/x-styl", // no highlighting so far
          coffee: "coffeescript",
          asciidoc: "text/x-asciidoc",
          markdown: "text/x-markdown",
          textile: "text/x-textile", // no highlighting so far
          creole: "text/x-creole", // no highlighting so far
          wiki: "text/x-wiki", // no highlighting so far
          mediawiki: "text/x-mediawiki", // no highlighting so far
          rdoc: "text/x-rdoc", // no highlighting so far
          builder: "text/x-builder", // no highlighting so far
          nokogiri: "text/x-nokogiri", // no highlighting so far
          erb: "application/x-erb"
        };
        var embeddedRegexp = function(map){
          var arr = [];
          for(var key in map) arr.push(key);
          return new RegExp("^("+arr.join('|')+"):");
        }(embedded);

        var styleMap = {
          "commentLine": "comment",
          "slimSwitch": "operator special",
          "slimTag": "tag",
          "slimId": "attribute def",
          "slimClass": "attribute qualifier",
          "slimAttribute": "attribute",
          "slimSubmode": "keyword special",
          "closeAttributeTag": null,
          "slimDoctype": null,
          "lineContinuation": null
        };
        var closing = {
          "{": "}",
          "[": "]",
          "(": ")"
        };

        var nameStartChar = "_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
        var nameChar = nameStartChar + "\\-0-9\xB7\u0300-\u036F\u203F-\u2040";
        var nameRegexp = new RegExp("^[:"+nameStartChar+"](?::["+nameChar+"]|["+nameChar+"]*)");
        var attributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*(?=\\s*=)");
        var wrappedAttributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*");
        var classNameRegexp = /^\.-?[_a-zA-Z]+[\w\-]*/;
        var classIdRegexp = /^#[_a-zA-Z]+[\w\-]*/;

        function backup(pos, tokenize, style) {
          var restore = function(stream, state) {
            state.tokenize = tokenize;
            if (stream.pos < pos) {
              stream.pos = pos;
              return style;
            }
            return state.tokenize(stream, state);
          };
          return function(stream, state) {
            state.tokenize = restore;
            return tokenize(stream, state);
          };
        }

        function maybeBackup(stream, state, pat, offset, style) {
          var cur = stream.current();
          var idx = cur.search(pat);
          if (idx > -1) {
            state.tokenize = backup(stream.pos, state.tokenize, style);
            stream.backUp(cur.length - idx - offset);
          }
          return style;
        }

        function continueLine(state, column) {
          state.stack = {
            parent: state.stack,
            style: "continuation",
            indented: column,
            tokenize: state.line
          };
          state.line = state.tokenize;
        }
        function finishContinue(state) {
          if (state.line == state.tokenize) {
            state.line = state.stack.tokenize;
            state.stack = state.stack.parent;
          }
        }

        function lineContinuable(column, tokenize) {
          return function(stream, state) {
            finishContinue(state);
            if (stream.match(/^\\$/)) {
              continueLine(state, column);
              return "lineContinuation";
            }
            var style = tokenize(stream, state);
            if (stream.eol() && stream.current().match(/(?:^|[^\\])(?:\\\\)*\\$/)) {
              stream.backUp(1);
            }
            return style;
          };
        }
        function commaContinuable(column, tokenize) {
          return function(stream, state) {
            finishContinue(state);
            var style = tokenize(stream, state);
            if (stream.eol() && stream.current().match(/,$/)) {
              continueLine(state, column);
            }
            return style;
          };
        }

        function rubyInQuote(endQuote, tokenize) {
          // TODO: add multi line support
          return function(stream, state) {
            var ch = stream.peek();
            if (ch == endQuote && state.rubyState.tokenize.length == 1) {
              // step out of ruby context as it seems to complete processing all the braces
              stream.next();
              state.tokenize = tokenize;
              return "closeAttributeTag";
            } else {
              return ruby(stream, state);
            }
          };
        }
        function startRubySplat(tokenize) {
          var rubyState;
          var runSplat = function(stream, state) {
            if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {
              stream.backUp(1);
              if (stream.eatSpace()) {
                state.rubyState = rubyState;
                state.tokenize = tokenize;
                return tokenize(stream, state);
              }
              stream.next();
            }
            return ruby(stream, state);
          };
          return function(stream, state) {
            rubyState = state.rubyState;
            state.rubyState = CodeMirror.startState(rubyMode);
            state.tokenize = runSplat;
            return ruby(stream, state);
          };
        }

        function ruby(stream, state) {
          return rubyMode.token(stream, state.rubyState);
        }

        function htmlLine(stream, state) {
          if (stream.match(/^\\$/)) {
            return "lineContinuation";
          }
          return html(stream, state);
        }
        function html(stream, state) {
          if (stream.match(/^#\{/)) {
            state.tokenize = rubyInQuote("}", state.tokenize);
            return null;
          }
          return maybeBackup(stream, state, /[^\\]#\{/, 1, htmlMode.token(stream, state.htmlState));
        }

        function startHtmlLine(lastTokenize) {
          return function(stream, state) {
            var style = htmlLine(stream, state);
            if (stream.eol()) state.tokenize = lastTokenize;
            return style;
          };
        }

        function startHtmlMode(stream, state, offset) {
          state.stack = {
            parent: state.stack,
            style: "html",
            indented: stream.column() + offset, // pipe + space
            tokenize: state.line
          };
          state.line = state.tokenize = html;
          return null;
        }

        function comment(stream, state) {
          stream.skipToEnd();
          return state.stack.style;
        }

        function commentMode(stream, state) {
          state.stack = {
            parent: state.stack,
            style: "comment",
            indented: state.indented + 1,
            tokenize: state.line
          };
          state.line = comment;
          return comment(stream, state);
        }

        function attributeWrapper(stream, state) {
          if (stream.eat(state.stack.endQuote)) {
            state.line = state.stack.line;
            state.tokenize = state.stack.tokenize;
            state.stack = state.stack.parent;
            return null;
          }
          if (stream.match(wrappedAttributeNameRegexp)) {
            state.tokenize = attributeWrapperAssign;
            return "slimAttribute";
          }
          stream.next();
          return null;
        }
        function attributeWrapperAssign(stream, state) {
          if (stream.match(/^==?/)) {
            state.tokenize = attributeWrapperValue;
            return null;
          }
          return attributeWrapper(stream, state);
        }
        function attributeWrapperValue(stream, state) {
          var ch = stream.peek();
          if (ch == '"' || ch == "\'") {
            state.tokenize = readQuoted(ch, "string", true, false, attributeWrapper);
            stream.next();
            return state.tokenize(stream, state);
          }
          if (ch == '[') {
            return startRubySplat(attributeWrapper)(stream, state);
          }
          if (stream.match(/^(true|false|nil)\b/)) {
            state.tokenize = attributeWrapper;
            return "keyword";
          }
          return startRubySplat(attributeWrapper)(stream, state);
        }

        function startAttributeWrapperMode(state, endQuote, tokenize) {
          state.stack = {
            parent: state.stack,
            style: "wrapper",
            indented: state.indented + 1,
            tokenize: tokenize,
            line: state.line,
            endQuote: endQuote
          };
          state.line = state.tokenize = attributeWrapper;
          return null;
        }

        function sub(stream, state) {
          if (stream.match(/^#\{/)) {
            state.tokenize = rubyInQuote("}", state.tokenize);
            return null;
          }
          var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);
          subStream.pos = stream.pos - state.stack.indented;
          subStream.start = stream.start - state.stack.indented;
          subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;
          subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;
          var style = state.subMode.token(subStream, state.subState);
          stream.pos = subStream.pos + state.stack.indented;
          return style;
        }
        function firstSub(stream, state) {
          state.stack.indented = stream.column();
          state.line = state.tokenize = sub;
          return state.tokenize(stream, state);
        }

        function createMode(mode) {
          var query = embedded[mode];
          var spec = CodeMirror.mimeModes[query];
          if (spec) {
            return CodeMirror.getMode(config, spec);
          }
          var factory = CodeMirror.modes[query];
          if (factory) {
            return factory(config, {name: query});
          }
          return CodeMirror.getMode(config, "null");
        }

        function getMode(mode) {
          if (!modes.hasOwnProperty(mode)) {
            return modes[mode] = createMode(mode);
          }
          return modes[mode];
        }

        function startSubMode(mode, state) {
          var subMode = getMode(mode);
          var subState = CodeMirror.startState(subMode);

          state.subMode = subMode;
          state.subState = subState;

          state.stack = {
            parent: state.stack,
            style: "sub",
            indented: state.indented + 1,
            tokenize: state.line
          };
          state.line = state.tokenize = firstSub;
          return "slimSubmode";
        }

        function doctypeLine(stream, _state) {
          stream.skipToEnd();
          return "slimDoctype";
        }

        function startLine(stream, state) {
          var ch = stream.peek();
          if (ch == '<') {
            return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);
          }
          if (stream.match(/^[|']/)) {
            return startHtmlMode(stream, state, 1);
          }
          if (stream.match(/^\/(!|\[\w+])?/)) {
            return commentMode(stream, state);
          }
          if (stream.match(/^(-|==?[<>]?)/)) {
            state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));
            return "slimSwitch";
          }
          if (stream.match(/^doctype\b/)) {
            state.tokenize = doctypeLine;
            return "keyword";
          }

          var m = stream.match(embeddedRegexp);
          if (m) {
            return startSubMode(m[1], state);
          }

          return slimTag(stream, state);
        }

        function slim(stream, state) {
          if (state.startOfLine) {
            return startLine(stream, state);
          }
          return slimTag(stream, state);
        }

        function slimTag(stream, state) {
          if (stream.eat('*')) {
            state.tokenize = startRubySplat(slimTagExtras);
            return null;
          }
          if (stream.match(nameRegexp)) {
            state.tokenize = slimTagExtras;
            return "slimTag";
          }
          return slimClass(stream, state);
        }
        function slimTagExtras(stream, state) {
          if (stream.match(/^(<>?|><?)/)) {
            state.tokenize = slimClass;
            return null;
          }
          return slimClass(stream, state);
        }
        function slimClass(stream, state) {
          if (stream.match(classIdRegexp)) {
            state.tokenize = slimClass;
            return "slimId";
          }
          if (stream.match(classNameRegexp)) {
            state.tokenize = slimClass;
            return "slimClass";
          }
          return slimAttribute(stream, state);
        }
        function slimAttribute(stream, state) {
          if (stream.match(/^([\[\{\(])/)) {
            return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);
          }
          if (stream.match(attributeNameRegexp)) {
            state.tokenize = slimAttributeAssign;
            return "slimAttribute";
          }
          if (stream.peek() == '*') {
            stream.next();
            state.tokenize = startRubySplat(slimContent);
            return null;
          }
          return slimContent(stream, state);
        }
        function slimAttributeAssign(stream, state) {
          if (stream.match(/^==?/)) {
            state.tokenize = slimAttributeValue;
            return null;
          }
          // should never happen, because of forward lookup
          return slimAttribute(stream, state);
        }

        function slimAttributeValue(stream, state) {
          var ch = stream.peek();
          if (ch == '"' || ch == "\'") {
            state.tokenize = readQuoted(ch, "string", true, false, slimAttribute);
            stream.next();
            return state.tokenize(stream, state);
          }
          if (ch == '[') {
            return startRubySplat(slimAttribute)(stream, state);
          }
          if (ch == ':') {
            return startRubySplat(slimAttributeSymbols)(stream, state);
          }
          if (stream.match(/^(true|false|nil)\b/)) {
            state.tokenize = slimAttribute;
            return "keyword";
          }
          return startRubySplat(slimAttribute)(stream, state);
        }
        function slimAttributeSymbols(stream, state) {
          stream.backUp(1);
          if (stream.match(/^[^\s],(?=:)/)) {
            state.tokenize = startRubySplat(slimAttributeSymbols);
            return null;
          }
          stream.next();
          return slimAttribute(stream, state);
        }
        function readQuoted(quote, style, embed, unescaped, nextTokenize) {
          return function(stream, state) {
            finishContinue(state);
            var fresh = stream.current().length == 0;
            if (stream.match(/^\\$/, fresh)) {
              if (!fresh) return style;
              continueLine(state, state.indented);
              return "lineContinuation";
            }
            if (stream.match(/^#\{/, fresh)) {
              if (!fresh) return style;
              state.tokenize = rubyInQuote("}", state.tokenize);
              return null;
            }
            var escaped = false, ch;
            while ((ch = stream.next()) != null) {
              if (ch == quote && (unescaped || !escaped)) {
                state.tokenize = nextTokenize;
                break;
              }
              if (embed && ch == "#" && !escaped) {
                if (stream.eat("{")) {
                  stream.backUp(2);
                  break;
                }
              }
              escaped = !escaped && ch == "\\";
            }
            if (stream.eol() && escaped) {
              stream.backUp(1);
            }
            return style;
          };
        }
        function slimContent(stream, state) {
          if (stream.match(/^==?/)) {
            state.tokenize = ruby;
            return "slimSwitch";
          }
          if (stream.match(/^\/$/)) { // tag close hint
            state.tokenize = slim;
            return null;
          }
          if (stream.match(/^:/)) { // inline tag
            state.tokenize = slimTag;
            return "slimSwitch";
          }
          startHtmlMode(stream, state, 0);
          return state.tokenize(stream, state);
        }

        var mode = {
          // default to html mode
          startState: function() {
            var htmlState = CodeMirror.startState(htmlMode);
            var rubyState = CodeMirror.startState(rubyMode);
            return {
              htmlState: htmlState,
              rubyState: rubyState,
              stack: null,
              last: null,
              tokenize: slim,
              line: slim,
              indented: 0
            };
          },

          copyState: function(state) {
            return {
              htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
              rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
              subMode: state.subMode,
              subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),
              stack: state.stack,
              last: state.last,
              tokenize: state.tokenize,
              line: state.line
            };
          },

          token: function(stream, state) {
            if (stream.sol()) {
              state.indented = stream.indentation();
              state.startOfLine = true;
              state.tokenize = state.line;
              while (state.stack && state.stack.indented > state.indented && state.last != "slimSubmode") {
                state.line = state.tokenize = state.stack.tokenize;
                state.stack = state.stack.parent;
                state.subMode = null;
                state.subState = null;
              }
            }
            if (stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            state.startOfLine = false;
            if (style) state.last = style;
            return styleMap.hasOwnProperty(style) ? styleMap[style] : style;
          },

          blankLine: function(state) {
            if (state.subMode && state.subMode.blankLine) {
              return state.subMode.blankLine(state.subState);
            }
          },

          innerMode: function(state) {
            if (state.subMode) return {state: state.subState, mode: state.subMode};
            return {state: state, mode: mode};
          }

          //indent: function(state) {
          //  return state.indented;
          //}
        };
        return mode;
      }, "htmlmixed", "ruby");

      CodeMirror.defineMIME("text/x-slim", "slim");
      CodeMirror.defineMIME("application/x-slim", "slim");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-smalltalk-smalltalk.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode('smalltalk', function(config) {

      var specialChars = /[+\-\/\\*~<>=@%|&?!.,:;^]/;
      var keywords = /true|false|nil|self|super|thisContext/;

      var Context = function(tokenizer, parent) {
        this.next = tokenizer;
        this.parent = parent;
      };

      var Token = function(name, context, eos) {
        this.name = name;
        this.context = context;
        this.eos = eos;
      };

      var State = function() {
        this.context = new Context(next, null);
        this.expectVariable = true;
        this.indentation = 0;
        this.userIndentationDelta = 0;
      };

      State.prototype.userIndent = function(indentation) {
        this.userIndentationDelta = indentation > 0 ? (indentation / config.indentUnit - this.indentation) : 0;
      };

      var next = function(stream, context, state) {
        var token = new Token(null, context, false);
        var aChar = stream.next();

        if (aChar === '"') {
          token = nextComment(stream, new Context(nextComment, context));

        } else if (aChar === '\'') {
          token = nextString(stream, new Context(nextString, context));

        } else if (aChar === '#') {
          if (stream.peek() === '\'') {
            stream.next();
            token = nextSymbol(stream, new Context(nextSymbol, context));
          } else {
            if (stream.eatWhile(/[^\s.{}\[\]()]/))
              token.name = 'string-2';
            else
              token.name = 'meta';
          }

        } else if (aChar === '$') {
          if (stream.next() === '<') {
            stream.eatWhile(/[^\s>]/);
            stream.next();
          }
          token.name = 'string-2';

        } else if (aChar === '|' && state.expectVariable) {
          token.context = new Context(nextTemporaries, context);

        } else if (/[\[\]{}()]/.test(aChar)) {
          token.name = 'bracket';
          token.eos = /[\[{(]/.test(aChar);

          if (aChar === '[') {
            state.indentation++;
          } else if (aChar === ']') {
            state.indentation = Math.max(0, state.indentation - 1);
          }

        } else if (specialChars.test(aChar)) {
          stream.eatWhile(specialChars);
          token.name = 'operator';
          token.eos = aChar !== ';'; // ; cascaded message expression

        } else if (/\d/.test(aChar)) {
          stream.eatWhile(/[\w\d]/);
          token.name = 'number';

        } else if (/[\w_]/.test(aChar)) {
          stream.eatWhile(/[\w\d_]/);
          token.name = state.expectVariable ? (keywords.test(stream.current()) ? 'keyword' : 'variable') : null;

        } else {
          token.eos = state.expectVariable;
        }

        return token;
      };

      var nextComment = function(stream, context) {
        stream.eatWhile(/[^"]/);
        return new Token('comment', stream.eat('"') ? context.parent : context, true);
      };

      var nextString = function(stream, context) {
        stream.eatWhile(/[^']/);
        return new Token('string', stream.eat('\'') ? context.parent : context, false);
      };

      var nextSymbol = function(stream, context) {
        stream.eatWhile(/[^']/);
        return new Token('string-2', stream.eat('\'') ? context.parent : context, false);
      };

      var nextTemporaries = function(stream, context) {
        var token = new Token(null, context, false);
        var aChar = stream.next();

        if (aChar === '|') {
          token.context = context.parent;
          token.eos = true;

        } else {
          stream.eatWhile(/[^|]/);
          token.name = 'variable';
        }

        return token;
      };

      return {
        startState: function() {
          return new State;
        },

        token: function(stream, state) {
          state.userIndent(stream.indentation());

          if (stream.eatSpace()) {
            return null;
          }

          var token = state.context.next(stream, state.context, state);
          state.context = token.context;
          state.expectVariable = token.eos;

          return token.name;
        },

        blankLine: function(state) {
          state.userIndent(0);
        },

        indent: function(state, textAfter) {
          var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;
          return (state.indentation + i) * config.indentUnit;
        },

        electricChars: ']'
      };

    });

    CodeMirror.defineMIME('text/x-stsrc', {name: 'smalltalk'});

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-sql-sql.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("sql", function(config, parserConfig) {
      var client         = parserConfig.client || {},
          atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},
          builtin        = parserConfig.builtin || set(defaultBuiltin),
          keywords       = parserConfig.keywords || set(sqlKeywords),
          operatorChars  = parserConfig.operatorChars || /^[*+\-%<>!=&|~^\/]/,
          support        = parserConfig.support || {},
          hooks          = parserConfig.hooks || {},
          dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true},
          backslashStringEscapes = parserConfig.backslashStringEscapes !== false,
          brackets       = parserConfig.brackets || /^[\{}\(\)\[\]]/,
          punctuation    = parserConfig.punctuation || /^[;.,:]/

      function tokenBase(stream, state) {
        var ch = stream.next();

        // call hooks from the mime type
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }

        if (support.hexNumber &&
          ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))
          || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
          // hex
          // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html
          return "number";
        } else if (support.binaryNumber &&
          (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))
          || (ch == "0" && stream.match(/^b[01]+/)))) {
          // bitstring
          // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html
          return "number";
        } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
          // numbers
          // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html
          stream.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/);
          support.decimallessFloat && stream.match(/^\.(?!\.)/);
          return "number";
        } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
          // placeholders
          return "variable-3";
        } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {
          // strings
          // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
          state.tokenize = tokenLiteral(ch);
          return state.tokenize(stream, state);
        } else if ((((support.nCharCast && (ch == "n" || ch == "N"))
            || (support.charsetCast && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))
            && (stream.peek() == "'" || stream.peek() == '"'))) {
          // charset casting: _utf8'str', N'str', n'str'
          // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
          return "keyword";
        } else if (support.escapeConstant && (ch == "e" || ch == "E")
            && (stream.peek() == "'" || (stream.peek() == '"' && support.doubleQuote))) {
          // escape constant: E'str', e'str'
          // ref: https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-ESCAPE
          state.tokenize = function(stream, state) {
            return (state.tokenize = tokenLiteral(stream.next(), true))(stream, state);
          }
          return "keyword";
        } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
          // 1-line comment
          stream.skipToEnd();
          return "comment";
        } else if ((support.commentHash && ch == "#")
            || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {
          // 1-line comments
          // ref: https://kb.askmonty.org/en/comment-syntax/
          stream.skipToEnd();
          return "comment";
        } else if (ch == "/" && stream.eat("*")) {
          // multi-line comments
          // ref: https://kb.askmonty.org/en/comment-syntax/
          state.tokenize = tokenComment(1);
          return state.tokenize(stream, state);
        } else if (ch == ".") {
          // .1 for 0.1
          if (support.zerolessFloat && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i))
            return "number";
          if (stream.match(/^\.+/))
            return null
          // .table_name (ODBC)
          // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
          if (support.ODBCdotTable && stream.match(/^[\w\d_$#]+/))
            return "variable-2";
        } else if (operatorChars.test(ch)) {
          // operators
          stream.eatWhile(operatorChars);
          return "operator";
        } else if (brackets.test(ch)) {
          // brackets
          return "bracket";
        } else if (punctuation.test(ch)) {
          // punctuation
          stream.eatWhile(punctuation);
          return "punctuation";
        } else if (ch == '{' &&
            (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
          // dates (weird ODBC syntax)
          // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
          return "number";
        } else {
          stream.eatWhile(/^[_\w\d]/);
          var word = stream.current().toLowerCase();
          // dates (standard SQL syntax)
          // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
          if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))
            return "number";
          if (atoms.hasOwnProperty(word)) return "atom";
          if (builtin.hasOwnProperty(word)) return "builtin";
          if (keywords.hasOwnProperty(word)) return "keyword";
          if (client.hasOwnProperty(word)) return "string-2";
          return null;
        }
      }

      // 'string', with char specified in quote escaped by '\'
      function tokenLiteral(quote, backslashEscapes) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = (backslashStringEscapes || backslashEscapes) && !escaped && ch == "\\";
          }
          return "string";
        };
      }
      function tokenComment(depth) {
        return function(stream, state) {
          var m = stream.match(/^.*?(\/\*|\*\/)/)
          if (!m) stream.skipToEnd()
          else if (m[1] == "/*") state.tokenize = tokenComment(depth + 1)
          else if (depth > 1) state.tokenize = tokenComment(depth - 1)
          else state.tokenize = tokenBase
          return "comment"
        }
      }

      function pushContext(stream, state, type) {
        state.context = {
          prev: state.context,
          indent: stream.indentation(),
          col: stream.column(),
          type: type
        };
      }

      function popContext(state) {
        state.indent = state.context.indent;
        state.context = state.context.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase, context: null};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (state.context && state.context.align == null)
              state.context.align = false;
          }
          if (state.tokenize == tokenBase && stream.eatSpace()) return null;

          var style = state.tokenize(stream, state);
          if (style == "comment") return style;

          if (state.context && state.context.align == null)
            state.context.align = true;

          var tok = stream.current();
          if (tok == "(")
            pushContext(stream, state, ")");
          else if (tok == "[")
            pushContext(stream, state, "]");
          else if (state.context && state.context.type == tok)
            popContext(state);
          return style;
        },

        indent: function(state, textAfter) {
          var cx = state.context;
          if (!cx) return CodeMirror.Pass;
          var closing = textAfter.charAt(0) == cx.type;
          if (cx.align) return cx.col + (closing ? 0 : 1);
          else return cx.indent + (closing ? 0 : config.indentUnit);
        },

        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : "--",
        closeBrackets: "()[]{}''\"\"``"
      };
    });

      // `identifier`
      function hookIdentifier(stream) {
        // MySQL/MariaDB identifiers
        // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch == "`" && !stream.eat("`")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
      }

      // "identifier"
      function hookIdentifierDoublequote(stream) {
        // Standard SQL /SQLite identifiers
        // ref: http://web.archive.org/web/20160813185132/http://savage.net.au/SQL/sql-99.bnf.html#delimited%20identifier
        // ref: http://sqlite.org/lang_keywords.html
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch == "\"" && !stream.eat("\"")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
      }

      // variable token
      function hookVar(stream) {
        // variables
        // @@prefix.varName @varName
        // varName can be quoted with ` or ' or "
        // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html
        if (stream.eat("@")) {
          stream.match('session.');
          stream.match('local.');
          stream.match('global.');
        }

        if (stream.eat("'")) {
          stream.match(/^.*'/);
          return "variable-2";
        } else if (stream.eat('"')) {
          stream.match(/^.*"/);
          return "variable-2";
        } else if (stream.eat("`")) {
          stream.match(/^.*`/);
          return "variable-2";
        } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
          return "variable-2";
        }
        return null;
      };

      // short client keyword token
      function hookClient(stream) {
        // \N means NULL
        // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html
        if (stream.eat("N")) {
            return "atom";
        }
        // \g, etc
        // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html
        return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
      }

      // these keywords are used by all SQL dialects (however, a mode can still overwrite it)
      var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";

      // turn a space-separated list into an array
      function set(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var defaultBuiltin = "bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"

      // A generic SQL Mode. It's not a standard, it just try to support what is generally supported
      CodeMirror.defineMIME("text/x-sql", {
        name: "sql",
        keywords: set(sqlKeywords + "begin"),
        builtin: set(defaultBuiltin),
        atoms: set("false true null unknown"),
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
      });

      CodeMirror.defineMIME("text/x-mssql", {
        name: "sql",
        client: set("$partition binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id"),
        keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx updlock with"),
        builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),
        atoms: set("is not null like and or in left right between inner outer join all any some cross unpivot pivot exists"),
        operatorChars: /^[*+\-%<>!=^\&|\/]/,
        brackets: /^[\{}\(\)]/,
        punctuation: /^[;.,:/]/,
        backslashStringEscapes: false,
        dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),
        hooks: {
          "@":   hookVar
        }
      });

      CodeMirror.defineMIME("text/x-mysql", {
        name: "sql",
        client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group group_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
          "@":   hookVar,
          "`":   hookIdentifier,
          "\\":  hookClient
        }
      });

      CodeMirror.defineMIME("text/x-mariadb", {
        name: "sql",
        client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
          "@":   hookVar,
          "`":   hookIdentifier,
          "\\":  hookClient
        }
      });

      // provided by the phpLiteAdmin project - phpliteadmin.org
      CodeMirror.defineMIME("text/x-sqlite", {
        name: "sql",
        // commands of the official SQLite client, ref: https://www.sqlite.org/cli.html#dotcmd
        client: set("auth backup bail binary changes check clone databases dbinfo dump echo eqp exit explain fullschema headers help import imposter indexes iotrace limit lint load log mode nullvalue once open output print prompt quit read restore save scanstats schema separator session shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width"),
        // ref: http://sqlite.org/lang_keywords.html
        keywords: set(sqlKeywords + "abort action add after all analyze attach autoincrement before begin cascade case cast check collate column commit conflict constraint cross current_date current_time current_timestamp database default deferrable deferred detach each else end escape except exclusive exists explain fail for foreign full glob if ignore immediate index indexed initially inner instead intersect isnull key left limit match natural no notnull null of offset outer plan pragma primary query raise recursive references regexp reindex release rename replace restrict right rollback row savepoint temp temporary then to transaction trigger unique using vacuum view virtual when with without"),
        // SQLite is weakly typed, ref: http://sqlite.org/datatype3.html. This is just a list of some common types.
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text clob bigint int int2 int8 integer float double char varchar date datetime year unsigned signed numeric real"),
        // ref: http://sqlite.org/syntax/literal-value.html
        atoms: set("null current_date current_time current_timestamp"),
        // ref: http://sqlite.org/lang_expr.html#binaryops
        operatorChars: /^[*+\-%<>!=&|/~]/,
        // SQLite is weakly typed, ref: http://sqlite.org/datatype3.html. This is just a list of some common types.
        dateSQL: set("date time timestamp datetime"),
        support: set("decimallessFloat zerolessFloat"),
        identifierQuote: "\"",  //ref: http://sqlite.org/lang_keywords.html
        hooks: {
          // bind-parameters ref:http://sqlite.org/lang_expr.html#varparam
          "@":   hookVar,
          ":":   hookVar,
          "?":   hookVar,
          "$":   hookVar,
          // The preferred way to escape Identifiers is using double quotes, ref: http://sqlite.org/lang_keywords.html
          "\"":   hookIdentifierDoublequote,
          // there is also support for backticks, ref: http://sqlite.org/lang_keywords.html
          "`":   hookIdentifier
        }
      });

      // the query language used by Apache Cassandra is called CQL, but this mime type
      // is called Cassandra to avoid confusion with Contextual Query Language
      CodeMirror.defineMIME("text/x-cassandra", {
        name: "sql",
        client: { },
        keywords: set("add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime"),
        builtin: set("ascii bigint blob boolean counter decimal double float frozen inet int list map static text timestamp timeuuid tuple uuid varchar varint"),
        atoms: set("false true infinity NaN"),
        operatorChars: /^[<>=]/,
        dateSQL: { },
        support: set("commentSlashSlash decimallessFloat"),
        hooks: { }
      });

      // this is based on Peter Raganitsch's 'plsql' mode
      CodeMirror.defineMIME("text/x-plsql", {
        name:       "sql",
        client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
        keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
        builtin:    set("abs acos add_months ascii asin atan atan2 average bfile bfilename bigserial bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least length lengthb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim serial sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid unlogged upper user userenv varchar varchar2 variance varying vsize xml"),
        operatorChars: /^[*\/+\-%<>!=~]/,
        dateSQL:    set("date time timestamp"),
        support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
      });

      // Created to support specific hive keywords
      CodeMirror.defineMIME("text/x-hive", {
        name: "sql",
        keywords: set("select alter $elem$ $key$ $value$ add after all analyze and archive as asc before between binary both bucket buckets by cascade case cast change cluster clustered clusterstatus collection column columns comment compute concatenate continue create cross cursor data database databases dbproperties deferred delete delimited desc describe directory disable distinct distribute drop else enable end escaped exclusive exists explain export extended external fetch fields fileformat first format formatted from full function functions grant group having hold_ddltime idxproperties if import in index indexes inpath inputdriver inputformat insert intersect into is items join keys lateral left like limit lines load local location lock locks mapjoin materialized minus msck no_drop nocompress not of offline on option or order out outer outputdriver outputformat overwrite partition partitioned partitions percent plus preserve procedure purge range rcfile read readonly reads rebuild recordreader recordwriter recover reduce regexp rename repair replace restrict revoke right rlike row schema schemas semi sequencefile serde serdeproperties set shared show show_database sort sorted ssl statistics stored streamtable table tables tablesample tblproperties temporary terminated textfile then tmp to touch transform trigger unarchive undo union uniquejoin unlock update use using utc utc_tmestamp view when where while with admin authorization char compact compactions conf cube current current_date current_timestamp day decimal defined dependency directories elem_type exchange file following for grouping hour ignore inner interval jar less logical macro minute month more none noscan over owner partialscan preceding pretty principals protection reload rewrite role roles rollup rows second server sets skewed transactions truncate unbounded unset uri user values window year"),
        builtin: set("bool boolean long timestamp tinyint smallint bigint int float double date datetime unsigned string array struct map uniontype key_type utctimestamp value_type varchar"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=]/,
        dateSQL: set("date timestamp"),
        support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
      });

      CodeMirror.defineMIME("text/x-pgsql", {
        name: "sql",
        client: set("source"),
        // For PostgreSQL - https://www.postgresql.org/docs/11/sql-keywords-appendix.html
        // For pl/pgsql lang - https://github.com/postgres/postgres/blob/REL_11_2/src/pl/plpgsql/src/pl_scanner.c
        keywords: set(sqlKeywords + "a abort abs absent absolute access according action ada add admin after aggregate alias all allocate also alter always analyse analyze and any are array array_agg array_max_cardinality as asc asensitive assert assertion assignment asymmetric at atomic attach attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli between bigint binary bit bit_length blob blocked bom boolean both breadth by c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain char char_length character character_length character_set_catalog character_set_name character_set_schema characteristics characters check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column column_name columns command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constant constraint constraint_catalog constraint_name constraint_schema constraints constructor contains content continue control conversion convert copy corr corresponding cost count covar_pop covar_samp create cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datatype date datetime_interval_code datetime_interval_precision day db deallocate debug dec decimal declare default defaults deferrable deferred defined definer degree delete delimiter delimiters dense_rank depends depth deref derived desc describe descriptor detach detail deterministic diagnostics dictionary disable discard disconnect dispatch distinct dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain double drop dump dynamic dynamic_function dynamic_function_code each element else elseif elsif empty enable encoding encrypted end end_frame end_partition endexec enforced enum equals errcode error escape event every except exception exclude excluding exclusive exec execute exists exit exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreach foreign fortran forward found frame_row free freeze from fs full function functions fusion g general generated get global go goto grant granted greatest group grouping groups handler having header hex hierarchy hint hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import in include including increment indent index indexes indicator info inherit inherits initially inline inner inout input insensitive insert instance instantiable instead int integer integrity intersect intersection interval into invoker is isnull isolation join k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like like_regex limit link listen ln load local localtime localtimestamp location locator lock locked log logged loop lower m map mapping match matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized not nothing notice notify notnull nowait nth_value ntile null nullable nullif nulls number numeric object occurrences_regex octet_length octets of off offset oids old on only open operator option options or order ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parallel parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password path percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding precision prepare prepared preserve primary print_strict_params prior privileges procedural procedure procedures program public publication query quote raise range rank read reads real reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result result_oid return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns reverse revoke right role rollback rollup routine routine_catalog routine_name routine_schema routines row row_count row_number rows rowtype rule savepoint scale schema schema_name schemas scope scope_catalog scope_name scope_schema scroll search second section security select selective self sensitive sequence sequences serializable server server_name session session_user set setof sets share show similar simple size skip slice smallint snapshot some source space specific specific_name specifictype sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable stacked standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time system_user t table table_name tables tablesample tablespace temp template temporary text then ties time timestamp timezone_hour timezone_minute to token top_level_count trailing transaction transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted union unique unknown unlink unlisten unlogged unnamed unnest until untyped update upper uri usage use_column use_variable user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of values var_pop var_samp varbinary varchar variable_conflict variadic varying verbose version versioning view views volatile warning when whenever where while whitespace width_bucket window with within without work wrapper write xml xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes zone"),
        // https://www.postgresql.org/docs/11/datatype.html
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*\/+\-%<>!=&|^\/#@?~]/,
        backslashStringEscapes: false,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast escapeConstant")
      });

      // Google's SQL-like query language, GQL
      CodeMirror.defineMIME("text/x-gql", {
        name: "sql",
        keywords: set("ancestor and asc by contains desc descendant distinct from group has in is limit offset on order select superset where"),
        atoms: set("false true"),
        builtin: set("blob datetime first key __key__ string integer double boolean null"),
        operatorChars: /^[*+\-%<>!=]/
      });

      // Greenplum
      CodeMirror.defineMIME("text/x-gpsql", {
        name: "sql",
        client: set("source"),
        //https://github.com/greenplum-db/gpdb/blob/master/src/include/parser/kwlist.h
        keywords: set("abort absolute access action active add admin after aggregate all also alter always analyse analyze and any array as asc assertion assignment asymmetric at authorization backward before begin between bigint binary bit boolean both by cache called cascade cascaded case cast chain char character characteristics check checkpoint class close cluster coalesce codegen collate column comment commit committed concurrency concurrently configuration connection constraint constraints contains content continue conversion copy cost cpu_rate_limit create createdb createexttable createrole createuser cross csv cube current current_catalog current_date current_role current_schema current_time current_timestamp current_user cursor cycle data database day deallocate dec decimal declare decode default defaults deferrable deferred definer delete delimiter delimiters deny desc dictionary disable discard distinct distributed do document domain double drop dxl each else enable encoding encrypted end enum errors escape every except exchange exclude excluding exclusive execute exists explain extension external extract false family fetch fields filespace fill filter first float following for force foreign format forward freeze from full function global grant granted greatest group group_id grouping handler hash having header hold host hour identity if ignore ilike immediate immutable implicit in including inclusive increment index indexes inherit inherits initially inline inner inout input insensitive insert instead int integer intersect interval into invoker is isnull isolation join key language large last leading least left level like limit list listen load local localtime localtimestamp location lock log login mapping master match maxvalue median merge minute minvalue missing mode modifies modify month move name names national natural nchar new newline next no nocreatedb nocreateexttable nocreaterole nocreateuser noinherit nologin none noovercommit nosuperuser not nothing notify notnull nowait null nullif nulls numeric object of off offset oids old on only operator option options or order ordered others out outer over overcommit overlaps overlay owned owner parser partial partition partitions passing password percent percentile_cont percentile_disc placing plans position preceding precision prepare prepared preserve primary prior privileges procedural procedure protocol queue quote randomly range read readable reads real reassign recheck recursive ref references reindex reject relative release rename repeatable replace replica reset resource restart restrict returning returns revoke right role rollback rollup rootpartition row rows rule savepoint scatter schema scroll search second security segment select sequence serializable session session_user set setof sets share show similar simple smallint some split sql stable standalone start statement statistics stdin stdout storage strict strip subpartition subpartitions substring superuser symmetric sysid system table tablespace temp template temporary text then threshold ties time timestamp to trailing transaction treat trigger trim true truncate trusted type unbounded uncommitted unencrypted union unique unknown unlisten until update user using vacuum valid validation validator value values varchar variadic varying verbose version view volatile web when where whitespace window with within without work writable write xml xmlattributes xmlconcat xmlelement xmlexists xmlforest xmlparse xmlpi xmlroot xmlserialize year yes zone"),
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
      });

      // Spark SQL
      CodeMirror.defineMIME("text/x-sparksql", {
        name: "sql",
        keywords: set("add after all alter analyze and anti archive array as asc at between bucket buckets by cache cascade case cast change clear cluster clustered codegen collection column columns comment commit compact compactions compute concatenate cost create cross cube current current_date current_timestamp database databases data dbproperties defined delete delimited deny desc describe dfs directories distinct distribute drop else end escaped except exchange exists explain export extended external false fields fileformat first following for format formatted from full function functions global grant group grouping having if ignore import in index indexes inner inpath inputformat insert intersect interval into is items join keys last lateral lazy left like limit lines list load local location lock locks logical macro map minus msck natural no not null nulls of on optimize option options or order out outer outputformat over overwrite partition partitioned partitions percent preceding principals purge range recordreader recordwriter recover reduce refresh regexp rename repair replace reset restrict revoke right rlike role roles rollback rollup row rows schema schemas select semi separated serde serdeproperties set sets show skewed sort sorted start statistics stored stratify struct table tables tablesample tblproperties temp temporary terminated then to touch transaction transactions transform true truncate unarchive unbounded uncache union unlock unset use using values view when where window with"),
        builtin: set("tinyint smallint int bigint boolean float double string binary timestamp decimal array map struct uniontype delimited serde sequencefile textfile rcfile inputformat outputformat"),
        atoms: set("false true null"),
        operatorChars: /^[*\/+\-%<>!=~&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable doubleQuote zerolessFloat")
      });

      // Esper
      CodeMirror.defineMIME("text/x-esper", {
        name: "sql",
        client: set("source"),
        // http://www.espertech.com/esper/release-5.5.0/esper-reference/html/appendix_keywords.html
        keywords: set("alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit after all and as at asc avedev avg between by case cast coalesce count create current_timestamp day days delete define desc distinct else end escape events every exists false first from full group having hour hours in inner insert instanceof into irstream is istream join last lastweekday left limit like max match_recognize matches median measures metadatasql min minute minutes msec millisecond milliseconds not null offset on or order outer output partition pattern prev prior regexp retain-union retain-intersection right rstream sec second seconds select set some snapshot sql stddev sum then true unidirectional until update variable weekday when where window"),
        builtin: {},
        atoms: set("false true null"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("time"),
        support: set("decimallessFloat zerolessFloat binaryNumber hexNumber")
      });
    });

    /*
      How Properties of Mime Types are used by SQL Mode
      =================================================

      keywords:
        A list of keywords you want to be highlighted.
      builtin:
        A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").
      operatorChars:
        All characters that must be handled as operators.
      client:
        Commands parsed and executed by the client (not the server).
      support:
        A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.
        * ODBCdotTable: .tableName
        * zerolessFloat: .1
        * doubleQuote
        * nCharCast: N'string'
        * charsetCast: _utf8'string'
        * commentHash: use # char for comments
        * commentSlashSlash: use // for comments
        * commentSpaceRequired: require a space after -- for comments
      atoms:
        Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:
        UNKNOWN, INFINITY, UNDERFLOW, NaN...
      dateSQL:
        Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.
    */
  uploads-admin-Public-Admin-plugins-codemirror-mode-turtle-turtle.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("turtle", function(config) {
      var indentUnit = config.indentUnit;
      var curPunc;

      function wordRegexp(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      }
      var ops = wordRegexp([]);
      var keywords = wordRegexp(["@prefix", "@base", "a"]);
      var operatorChars = /[*+\-<>=&|]/;

      function tokenBase(stream, state) {
        var ch = stream.next();
        curPunc = null;
        if (ch == "<" && !stream.match(/^[\s\u00a0=]/, false)) {
          stream.match(/^[^\s\u00a0>]*>?/);
          return "atom";
        }
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenLiteral(ch);
          return state.tokenize(stream, state);
        }
        else if (/[{}\(\),\.;\[\]]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        else if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        }
        else if (operatorChars.test(ch)) {
          stream.eatWhile(operatorChars);
          return null;
        }
        else if (ch == ":") {
              return "operator";
            } else {
          stream.eatWhile(/[_\w\d]/);
          if(stream.peek() == ":") {
            return "variable-3";
          } else {
                 var word = stream.current();

                 if(keywords.test(word)) {
                            return "meta";
                 }

                 if(ch >= "A" && ch <= "Z") {
                        return "comment";
                     } else {
                            return "keyword";
                     }
          }
          var word = stream.current();
          if (ops.test(word))
            return null;
          else if (keywords.test(word))
            return "meta";
          else
            return "variable";
        }
      }

      function tokenLiteral(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          return "string";
        };
      }

      function pushContext(state, type, col) {
        state.context = {prev: state.context, indent: state.indent, col: col, type: type};
      }
      function popContext(state) {
        state.indent = state.context.indent;
        state.context = state.context.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase,
                  context: null,
                  indent: 0,
                  col: 0};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (state.context && state.context.align == null) state.context.align = false;
            state.indent = stream.indentation();
          }
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);

          if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {
            state.context.align = true;
          }

          if (curPunc == "(") pushContext(state, ")", stream.column());
          else if (curPunc == "[") pushContext(state, "]", stream.column());
          else if (curPunc == "{") pushContext(state, "}", stream.column());
          else if (/[\]\}\)]/.test(curPunc)) {
            while (state.context && state.context.type == "pattern") popContext(state);
            if (state.context && curPunc == state.context.type) popContext(state);
          }
          else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);
          else if (/atom|string|variable/.test(style) && state.context) {
            if (/[\}\]]/.test(state.context.type))
              pushContext(state, "pattern", stream.column());
            else if (state.context.type == "pattern" && !state.context.align) {
              state.context.align = true;
              state.context.col = stream.column();
            }
          }

          return style;
        },

        indent: function(state, textAfter) {
          var firstChar = textAfter && textAfter.charAt(0);
          var context = state.context;
          if (/[\]\}]/.test(firstChar))
            while (context && context.type == "pattern") context = context.prev;

          var closing = context && firstChar == context.type;
          if (!context)
            return 0;
          else if (context.type == "pattern")
            return context.col;
          else if (context.align)
            return context.col + (closing ? 0 : 1);
          else
            return context.indent + (closing ? 0 : indentUnit);
        },

        lineComment: "#"
      };
    });

    CodeMirror.defineMIME("text/turtle", "turtle");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-twig-twig.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"),  require("../../addon/mode/multiplex"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../addon/mode/multiplex"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
      "use strict";

      CodeMirror.defineMode("twig:inner", function() {
        var keywords = ["and", "as", "autoescape", "endautoescape", "block", "do", "endblock", "else", "elseif", "extends", "for", "endfor", "embed", "endembed", "filter", "endfilter", "flush", "from", "if", "endif", "in", "is", "include", "import", "not", "or", "set", "spaceless", "endspaceless", "with", "endwith", "trans", "endtrans", "blocktrans", "endblocktrans", "macro", "endmacro", "use", "verbatim", "endverbatim"],
            operator = /^[+\-*&%=<>!?|~^]/,
            sign = /^[:\[\(\{]/,
            atom = ["true", "false", "null", "empty", "defined", "divisibleby", "divisible by", "even", "odd", "iterable", "sameas", "same as"],
            number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

        keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
        atom = new RegExp("((" + atom.join(")|(") + "))\\b");

        function tokenBase (stream, state) {
          var ch = stream.peek();

          //Comment
          if (state.incomment) {
            if (!stream.skipTo("#}")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\#|}/);
              state.incomment = false;
            }
            return "comment";
          //Tag
          } else if (state.intag) {
            //After operator
            if (state.operator) {
              state.operator = false;
              if (stream.match(atom)) {
                return "atom";
              }
              if (stream.match(number)) {
                return "number";
              }
            }
            //After sign
            if (state.sign) {
              state.sign = false;
              if (stream.match(atom)) {
                return "atom";
              }
              if (stream.match(number)) {
                return "number";
              }
            }

            if (state.instring) {
              if (ch == state.instring) {
                state.instring = false;
              }
              stream.next();
              return "string";
            } else if (ch == "'" || ch == '"') {
              state.instring = ch;
              stream.next();
              return "string";
            } else if (stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
              state.intag = false;
              return "tag";
            } else if (stream.match(operator)) {
              state.operator = true;
              return "operator";
            } else if (stream.match(sign)) {
              state.sign = true;
            } else {
              if (stream.eat(" ") || stream.sol()) {
                if (stream.match(keywords)) {
                  return "keyword";
                }
                if (stream.match(atom)) {
                  return "atom";
                }
                if (stream.match(number)) {
                  return "number";
                }
                if (stream.sol()) {
                  stream.next();
                }
              } else {
                stream.next();
              }

            }
            return "variable";
          } else if (stream.eat("{")) {
            if (stream.eat("#")) {
              state.incomment = true;
              if (!stream.skipTo("#}")) {
                stream.skipToEnd();
              } else {
                stream.eatWhile(/\#|}/);
                state.incomment = false;
              }
              return "comment";
            //Open tag
            } else if (ch = stream.eat(/\{|%/)) {
              //Cache close tag
              state.intag = ch;
              if (ch == "{") {
                state.intag = "}";
              }
              stream.eat("-");
              return "tag";
            }
          }
          stream.next();
        };

        return {
          startState: function () {
            return {};
          },
          token: function (stream, state) {
            return tokenBase(stream, state);
          }
        };
      });

      CodeMirror.defineMode("twig", function(config, parserConfig) {
        var twigInner = CodeMirror.getMode(config, "twig:inner");
        if (!parserConfig || !parserConfig.base) return twigInner;
        return CodeMirror.multiplexingMode(
          CodeMirror.getMode(config, parserConfig.base), {
            open: /\{[{#%]/, close: /[}#%]\}/, mode: twigInner, parseDelimiters: true
          }
        );
      });
      CodeMirror.defineMIME("text/x-twig", "twig");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-velocity-velocity.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode("velocity", function() {
        function parseWords(str) {
            var obj = {}, words = str.split(" ");
            for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
            return obj;
        }

        var keywords = parseWords("#end #else #break #stop #[[ #]] " +
                                  "#{end} #{else} #{break} #{stop}");
        var functions = parseWords("#if #elseif #foreach #set #include #parse #macro #define #evaluate " +
                                   "#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}");
        var specials = parseWords("$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent");
        var isOperatorChar = /[+\-*&%=<>!?:\/|]/;

        function chain(stream, state, f) {
            state.tokenize = f;
            return f(stream, state);
        }
        function tokenBase(stream, state) {
            var beforeParams = state.beforeParams;
            state.beforeParams = false;
            var ch = stream.next();
            // start of unparsed string?
            if ((ch == "'") && !state.inString && state.inParams) {
                state.lastTokenWasBuiltin = false;
                return chain(stream, state, tokenString(ch));
            }
            // start of parsed string?
            else if ((ch == '"')) {
                state.lastTokenWasBuiltin = false;
                if (state.inString) {
                    state.inString = false;
                    return "string";
                }
                else if (state.inParams)
                    return chain(stream, state, tokenString(ch));
            }
            // is it one of the special signs []{}().,;? Separator?
            else if (/[\[\]{}\(\),;\.]/.test(ch)) {
                if (ch == "(" && beforeParams)
                    state.inParams = true;
                else if (ch == ")") {
                    state.inParams = false;
                    state.lastTokenWasBuiltin = true;
                }
                return null;
            }
            // start of a number value?
            else if (/\d/.test(ch)) {
                state.lastTokenWasBuiltin = false;
                stream.eatWhile(/[\w\.]/);
                return "number";
            }
            // multi line comment?
            else if (ch == "#" && stream.eat("*")) {
                state.lastTokenWasBuiltin = false;
                return chain(stream, state, tokenComment);
            }
            // unparsed content?
            else if (ch == "#" && stream.match(/ *\[ *\[/)) {
                state.lastTokenWasBuiltin = false;
                return chain(stream, state, tokenUnparsed);
            }
            // single line comment?
            else if (ch == "#" && stream.eat("#")) {
                state.lastTokenWasBuiltin = false;
                stream.skipToEnd();
                return "comment";
            }
            // variable?
            else if (ch == "$") {
                stream.eat("!");
                stream.eatWhile(/[\w\d\$_\.{}-]/);
                // is it one of the specials?
                if (specials && specials.propertyIsEnumerable(stream.current())) {
                    return "keyword";
                }
                else {
                    state.lastTokenWasBuiltin = true;
                    state.beforeParams = true;
                    return "builtin";
                }
            }
            // is it a operator?
            else if (isOperatorChar.test(ch)) {
                state.lastTokenWasBuiltin = false;
                stream.eatWhile(isOperatorChar);
                return "operator";
            }
            else {
                // get the whole word
                stream.eatWhile(/[\w\$_{}@]/);
                var word = stream.current();
                // is it one of the listed keywords?
                if (keywords && keywords.propertyIsEnumerable(word))
                    return "keyword";
                // is it one of the listed functions?
                if (functions && functions.propertyIsEnumerable(word) ||
                        (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()=="(") &&
                         !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {
                    state.beforeParams = true;
                    state.lastTokenWasBuiltin = false;
                    return "keyword";
                }
                if (state.inString) {
                    state.lastTokenWasBuiltin = false;
                    return "string";
                }
                if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)=="." && state.lastTokenWasBuiltin)
                    return "builtin";
                // default: just a "word"
                state.lastTokenWasBuiltin = false;
                return null;
            }
        }

        function tokenString(quote) {
            return function(stream, state) {
                var escaped = false, next, end = false;
                while ((next = stream.next()) != null) {
                    if ((next == quote) && !escaped) {
                        end = true;
                        break;
                    }
                    if (quote=='"' && stream.peek() == '$' && !escaped) {
                        state.inString = true;
                        end = true;
                        break;
                    }
                    escaped = !escaped && next == "\\";
                }
                if (end) state.tokenize = tokenBase;
                return "string";
            };
        }

        function tokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
                if (ch == "#" && maybeEnd) {
                    state.tokenize = tokenBase;
                    break;
                }
                maybeEnd = (ch == "*");
            }
            return "comment";
        }

        function tokenUnparsed(stream, state) {
            var maybeEnd = 0, ch;
            while (ch = stream.next()) {
                if (ch == "#" && maybeEnd == 2) {
                    state.tokenize = tokenBase;
                    break;
                }
                if (ch == "]")
                    maybeEnd++;
                else if (ch != " ")
                    maybeEnd = 0;
            }
            return "meta";
        }
        // Interface

        return {
            startState: function() {
                return {
                    tokenize: tokenBase,
                    beforeParams: false,
                    inParams: false,
                    inString: false,
                    lastTokenWasBuiltin: false
                };
            },

            token: function(stream, state) {
                if (stream.eatSpace()) return null;
                return state.tokenize(stream, state);
            },
            blockCommentStart: "#*",
            blockCommentEnd: "*#",
            lineComment: "##",
            fold: "velocity"
        };
    });

    CodeMirror.defineMIME("text/velocity", "velocity");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-vue-vue.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function (mod) {
      "use strict";
      if (typeof exports === "object" && typeof module === "object") {// CommonJS
        mod(require("../../lib/codemirror"),
            require("../../addon/mode/overlay"),
            require("../xml/xml"),
            require("../javascript/javascript"),
            require("../coffeescript/coffeescript"),
            require("../css/css"),
            require("../sass/sass"),
            require("../stylus/stylus"),
            require("../pug/pug"),
            require("../handlebars/handlebars"));
      } else if (typeof define === "function" && define.amd) { // AMD
        define(["../../lib/codemirror",
                "../../addon/mode/overlay",
                "../xml/xml",
                "../javascript/javascript",
                "../coffeescript/coffeescript",
                "../css/css",
                "../sass/sass",
                "../stylus/stylus",
                "../pug/pug",
                "../handlebars/handlebars"], mod);
      } else { // Plain browser env
        mod(CodeMirror);
      }
    })(function (CodeMirror) {
      var tagLanguages = {
        script: [
          ["lang", /coffee(script)?/, "coffeescript"],
          ["type", /^(?:text|application)\/(?:x-)?coffee(?:script)?$/, "coffeescript"],
          ["lang", /^babel$/, "javascript"],
          ["type", /^text\/babel$/, "javascript"],
          ["type", /^text\/ecmascript-\d+$/, "javascript"]
        ],
        style: [
          ["lang", /^stylus$/i, "stylus"],
          ["lang", /^sass$/i, "sass"],
          ["lang", /^less$/i, "text/x-less"],
          ["lang", /^scss$/i, "text/x-scss"],
          ["type", /^(text\/)?(x-)?styl(us)?$/i, "stylus"],
          ["type", /^text\/sass/i, "sass"],
          ["type", /^(text\/)?(x-)?scss$/i, "text/x-scss"],
          ["type", /^(text\/)?(x-)?less$/i, "text/x-less"]
        ],
        template: [
          ["lang", /^vue-template$/i, "vue"],
          ["lang", /^pug$/i, "pug"],
          ["lang", /^handlebars$/i, "handlebars"],
          ["type", /^(text\/)?(x-)?pug$/i, "pug"],
          ["type", /^text\/x-handlebars-template$/i, "handlebars"],
          [null, null, "vue-template"]
        ]
      };

      CodeMirror.defineMode("vue-template", function (config, parserConfig) {
        var mustacheOverlay = {
          token: function (stream) {
            if (stream.match(/^\{\{.*?\}\}/)) return "meta mustache";
            while (stream.next() && !stream.match("{{", false)) {}
            return null;
          }
        };
        return CodeMirror.overlayMode(CodeMirror.getMode(config, parserConfig.backdrop || "text/html"), mustacheOverlay);
      });

      CodeMirror.defineMode("vue", function (config) {
        return CodeMirror.getMode(config, {name: "htmlmixed", tags: tagLanguages});
      }, "htmlmixed", "xml", "javascript", "coffeescript", "css", "sass", "stylus", "pug", "handlebars");

      CodeMirror.defineMIME("script/x-vue", "vue");
      CodeMirror.defineMIME("text/x-vue", "vue");
    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-wast-wast.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
        mod(require("../../lib/codemirror"), require("../../addon/mode/simple"));
      else if (typeof define == "function" && define.amd) // AMD
        define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
      else // Plain browser env
        mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    var kKeywords = [
        "align",
        "block",
        "br(_if|_table|_on_(cast|data|func|i31|null))?",
        "call(_indirect|_ref)?",
        "current_memory",
        "\\bdata\\b",
        "catch(_all)?",
        "delegate",
        "drop",
        "elem",
        "else",
        "end",
        "export",
        "\\bextern\\b",
        "\\bfunc\\b",
        "global(\\.(get|set))?",
        "if",
        "import",
        "local(\\.(get|set|tee))?",
        "loop",
        "module",
        "mut",
        "nop",
        "offset",
        "param",
        "result",
        "rethrow",
        "return(_call(_indirect|_ref)?)?",
        "select",
        "start",
        "table(\\.(size|get|set|size|grow|fill|init|copy))?",
        "then",
        "throw",
        "try",
        "type",
        "unreachable",
        "unwind",

        // Numeric opcodes.
        "i(32|64)\\.(store(8|16)|(load(8|16)_[su]))",
        "i64\\.(load32_[su]|store32)",
        "[fi](32|64)\\.(const|load|store)",
        "f(32|64)\\.(abs|add|ceil|copysign|div|eq|floor|[gl][et]|max|min|mul|nearest|neg?|sqrt|sub|trunc)",
        "i(32|64)\\.(a[dn]d|c[lt]z|(div|rem)_[su]|eqz?|[gl][te]_[su]|mul|ne|popcnt|rot[lr]|sh(l|r_[su])|sub|x?or)",
        "i64\\.extend_[su]_i32",
        "i32\\.wrap_i64",
        "i(32|64)\\.trunc_f(32|64)_[su]",
        "f(32|64)\\.convert_i(32|64)_[su]",
        "f64\\.promote_f32",
        "f32\\.demote_f64",
        "f32\\.reinterpret_i32",
        "i32\\.reinterpret_f32",
        "f64\\.reinterpret_i64",
        "i64\\.reinterpret_f64",
        // Atomics.
        "memory(\\.((atomic\\.(notify|wait(32|64)))|grow|size))?",
        "i64\.atomic\\.(load32_u|store32|rmw32\\.(a[dn]d|sub|x?or|(cmp)?xchg)_u)",
        "i(32|64)\\.atomic\\.(load((8|16)_u)?|store(8|16)?|rmw(\\.(a[dn]d|sub|x?or|(cmp)?xchg)|(8|16)\\.(a[dn]d|sub|x?or|(cmp)?xchg)_u))",
        // SIMD.
        "v128\\.load(8x8|16x4|32x2)_[su]",
        "v128\\.load(8|16|32|64)_splat",
        "v128\\.(load|store)(8|16|32|64)_lane",
        "v128\\.load(32|64)_zero",
        "v128\.(load|store|const|not|andnot|and|or|xor|bitselect|any_true)",
        "i(8x16|16x8)\\.(extract_lane_[su]|(add|sub)_sat_[su]|avgr_u)",
        "i(8x16|16x8|32x4|64x2)\\.(neg|add|sub|abs|shl|shr_[su]|all_true|bitmask|eq|ne|[lg][te]_s)",
        "(i(8x16|16x8|32x4|64x2)|f(32x4|64x2))\.(splat|replace_lane)",
        "i(8x16|16x8|32x4)\\.(([lg][te]_u)|((min|max)_[su]))",
        "f(32x4|64x2)\\.(neg|add|sub|abs|nearest|eq|ne|[lg][te]|sqrt|mul|div|min|max|ceil|floor|trunc)",
        "[fi](32x4|64x2)\\.extract_lane",
        "i8x16\\.(shuffle|swizzle|popcnt|narrow_i16x8_[su])",
        "i16x8\\.(narrow_i32x4_[su]|mul|extadd_pairwise_i8x16_[su]|q15mulr_sat_s)",
        "i16x8\\.(extend|extmul)_(low|high)_i8x16_[su]",
        "i32x4\\.(mul|dot_i16x8_s|trunc_sat_f64x2_[su]_zero)",
        "i32x4\\.((extend|extmul)_(low|high)_i16x8_|trunc_sat_f32x4_|extadd_pairwise_i16x8_)[su]",
        "i64x2\\.(mul|(extend|extmul)_(low|high)_i32x4_[su])",
        "f32x4\\.(convert_i32x4_[su]|demote_f64x2_zero)",
        "f64x2\\.(promote_low_f32x4|convert_low_i32x4_[su])",
        // Reference types, function references, and GC.
        "\\bany\\b",
        "array\\.len",
        "(array|struct)(\\.(new_(default_)?with_rtt|get(_[su])?|set))?",
        "\\beq\\b",
        "field",
        "i31\\.(new|get_[su])",
        "\\bnull\\b",
        "ref(\\.(([ai]s_(data|func|i31))|cast|eq|func|(is_|as_non_)?null|test))?",
        "rtt(\\.(canon|sub))?",
    ];

    CodeMirror.defineSimpleMode('wast', {
      start: [
        {regex: /[+\-]?(?:nan(?::0x[0-9a-fA-F]+)?|infinity|inf|0x[0-9a-fA-F]+\.?[0-9a-fA-F]*p[+\/-]?\d+|\d+(?:\.\d*)?[eE][+\-]?\d*|\d+\.\d*|0x[0-9a-fA-F]+|\d+)/, token: "number"},
        {regex: new RegExp(kKeywords.join('|')), token: "keyword"},
        {regex: /\b((any|data|eq|extern|i31|func)ref|[fi](32|64)|i(8|16))\b/, token: "atom"},
        {regex: /\$([a-zA-Z0-9_`\+\-\*\/\\\^~=<>!\?@#$%&|:\.]+)/, token: "variable-2"},
        {regex: /"(?:[^"\\\x00-\x1f\x7f]|\\[nt\\'"]|\\[0-9a-fA-F][0-9a-fA-F])*"/, token: "string"},
        {regex: /\(;.*?/, token: "comment", next: "comment"},
        {regex: /;;.*$/, token: "comment"},
        {regex: /\(/, indent: true},
        {regex: /\)/, dedent: true},
      ],

      comment: [
        {regex: /.*?;\)/, token: "comment", next: "start"},
        {regex: /.*/, token: "comment"},
      ],

      meta: {
        dontIndentStates: ['comment'],
      },
    });

    // https://github.com/WebAssembly/design/issues/981 mentions text/webassembly,
    // which seems like a reasonable choice, although it's not standard right now.
    CodeMirror.defineMIME("text/webassembly", "wast");

    });
  uploads-admin-Public-Admin-plugins-codemirror-mode-z80-z80.js: |
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    (function(mod) {
      if (typeof exports == "object" && typeof module == "object") // CommonJS
      mod(require("../../lib/codemirror"));
      else if (typeof define == "function" && define.amd) // AMD
      define(["../../lib/codemirror"], mod);
      else // Plain browser env
      mod(CodeMirror);
    })(function(CodeMirror) {
    "use strict";

    CodeMirror.defineMode('z80', function(_config, parserConfig) {
      var ez80 = parserConfig.ez80;
      var keywords1, keywords2;
      if (ez80) {
        keywords1 = /^(exx?|(ld|cp)([di]r?)?|[lp]ea|pop|push|ad[cd]|cpl|daa|dec|inc|neg|sbc|sub|and|bit|[cs]cf|x?or|res|set|r[lr]c?a?|r[lr]d|s[lr]a|srl|djnz|nop|[de]i|halt|im|in([di]mr?|ir?|irx|2r?)|ot(dmr?|[id]rx|imr?)|out(0?|[di]r?|[di]2r?)|tst(io)?|slp)(\.([sl]?i)?[sl])?\b/i;
        keywords2 = /^(((call|j[pr]|rst|ret[in]?)(\.([sl]?i)?[sl])?)|(rs|st)mix)\b/i;
      } else {
        keywords1 = /^(exx?|(ld|cp|in)([di]r?)?|pop|push|ad[cd]|cpl|daa|dec|inc|neg|sbc|sub|and|bit|[cs]cf|x?or|res|set|r[lr]c?a?|r[lr]d|s[lr]a|srl|djnz|nop|rst|[de]i|halt|im|ot[di]r|out[di]?)\b/i;
        keywords2 = /^(call|j[pr]|ret[in]?|b_?(call|jump))\b/i;
      }

      var variables1 = /^(af?|bc?|c|de?|e|hl?|l|i[xy]?|r|sp)\b/i;
      var variables2 = /^(n?[zc]|p[oe]?|m)\b/i;
      var errors = /^([hl][xy]|i[xy][hl]|slia|sll)\b/i;
      var numbers = /^([\da-f]+h|[0-7]+o|[01]+b|\d+d?)\b/i;

      return {
        startState: function() {
          return {
            context: 0
          };
        },
        token: function(stream, state) {
          if (!stream.column())
            state.context = 0;

          if (stream.eatSpace())
            return null;

          var w;

          if (stream.eatWhile(/\w/)) {
            if (ez80 && stream.eat('.')) {
              stream.eatWhile(/\w/);
            }
            w = stream.current();

            if (stream.indentation()) {
              if ((state.context == 1 || state.context == 4) && variables1.test(w)) {
                state.context = 4;
                return 'var2';
              }

              if (state.context == 2 && variables2.test(w)) {
                state.context = 4;
                return 'var3';
              }

              if (keywords1.test(w)) {
                state.context = 1;
                return 'keyword';
              } else if (keywords2.test(w)) {
                state.context = 2;
                return 'keyword';
              } else if (state.context == 4 && numbers.test(w)) {
                return 'number';
              }

              if (errors.test(w))
                return 'error';
            } else if (stream.match(numbers)) {
              return 'number';
            } else {
              return null;
            }
          } else if (stream.eat(';')) {
            stream.skipToEnd();
            return 'comment';
          } else if (stream.eat('"')) {
            while (w = stream.next()) {
              if (w == '"')
                break;

              if (w == '\\')
                stream.next();
            }
            return 'string';
          } else if (stream.eat('\'')) {
            if (stream.match(/\\?.'/))
              return 'number';
          } else if (stream.eat('.') || stream.sol() && stream.eat('#')) {
            state.context = 5;

            if (stream.eatWhile(/\w/))
              return 'def';
          } else if (stream.eat('$')) {
            if (stream.eatWhile(/[\da-f]/i))
              return 'number';
          } else if (stream.eat('%')) {
            if (stream.eatWhile(/[01]/))
              return 'number';
          } else {
            stream.next();
          }
          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-z80", "z80");
    CodeMirror.defineMIME("text/x-ez80", { name: "z80", ez80: true });

    });
  uploads-admin-Public-Admin-plugins-codemirror-theme-abbott.css: |
    /*
     * abbott.css
     * A warm, dark theme for prose and code, with pastels and pretty greens.
     *
     * Ported from abbott.vim (https://github.com/bcat/abbott.vim) version 2.1.
     * Original design and CodeMirror port by Jonathan Rascher.
     *
     * This theme shares the following color palette with the Vim color scheme.
     *
     * Brown shades:
     *   bistre: #231c14
     *   chocolate: #3c3022
     *   cocoa: #745d42
     *   vanilla_cream: #fef3b4
     *
     * Red shades:
     *   crimson: #d80450
     *   cinnabar: #f63f05
     *
     * Green shades:
     *   dark_olive: #273900
     *   forest_green: #24a507
     *   chartreuse: #a0ea00
     *   pastel_chartreuse: #d8ff84
     *
     * Yellow shades:
     *   marigold: #fbb32f
     *   lemon_meringue: #fbec5d
     *
     * Blue shades:
     *   cornflower_blue: #3f91f1
     *   periwinkle_blue: #8ccdf0
     *
     * Magenta shades:
     *   french_pink: #ec6c99
     *   lavender: #e6a2f3
     *
     * Cyan shades:
     *   zomp: #39a78d
     *   seafoam_green: #00ff7f
     */

    /* Style the UI: */

    /* Equivalent to Vim's Normal group. */
    .cm-s-abbott.CodeMirror {
      background: #231c14 /* bistre */;
      color: #d8ff84 /* pastel_chartreuse */;
    }

    /* Roughly equivalent to Vim's LineNr group. */
    .cm-s-abbott .CodeMirror-gutters {
      background: #231c14 /* bistre */;
      border: none;
    }
    .cm-s-abbott .CodeMirror-linenumber { color: #fbec5d /* lemon_meringue */; }

    .cm-s-abbott .CodeMirror-guttermarker { color: #f63f05 /* cinnabar */; }

    /* Roughly equivalent to Vim's FoldColumn group. */
    .cm-s-abbott .CodeMirror-guttermarker-subtle { color: #fbb32f /* marigold */; }

    /*
     * Roughly equivalent to Vim's CursorColumn group. (We use a brighter color
     * since Vim's cursorcolumn option highlights a whole column, whereas
     * CodeMirror's rule just highlights a thin line.)
     */
    .cm-s-abbott .CodeMirror-ruler { border-color: #745d42 /* cocoa */; }

    /* Equivalent to Vim's Cursor group in insert mode. */
    .cm-s-abbott .CodeMirror-cursor { border-color: #a0ea00 /* chartreuse */; }

    /* Equivalent to Vim's Cursor group in normal mode. */
    .cm-s-abbott.cm-fat-cursor .CodeMirror-cursor,
    .cm-s-abbott .cm-animate-fat-cursor {
      /*
       * CodeMirror doesn't allow changing the foreground color of the character
       * under the cursor, so we can't use a reverse video effect for the cursor.
       * Instead, make it semitransparent.
       */
      background: rgba(160, 234, 0, 0.5) /* chartreuse */;
    }
    .cm-s-abbott.cm-fat-cursor .CodeMirror-cursors {
      /*
       * Boost the z-index so the fat cursor shows up on top of text and
       * matchingbracket/matchingtag highlights.
       */
      z-index: 3;
    }

    /* Equivalent to Vim's Cursor group in replace mode. */
    .cm-s-abbott .CodeMirror-overwrite .CodeMirror-cursor {
      border-bottom: 1px solid #a0ea00 /* chartreuse */;
      border-left: none;
      width: auto;
    }

    /* Roughly equivalent to Vim's CursorIM group. */
    .cm-s-abbott .CodeMirror-secondarycursor {
      border-color: #00ff7f /* seafoam_green */;
    }

    /* Roughly equivalent to Vim's Visual group. */
    .cm-s-abbott .CodeMirror-selected,
    .cm-s-abbott.CodeMirror-focused .CodeMirror-selected {
      background: #273900 /* dark_olive */;
    }
    .cm-s-abbott .CodeMirror-line::selection,
    .cm-s-abbott .CodeMirror-line > span::selection,
    .cm-s-abbott .CodeMirror-line > span > span::selection {
      background: #273900 /* dark_olive */;
    }
    .cm-s-abbott .CodeMirror-line::-moz-selection,
    .cm-s-abbott .CodeMirror-line > span::-moz-selection,
    .cm-s-abbott .CodeMirror-line > span > span::-moz-selection {
      background: #273900 /* dark_olive */;
    }

    /* Roughly equivalent to Vim's SpecialKey group. */
    .cm-s-abbott .cm-tab { color: #00ff7f /* seafoam_green */; }

    /* Equivalent to Vim's Search group. */
    .cm-s-abbott .cm-searching {
      background: #fef3b4 /* vanilla_cream */ !important;
      color: #231c14 /* bistre */ !important;
    }

    /* Style syntax highlighting modes: */

    /* Equivalent to Vim's Comment group. */
    .cm-s-abbott span.cm-comment {
      color: #fbb32f /* marigold */;
      font-style: italic;
    }

    /* Equivalent to Vim's String group. */
    .cm-s-abbott span.cm-string,
    .cm-s-abbott span.cm-string-2 {
      color: #e6a2f3 /* lavender */;
    }

    /* Equivalent to Vim's Constant group. */
    .cm-s-abbott span.cm-number,
    .cm-s-abbott span.cm-string.cm-url { color: #f63f05 /* cinnabar */; }

    /* Roughly equivalent to Vim's SpecialKey group. */
    .cm-s-abbott span.cm-invalidchar { color: #00ff7f /* seafoam_green */; }

    /* Equivalent to Vim's Special group. */
    .cm-s-abbott span.cm-atom { color: #fef3b4 /* vanilla_cream */; }

    /* Equivalent to Vim's Delimiter group. */
    .cm-s-abbott span.cm-bracket,
    .cm-s-abbott span.cm-punctuation {
      color: #fef3b4 /* vanilla_cream */;
    }

    /* Equivalent Vim's Operator group. */
    .cm-s-abbott span.cm-operator { font-weight: bold; }

    /* Roughly equivalent to Vim's Identifier group. */
    .cm-s-abbott span.cm-def,
    .cm-s-abbott span.cm-variable,
    .cm-s-abbott span.cm-variable-2,
    .cm-s-abbott span.cm-variable-3 {
      color: #8ccdf0 /* periwinkle_blue */;
    }

    /* Roughly equivalent to Vim's Function group. */
    .cm-s-abbott span.cm-builtin,
    .cm-s-abbott span.cm-property,
    .cm-s-abbott span.cm-qualifier {
      color: #3f91f1 /* cornflower_blue */;
    }

    /* Equivalent to Vim's Type group. */
    .cm-s-abbott span.cm-type { color: #24a507 /* forest_green */; }

    /* Equivalent to Vim's Keyword group. */
    .cm-s-abbott span.cm-keyword {
      color: #d80450 /* crimson */;
      font-weight: bold;
    }

    /* Equivalent to Vim's PreProc group. */
    .cm-s-abbott span.cm-meta { color: #ec6c99 /* french_pink */; }

    /* Equivalent to Vim's htmlTagName group (linked to Statement). */
    .cm-s-abbott span.cm-tag {
      color: #d80450 /* crimson */;
      font-weight: bold;
    }

    /* Equivalent to Vim's htmlArg group (linked to Type). */
    .cm-s-abbott span.cm-attribute { color: #24a507 /* forest_green */; }

    /* Equivalent to Vim's htmlH1, markdownH1, etc. groups (linked to Title). */
    .cm-s-abbott span.cm-header {
      color: #d80450 /* crimson */;
      font-weight: bold;
    }

    /* Equivalent to Vim's markdownRule group (linked to PreProc). */
    .cm-s-abbott span.cm-hr { color: #ec6c99 /* french_pink */; }

    /* Roughly equivalent to Vim's Underlined group. */
    .cm-s-abbott span.cm-link { color: #e6a2f3 /* lavender */; }

    /* Equivalent to Vim's diffRemoved group. */
    .cm-s-abbott span.cm-negative {
      background: #d80450 /* crimson */;
      color: #231c14 /* bistre */;
    }

    /* Equivalent to Vim's diffAdded group. */
    .cm-s-abbott span.cm-positive {
      background: #a0ea00 /* chartreuse */;
      color: #231c14 /* bistre */;
      font-weight: bold;
    }

    /* Equivalent to Vim's Error group. */
    .cm-s-abbott span.cm-error {
      background: #d80450 /* crimson */;
      color: #231c14 /* bistre */;
    }

    /* Style addons: */

    /* Equivalent to Vim's MatchParen group. */
    .cm-s-abbott span.CodeMirror-matchingbracket {
      background: #745d42 /* cocoa */ !important;
      color: #231c14 /* bistre */ !important;
      font-weight: bold;
    }

    /*
     * Roughly equivalent to Vim's Error group. (Vim doesn't seem to have a direct
     * equivalent in its own matchparen plugin, but many syntax highlighting plugins
     * mark mismatched brackets as Error.)
     */
    .cm-s-abbott span.CodeMirror-nonmatchingbracket {
      background: #d80450 /* crimson */ !important;
      color: #231c14 /* bistre */ !important;
    }

    .cm-s-abbott .CodeMirror-matchingtag,
    .cm-s-abbott .cm-matchhighlight {
      outline: 1px solid #39a78d /* zomp */;
    }

    /* Equivalent to Vim's CursorLine group. */
    .cm-s-abbott .CodeMirror-activeline-background,
    .cm-s-abbott .CodeMirror-activeline-gutter {
      background: #3c3022 /* chocolate */;
    }

    /* Equivalent to Vim's CursorLineNr group. */
    .cm-s-abbott .CodeMirror-activeline-gutter .CodeMirror-linenumber {
      color: #d8ff84 /* pastel_chartreuse */;
      font-weight: bold;
    }

    /* Roughly equivalent to Vim's Folded group. */
    .cm-s-abbott .CodeMirror-foldmarker {
      color: #f63f05 /* cinnabar */;
      text-shadow: none;
    }
  uploads-admin-Public-Admin-plugins-codemirror-theme-dracula.css: |
    /*

        Name:       dracula
        Author:     Michael Kaminsky (http://github.com/mkaminsky11)

        Original dracula color scheme by Zeno Rocha (https://github.com/zenorocha/dracula-theme)

    */


    .cm-s-dracula.CodeMirror, .cm-s-dracula .CodeMirror-gutters {
      background-color: #282a36 !important;
      color: #f8f8f2 !important;
      border: none;
    }
    .cm-s-dracula .CodeMirror-gutters { color: #282a36; }
    .cm-s-dracula .CodeMirror-cursor { border-left: solid thin #f8f8f0; }
    .cm-s-dracula .CodeMirror-linenumber { color: #6D8A88; }
    .cm-s-dracula .CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }
    .cm-s-dracula .CodeMirror-line::selection, .cm-s-dracula .CodeMirror-line > span::selection, .cm-s-dracula .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }
    .cm-s-dracula .CodeMirror-line::-moz-selection, .cm-s-dracula .CodeMirror-line > span::-moz-selection, .cm-s-dracula .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }
    .cm-s-dracula span.cm-comment { color: #6272a4; }
    .cm-s-dracula span.cm-string, .cm-s-dracula span.cm-string-2 { color: #f1fa8c; }
    .cm-s-dracula span.cm-number { color: #bd93f9; }
    .cm-s-dracula span.cm-variable { color: #50fa7b; }
    .cm-s-dracula span.cm-variable-2 { color: white; }
    .cm-s-dracula span.cm-def { color: #50fa7b; }
    .cm-s-dracula span.cm-operator { color: #ff79c6; }
    .cm-s-dracula span.cm-keyword { color: #ff79c6; }
    .cm-s-dracula span.cm-atom { color: #bd93f9; }
    .cm-s-dracula span.cm-meta { color: #f8f8f2; }
    .cm-s-dracula span.cm-tag { color: #ff79c6; }
    .cm-s-dracula span.cm-attribute { color: #50fa7b; }
    .cm-s-dracula span.cm-qualifier { color: #50fa7b; }
    .cm-s-dracula span.cm-property { color: #66d9ef; }
    .cm-s-dracula span.cm-builtin { color: #50fa7b; }
    .cm-s-dracula span.cm-variable-3, .cm-s-dracula span.cm-type { color: #ffb86c; }

    .cm-s-dracula .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }
    .cm-s-dracula .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
  uploads-admin-Public-Admin-plugins-codemirror-theme-icecoder.css: |
    /*
    ICEcoder default theme by Matt Pass, used in code editor available at https://icecoder.net
    */

    .cm-s-icecoder { color: #666; background: #1d1d1b; }

    .cm-s-icecoder span.cm-keyword { color: #eee; font-weight:bold; }  /* off-white 1 */
    .cm-s-icecoder span.cm-atom { color: #e1c76e; }                    /* yellow */
    .cm-s-icecoder span.cm-number { color: #6cb5d9; }                  /* blue */
    .cm-s-icecoder span.cm-def { color: #b9ca4a; }                     /* green */

    .cm-s-icecoder span.cm-variable { color: #6cb5d9; }                /* blue */
    .cm-s-icecoder span.cm-variable-2 { color: #cc1e5c; }              /* pink */
    .cm-s-icecoder span.cm-variable-3, .cm-s-icecoder span.cm-type { color: #f9602c; } /* orange */

    .cm-s-icecoder span.cm-property { color: #eee; }                   /* off-white 1 */
    .cm-s-icecoder span.cm-operator { color: #9179bb; }                /* purple */
    .cm-s-icecoder span.cm-comment { color: #97a3aa; }                 /* grey-blue */

    .cm-s-icecoder span.cm-string { color: #b9ca4a; }                  /* green */
    .cm-s-icecoder span.cm-string-2 { color: #6cb5d9; }                /* blue */

    .cm-s-icecoder span.cm-meta { color: #555; }                       /* grey */

    .cm-s-icecoder span.cm-qualifier { color: #555; }                  /* grey */
    .cm-s-icecoder span.cm-builtin { color: #214e7b; }                 /* bright blue */
    .cm-s-icecoder span.cm-bracket { color: #cc7; }                    /* grey-yellow */

    .cm-s-icecoder span.cm-tag { color: #e8e8e8; }                     /* off-white 2 */
    .cm-s-icecoder span.cm-attribute { color: #099; }                  /* teal */

    .cm-s-icecoder span.cm-header { color: #6a0d6a; }                  /* purple-pink */
    .cm-s-icecoder span.cm-quote { color: #186718; }                   /* dark green */
    .cm-s-icecoder span.cm-hr { color: #888; }                         /* mid-grey */
    .cm-s-icecoder span.cm-link { color: #e1c76e; }                    /* yellow */
    .cm-s-icecoder span.cm-error { color: #d00; }                      /* red */

    .cm-s-icecoder .CodeMirror-cursor { border-left: 1px solid white; }
    .cm-s-icecoder div.CodeMirror-selected { color: #fff; background: #037; }
    .cm-s-icecoder .CodeMirror-gutters { background: #1d1d1b; min-width: 41px; border-right: 0; }
    .cm-s-icecoder .CodeMirror-linenumber { color: #555; cursor: default; }
    .cm-s-icecoder .CodeMirror-matchingbracket { color: #fff !important; background: #555 !important; }
    .cm-s-icecoder .CodeMirror-activeline-background { background: #000; }
  uploads-admin-Public-Admin-plugins-codemirror-theme-material-palenight.css: |
    /*
      Name:       material
      Author:     Mattia Astorino (http://github.com/equinusocio)
      Website:    https://material-theme.site/
    */

    .cm-s-material-palenight.CodeMirror {
      background-color: #292D3E;
      color: #A6ACCD;
    }

    .cm-s-material-palenight .CodeMirror-gutters {
      background: #292D3E;
      color: #676E95;
      border: none;
    }

    .cm-s-material-palenight .CodeMirror-guttermarker,
    .cm-s-material-palenight .CodeMirror-guttermarker-subtle,
    .cm-s-material-palenight .CodeMirror-linenumber {
      color: #676E95;
    }

    .cm-s-material-palenight .CodeMirror-cursor {
      border-left: 1px solid #FFCC00;
    }
    .cm-s-material-palenight.cm-fat-cursor .CodeMirror-cursor {
      background-color: #607c8b80 !important;
    }
    .cm-s-material-palenight .cm-animate-fat-cursor {
      background-color: #607c8b80 !important;
    }

    .cm-s-material-palenight div.CodeMirror-selected {
      background: rgba(113, 124, 180, 0.2);
    }

    .cm-s-material-palenight.CodeMirror-focused div.CodeMirror-selected {
      background: rgba(113, 124, 180, 0.2);
    }

    .cm-s-material-palenight .CodeMirror-line::selection,
    .cm-s-material-palenight .CodeMirror-line>span::selection,
    .cm-s-material-palenight .CodeMirror-line>span>span::selection {
      background: rgba(128, 203, 196, 0.2);
    }

    .cm-s-material-palenight .CodeMirror-line::-moz-selection,
    .cm-s-material-palenight .CodeMirror-line>span::-moz-selection,
    .cm-s-material-palenight .CodeMirror-line>span>span::-moz-selection {
      background: rgba(128, 203, 196, 0.2);
    }

    .cm-s-material-palenight .CodeMirror-activeline-background {
      background: rgba(0, 0, 0, 0.5);
    }

    .cm-s-material-palenight .cm-keyword {
      color: #C792EA;
    }

    .cm-s-material-palenight .cm-operator {
      color: #89DDFF;
    }

    .cm-s-material-palenight .cm-variable-2 {
      color: #EEFFFF;
    }

    .cm-s-material-palenight .cm-variable-3,
    .cm-s-material-palenight .cm-type {
      color: #f07178;
    }

    .cm-s-material-palenight .cm-builtin {
      color: #FFCB6B;
    }

    .cm-s-material-palenight .cm-atom {
      color: #F78C6C;
    }

    .cm-s-material-palenight .cm-number {
      color: #FF5370;
    }

    .cm-s-material-palenight .cm-def {
      color: #82AAFF;
    }

    .cm-s-material-palenight .cm-string {
      color: #C3E88D;
    }

    .cm-s-material-palenight .cm-string-2 {
      color: #f07178;
    }

    .cm-s-material-palenight .cm-comment {
      color: #676E95;
    }

    .cm-s-material-palenight .cm-variable {
      color: #f07178;
    }

    .cm-s-material-palenight .cm-tag {
      color: #FF5370;
    }

    .cm-s-material-palenight .cm-meta {
      color: #FFCB6B;
    }

    .cm-s-material-palenight .cm-attribute {
      color: #C792EA;
    }

    .cm-s-material-palenight .cm-property {
      color: #C792EA;
    }

    .cm-s-material-palenight .cm-qualifier {
      color: #DECB6B;
    }

    .cm-s-material-palenight .cm-variable-3,
    .cm-s-material-palenight .cm-type {
      color: #DECB6B;
    }


    .cm-s-material-palenight .cm-error {
      color: rgba(255, 255, 255, 1.0);
      background-color: #FF5370;
    }

    .cm-s-material-palenight .CodeMirror-matchingbracket {
      text-decoration: underline;
      color: white !important;
    }
  uploads-admin-Public-Admin-plugins-codemirror-theme-material.css: |
    /*
      Name:       material
      Author:     Mattia Astorino (http://github.com/equinusocio)
      Website:    https://material-theme.site/
    */

    .cm-s-material.CodeMirror {
      background-color: #263238;
      color: #EEFFFF;
    }

    .cm-s-material .CodeMirror-gutters {
      background: #263238;
      color: #546E7A;
      border: none;
    }

    .cm-s-material .CodeMirror-guttermarker,
    .cm-s-material .CodeMirror-guttermarker-subtle,
    .cm-s-material .CodeMirror-linenumber {
      color: #546E7A;
    }

    .cm-s-material .CodeMirror-cursor {
      border-left: 1px solid #FFCC00;
    }
    .cm-s-material.cm-fat-cursor .CodeMirror-cursor {
      background-color: #5d6d5c80 !important;
    }
    .cm-s-material .cm-animate-fat-cursor {
      background-color: #5d6d5c80 !important;
    }

    .cm-s-material div.CodeMirror-selected {
      background: rgba(128, 203, 196, 0.2);
    }

    .cm-s-material.CodeMirror-focused div.CodeMirror-selected {
      background: rgba(128, 203, 196, 0.2);
    }

    .cm-s-material .CodeMirror-line::selection,
    .cm-s-material .CodeMirror-line>span::selection,
    .cm-s-material .CodeMirror-line>span>span::selection {
      background: rgba(128, 203, 196, 0.2);
    }

    .cm-s-material .CodeMirror-line::-moz-selection,
    .cm-s-material .CodeMirror-line>span::-moz-selection,
    .cm-s-material .CodeMirror-line>span>span::-moz-selection {
      background: rgba(128, 203, 196, 0.2);
    }

    .cm-s-material .CodeMirror-activeline-background {
      background: rgba(0, 0, 0, 0.5);
    }

    .cm-s-material .cm-keyword {
      color: #C792EA;
    }

    .cm-s-material .cm-operator {
      color: #89DDFF;
    }

    .cm-s-material .cm-variable-2 {
      color: #EEFFFF;
    }

    .cm-s-material .cm-variable-3,
    .cm-s-material .cm-type {
      color: #f07178;
    }

    .cm-s-material .cm-builtin {
      color: #FFCB6B;
    }

    .cm-s-material .cm-atom {
      color: #F78C6C;
    }

    .cm-s-material .cm-number {
      color: #FF5370;
    }

    .cm-s-material .cm-def {
      color: #82AAFF;
    }

    .cm-s-material .cm-string {
      color: #C3E88D;
    }

    .cm-s-material .cm-string-2 {
      color: #f07178;
    }

    .cm-s-material .cm-comment {
      color: #546E7A;
    }

    .cm-s-material .cm-variable {
      color: #f07178;
    }

    .cm-s-material .cm-tag {
      color: #FF5370;
    }

    .cm-s-material .cm-meta {
      color: #FFCB6B;
    }

    .cm-s-material .cm-attribute {
      color: #C792EA;
    }

    .cm-s-material .cm-property {
      color: #C792EA;
    }

    .cm-s-material .cm-qualifier {
      color: #DECB6B;
    }

    .cm-s-material .cm-variable-3,
    .cm-s-material .cm-type {
      color: #DECB6B;
    }


    .cm-s-material .cm-error {
      color: rgba(255, 255, 255, 1.0);
      background-color: #FF5370;
    }

    .cm-s-material .CodeMirror-matchingbracket {
      text-decoration: underline;
      color: white !important;
    }
  uploads-admin-Public-Admin-plugins-codemirror-theme-midnight.css: |
    /* Based on the theme at http://bonsaiden.github.com/JavaScript-Garden */

    /*<!--activeline-->*/
    .cm-s-midnight .CodeMirror-activeline-background { background: #253540; }

    .cm-s-midnight.CodeMirror {
        background: #0F192A;
        color: #D1EDFF;
    }

    .cm-s-midnight div.CodeMirror-selected { background: #314D67; }
    .cm-s-midnight .CodeMirror-line::selection, .cm-s-midnight .CodeMirror-line > span::selection, .cm-s-midnight .CodeMirror-line > span > span::selection { background: rgba(49, 77, 103, .99); }
    .cm-s-midnight .CodeMirror-line::-moz-selection, .cm-s-midnight .CodeMirror-line > span::-moz-selection, .cm-s-midnight .CodeMirror-line > span > span::-moz-selection { background: rgba(49, 77, 103, .99); }
    .cm-s-midnight .CodeMirror-gutters { background: #0F192A; border-right: 1px solid; }
    .cm-s-midnight .CodeMirror-guttermarker { color: white; }
    .cm-s-midnight .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
    .cm-s-midnight .CodeMirror-linenumber { color: #D0D0D0; }
    .cm-s-midnight .CodeMirror-cursor { border-left: 1px solid #F8F8F0; }

    .cm-s-midnight span.cm-comment { color: #428BDD; }
    .cm-s-midnight span.cm-atom { color: #AE81FF; }
    .cm-s-midnight span.cm-number { color: #D1EDFF; }

    .cm-s-midnight span.cm-property, .cm-s-midnight span.cm-attribute { color: #A6E22E; }
    .cm-s-midnight span.cm-keyword { color: #E83737; }
    .cm-s-midnight span.cm-string { color: #1DC116; }

    .cm-s-midnight span.cm-variable { color: #FFAA3E; }
    .cm-s-midnight span.cm-variable-2 { color: #FFAA3E; }
    .cm-s-midnight span.cm-def { color: #4DD; }
    .cm-s-midnight span.cm-bracket { color: #D1EDFF; }
    .cm-s-midnight span.cm-tag { color: #449; }
    .cm-s-midnight span.cm-link { color: #AE81FF; }
    .cm-s-midnight span.cm-error { background: #F92672; color: #F8F8F0; }

    .cm-s-midnight .CodeMirror-matchingbracket {
      text-decoration: underline;
      color: white !important;
    }
  uploads-admin-Public-Admin-plugins-codemirror-theme-panda-syntax.css: "/*\n\tName:
    \      Panda Syntax\n\tAuthor:     Siamak Mokhtari (http://github.com/siamak/)\n\tCodeMirror
    template by Siamak Mokhtari (https://github.com/siamak/atom-panda-syntax)\n*/\n.cm-s-panda-syntax
    {\n\tbackground: #292A2B;\n\tcolor: #E6E6E6;\n\tline-height: 1.5;\n\tfont-family:
    'Operator Mono', 'Source Code Pro', Menlo, Monaco, Consolas, Courier New, monospace;\n}\n.cm-s-panda-syntax
    .CodeMirror-cursor { border-color: #ff2c6d; }\n.cm-s-panda-syntax .CodeMirror-activeline-background
    {\n\tbackground: rgba(99, 123, 156, 0.1);\n}\n.cm-s-panda-syntax .CodeMirror-selected
    {\n\tbackground: #FFF;\n}\n.cm-s-panda-syntax .cm-comment {\n\tfont-style: italic;\n\tcolor:
    #676B79;\n}\n.cm-s-panda-syntax .cm-operator {\n\tcolor: #f3f3f3;\n}\n.cm-s-panda-syntax
    .cm-string {\n\tcolor: #19F9D8;\n}\n.cm-s-panda-syntax .cm-string-2 {\n    color:
    #FFB86C;\n}\n\n.cm-s-panda-syntax .cm-tag {\n\tcolor: #ff2c6d;\n}\n.cm-s-panda-syntax
    .cm-meta {\n\tcolor: #b084eb;\n}\n\n.cm-s-panda-syntax .cm-number {\n\tcolor:
    #FFB86C;\n}\n.cm-s-panda-syntax .cm-atom {\n\tcolor: #ff2c6d;\n}\n.cm-s-panda-syntax
    .cm-keyword {\n\tcolor: #FF75B5;\n}\n.cm-s-panda-syntax .cm-variable {\n\tcolor:
    #ffb86c;\n}\n.cm-s-panda-syntax .cm-variable-2 {\n\tcolor: #ff9ac1;\n}\n.cm-s-panda-syntax
    .cm-variable-3, .cm-s-panda-syntax .cm-type {\n\tcolor: #ff9ac1;\n}\n\n.cm-s-panda-syntax
    .cm-def {\n\tcolor: #e6e6e6;\n}\n.cm-s-panda-syntax .cm-property {\n\tcolor: #f3f3f3;\n}\n.cm-s-panda-syntax
    .cm-unit {\n    color: #ffb86c;\n}\n\n.cm-s-panda-syntax .cm-attribute {\n    color:
    #ffb86c;\n}\n\n.cm-s-panda-syntax .CodeMirror-matchingbracket {\n    border-bottom:
    1px dotted #19F9D8;\n    padding-bottom: 2px;\n    color: #e6e6e6;\n}\n.cm-s-panda-syntax
    .CodeMirror-gutters {\n    background: #292a2b;\n    border-right-color: rgba(255,
    255, 255, 0.1);\n}\n.cm-s-panda-syntax .CodeMirror-linenumber {\n    color: #e6e6e6;\n
    \   opacity: 0.6;\n}\n"
  uploads-admin-Public-Admin-plugins-codemirror-theme-solarized.css: |
    /*
    Solarized theme for code-mirror
    http://ethanschoonover.com/solarized
    */

    /*
    Solarized color palette
    http://ethanschoonover.com/solarized/img/solarized-palette.png
    */

    .solarized.base03 { color: #002b36; }
    .solarized.base02 { color: #073642; }
    .solarized.base01 { color: #586e75; }
    .solarized.base00 { color: #657b83; }
    .solarized.base0 { color: #839496; }
    .solarized.base1 { color: #93a1a1; }
    .solarized.base2 { color: #eee8d5; }
    .solarized.base3  { color: #fdf6e3; }
    .solarized.solar-yellow  { color: #b58900; }
    .solarized.solar-orange  { color: #cb4b16; }
    .solarized.solar-red { color: #dc322f; }
    .solarized.solar-magenta { color: #d33682; }
    .solarized.solar-violet  { color: #6c71c4; }
    .solarized.solar-blue { color: #268bd2; }
    .solarized.solar-cyan { color: #2aa198; }
    .solarized.solar-green { color: #859900; }

    /* Color scheme for code-mirror */

    .cm-s-solarized {
      line-height: 1.45em;
      color-profile: sRGB;
      rendering-intent: auto;
    }
    .cm-s-solarized.cm-s-dark {
      color: #839496;
      background-color: #002b36;
      text-shadow: #002b36 0 1px;
    }
    .cm-s-solarized.cm-s-light {
      background-color: #fdf6e3;
      color: #657b83;
      text-shadow: #eee8d5 0 1px;
    }

    .cm-s-solarized .CodeMirror-widget {
      text-shadow: none;
    }

    .cm-s-solarized .cm-header { color: #586e75; }
    .cm-s-solarized .cm-quote { color: #93a1a1; }

    .cm-s-solarized .cm-keyword { color: #cb4b16; }
    .cm-s-solarized .cm-atom { color: #d33682; }
    .cm-s-solarized .cm-number { color: #d33682; }
    .cm-s-solarized .cm-def { color: #2aa198; }

    .cm-s-solarized .cm-variable { color: #839496; }
    .cm-s-solarized .cm-variable-2 { color: #b58900; }
    .cm-s-solarized .cm-variable-3, .cm-s-solarized .cm-type { color: #6c71c4; }

    .cm-s-solarized .cm-property { color: #2aa198; }
    .cm-s-solarized .cm-operator { color: #6c71c4; }

    .cm-s-solarized .cm-comment { color: #586e75; font-style:italic; }

    .cm-s-solarized .cm-string { color: #859900; }
    .cm-s-solarized .cm-string-2 { color: #b58900; }

    .cm-s-solarized .cm-meta { color: #859900; }
    .cm-s-solarized .cm-qualifier { color: #b58900; }
    .cm-s-solarized .cm-builtin { color: #d33682; }
    .cm-s-solarized .cm-bracket { color: #cb4b16; }
    .cm-s-solarized .CodeMirror-matchingbracket { color: #859900; }
    .cm-s-solarized .CodeMirror-nonmatchingbracket { color: #dc322f; }
    .cm-s-solarized .cm-tag { color: #93a1a1; }
    .cm-s-solarized .cm-attribute { color: #2aa198; }
    .cm-s-solarized .cm-hr {
      color: transparent;
      border-top: 1px solid #586e75;
      display: block;
    }
    .cm-s-solarized .cm-link { color: #93a1a1; cursor: pointer; }
    .cm-s-solarized .cm-special { color: #6c71c4; }
    .cm-s-solarized .cm-em {
      color: #999;
      text-decoration: underline;
      text-decoration-style: dotted;
    }
    .cm-s-solarized .cm-error,
    .cm-s-solarized .cm-invalidchar {
      color: #586e75;
      border-bottom: 1px dotted #dc322f;
    }

    .cm-s-solarized.cm-s-dark div.CodeMirror-selected { background: #073642; }
    .cm-s-solarized.cm-s-dark.CodeMirror ::selection { background: rgba(7, 54, 66, 0.99); }
    .cm-s-solarized.cm-s-dark .CodeMirror-line::-moz-selection, .cm-s-dark .CodeMirror-line > span::-moz-selection, .cm-s-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(7, 54, 66, 0.99); }

    .cm-s-solarized.cm-s-light div.CodeMirror-selected { background: #eee8d5; }
    .cm-s-solarized.cm-s-light .CodeMirror-line::selection, .cm-s-light .CodeMirror-line > span::selection, .cm-s-light .CodeMirror-line > span > span::selection { background: #eee8d5; }
    .cm-s-solarized.cm-s-light .CodeMirror-line::-moz-selection, .cm-s-light .CodeMirror-line > span::-moz-selection, .cm-s-light .CodeMirror-line > span > span::-moz-selection { background: #eee8d5; }

    /* Editor styling */



    /* Little shadow on the view-port of the buffer view */
    .cm-s-solarized.CodeMirror {
      -moz-box-shadow: inset 7px 0 12px -6px #000;
      -webkit-box-shadow: inset 7px 0 12px -6px #000;
      box-shadow: inset 7px 0 12px -6px #000;
    }

    /* Remove gutter border */
    .cm-s-solarized .CodeMirror-gutters {
      border-right: 0;
    }

    /* Gutter colors and line number styling based of color scheme (dark / light) */

    /* Dark */
    .cm-s-solarized.cm-s-dark .CodeMirror-gutters {
      background-color: #073642;
    }

    .cm-s-solarized.cm-s-dark .CodeMirror-linenumber {
      color: #586e75;
      text-shadow: #021014 0 -1px;
    }

    /* Light */
    .cm-s-solarized.cm-s-light .CodeMirror-gutters {
      background-color: #eee8d5;
    }

    .cm-s-solarized.cm-s-light .CodeMirror-linenumber {
      color: #839496;
    }

    /* Common */
    .cm-s-solarized .CodeMirror-linenumber {
      padding: 0 5px;
    }
    .cm-s-solarized .CodeMirror-guttermarker-subtle { color: #586e75; }
    .cm-s-solarized.cm-s-dark .CodeMirror-guttermarker { color: #ddd; }
    .cm-s-solarized.cm-s-light .CodeMirror-guttermarker { color: #cb4b16; }

    .cm-s-solarized .CodeMirror-gutter .CodeMirror-gutter-text {
      color: #586e75;
    }

    /* Cursor */
    .cm-s-solarized .CodeMirror-cursor { border-left: 1px solid #819090; }

    /* Fat cursor */
    .cm-s-solarized.cm-s-light.cm-fat-cursor .CodeMirror-cursor { background: #77ee77; }
    .cm-s-solarized.cm-s-light .cm-animate-fat-cursor { background-color: #77ee77; }
    .cm-s-solarized.cm-s-dark.cm-fat-cursor .CodeMirror-cursor { background: #586e75; }
    .cm-s-solarized.cm-s-dark .cm-animate-fat-cursor { background-color: #586e75; }

    /* Active line */
    .cm-s-solarized.cm-s-dark .CodeMirror-activeline-background {
      background: rgba(255, 255, 255, 0.06);
    }
    .cm-s-solarized.cm-s-light .CodeMirror-activeline-background {
      background: rgba(0, 0, 0, 0.06);
    }
  uploads-admin-Public-Admin-plugins-codemirror-theme-ssms.css: ".cm-s-ssms span.cm-keyword
    { color: blue; }\n.cm-s-ssms span.cm-comment { color: darkgreen; }\n.cm-s-ssms
    span.cm-string { color: red; }\n.cm-s-ssms span.cm-def { color: black; }\n.cm-s-ssms
    span.cm-variable { color: black; }\n.cm-s-ssms span.cm-variable-2 { color: black;
    }\n.cm-s-ssms span.cm-atom { color: darkgray; }\n.cm-s-ssms .CodeMirror-linenumber
    { color: teal; }\n.cm-s-ssms .CodeMirror-activeline-background { background: #ffffff;
    }\n.cm-s-ssms span.cm-string-2 { color: #FF00FF; }\n.cm-s-ssms span.cm-operator,
    \n.cm-s-ssms span.cm-bracket, \n.cm-s-ssms span.cm-punctuation { color: darkgray;
    }\n.cm-s-ssms .CodeMirror-gutters { border-right: 3px solid #ffee62; background-color:
    #ffffff; }\n.cm-s-ssms div.CodeMirror-selected { background: #ADD6FF; }\n\n"
  uploads-admin-Public-Admin-plugins-codemirror-theme-yeti.css: |
    /*

        Name:       yeti
        Author:     Michael Kaminsky (http://github.com/mkaminsky11)

        Original yeti color scheme by Jesse Weed (https://github.com/jesseweed/yeti-syntax)

    */


    .cm-s-yeti.CodeMirror {
      background-color: #ECEAE8 !important;
      color: #d1c9c0 !important;
      border: none;
    }

    .cm-s-yeti .CodeMirror-gutters {
      color: #adaba6;
      background-color: #E5E1DB;
      border: none;
    }
    .cm-s-yeti .CodeMirror-cursor { border-left: solid thin #d1c9c0; }
    .cm-s-yeti .CodeMirror-linenumber { color: #adaba6; }
    .cm-s-yeti.CodeMirror-focused div.CodeMirror-selected { background: #DCD8D2; }
    .cm-s-yeti .CodeMirror-line::selection, .cm-s-yeti .CodeMirror-line > span::selection, .cm-s-yeti .CodeMirror-line > span > span::selection { background: #DCD8D2; }
    .cm-s-yeti .CodeMirror-line::-moz-selection, .cm-s-yeti .CodeMirror-line > span::-moz-selection, .cm-s-yeti .CodeMirror-line > span > span::-moz-selection { background: #DCD8D2; }
    .cm-s-yeti span.cm-comment { color: #d4c8be; }
    .cm-s-yeti span.cm-string, .cm-s-yeti span.cm-string-2 { color: #96c0d8; }
    .cm-s-yeti span.cm-number { color: #a074c4; }
    .cm-s-yeti span.cm-variable { color: #55b5db; }
    .cm-s-yeti span.cm-variable-2 { color: #a074c4; }
    .cm-s-yeti span.cm-def { color: #55b5db; }
    .cm-s-yeti span.cm-operator { color: #9fb96e; }
    .cm-s-yeti span.cm-keyword { color: #9fb96e; }
    .cm-s-yeti span.cm-atom { color: #a074c4; }
    .cm-s-yeti span.cm-meta { color: #96c0d8; }
    .cm-s-yeti span.cm-tag { color: #96c0d8; }
    .cm-s-yeti span.cm-attribute { color: #9fb96e; }
    .cm-s-yeti span.cm-qualifier { color: #96c0d8; }
    .cm-s-yeti span.cm-property { color: #a074c4; }
    .cm-s-yeti span.cm-builtin { color: #a074c4; }
    .cm-s-yeti span.cm-variable-3, .cm-s-yeti span.cm-type { color: #96c0d8; }
    .cm-s-yeti .CodeMirror-activeline-background { background: #E7E4E0; }
    .cm-s-yeti .CodeMirror-matchingbracket { text-decoration: underline; }
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: php-code-content-104
